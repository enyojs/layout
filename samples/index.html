<!DOCTYPE html><html lang="en"><head>
	<meta charset="utf8">
	<title>Layout Samples</title>
<style>.enyo-list {
  position: relative;
}
.enyo-list-port {
  overflow: hidden;
  position: relative;
}
.enyo-list-holdingarea {
  position: absolute;
  left: 0;
  right: 0;
}
.enyo-list-port.horizontal {
  white-space: nowrap;
  width: 1000000px;
  height: 1000000px;
}
.enyo-list-port.vertical {
  height: 1000000px;
}
.enyo-list-page {
  position: absolute;
  left: 0;
}
.enyo-locale-right-to-left .enyo-list-page {
  left: auto;
  right: 0;
}
.enyo-list-page.vertical {
  left: 0;
  right: 0;
}
.enyo-list-holdingarea {
  top: -10000px;
}
.enyo-pinned-list-placeholder {
  border: 1px solid red;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1000;
  background: transparent;
  overflow: hidden;
}
.enyo-pinned-list-placeholder button {
  width: 100px;
  height: 100%;
  position: absolute;
  top: 0;
  right: 0;
}
.enyo-list-reorder-container {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1000;
  background: transparent;
  overflow: hidden;
}
.enyo-animatedTopAndLeft {
  -webkit-transition: top 0.1s linear, left 0.1s linear;
  -moz-transition: top 0.1s linear, left 0.1s linear;
  -o-transition: top 0.1s linear, left 0.1s linear;
  transition: top 0.1s linear, left 0.1s linear;
}
.enyo-arranger {
  position: relative;
  overflow: hidden;
}
.enyo-arranger.enyo-fit {
  position: absolute;
}
.enyo-arranger > * {
  position: absolute;
  left: 0;
  top: 0;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
.enyo-arranger-fit > * {
  /* override any width/height set on panels */
  width: 100% !important;
  height: 100% !important;
  min-width: 0 !important;
  min-height: 0 !important;
}
/* ContextualLayout.css - popup positioning and border radius adjustments */
/*for popups above activator*/
.vertical.above {
  top: auto;
  margin-top: -10px;
  bottom: 100%;
  margin-bottom: 10px;
}
/*for popups below activator*/
.vertical.below {
  margin-top: 10px;
}
/*for popups on the left of the activator*/
.right.horizontal {
  margin-left: -11px;
}
/*for popups on the right of the activator*/
.left.horizontal {
  margin-left: 10px;
}
/*corners*/
/*vertical top corners*/
/*for popups on the left of the activator*/
.vertical.right.corner {
  margin-left: 0px;
}
/*for popups on the right of the activator*/
.vertical.left.corner {
  margin-left: 0px;
}
.vertical.below.left.corner {
  border-top-right-radius: 0px;
}
.vertical.below.right.corner {
  border-top-left-radius: 0px;
}
/*vertical bottom corners*/
.left.above.corner {
  border-bottom-right-radius: 0px;
}
.right.above.corner {
  border-bottom-left-radius: 0px;
}
/*horizontal bottom corners*/
.left.low.corner {
  border-bottom-left-radius: 0px;
}
.right.low.corner {
  border-bottom-right-radius: 0px;
}
/*horizontal top corners*/
.left.high.corner {
  border-top-left-radius: 0px;
}
.right.high.corner {
  border-top-right-radius: 0px;
}
/* Fullscreen CSS */
:-webkit-full-screen {
  width: 100% !important;
  height: 100% !important;
}
:-moz-full-screen {
  width: 100% !important;
  height: 100% !important;
}
:-ms-full-screen {
  width: 100% !important;
  height: 100% !important;
}
:-o-full-screen {
  width: 100% !important;
  height: 100% !important;
}
:full-screen {
  width: 100% !important;
  height: 100% !important;
}
/* Fallback Fullscreen CSS */
body .enyo-fullscreen {
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  width: 100% !important;
  height: 100% !important;
  box-sizing: border-box !important;
}
@media all and (max-width: 800px) {
  .enyo-panels-fit-narrow > * {
    min-width: 100%;
    max-width: 100%;
  }
}
.enyo-panels-force-narrow > * {
  min-width: 100%;
  max-width: 100%;
}
/* things we always want */
body {
  font-family: 'Helvetica Neue', 'Nimbus Sans L', Arial, sans-serif;
}
/* allow hw-accelerated scrolling on platforms that support it */
body.webkitOverflowScrolling {
  -webkit-overflow-scrolling: touch;
}
/* for apps */
.enyo-document-fit {
  margin: 0;
  height: 100%;
  /* note: giving html overflow: auto is odd and was only ever done to avoid duplication
		however, android 4.04 sometimes does not hide nodes when their display is set to none
		if document is overflow auto.
	*/
  position: relative;
}
.enyo-body-fit {
  margin: 0;
  height: 100%;
  /* helps prevent ios page scroll */
  overflow: auto;
  position: relative;
}
.enyo-no-touch-action {
  -ms-touch-action: none;
}
.enyo-untouchable {
  pointer-events: none;
}
.enyo-untouchable > * {
  pointer-events: auto;
}
/* user selection */
.enyo-unselectable {
  cursor: default;
  -ms-user-select: none;
  -webkit-user-select: none;
  -moz-user-select: -moz-none;
  user-select: none;
}
.enyo-selectable {
  cursor: auto;
  -ms-user-select: element;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}
.enyo-selectable::selection,
.enyo-selectable ::selection {
  background: #3297FD;
  color: #FFF;
}
/* layout */
body .enyo-fit {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
}
.enyo-clip {
  overflow: hidden;
}
.enyo-border-box {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
/* compositing */
.enyo-composite {
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}
.enyo-inline {
  display: inline-block;
}
.enyo-positioned {
  position: relative;
}
.enyo-fill {
  position: relative;
  width: 100%;
  height: 100%;
}
.enyo-image.sized {
  display: inline-block;
  background-position: center;
  background-repeat: no-repeat;
}
.enyo-image.contain {
  background-size: contain;
}
.enyo-image.cover {
  background-size: cover;
}
.enyo-scrim {
  z-index: 1;
  /*
		note: by using pointer-events we allow tapping on scrim
		while it is fading out; however, this requires any showing classes
		to set pointer events to auto or scrim will not function as expected.
	*/
  pointer-events: none;
}
.enyo-scrim.enyo-scrim-translucent {
  pointer-events: auto;
  background-color: #000000;
  opacity: 0.65;
  filter: alpha(opacity=65);
}
.enyo-scrim.enyo-scrim-transparent {
  pointer-events: auto;
  background: transparent;
}
.enyo-thumb {
  position: absolute;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  border-radius: 4px;
  background: #333;
  border: 1px solid #666;
  opacity: 0.75;
  z-index: 1;
}
.enyo-vthumb {
  top: 0;
  right: 2px;
  width: 4px;
}
.enyo-hthumb {
  left: 0;
  bottom: 2px;
  height: 4px;
}
.enyo-fittable-rows-layout {
  position: relative;
}
.enyo-fittable-rows-layout > * {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* float when not stretched */
  float: left;
  clear: both;
}
/* non-floating when stretched */
.enyo-fittable-rows-layout.enyo-stretch > * {
  float: none;
  clear: none;
}
/* setting to enforce margin collapsing */
/* NOTE: rows cannot have margin left/right */
.enyo-fittable-rows-layout.enyo-stretch.enyo-margin-expand > * {
  float: left;
  clear: both;
  width: 100%;
  /* note: harsh resets */
  margin-left: 0 !important;
  margin-right: 0 !important;
}
.enyo-fittable-columns-layout {
  position: relative;
  text-align: left;
  white-space: nowrap;
}
.enyo-locale-right-to-left .enyo-fittable-columns-layout {
  text-align: right;
}
.enyo-fittable-columns-layout.enyo-center,
.enyo-locale-right-to-left .enyo-fittable-columns-layout.enyo-center {
  text-align: center;
}
.enyo-fittable-columns-layout > * {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  vertical-align: top;
  display: inline-block;
  white-space: normal;
}
.enyo-fittable-columns-layout > table {
  display: inline-table;
}
.enyo-fittable-columns-layout.enyo-tool-decorator > * {
  vertical-align: middle;
}
/* repair clobbered white-space setting for pre, code */
.enyo-fittable-columns-layout > pre,
.enyo-fittable-columns-layout > code {
  white-space: pre;
}
.enyo-fittable-columns-layout > .enyo-fittable-columns-layout,
.enyo-fittable-columns-layout > .onyx-toolbar-inline {
  white-space: nowrap;
}
/* NOTE: columns cannot have margin top/bottom */
.enyo-fittable-columns-layout.enyo-stretch > * {
  height: 100%;
  /* note: harsh resets */
  margin-top: 0 !important;
  margin-bottom: 0 !important;
}
.enyo-locale-right-to-left .enyo-fittable-columns-layout {
  direction: rtl;
  text-align: right;
}
.enyo-locale-right-to-left .enyo-fittable-columns-layout.force-left-to-right {
  direction: ltr;
  text-align: left;
}
.enyo-flex-container {
  display: -webkit-box;
  display: -moz-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}
.enyo-flex-container.enyo-center {
  justify-content: center;
}
.enyo-flex-container.columns {
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
}
.enyo-flex-container.rows {
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
}
.enyo-flex-item {
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  -webkit-flex: 0 0 auto;
  -ms-flex: 0 0 auto;
  flex: 0 0 auto;
}
.enyo-flex-item.flex {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1 auto;
  -ms-flex: 1 1 auto;
  flex: 1 1 auto;
}
.enyo-flex-container.nostretch > .enyo-flex-item {
  -webkit-align-self: flex-start;
  -ms-flex-item-align: flex-start;
  align-self: flex-start;
}
.pinDebug {
  background: yellow;
  border: 1px solid yellow;
}
.enyo-list-pulldown {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
}
.enyo-puller {
  position: relative;
  height: 50px;
  font-size: 22px;
  color: #444;
  padding: 20px 0 0px 34px;
}
.enyo-puller-text {
  position: absolute;
  left: 80px;
  top: 22px;
}
.enyo-puller-arrow {
  position: relative;
  background: #444;
  width: 7px;
  height: 28px;
  transition: transform 0.3s;
  -webkit-transition: -webkit-transform 0.3s;
  -moz-transition: -moz-transform 0.3s;
  -o-transition: -o-transform 0.3s;
  -ms-transition: -ms-transform 0.3s;
}
.enyo-puller-arrow:after {
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  border: 10px solid transparent;
  border-bottom-color: #444;
  bottom: 100%;
  left: 50%;
  margin-left: -10px;
}
.enyo-puller-arrow-up {
  transform: rotate(0deg);
  -webkit-transform: rotate(0deg);
  -moz-transform: rotate(0deg);
  -o-transform: rotate(0deg);
  -ms-transform: rotate(0deg);
}
.enyo-puller-arrow-down {
  transform: rotate(180deg);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
}
.enyo-tool-decorator {
  display: inline-block;
}
.enyo-tool-decorator > * {
  display: inline-block;
  vertical-align: middle;
}
.enyo-node {
  cursor: default;
  padding: 4px;
}
.enyo-node img {
  vertical-align: middle;
  padding-right: 6px;
}
.enyo-node-box {
  overflow: hidden;
}
.enyo-node-client {
  position: relative;
}
.enyo-animate .enyo-node-box,
.enyo-animate .enyo-node-client {
  -ms-transition-property: height, top;
  -ms-transition-duration: 0.2s, 0.2s;
  -moz-transition-property: height, top;
  -moz-transition-duration: 0.2s, 0.2s;
  -o-transition-property: height, top;
  -o-transition-duration: 0.2s, 0.2s;
  -webkit-transition-property: height, top;
  -webkit-transition-duration: 0.2s, 0.2s;
  transition-property: height, top;
  transition-duration: 0.2s, 0.2s;
}
.enyo-popup {
  position: absolute;
  z-index: 10;
}
/* reset */
button {
  font-size: inherit;
  font-family: inherit;
}
button::-moz-focus-inner {
  border: 0;
  padding: 0;
}
.enyo-scroller {
  position: relative;
}
.enyo-fit.enyo-scroller {
  position: absolute;
}
.enyo-touch-scroller {
  overflow: hidden;
}
.enyo-touch-strategy-container {
  overflow: hidden;
}
.enyo-scrollee-fit {
  height: 100%;
}
.enyo-flex-item.flex .enyo-scrollee-fit {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}
/*popup styling*/
.sample-contextual-popup {
  min-height: 50px;
  min-width: 50px;
  font-size: 16px;
  box-shadow: 0 6px 10px blue;
  border: 1px solid blue;
  border-radius: 8px;
  padding: 6px;
  color: orange;
  background: blue;
}
/****below here is all nub styling****/
/*setup the nub*/
.sample-contextual-popup::after {
  content: '';
  position: absolute;
  top: -10px;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid transparent;
  border-bottom: 10px solid transparent;
}
/*nub positioning*/
/*horizontally centered nub*/
.sample-contextual-popup.vertical::after {
  position: absolute;
  left: 45%;
  border-bottom: 10px solid blue;
  border-top: none;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
}
/*nub near horizontal left*/
.sample-contextual-popup.vertical.right::after {
  left: 0%;
  margin-left: 20px;
}
/*nub near horizontal right*/
.sample-contextual-popup.vertical.left::after {
  left: 100%;
  margin-left: -55px;
}
/*downward facing nub*/
.sample-contextual-popup.vertical.above::after {
  top: 100%;
  border-top: 10px solid blue;
  border-bottom: none;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
}
.sample-contextual-popup.vertical.below.right::after {
  top: 0%;
  margin-top: -10px;
  border-bottom: 10px solid blue;
  border-left: 10px solid transparent;
}
.sample-contextual-popup.vertical.below.left::after {
  top: 0%;
  margin-top: -10px;
  border-right: 10px solid transparent;
}
/*nub positioning for left/right popups*/
/*vertically centered nub for popups on left of activator*/
.sample-contextual-popup.right::after {
  left: 100%;
  top: 47%;
  margin-right: 20px;
  border-left: 10px solid blue;
}
/*nub near vertical top for popups on left of activator*/
.sample-contextual-popup.right.high::after {
  top: 35px;
  border-left: 10px solid blue;
}
/*nub near vertical bottom for popups on left of activator*/
.sample-contextual-popup.right.low::after {
  top: 100%;
  margin-top: -55px;
  border-left: 10px solid blue;
}
/*vertically centered nub for popups on right of activator*/
.sample-contextual-popup.left::after {
  left: 0%;
  margin-left: -20px;
  top: 45%;
  border-right: 10px solid blue;
}
/*nub near vertical top for popups on right of activator*/
.sample-contextual-popup.left.high::after {
  top: 35px;
  border-right: 10px solid blue;
}
/*nub near vertical bottom for popups on right of activator*/
.sample-contextual-popup.left.low::after {
  top: 100%;
  margin-top: -55px;
  border-right: 10px solid blue;
}
/*corners*/
/*vertical top corners*/
/*for popups on the left of the activator*/
.sample-contextual-popup.vertical.below.left.corner::after {
  top: 0%;
  left: 100%;
  margin-top: -10px;
  margin-left: -19px;
  border-right: 10px solid blue;
  border-top: 10px solid transparent;
}
.sample-contextual-popup.vertical.below.right.corner::after {
  top: 0%;
  left: 0%;
  margin-left: -1px;
  border-left: 10px solid blue;
  border-top: 10px solid transparent;
}
/*vertical bottom corners*/
.sample-contextual-popup.vertical.left.above.corner::after {
  top: 100%;
  margin-left: -19px;
  border-right: 10px solid blue;
  border-bottom: 10px solid transparent;
  border-top: none;
}
.sample-contextual-popup.vertical.right.above.corner::after {
  top: 100%;
  left: 0%;
  margin-left: -1px;
  border-left: 10px solid blue;
  border-bottom: 10px solid transparent;
  border-top: none;
}
/*horizontal bottom corners*/
.sample-contextual-popup.left.low.corner::after {
  top: 100%;
  left: 0%;
  margin-top: -19px;
  margin-left: -12px;
  border-bottom: 10px solid blue;
  border-right: 10px solid blue;
}
.sample-contextual-popup.right.low.corner::after {
  top: 100%;
  left: 100%;
  margin-top: -19px;
  border-bottom: 10px solidblue;
  border-left: none;
}
/*horizontal top corners*/
.sample-contextual-popup.left.high.corner::after {
  top: 0%;
  left: 0%;
  margin-top: -1px;
  margin-left: -12px;
  border-top: 10px solid blue;
  border-bottom: none;
}
.sample-contextual-popup.right.high.corner::after {
  top: 0%;
  left: 100%;
  margin-top: -1px;
  margin-left: -9px;
  border-top: 10px solid blue;
  border-bottom: none;
}
.sample-popup-button {
  padding: 4px 12px;
  border: 1px solid #888;
  border-radius: 4px;
  margin: 8px;
}
.sample-popup-button.icon-button {
  padding: 4px;
  background-position: 4px 4px;
  background-size: 32px 64px;
  height: 32px;
  width: 32px;
}
.easing-sample {
  background: #eaeaea;
  padding: 20px;
}
.easing-sample-divider {
  color: #F49200;
  text-transform: uppercase;
  font-family: Segoe UI, Prelude Medium, Helvetica, Verdana, sans-serif;
  font-size: 14px;
  font-weight: bold;
  margin-bottom: 8px;
}
.easing-sample-ball-container {
  display: inline-block;
  width: 50px;
  height: 200px;
  border-top: 1px solid black;
  border-bottom: 1px solid black;
}
.easing-sample-control-container {
  display: inline-block;
  vertical-align: top;
  padding: 0px 20px;
}
.easing-sample-ball {
  position: relative;
  left: 0px;
  width: 50px;
  height: 50px;
  background-color: blue;
  border-radius: 25px;
}
.fittable-sample-box {
  border: 2px solid lightblue;
  padding: 4px;
}
.fittable-sample-b {
  background-color: #F1FFF1;
}
.fittable-sample-mtb {
  margin-top: 3px;
  margin-bottom: 3px;
}
.fittable-sample-mlr {
  margin-left: 6px;
  margin-right: 6px;
}
.fittable-sample-o {
  border-color: orange;
}
.fittable-sample-height {
  height: 140px;
}
.fittable-sample-fitting-color {
  background: #B7BFC4;
}
.fittable-sample-shadow {
  box-shadow: -6px 0px 6px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: -6px 0px 6px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: -6px 0px 6px rgba(0, 0, 0, 0.3);
}
.fittable-sample-shadow2 {
  box-shadow: 6px 6px 6px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: 6px 6px 6px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: 6px 6px 6px rgba(0, 0, 0, 0.3);
}
.fittable-sample-shadow3 {
  box-shadow: 0 -6px 6px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: 0 -6px 6px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: 0 -6px 6px rgba(0, 0, 0, 0.3);
}
.fittable-sample-shadow4 {
  box-shadow: 6px 0px 6px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: 6px 0px 6px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: 6px 0px 6px rgba(0, 0, 0, 0.3);
  z-index: 1;
}
.fittable-sample-boxable {
  margin: 0.5em;
  padding: 1em;
  border: 0.2em solid beige;
}
.fittable-sample-boxable > * {
  border: 0.1em dotted orange;
  padding: 0.5em;
}
.fittable-sample-test {
  border-width: 0.2em;
  border-color: red;
}
.fittable-sample-small-test {
  border-width: 0.2em;
  border-color: red;
  height: 150px;
}
.fittable-sample-section {
  padding: 30px 10px 10px;
  font-weight: bold;
}
@media only screen and (min-width: 768px) {
  .fittable-sample-row {
    height: 300px;
  }
  .fittable-sample-column {
    width: 300px;
  }
}
@media only screen and (max-width: 767px) {
  .fittable-sample-row {
    height: 120px;
  }
  .fittable-sample-column {
    width: 120px;
  }
}
.flyweight-repeater-sample {
  background-color: gray;
  position: relative;
}
.flyweight-repeater-sample-list {
  position: relative;
  width: 100%;
  margin: auto;
  background-color: #eee;
}
.flyweight-repeater-sample-item {
  border: 1px solid silver;
  padding: 18px;
  font-size: 18px;
  font-weight: bold;
}
.imagecarousel-sample-input {
  margin: 0px 6px;
}
.imagecarousel-sample-input input {
  text-align: center;
  width: 30px;
}
.list-sample-around {
  background: url('assets/bg.png');
}
/* item */
.list-sample-around-item {
  height: 100px;
  border-top: 1px solid silver;
  padding: 12px 16px;
  background-color: #333333;
}
.list-sample-around-item-selected {
  background: #226b9a url('assets/item-hilite.png') repeat-x bottom;
}
.list-sample-around-item > * {
  display: inline-block;
  vertical-align: middle;
}
.list-sample-around-avatar {
  width: 32px;
  height: 32px;
  padding-right: 10px;
}
.list-sample-around-name {
  font-size: 16px;
  font-weight: bold;
  color: white;
}
.list-sample-around-description {
  font-size: 12px;
  color: silver;
}
.list-sample-around-remove-button {
  float: right;
  display: none;
}
/* divider */
.list-sample-around-divider {
  background-color: #666;
  font-size: 14px;
  font-weight: bold;
  padding: 8px 14px;
}
/* popup */
.list-sample-around-popup {
  width: 280px;
}
.list-sample-around-popup > * {
  display: block;
  margin: 10px 10px;
}
.list-sample-around-populate-button {
  float: right;
  margin-top: 25px;
}
.list-sample-around-label {
  display: inline-block;
  width: 120px;
  padding-right: 10px;
}
.list-sample {
  background-color: gray;
}
.list-sample-list {
  width: 50%;
  min-width: 300px;
  max-width: 600px;
  margin: auto;
  background-color: #eee;
}
.list-sample-item {
  border: 1px solid silver;
  padding: 18px;
  font-size: 18px;
  font-weight: bold;
}
.list-sample-index {
  float: right;
  font-size: 16px;
  font-weight: normal;
}
.list-sample-selected {
  background-color: #c4e3fe;
}
/* needed to make onyx-highlight more specific for highlighting to work */
.onyx-highlight.list-sample-selected {
  background-color: #dedfdf;
}
.list-sample-contacts {
  color: white;
}
.list-sample-contacts-list {
  background: url('assets/bg.png');
}
/* item */
.list-sample-contacts-item {
  height: 100px;
  border-top: 1px solid silver;
  padding: 12px 16px;
  background-color: #333333;
}
.list-sample-contacts-item-selected {
  background: #226b9a url('assets/item-hilite.png') repeat-x bottom;
}
.list-sample-contacts-item > * {
  display: inline-block;
  vertical-align: middle;
}
.list-sample-contacts-avatar {
  width: 32px;
  height: 32px;
  padding-right: 10px;
}
.list-sample-contacts-description {
  font-size: 12px;
  color: silver;
}
.list-sample-contacts-remove-button {
  float: right;
  display: none;
  background: url('assets/remove-icon.png') top center / 32px 64px no-repeat;
  width: 32px;
  height: 32px;
}
/* divider */
.list-sample-contacts-divider {
  background-color: #666;
  font-size: 14px;
  font-weight: bold;
  padding: 8px 14px;
}
/* popup */
.list-sample-contacts-popup {
  width: 280px;
  background: #aaa;
  padding: 10px;
  border-radius: 5px;
}
.list-sample-contacts-popup > * {
  display: block;
  margin: 10px 10px;
}
.list-sample-contacts-populate-button {
  float: right;
  margin-top: 25px;
}
.list-sample-contacts-label {
  display: inline-block;
  width: 120px;
  padding-right: 10px;
}
.list-sample-flickr {
  color: white;
  background: #555;
  box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
}
.list-sample-flickr-item {
  position: relative;
  border-bottom: 1px solid #0E0E0E;
  padding: 12px 16px;
  background-color: #333333;
}
.list-sample-flickr-item.onyx-selected {
  background-color: MidnightBlue;
}
.list-sample-flickr-title {
  position: absolute;
  top: 40px;
  right: 0;
  left: 100px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.list-sample-flickr-thumbnail {
  width: 100px;
  height: auto;
}
.list-sample-flickr-more {
  background-color: #333333;
  color: white;
  width: 150px;
}
.list-sample-flickr-more-spinner {
  vertical-align: middle;
  margin: -4px 0 0 4px;
}
.list-sample-language {
  color: white;
}
.list-sample-language-list {
  background: url('assets/bg.png');
}
.list-sample-language-item {
  height: 80px;
  border-top: 1px solid #000;
  padding: 12px 16px;
  background-color: #333333;
  position: relative;
}
.list-sample-language-list .rowNumberLabel {
  position: absolute;
  right: 15px;
  bottom: 10px;
  font-size: 12px;
}
.list-sample-language-list .itemLabel {
  font-size: 24px;
  line-height: 80px;
  padding-left: 30px;
}
.list-sample-language-list .serialLabel {
  position: absolute;
  right: 80px;
  bottom: 10px;
  font-size: 12px;
}
.list-sample-language-list .reorderDragger {
  background: #000000;
}
.list-sample-language-list .swipeGreen {
  background-color: #00a028;
}
.list-sample-language-list h2 {
  margin: 0;
  padding: 0 0 0 20px;
  font-size: 24px;
  line-height: 100px;
}
.list-sample-language-list .dropButton {
  width: 90px;
  height: 60px;
  position: absolute;
  top: 20px;
  right: 110px;
}
.list-sample-language-list .cancelButton {
  width: 90px;
  height: 60px;
  position: absolute;
  top: 20px;
  right: 10px;
}
.list-sample-language-list .swipeTitle {
  font-size: 30px;
  font-weight: bold;
  text-align: center;
  line-height: 100px;
  padding: 0;
  margin: 0;
}
.list-sample-pulldown-list {
  background: grey;
}
.list-sample-pulldown-item {
  border-bottom: 1px solid #0E0E0E;
  padding: 12px 16px;
  background-color: #333333;
  /**/
  font-size: 14px;
  color: white;
  overflow: hidden;
}
/*
	Put anything you reference with "url('.')" in ../assets/
	This way, you can minify your application, and just remove the "source" folder for production
*/
.panzoomview-demoButton {
  margin: 8px;
}
.panzoomview-demo {
  width: 800px;
  height: 500px;
  margin: auto;
  background-color: gray;
}
@media all and (max-width: 900px) {
  .panzoomview-demo {
    width: 550px;
    height: 400px;
  }
}
@media all and (max-width: 650px) {
  .panzoomview-demo {
    width: 280px;
    height: 250px;
  }
}
.panels-sample-flickr-panels {
  color: white;
  background: #555;
}
.panels-sample-flickr-panels > * {
  width: 320px;
  box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: -4px 0px 4px rgba(0, 0, 0, 0.3);
}
.panels-sample-flickr-item {
  position: relative;
  border-bottom: 1px solid #0E0E0E;
  padding: 12px 16px;
  background-color: #333333;
}
.panels-sample-flickr-item.onyx-selected {
  background-color: MidnightBlue;
}
.panels-sample-flickr-title {
  position: absolute;
  top: 40px;
  right: 0;
  left: 100px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.panels-sample-flickr-thumbnail {
  width: 75px;
  height: 75px;
}
.panels-sample-flickr-more-button {
  color: white;
  margin: 10px;
}
.panels-sample-flickr-more-spinner {
  vertical-align: middle;
  margin: -4px 0 0 4px;
}
.panels-sample-flickr-center {
  margin: auto;
}
.panels-sample-flickr-main {
  background-color: #333;
}
.panels-sample-flickr-image {
  box-sizing: border-box;
  max-height: 90%;
  max-width: 90%;
  border: solid 5px #CCC;
  box-shadow: 1px 1px 5px #999;
  width: auto;
  height: auto;
}
.panels-sample-flickr-image.wide {
  width: 100%;
}
@media all and (max-width: 800px) {
  .panels-sample-flickr-image.wide {
    width: auto;
  }
}
.panels-sample-flickr-image.tall {
  height: 100%;
}
.panels-sample-sliding-panels > * {
  width: 320px;
  background-color: #EAEAEA;
  -moz-box-shadow: -4px 0 4px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: -4px 0 4px rgba(0, 0, 0, 0.3);
  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.3);
}
.panels-sample-sliding-item {
  padding: 10px;
  border-bottom: 1px solid black;
}
.panels-sample-sliding-content {
  text-align: left;
  padding: 10px;
}
.list-sample-persistent-swipeable-item {
  color: white;
}
.list-sample-persistent-swipeable-item-list {
  background: url('assets/bg.png');
}
.list-sample-persistent-swipeable-item-item {
  height: 80px;
  border-top: 1px solid #000;
  padding: 12px 16px;
  background-color: rgba(0, 0, 0, 0.5);
}
.list-sample-contacts-item > * {
  display: inline-block;
  vertical-align: middle;
}
.list-sample-persistent-swipeable-item-list .itemLabel {
  float: left;
  font-size: 24px;
  line-height: 80px;
  padding-left: 20px;
}
.list-sample-persistent-swipeable-item-list .swipeGreen {
  background-color: rgba(0, 160, 40, 0.8);
}
.list-sample-persistent-swipeable-item-list .swipeRed {
  background-color: rgba(160, 0, 40, 0.8);
}
.list-sample-persistent-swipeable-item-list h2 {
  margin: 0px;
  padding: 0px 0px 0px 20px;
  font-size: 24px;
  line-height: 100px;
}
.list-sample-persistent-swipeable-item-list .swipeTitle {
  font-size: 30px;
  font-weight: bold;
  text-align: center;
  line-height: 100px;
  padding: 0px;
  margin: 0px;
}
.slideable-sample {
  position: absolute;
  background-color: #333;
  color: #fff;
}
.slideable-sample.top {
  height: 200px;
  height: 40%;
  border-bottom: solid 1px #f00;
}
.slideable-sample.right {
  right: 0;
  left: auto;
  width: 200px;
  width: 40%;
  border-left: solid 1px #ff0;
}
.slideable-sample.bottom {
  top: auto;
  bottom: 0;
  height: 200px;
  height: 40%;
  border-top: solid 1px #fff;
}
.slideable-sample.left {
  width: 200px;
  width: 40%;
  border-right: solid 1px #0ff;
}
.slideableinfo-sample {
  background-color: #f0f;
  border: solid 1px #fff;
  max-width: 150px;
  text-align: center;
  vertical-align: middle;
}
.layout-sample-toolbar {
  height: 40px;
  padding: 5px;
  background: #424242;
  color: #ffffff;
}
.layout-sample-toolbar > * {
  display: inline-block;
  margin: 0px 5px;
}
.enyo-sample-panelssample .toolbar {
  padding: 5px;
}
.enyo-sample-panelssample .toolbar .enyo-tool-decorator {
  width: 80px;
}
.enyo-sample-panelssample .toolbar .enyo-input {
  width: 100%;
}
.enyo-sample-panelssample .toolbar > * {
  display: inline-block;
  margin: 0 10px;
}
.enyo-sample-panelssample .panels-sample-panels {
  min-height: 320px;
  min-width: 320px;
}
.enyo-sample-panelssample .panels-sample-panels > * {
  border: 2px solid #333;
  font-size: 5em;
  text-align: center;
}
.enyo-sample-panelssample .panels-sample-wide > * {
  min-width: 50%;
}
.enyo-sample-panelssample .panels-sample-collapsible > * {
  min-width: 250px;
}
.enyo-sample-panelssample .panels-sample-spiral > * {
  min-width: 150px;
  min-height: 150px;
  max-height: 150px;
  max-width: 150px;
}
.enyo-sample-panelssample .panels-sample-grid > * {
  min-width: 150px;
  min-height: 150px;
  max-height: 150px;
  max-width: 150px;
}
@media screen and (max-width: 480px) {
  .enyo-sample-panelssample .arranger-scroller {
    max-height: 270px;
  }
}
</style><script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({36:[function(require,module,exports){


var PathResolverFactory = module.exports = function() {
	this.paths = {};
	this.pathNames = [];
};

PathResolverFactory.prototype = {
	addPath: function(inName, inPath) {
		this.paths[inName] = inPath;
		this.pathNames.push(inName);
		this.pathNames.sort(function(a, b) {
			return b.length - a.length;
		});
		return inPath;
	},
	addPaths: function(inPaths) {
		if (inPaths) {
			for (var n in inPaths) {
				this.addPath(n, inPaths[n]);
			}
		}
	},
	includeTrailingSlash: function(inPath) {
		return (inPath && inPath.slice(-1) !== "/") ? inPath + "/" : inPath;
	},
	// replace macros of the form $pathname with the mapped value of paths.pathname
	rewrite: function (inPath) {
		var working, its = this.includeTrailingSlash, paths = this.paths;
		var fn = function(macro, name) {
			working = true;
			return its(paths[name]) || '';
		};
		var result = inPath;
		do {
			working = false;
			for (var i=0; i<this.pathNames.length; i++) {
				var regex = new RegExp("\\$(" + this.pathNames[i] + ")(\\/)?", "g");
				result = result.replace(regex, fn);
			}
		} while (working);
		return result;
	}
};
},{}],69:[function(require,module,exports){
(function (global){
'use strict';

module.exports = (global.enyo && global.enyo.options) || {};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],125:[function(require,module,exports){
// Licensed under Creative Commons Attribution 3.0 License
// attributed to: http://leapon.net/en/random-name-generator-javascript

/* exported makeName */
module.exports = {
	makeName: function (minlength, maxlength, prefix, suffix) {

		function rnd(minv, maxv) {
			if (maxv < minv) {
				return 0;
			}
			return Math.floor(Math.random()*(maxv-minv+1)) + minv;
		}

		prefix = prefix || '';
		suffix = suffix || '';
		// these weird character sets are intended to cope with the nature of English (e.g. char 'x' pops up less frequently than char 's')
		// note: 'h' appears as consonants and vocals
		var vocals = 'aeiouyh' + 'aeiou' + 'aeiou';
		var cons = 'bcdfghjklmnpqrstvwxz' + 'bcdfgjklmnprstvw' + 'bcdfgjklmnprst';
		var allchars = vocals + cons;
		var length = rnd(minlength, maxlength) - prefix.length - suffix.length;
		if (length < 1) {
			length = 1;
		}
		var consnum = 0;
		var i;
		if (prefix.length > 0) {
			for (i = 0; i < prefix.length; i++) {
				if (consnum == 2) {
					consnum = 0;
				}
				if (cons.indexOf(prefix[i]) != -1) {
					consnum++;
				}
			}
		}
		else {
			consnum = 1;
		}
		var name = prefix;
		for (i = 0; i < length; i++)
		{
			var touse;
			//if we have used 2 consonants, the next char must be vocal.
			if (consnum == 2)
			{
				touse = vocals;
				consnum = 0;
			}
			else {
				touse = allchars;
			}
			//pick a random character from the set we are goin to use.
			var c = touse.charAt(rnd(0, touse.length - 1));
			name = name + c;
			if (cons.indexOf(c) != -1) {
				consnum++;
			}
		}
		name = name.charAt(0).toUpperCase() + name.substring(1, name.length) + suffix;
		return name;
	}
};
},{}],70:[function(require,module,exports){
var PathResolverFactory = require('./PathResolverFactory');

module.exports = new PathResolverFactory();
},{"./PathResolverFactory":36}],1:[function(require,module,exports){
'use strict';

exports = module.exports = require('./lib/options');
exports.version = '2.6.0-pre';
},{"./lib/options":69}],3:[function(require,module,exports){
require('../../enyo');

/**
* The available options used by {@link enyo.Ajax} and {@link enyo.WebService}.
*
* @namespace enyo.AjaxProperties
* @public
*/
module.exports = /** @lends enyo.AjaxProperties */ {
	
	/**
	* When `true`, appends a random number as a parameter for `GET` requests to try to
	* force a new fetch of the resource instead of reusing a local cache.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	cacheBust: true,
	
	/**
	* The URL for the service. This may be a relative URL if used to fetch resources bundled
	* with the application.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	url: '',
	
	/**
	* The HTTP method to use for the request; defaults to `'GET'`.  Supported values include
	* `'GET'`, `'POST'`, `'PUT'`, and `'DELETE'`.
	*
	* @type {String}
	* @default 'GET'
	* @public
	*/
	method: 'GET', // {value: 'GET', options: ['GET', 'POST', 'PUT', 'DELETE']}
	
	/**
	* How the response will be handled. Supported values are `'json'`, `'text'`, and `'xml'`.
	*
	* @type {String}
	* @default 'json'
	* @public
	*/
	handleAs: 'json', // {value: 'json', options: ['text', 'json', 'xml']}
	
	/**
	* The `Content-Type` header for the request as a String.
	*
	* @type {String}
	* @default 'application/x-www-form-urlencoded'
	* @public
	*/
	contentType: 'application/x-www-form-urlencoded',
	
	/**
	* If `true`, makes a synchronous (blocking) call, if supported.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	sync: false,
	
	/**
	* Optional additional request headers as a [hash]{@glossary Object}, or `null`.
	
	* ```javascript
	* { 'X-My-Header': 'My Value', 'Mood': 'Happy' }
	* ```
	*
	* @type {Object}
	* @default null
	* @public
	*/
	headers: null,
	
	/**
	* The content for the request body for `POST/PUT` methods. When `postBody` is a
	* [buffer]{@glossary Buffer} or a [string]{@glossary String}, it is passed
	* verbatim in the request body. When it is a [hash]{@glossary Object}, the way it is
	* encoded depends on the `contentType`:
	*
	* - `'application/json'` => [JSON.stringify()]{@glossary JSON.stringify}
	* - `'application/x-www-urlencoded'` => url-encoded parameters
	* - `'multipart/form-data'` => passed as fields in {@link enyo.FormData} (XHR2 emulation)
	*
	* @type {(String|Buffer|Object)}
	* @default ''
	* @public
	*/
	postBody: '',

	/**
	* The optional username to use for authentication purposes.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	username: '',
	
	/**
	* The optional password to use for authentication purposes.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	password: '',
	
	/**
	* Optional [hash]{@glossary Object} with fields to pass directly to the underlying XHR
	* object. One example is the `withCredentials` flag used for cross-origin requests.
	*
	* @type {Object}
	* @default null
	* @public
	*/
	xhrFields: null,
	
	/**
	* Optional [string]{@glossary String} to override the `MIME-Type` header.
	*
	* @type {String}
	* @default null
	* @public
	*/
	mimeType: null
};
},{"../../enyo":1}],31:[function(require,module,exports){
require('../../enyo');

/**
* A special type of [array]{@glossary Array} used internally by data layer
* [kinds]{@glossary kind}.
*
* @class enyo.ModelList
* @protected
*/
function ModelList (args) {
	Array.call(this);
	this.table = {};
	if (args) this.add(args, 0);
}

ModelList.prototype = Object.create(Array.prototype);

module.exports = ModelList;

/**
* Adds [models]{@link enyo.Model} to the [list]{@link enyo.ModelList}, updating an
* internal table by the model's [primaryKey]{@link enyo.Model#primaryKey} (if
* possible) and its [euid]{@glossary euid}.
*
* @name enyo.ModelList#add
* @method
* @param {(enyo.Model|enyo.Model[])} models The [model or models]{@link enyo.Model}
*	to add to the [list]{@link enyo.ModelList}.
* @param {Number} [idx] - If provided and valid, the models will be
* [spliced]{@glossary Array.splice} into the list at this position.
* @returns {enyo.Model[]} An immutable [array]{@glossary Array} of models
* that were actually added to the list.
* @protected
*/
ModelList.prototype.add = function (models, idx) {
	var table = this.table,
		added = [],
		model,
		euid,
		id,
		i = 0;
	
	if (models && !(models instanceof Array)) models = [models];
	
	for (; (model = models[i]); ++i) {
		euid = model.euid;
		
		// we only want to actually add models we haven't already seen...
		if (!table[euid]) {
			id = model.get(model.primaryKey);
		
			if (id != null) {
			
				// @TODO: For now if we already have an entry for a model by its supposed unique
				// identifier but it isn't the instance we just found we can't just
				// overwrite the previous instance so we mark the new one as headless
				if (table[id] && table[id] !== model) model.headless = true;
				// otherwise we do the normal thing and add the entry for it
				else table[id] = model; 
			}
		
			// nomatter what though the euid should be unique
			table[euid] = model;
			added.push(model);
		}
	}
	
	if (added.length) {
		idx = !isNaN(idx) ? Math.min(Math.max(0, idx), this.length) : 0;
		added.unshift(0);
		added.unshift(idx);
		this.splice.apply(this, added);
	}
	
	return added.length > 0 ? added.slice(2) : added; 
};

/**
* Removes the specified [models]{@link enyo.Model} from the [list]{@link enyo.ModelList}.
*
* @name enyo.ModelList#remove
* @method
* @param {(enyo.Model|enyo.Model[])} models The [model or models]{@link enyo.Model}
*	to remove from the [list]{@link enyo.ModelList}.
* @returns {enyo.Model[]} An immutable [array]{@glossary Array} of
*	models that were actually removed from the list.
* @protected
*/
ModelList.prototype.remove = function (models) {
	var table = this.table,
		removed = [],
		model,
		idx,
		id,
		i,
		
		// these modifications are made to allow more performant logic to take place in
		// views that may need to know this information
		low = Infinity;
	
	if (models && !(models instanceof Array)) models = [models];
	
	// we start at the end to ensure that you could even pass the list itself
	// and it will work
	for (i = models.length - 1; (model = models[i]); --i) {
		table[model.euid] = null;
		id = model.get(model.primaryKey);
		
		if (id != null) table[id] = null;
		
		idx = models === this ? i : this.indexOf(model);
		if (idx > -1) {				
			if (idx < low) low = idx;
			
			this.splice(idx, 1);
			removed.push(model);
		}
	}
	
	// since this is a separate array we will add this property to it for internal use only
	removed.low = low;
	
	return removed;
};

/**
* Determines whether the specified [model]{@link enyo.Model} is present in the
* [list]{@link enyo.ModelList}. Will attempt to resolve a [string]{@glossary String}
* or [number]{@glossary Number} to either a [primaryKey]{@link enyo.Model#primaryKey}
* or [euid]{@glossary euid}.
*
* @name enyo.ModelList#has
* @method
* @param {(enyo.Model|String|Number)} model An identifier representing either the
*	[model]{@link enyo.Model} instance, its [primaryKey]{@link enyo.Model#primaryKey},
* or its [euid]{@glossary euid}.
* @returns {Boolean} Whether or not the model is present in the [list]{@link enyo.ModelList}.
* @protected
*/
ModelList.prototype.has = function (model) {
	if (model === undefined || model === null) return false;
	
	if (typeof model == 'string' || typeof model == 'number') {
		return !! this.table[model];
	} else return this.indexOf(model) > -1;
};

/**
* Given an identifier, attempts to return the associated [model]{@link enyo.Model}.
* The identifier should be a [string]{@glossary String} or [number]{@glossary Number}.
*
* @name enyo.ModelList#resolve
* @method
* @param {(String|Number)} model - An identifier (either a
*	[primaryKey]{@link enyo.Model#primaryKey} or an [euid]{@glossary euid}).
* @returns {(undefined|null|enyo.Model)} If the identifier could be resolved, a
*	[model]{@link enyo.Model} instance is returned; otherwise, `undefined`, or
* possibly `null` if the model once belonged to the [list]{@link enyo.ModelList}.
* @protected
*/
ModelList.prototype.resolve = function (model) {
	if (typeof model == 'string' || typeof model == 'number') {
		return this.table[model];
	} else return model;
};

/**
* Copies the current [list]{@link enyo.ModelList} and returns an shallow copy. This
* method differs from the [slice()]{@glossary Array.slice} method inherited from
* native [Array]{@glossary Array} in that this returns an {@link enyo.ModelList},
* while `slice()` returns an array.
* 
* @name enyo.ModelList#copy
* @method
* @returns {enyo.ModelList} A shallow copy of the callee.
* @protected
*/
ModelList.prototype.copy = function () {
	return new ModelList(this);
};
},{"../../enyo":1}],50:[function(require,module,exports){
require('../../enyo');

/**
* Shared values for various [kinds]{@glossary kind} used to indicate a state or
* (multiple, simultaneous) states. These flags are binary values represented by
* hexadecimal numerals. They may be modified and compared (or even extended) using
* [bitwise operations]{@glossary bitwise} or various
* [API methods]{@link enyo.StateSupport} available to the kinds that support them.
* Make sure to explore the documentation for individual kinds, as they may have
* specific uses for a given flag.
* 
* As a cursory overview, here is a table of the values already declared by built-in flags.
* Each hexadecimal numeral represents a unique power of 2 in binary, from which we can use
* [bitwise masks]{@glossary bitwise} to determine if a particular value is present.
* 
* ```javascript
* HEX             DEC             BIN
* 0x0001             1            0000 0000 0000 0001
* 0x0002             2            0000 0000 0000 0010
* 0x0004             4            0000 0000 0000 0100
* 0x0008             8            0000 0000 0000 1000
* 0x0010            16            0000 0000 0001 0000
* 0x0020            32            0000 0000 0010 0000
* 0x0040            64            0000 0000 0100 0000
* 0x0080           128            0000 0000 1000 0000
* 0x0100           256            0000 0001 0000 0000
* 0x0200           512            0000 0010 0000 0000
* 0x0400          1024            0000 0100 0000 0000
* 0x0800          2048            0000 1000 0000 0000
* 
* ...
* 
* 0x1000          4096            0001 0000 0000 0000
* ```
*
* As a hint, converting (HEX) 0x0800 to DEC do:
*
* ```javascript
* (0*16^3) + (8*16^2) + (0*16^1) + (0*16^0) = 2048
* ```
*
* As a hint, converting (HEX) 0x0800 to BIN do:
*
* ```javascript
* 0    8    0    0    (HEX)
* ---- ---- ---- ----
* 0000 1000 0000 0000 (BIN)
* ```
*
* @name enyo.States
* @enum {Number}
* @public
* @see enyo.StateSupport
*/
module.exports = {
	
	/**
	* Only exists in the client and was created during the runtime of the
	* [application]{@glossary application}.
	*
	* @name enyo.States.NEW
	* @default 1
	*/
	NEW: 0x0001,
	
	/**
	* Has been modified locally only.
	*
	* @name enyo.States.DIRTY
	* @default 2
	*/
	DIRTY: 0x0002,
	
	/**
	* Has not been modified locally.
	*
	* @name enyo.States.CLEAN
	* @default 4
	*/
	CLEAN: 0x0004,
	
	/**
	* Can no longer be modified.
	*
	* @default 8
	*/
	DESTROYED: 0x0008,
	
	/**
	* Currently attempting to fetch.
	* 
	* @see enyo.Model.fetch
	* @see enyo.RelationalModel.fetch
	* @see enyo.Collection.fetch
	*
	* @default 16
	*/
	FETCHING: 0x0010,
	
	/**
	* Currently attempting to commit.
	* 
	* @see enyo.Model.commit
	* @see enyo.RelationalModel.commit
	* @see enyo.Collection.commit
	*
	* @default 32
	*/
	COMMITTING: 0x0020,
	
	/**
	* Currently attempting to destroy.
	* 
	* @see enyo.Model.destroy
	* @see enyo.RelationalModel.destroy
	* @see enyo.Collection.destroy
	*
	* @default 64
	*/
	DESTROYING: 0x0040,
	
	/**
	* There was an error during commit.
	* 
	* @see enyo.Model.commit
	* @see enyo.RelationalModel.commit
	* @see enyo.Collection.commit
	*
	* @default 128
	*/
	ERROR_COMMITTING: 0x0080,
	
	/**
	* There was an error during fetch.
	* 
	* @see enyo.Model.fetch
	* @see enyo.RelationalModel.fetch
	* @see enyo.Collection.fetch
	*
	* @default 256
	*/
	ERROR_FETCHING: 0x0100,
	
	/**
	* There was an error during destroy.
	* 
	* @see enyo.Model.destroy
	* @see enyo.RelationalModel.destroy
	* @see enyo.Collection.destroy
	*
	* @default 512
	*/
	ERROR_DESTROYING: 0x0200,
	
	/**
	* An error was encountered for which there was no exact flag, or an invalid error was
	* specified.
	*
	* @default 1024
	*/
	ERROR_UNKNOWN: 0x0400,
	
	/**
	* A multi-state [bitmask]{@glossary bitwise}. Compares a given flag to the states
	* included in the definition of `BUSY`. By default, this is one of
	* [FETCHING]{@link enyo.States.FETCHING}, [COMMITTING]{@link enyo.States.COMMITTING}, or
	* [DESTROYING]{@link enyo.States.DESTROYING}. It may be extended to include additional
	* values using the [bitwise]{@glossary bitwise} `OR` operator (`|`).
	*
	* @default 112
	*/
	BUSY: 0x0010 | 0x0020 | 0x0040,
	
	/**
	* A multi-state [bitmask]{@glossary bitwise}. Compares a given flag to the states
	* included in the definition of `ERROR`. By default, this is one of
	* [ERROR_FETCHING]{@link enyo.States.ERROR_FETCHING},
	* [ERROR_COMMITTING]{@link enyo.States.ERROR_COMMITTING},
	* [ERROR_DESTROYING]{@link enyo.States.ERROR_DESTROYING}, or
	* [ERROR_UNKNOWN]{@link enyo.States.ERROR_UNKNOWN}. It may be extended to include
	* additional values using the [bitwise]{@glossary bitwise} `OR` operator (`|`).
	*
	* @name enyo.States.ERROR
	* @default 1920
	*/
	ERROR: 0x0080 | 0x0100 | 0x0200 | 0x0400,
	
	/**
	* A multi-state [bitmask]{@glossary bitwise}. Compares a given flag to the states
	* included in the definition of `READY`. By default, this is the inverse of any
	* values included in [BUSY]{@link enyo.States.BUSY} or [ERROR]{@link enyo.States.ERROR}.
	*
	* @name enyo.States.READY
	* @default -2041
	*/
	READY: ~(0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080 | 0x0100 | 0x0200 | 0x0400)
};
},{"../../enyo":1}],63:[function(require,module,exports){
require('../../enyo');

var _jobs = {};

/**
* Runs a [job]{@link exports} after the specified amount of time has elapsed
* since a job with the same name has run.
* 
* Jobs can be used to throttle behaviors.  If some event may occur one time or
* multiple times, but we want a response to occur only once every `n` seconds,
* we can use a job.
*
* @example
* onscroll: function() {
*	// updateThumb will be called, but only when 1 second has elapsed since the
*	// last onscroll
*	exports("updateThumb", this.bindSafely("updateThumb"), 1000);
* }
*
* @param {String} nom - The name of the [job]{@link exports} to throttle.
* @param {(Function|String)} job - Either the name of a method or a [function]{@glossary Function}
*                                to execute as the requested job.
* @param {Number} wait - The number of milliseconds to wait before executing the job again.
* @static
* @public
*/
exports = module.exports = function (nom, job, wait) {
	exports.stop(nom);
	_jobs[nom] = setTimeout(function() {
		exports.stop(nom);
		job();
	}, wait);
};

/**
* Cancels the named [job]{@link exports}, if it has not already fired.
*
* @param {String} nom - The name of the [job]{@link exports} to cancel.
* @static
* @public
*/
exports.stop = function (nom) {
	if (_jobs[nom]) {
		clearTimeout(_jobs[nom]);
		delete _jobs[nom];
	}
};

/**
* Immediately invokes the [job]{@link exports} and prevents any other calls
* to `exports.throttle()` with the same job name from running for the
* specified amount of time.
* 
* This is used for throttling user events when you want to provide an
* immediate response, but later invocations might just be noise if they arrive
* too often.
* 
* @param {String} nom - The name of the [job]{@link exports} to throttle.
* @param {(Function|String)} job - Either the name of a method or a [function]{@glossary Function}
*                                to execute as the requested job.
* @param {Number} wait - The number of milliseconds to wait before executing the
*                      job again.
* @static
* @public
*/
exports.throttle = function (nom, job, wait) {
	// if we still have a job with this name pending, return immediately
	if (_jobs[nom]) {
		return;
	}
	job();
	_jobs[nom] = setTimeout(function() {
		exports.stop(nom);
	}, wait);
};
},{"../../enyo":1}],65:[function(require,module,exports){
require('../../enyo');


/**
* [JSON]{@glossary JSON} related methods and wrappers.
*
* @namespace enyo.json
* @public
*/
module.exports = /** @lends enyo.json */ {
	
	/**
	* Wrapper for [JSON.stringify()]{@glossary JSON.stringify}. Creates a
	* [JSON]{@glossary JSON} [string]{@glossary String} from an
	* [object]{@glossary Object}.
	*
	* @see {@glossary JSON.stringify}
	* @param {Object} value - The [object]{@glossary Object} to convert to a
	*	[JSON]{@glossary JSON} [string]{@glossary String}.
	* @param {(Function|String[])} [replacer] An optional parameter indicating either an
	*	[array]{@glossary Array} of keys to include in the final output or a
	*	[function]{@glossary Function} that will have the opportunity to dynamically return
	*	values to include for keys.
	* @param {(Number|String)} [space] - Determines the spacing (if any) for pretty-printed
	*	output of the JSON string. A [number]{@glossary Number} indicates the number of
	* spaces to use in the output, while a string will be used verbatim.
	* @returns {String} The JSON string for the given object.
	* @public
	*/
	stringify: function(value, replacer, space) {
		return JSON.stringify(value, replacer, space);
	},
	
	/**
	* Wrapper for [JSON.parse()]{@glossary JSON.parse}. Parses a valid
	* [JSON]{@glossary JSON} [string]{@glossary String} and returns an
	* [object]{@glossary Object}, or `null` if the parameters are invalid.
	*
	* @see {@glossary JSON.parse}
	* @param {String} json - The [JSON]{@glossary JSON} [string]{@glossary String} to
	*	parse into an [object]{@glossary Object}.
	* @param {Function} [reviver] - The optional [function]{@glossary Function} to use to
	*	parse individual keys of the return object.
	* @returns {(Object|null)} If parameters are valid, an [object]{@glossary Object}
	* is returned; otherwise, `null`.
	* @public
	*/
	parse: function(json, reviver) {
		return json ? JSON.parse(json, reviver) : null;
	}
};
},{"../../enyo":1}],72:[function(require,module,exports){
(function (global){
require('../../enyo');

// we need to register appropriately to know when
// the document is officially ready, to ensure that
// client code is only going to execute at the
// appropriate time

var doc = global.document;
var queue = [];
var ready = ("complete" === doc.readyState);
var run;
var init;
var remove;
var add;
var flush;
var flushScheduled = false;

/**
* Registers a callback (and optional `this` context) to run after all the Enyo and library code
* has loaded and the `DOMContentLoaded` event (or equivalent on older browsers) has been sent.
* 
* If called after the system is in a ready state, runs the supplied code asynchronously at the
* earliest opportunity.
*
* @name enyo.ready
* @method
* @param {Function} fn - The method to execute when the DOM is ready.
* @param {Object} [context] - The optional context (`this`) under which to execute the
*	callback method.
* @public
*/
module.exports = function (fn, context) {
	queue.push([fn, context]);
	// schedule another queue flush if needed to run new ready calls
	if (ready && !flushScheduled) {
		setTimeout(flush, 0);
		flushScheduled = true;
	}
};

/**
* @private
*/
run = function (fn, context) {
	fn.call(context || global);
};

/**
* @private
*/
init = function (event) {
	// if we're interactive, it should be safe to move
	// forward because the content has been parsed
	if ((ready = ("interactive" === doc.readyState))) {
		if ("DOMContentLoaded" !== event.type && "readystatechange" !== event.type) {
			remove(event.type, init);
			flush();
		}
	}
	// for an IE8 fallback and legacy WebKit (including webOS 3.x and less) and assurance
	if ((ready = ("complete" === doc.readyState || "loaded" === doc.readyState))) {
		remove(event.type, init);
		flush();
	}
};

/**
* @private
*/
add = function (event, fn) {
	var name = doc.addEventListener? "addEventListener": "attachEvent";
	var on = name === "attachEvent"? "on": "";
	doc[name](on + event, fn, false);
};

/**
* @private
*/
remove = function (event, fn) {
	var name = doc.addEventListener? "removeEventListener": "detachEvent";
	var on = name === "detachEvent"? "on": "";
	doc[name](on + event, fn, false);
};

/**
* @private
*/
flush = function () {
	if (ready && queue.length) {
		while (queue.length) {
			run.apply(global, queue.shift());
		}
	}
	flushScheduled = false;
};

// ok, let's hook this up
add("DOMContentLoaded", init);
add("readystatechange", init);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1}],74:[function(require,module,exports){
(function (global){
require('../../enyo');

/**
* @private
*/
var callbacks = [],
	roots = [];

exports.roots = roots;

/**
* Registers a single callback to be executed whenever a root view is rendered.
* 
* @name enyo.rendered
* @method
* @param {Function} method - The callback to execute.
* @param {Object} [context=enyo.global] The context under which to execute the callback.
* @public
*/
exports.rendered = function (method, context) {
	callbacks.push({method: method, context: context || global});
};

/**
* @private
*/
exports.roots = roots;

/**
* Invokes all known callbacks (if any) against the root view once it has been rendered.
* This method is not likely to be executed very often.
* 
* @private
*/
function invoke (root) {
	callbacks.forEach(function (ln) {
		ln.method.call(ln.context, root);
	});
}

/**
* @private
*/
exports.addToRoots = function (view) {
	var rendered,
		destroy;
	
	// since it is possible to call renderInto more than once on a given view we ensure we
	// don't register it twice unnecessarily
	if (roots.indexOf(view) === -1) {
		
		roots.push(view);
		
		// hijack the rendered method
		rendered = view.rendered;
		
		// hijack the destroy method
		destroy = view.destroy;
		
		// supply our rendered hook
		view.rendered = function () {
			// we call the original first
			rendered.apply(this, arguments);
			
			// and now we invoke the known callbacks against this root
			invoke(this);
		};
		
		// supply our destroy hook
		view.destroy = function () {
			var idx = roots.indexOf(this);
			
			// remove it from the roots array
			if (idx > -1) roots.splice(idx, 1);
			
			// now we can call the original
			destroy.apply(this, arguments);
		};
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1}],75:[function(require,module,exports){
(function (global){
require('../../enyo');


/**
* A polyfill for platforms that don't yet support
* [bind()]{@glossary Function.prototype.bind}. As explained in the linked article, this
* polyfill handles the general use case but cannot exactly mirror the ECMA-262 version 5
* implementation specification. This is an adaptation of the example promoted
* [here]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind}.
*/
if (!Function.prototype.bind) {
	Function.prototype.bind = function (ctx) {
		// deliberately used here...
		var args = Array.prototype.slice.call(arguments, 1),
			scop = this,
			nop = function () {},
			ret;
		
		// as-per MDN's explanation of this polyfill we're filling in for the IsCallable
		// internal (we can't access it)
		if (typeof this != 'function') {
			throw new TypeError('Function.prototype.bind called on non-callable object.');
		}
		
		ret = function () {
			var largs = args.concat(Array.prototype.slice.call(arguments)),
				lctx = this instanceof nop && ctx ? this : ctx;
			
			return scop.apply(lctx, largs);
		};
		
		nop.prototype = this.prototype;
		
		/*jshint -W055 */
		ret.prototype = new nop();
		/*jshint +W055 */
		
		return ret;
	};
}

/**
* @private
*/
exports.nop = function () {};

/**
* @private
*/
exports.nob = {};

/**
* @private
*/
exports.nar = [];

/**
* This name is reported in inspectors as the type of objects created via delegate;
* otherwise, we would just use {@link enyo.nop}.
*
* @private
*/
var Instance = exports.instance = function () {};
	
/**
* @private
*/
var setPrototype = exports.setPrototype = function (ctor, proto) {
	ctor.prototype = proto;
};

/**
* Boodman/crockford delegation w/cornford optimization
* 
* @private
*/
exports.delegate = function (proto) {
	setPrototype(Instance, proto);
	return new Instance();
};

// ----------------------------------
// General Functions
// ----------------------------------

/**
* Determines whether a variable is defined.
* 
* @param {*} target - Anything that can be compared to `undefined`.
* @returns {Boolean} `true` if defined, `false` otherwise.
* @public
*/
var exists = exports.exists = function (target) {
	return (target !== undefined);
};

var uidCounter = 0;

/**
* Creates a unique identifier (with an optional prefix) and returns the identifier as a string.
*
* @param {String} [prefix] - The prefix to prepend to the generated unique id.
* @returns {String} An optionally-prefixed identifier.
* @public
*/
exports.uid = function (prefix) {
	return String((prefix? prefix: '') + uidCounter++);
};

/**
* RFC4122 uuid generator for the browser.
*
* @returns {String} An [RFC4122]{@glossary UUID}-compliant, universally unique identifier.
* @public
*/
exports.uuid = function () {
	// @TODO: Could possibly be faster
	var t, p = (
		(Math.random().toString(16).substr(2,8)) + '-' +
		((t=Math.random().toString(16).substr(2,8)).substr(0,4)) + '-' +
		(t.substr(4,4)) +
		((t=Math.random().toString(16).substr(2,8)).substr(0,4)) + '-' +
		(t.substr(4,4)) +
		(Math.random().toString(16).substr(2,8))
	);
	return p;
};

/**
* Generates a random number using [Math.random]{@glossary Math.random}.
*
* @param {Number} bound - The multiplier used to generate the product.
* @returns {Number} A random number.
* @public
*/
exports.irand = function (bound) {
	return Math.floor(Math.random() * bound);
};

var toString = Object.prototype.toString;

/**
* Determines whether a given variable is a [String]{@glossary String}.
*
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is a [String]{@glossary String};
* otherwise, `false`.
* @public
*/
exports.isString = function (it) {
	return toString.call(it) === '[object String]';
};

/**
* Determines whether a given variable is a [Function]{@glossary Function}.
* 
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is a [Function]{@glossary Function};
* otherwise, `false`.
* @public
*/
var isFunction = exports.isFunction = function (it) {
	return toString.call(it) === '[object Function]';
};

/**
* Determines whether a given variable is an [Array]{@glossary Array}.
*
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is an [Array]{@glossary Array};
* otherwise, `false`.
* @method
* @public
*/
var isArray = exports.isArray = Array.isArray || function (it) {
	return toString.call(it) === '[object Array]';
};

/**
* Determines whether a given variable is an [Object]{@glossary Object}.
*
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is an [Object]{@glossary Object};
* otherwise, `false`.
* @method
* @public
*/
exports.isObject = Object.isObject || function (it) {
	// explicit null/undefined check for IE8 compatibility
	return (it != null) && (toString.call(it) === '[object Object]');
};

/**
* Determines whether a given variable is an explicit boolean `true`.
*
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is an explicit `true`; otherwise,
* `false`.
* @public
*/
exports.isTrue = function (it) {
	return !(it === 'false' || it === false || it === 0 || it === null || it === undefined);
};

/**
* Determines whether a given variable is a numeric value.
*
* @param {*} it - The variable to be tested.
* @returns {Boolean} `true` if variable is a numeric value; otherwise,
* `false`.
* @public
*/
exports.isNumeric = function (it) {
	// borrowed from jQuery
	return !isArray(it) && (it - parseFloat(it) + 1) >= 0;
};

/**
* Binds the `this` context of any method to a scope and a variable number of provided initial
* parameters.
*
* @param {Object} scope - The `this` context for the method.
* @param {(Function|String)} method - A Function or the name of a method to bind.
* @param {...*} [args] Any arguments that will be provided as the initial arguments to the
*                      enclosed method.
* @returns {Function} The bound method/closure.
* @public
*/
var bind = exports.bind = function (scope, method) {
	if (!method) {
		method = scope;
		scope = null;
	}
	scope = scope || global;
	if (typeof method == 'string') {
		if (scope[method]) {
			method = scope[method];
		} else {
			throw('enyo.bind: scope["' + method + '"] is null (scope="' + scope + '")');
		}
	}
	if (typeof method == 'function') {
		var args = cloneArray(arguments, 2);
		if (method.bind) {
			return method.bind.apply(method, [scope].concat(args));
		} else {
			return function() {
				var nargs = cloneArray(arguments);
				// invoke with collected args
				return method.apply(scope, args.concat(nargs));
			};
		}
	} else {
		throw('enyo.bind: scope["' + method + '"] is not a function (scope="' + scope + '")');
	}
};

/**
* Binds a callback to a scope. If the object has a `destroyed` property that's truthy, then the
* callback will not be run if called. This can be used to implement both
* {@link enyo.Object.bindSafely} and {@link enyo.Object}-like objects like
* {@link enyo.Model} and {@link enyo.Collection}.
*
* @param {Object} scope - The `this` context for the method.
* @param {(Function|String)} method - A Function or the name of a method to bind.
* @param {...*} [args] Any arguments that will be provided as the initial arguments to the
*                      enclosed method.
* @returns {Function} The bound method/closure.
* @public
*/
exports.bindSafely = function (scope, method) {
	if (typeof method == 'string') {
		if (scope[method]) {
			method = scope[method];
		} else {
			throw('enyo.bindSafely: scope["' + method + '"] is null (this="' + this + '")');
		}
	}
	if (typeof method == 'function') {
		var args = cloneArray(arguments, 2);
		return function() {
			if (scope.destroyed) {
				return;
			}
			var nargs = cloneArray(arguments);
			return method.apply(scope, args.concat(nargs));
		};
	} else {
		throw('enyo.bindSafely: scope["' + method + '"] is not a function (this="' + this + '")');
	}
};

/**
* Calls the provided `method` on `scope`, asynchronously.
*
* Uses [window.setTimeout()]{@glossary window.setTimeout} with minimum delay,
* usually around 10ms.
*
* Additional arguments are passed to `method` when it is invoked.
*
* If only a single argument is supplied, will just call that function asynchronously without
* doing any additional binding.
*
* @param {Object} scope - The `this` context for the method.
* @param {(Function|String)} method - A Function or the name of a method to bind.
* @param {...*} [args] Any arguments that will be provided as the initial arguments to the
*                      enclosed method.
* @returns {Number} The `setTimeout` id.
* @public
*/
exports.asyncMethod = function (scope, method) {
	if (!method) {
		// passed just a single argument
		return setTimeout(scope, 1);
	} else {
		return setTimeout(bind.apply(scope, arguments), 1);
	}
};

/**
* Calls the provided `method` ([String]{@glossary String}) on `scope` with optional
* arguments `args` ([Array]{@glossary Array}), if the object and method exist.
*
* @example
* 	enyo.call(myWorkObject, 'doWork', [3, 'foo']);
*
* @param {Object} scope - The `this` context for the method.
* @param {(Function|String)} method - A Function or the name of a method to bind.
* @param {Array} [args] - An array of arguments to pass to the method.
* @returns {*} The return value of the method.
* @public
*/
exports.call = function (scope, method, args) {
	var context = scope || this;
	if (method) {
		var fn = context[method] || method;
		if (fn && fn.apply) {
			return fn.apply(context, args || []);
		}
	}
};

/**
* Returns the current time in milliseconds. On platforms that support it,
* [Date.now()]{@glossary Date.now} will be used; otherwise this will
* be equivalent to [new Date().getTime()]{@glossary Date.getTime}.
* 
* @returns {Number} Number of milliseconds representing the current time.
* @method
* @public
*/

var now = exports.now = Date.now || function () {
	return new Date().getTime();
};

/**
* When [window.performance]{@glossary window.performance} is available, supplies
* a high-precision, high-performance monotonic timestamp, which is independent of
* changes to the system clock and thus safer for use in animation, etc. Falls back to
* [enyo.now()]{@link enyo#now} (based on the JavaScript [Date]{@glossary Date}
* object), which is subject to system time changes.
* 
* @returns {Number} Number of milliseconds representing the current time or time since
*                   start of application execution as reported by the platform.
* @method
* @public
*/
exports.perfNow = (function () {
	// we have to check whether or not the browser has supplied a valid
	// method to use
	var perf = window.performance || {};
	// test against all known vendor-specific implementations, but use
	// a fallback just in case
	perf.now = perf.now || perf.mozNow || perf.msNow || perf.oNow || perf.webkitNow || now;
	return function () {
		return perf.now();
	};
}());

/**
* A fast-path enabled global getter that takes a string path, which may be a full path (from
* context window/Enyo) or a relative path (to the execution context of the method). It knows how
* to check for and call the backwards-compatible generated getters, as well as how to handle
* computed properties. Returns `undefined` if the object at the given path cannot be found. May
* safely be called on non-existent paths.
*	
* @param {String} path - The path from which to retrieve a value.
* @returns {*} The value for the given path, or `undefined` if the path could not be
*                  completely resolved.
* @method enyo.getPath
* @public
*/
var getPath = exports.getPath = function (path) {
	// we're trying to catch only null/undefined not empty string or 0 cases
	if (!path && path !== null && path !== undefined) return path;
	
	var next = this,
		parts,
		part,
		getter,
		prev;
	
	// obviously there is a severe penalty for requesting get with a path lead
	// by unnecessary relative notation...
	if (path[0] == '.') path = path.replace(/^\.+/, '');
	
	// here's where we check to make sure we have a truthy string-ish
	if (!path) return;
	
	parts = path.split('.');
	part = parts.shift();
	
	do {
		prev = next;
		// for constructors we must check to make sure they are undeferred before
		// looking for static properties
		// for the auto generated or provided published property support we have separate
		// routines that must be called to preserve compatibility
		if (next._getters && ((getter = next._getters[part])) && !getter.generated) next = next[getter]();
		// for all other special cases to ensure we use any overloaded getter methods
		else if (next.get && next !== this && next.get !== getPath) next = next.get(part);
		// and for regular cases
		else next = next[part];
	} while (next && (part = parts.shift()));
			
	// if necessary we ensure we've undeferred any constructor that we're
	// retrieving here as a final property as well
	return next;
};

/**
* @private
*/
getPath.fast = function (path) {
	// the current context
	var b = this, fn, v;
	if (b._getters && (fn = b._getters[path])) {
		v = b[fn]();
	} else {
		v = b[path];
	}
	
	return v;
};

/**
* @TODO: Out of date...
* A global setter that takes a string path (relative to the method's execution context) or a
* full path (relative to window). Attempts to automatically retrieve any previously existing
* value to supply to any observers. If the context is an {@link enyo.Object} or subkind, the
* {@link enyo.ObserverSupport.notify} method is used to notify listeners for the path's being
* set. If the previous value is equivalent to the newly set value, observers will not be
* triggered by default. If the third parameter is present and is an explicit boolean true, the
* observers will be triggered regardless. Returns the context from which the method was executed.
*
* @param {String} path - The path for which to set the given value.
* @param {*} is - The value to set.
* @param {Object} [opts] - An options hash.
* @returns {this} Whatever the given context was when executed.
* @method enyo.setPath
* @public
*/
var setPath = exports.setPath = function (path, is, opts) {
	// we're trying to catch only null/undefined not empty string or 0 cases
	if (!path || (!path && path !== null && path !== undefined)) return this;
	
	var next = this,
		options = {create: true, silent: false, force: false},
		base = next,
		parts,
		part,
		was,
		force,
		create,
		silent,
		comparator;
	
	if (typeof opts == 'object') opts = mixin({}, [options, opts]);
	else {
		force = opts;
		opts = options;
	}
	
	if (opts.force) force = true;
	silent = opts.silent;
	create = opts.create;
	comparator = opts.comparator;
	
	
	// obviously there is a severe penalty for requesting get with a path lead
	// by unnecessary relative notation...
	if (path[0] == '.') path = path.replace(/^\.+/, '');
	
	// here's where we check to make sure we have a truthy string-ish
	if (!path) return next;
	
	parts = path.split('.');
	part = parts.shift();
	
	do {
		
		if (!parts.length) was = next.get && next.get !== getPath? next.get(part): next[part];
		else {
			// this allows us to ensure that if we're setting a static property of a constructor we have the
			// correct constructor
			// @TODO: It seems ludicrous to have to check this on every single part of a chain; if we didn't have
			// deferred constructors this wouldn't be necessary and is expensive - unnecessarily so when speed is so important
			if (next !== base && next.set && next.set !== setPath) {
				parts.unshift(part);
				next.set(parts.join('.'), is, opts);
				return base;
			}
			if (next !== base && next.get) next = (next.get !== getPath? next.get(part): next[part]) || (create && (next[part] = {}));
			else next = next[part] || (create && (next[part] = {}));
		}
		
	} while (next && parts.length && (part = parts.shift()));
	
	if (!next) return base;
	
	// now update to the new value
	if (next !== base && next.set && next.set !== setPath) {
		next.set(part, is, opts);
		return base;
	} else next[part] = is;
	
	// if possible we notify the changes but this change is notified from the immediate
	// parent not the root object (could be the same)
	if (next.notify && !silent && (force || was !== is || (comparator && comparator(was, is)))) next.notify(part, was, is, opts);
	// we will always return the original root-object of the call
	return base;
};

/**
* @private
*/
setPath.fast = function (path, value) {
	// the current context
	var b = this,
		// the previous value and helper variable
		rv, fn;
	// we have to check and ensure that we're not setting a computed property
	// and if we are, do nothing
	if (b._computed && b._computed[path] !== undefined) {
		return b;
	}
	if (b._getters && (fn=b._getters[path])) {
		rv = b[fn]();
	} else {
		rv = b[path];
	}
	// set the new value now that we can
	b[path] = value;
	
	// this method is only ever called from the context of enyo objects
	// as a protected method
	if (rv !== value) { b.notifyObservers(path, rv, value); }
	// return the context
	return b;
};

// ----------------------------------
// String Functions
// ----------------------------------

/**
* Uppercases a given string. Will coerce to a [String]{@glossary String}
* if possible/necessary.
*
* @param {String} str - The string to uppercase.
* @returns {String} The uppercased string.
* @public
*/
exports.toUpperCase = function (str) {
	if (str != null) {
		return str.toString().toUpperCase();
	}
	return str;
};

/**
* Lowercases a given string. Will coerce to a [String]{@glossary String}
* if possible/necessary.
*
* @param {String} str - The string to lowercase.
* @returns {String} The lowercased string.
* @public
*/
exports.toLowerCase = function (str) {
	if (str != null) {
		return str.toString().toLowerCase();
	}
	return str;
};

/**
* Capitalizes a given string.
*
* @param {String} str - The string to capitalize.
* @returns {String} The capitalized string.
* @public
*/
exports.cap = function (str) {
	return str.slice(0, 1).toUpperCase() + str.slice(1);
};

/**
* Un-capitalizes a given string.
* 
* @param {String} str - The string to un-capitalize.
* @returns {String} The un-capitalized string.
* @public
*/
exports.uncap = function (str) {
	return str.slice(0, 1).toLowerCase() + str.slice(1);
};

/**
* Injects an arbitrary number of values, in order, into a template string at
* positions marked by `"%."`.
*
* @param {String} template - The string template to inject with values.
* @param {...String} val The values to inject into the template.
* @returns {String} A copy of the template populated with values.
* @public
*/
exports.format = function (template) {
	var pattern = /\%./g,
		arg = 0,
		tmp = template,
		args = arguments,
		replacer;
	
	replacer = function () {
		return args[++arg];
	};
	
	return tmp.replace(pattern, replacer);
};

/**
* @private
*/
String.prototype.trim = String.prototype.trim || function () {
	return this.replace(/^\s+|\s+$/g, '');
};

/**
* Takes a string and trims leading and trailing spaces. Strings with no length,
* non-strings, and falsy values will be returned without modification.
*
* @param {String} str - The string from which to remove whitespace.
* @returns {String} The trimmed string.
* @public
*/
exports.trim = function (str) {
	return (typeof str == 'string' && str.trim()) || str;
};

// ----------------------------------
// Object Functions
// ----------------------------------

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Object.create()]{@glossary Object.create}.
*/
Object.create = Object.create || (function () {
	var Anon = function () {};
	return function (obj) {
		// in the polyfill we can't support the additional features so we are ignoring
		// the extra parameters
		if (!obj || obj === null || typeof obj != 'object') throw 'Object.create: Invalid parameter';
		Anon.prototype = obj;
		return new Anon();
	};
})();

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Object.keys()]{@glossary Object.keys}.
*/
Object.keys = Object.keys || function (obj) {
	var results = [];
	var hop = Object.prototype.hasOwnProperty;
	for (var prop in obj) {
		if (hop.call(obj, prop)) {
			results.push(prop);
		}
	}
	// *sigh* IE 8
	if (!({toString: null}).propertyIsEnumerable('toString')) {
		var dontEnums = [
			'toString',
			'toLocaleString',
			'valueOf',
			'hasOwnProperty',
			'isPrototypeOf',
			'propertyIsEnumerable',
			'constructor'
		];
		for (var i = 0, p; (p = dontEnums[i]); i++) {
			if (hop.call(obj, p)) {
				results.push(p);
			}
		}
	}
	return results;
};

/**
* Returns an array of all known enumerable properties found on a given object.
*
* @alias Object.keys.
* @method enyo.keys
* @public
*/
exports.keys = Object.keys;

/**
* Convenience method that takes an [array]{@glossary Array} of properties
* and an [object]{@glossary Object} as parameters. Returns a new object
* with only those properties named in the array that are found to exist on the
* base object. If the third parameter is `true`, falsy values will be ignored.
*
* @param {String[]} properties The properties to include on the returned object.
* @param {Object} object - The object from which to retrieve values for the requested properties.
* @param {Boolean} [ignore=false] Whether or not to ignore copying falsy values.
* @returns {Object} A new object populated with the requested properties and values from
*                     the given object.
* @public
*/
exports.only = function (properties, object, ignore) {
	var ret = {},
		prop,
		len,
		i;
	
	for (i = 0, len = properties.length >>> 0; i < len; ++i) {
		prop = properties[i];
		
		if (ignore && (object[prop] === undefined || object[prop] === null)) continue;
		ret[prop] = object[prop];
	}
	
	return ret;
};

/**
* Convenience method that takes two [objects]{@glossary Object} as parameters.
* For each key from the first object, if the key also exists in the second object,
* a mapping of the key from the first object to the key from the second object is
* added to a result object, which is eventually returned. In other words, the
* returned object maps the named properties of the first object to the named
* properties of the second object. The optional third parameter is a boolean
* designating whether to pass unknown key/value pairs through to the new object.
* If `true`, those keys will exist on the returned object.
*
* @param {Object} map - The object with key/value pairs.
* @param {Object} obj - The object whose values will be used.
* @param {Boolean} [pass=false] Whether or not to pass unnamed properties through
*                               from the given object.
* @returns {Object} A new object whose properties have been mapped.
* @public
*/
exports.remap = function (map, obj, pass) {
	var ret = pass ? clone(obj) : {},
		key;
	
	for (key in map) {
		if (key in obj) ret[map[key]] = obj.get ? obj.get(key) : obj[key];
	}
	return ret;
};

/**
* Helper method that accepts an [array]{@glossary Array} of
* [objects]{@glossary Object} and returns a hash of those objects indexed
* by the specified `property`. If a `filter` is provided, the filter should
* accept four parameters: the key, the value (object), the current mutable map
* reference, and an immutable copy of the original array of objects for
* comparison.
*
* @param {String} property - The property to index the array by.
* @param {Array} array - An array of property objects.
* @param {Function} [filter] - The filter function to use; accepts four arguments.
* @returns {Object} A hash (object) indexed by the `property` argument
* @public
*/
exports.indexBy = function (property, array, filter) {
	// the return value - indexed map from the given array
	var map = {},
		value,
		len,
		idx = 0;
	// sanity check for the array with an efficient native array check
	if (!exists(array) || !(array instanceof Array)) {
		return map;
	}
	// sanity check the property as a string
	if (!exists(property) || 'string' !== typeof property) {
		return map;
	}
	// the immutable copy of the array
	var copy = clone(array);
	// test to see if filter actually exsits
	filter = exists(filter) && 'function' === typeof filter ? filter : undefined;
	for (len = array.length; idx < len; ++idx) {
		// grab the value from the array
		value = array[idx];
		// make sure that it exists and has the requested property at all
		if (exists(value) && exists(value[property])) {
			if (filter) {
				// if there was a filter use it - it is responsible for
				// updating the map accordingly
				filter(property, value, map, copy);
			} else {
				// use the default behavior - check to see if the key
				// already exists on the map it will be overwritten
				map[value[property]] = value;
			}
		}
	}
	// go ahead and return our modified map
	return map;
};

/**
* Creates and returns a shallow copy of an [Object]{@glossary Object} or an
* [Array]{@glossary Array}. For objects, by default, properties will be scanned and
* copied directly to the clone such that they would pass the
* [hasOwnProperty()]{@glossary Object.hasOwnProperty} test. This is expensive and often not
* required. In this case, the optional second parameter may be used to allow a more efficient
* [copy]{@link Object.create} to be made.
* 
* @param {(Object|Array)} base - The [Object]{@glossary Object} or
*                              [Array]{@glossary Array} to be cloned.
* @param {Boolean} [quick] - If `true`, when cloning objects, a faster [copy]{@link Object.create}
*                          method will be used. This parameter has no meaning when cloning arrays.
* @returns {*} A clone of the provided `base` if `base` is of the correct type; otherwise,
*              returns `base` as it was passed in.
* @public
*/
var clone = exports.clone = function (base, quick) {
	if (base) {
		
		// avoid the overhead of calling yet another internal function to do type-checking
		// just copy the array and be done with it
		if (base instanceof Array) return base.slice();
		else if (base instanceof Object) {
			return quick ? Object.create(base) : mixin({}, base);
		}
	}
	
	// we will only do this if it is not an array or native object
	return base;
};

var empty = {};
var mixinDefaults = {
	exists: false,
	ignore: false,
	filter: null
};

/**
	@todo Rewrite with appropriate documentation for options parameter (typedef)
	@todo document 'quick' option

	Will take a variety of options to ultimately mix a set of properties
	from objects into single object. All configurations accept a boolean as
	the final parameter to indicate whether or not to ignore _truthy_/_existing_
	values on any _objects_ prior.

	If _target_ exists and is an object, it will be the base for all properties
	and the returned value. If the parameter is used but is _falsy_, a new
	object will be created and returned. If no such parameter exists, the first
	parameter must be an array of objects and a new object will be created as
	the _target_.

	The _source_ parameter may be an object or an array of objects. If no
	_target_ parameter is provided, _source_ must be an array of objects.

	The _options_ parameter allows you to set the _ignore_ and/or _exists_ flags
	such that if _ignore_ is true, it will not override any truthy values in the
	target, and if _exists_ is true, it will only use truthy values from any of
	the sources. You may optionally add a _filter_ method-option that returns a
	true or false value to indicate whether the value should be used. It receives
	parameters in this order: _property_, _source value_, _source values_,
	_target_, _options_. Note that modifying the target in the filter method can
	have unexpected results.

	Setting _options_ to true will set all options to true.

* @method enyo.mixin
* @public
*/
var mixin = exports.mixin = function () {
	var ret = arguments[0],
		src = arguments[1],
		opts = arguments[2],
		val;
	
	if (!ret) ret = {};
	else if (ret instanceof Array) {
		opts = src;
		src = ret;
		ret = {};
	}
	
	if (!opts || opts === true) opts = mixinDefaults;

	if (src instanceof Array) for (var i=0, it; (it=src[i]); ++i) mixin(ret, it, opts);
	else {
		for (var key in src) {
			val = src[key];
			
			// quickly ensure the property isn't a default
			if (empty[key] !== val) {
				if (
					(!opts.exists || val) &&
					(!opts.ignore || !ret[key]) &&
					(opts.filter? opts.filter(key, val, src, ret, opts): true)
				) {
					ret[key] = val;
				}
			}
		}
	}
	
	return ret;
};

/**
* Returns an [array]{@glossary Array} of the values of all properties in an
* [object]{@glossary Object}.
*
* @param {Object} obj - The [Object]{@glossary Object} to read the values from.
* @returns {Array} An [array]{@glossary Array} with the values from the `obj`.
* @public
*/
exports.values = function (obj) {
	var ret = [];
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) ret.push(obj[key]);
	}
	return ret;
};

// ----------------------------------
// Array Functions
// ----------------------------------

/**
* Because our older API parameters are not consistent with other array API methods, and also
* because only [IE8 lacks integrated support]{@glossary polyfill} for
* [indexOf()]{@linkcode external:Array.indexOf}, we ensure it is defined (only IE8) and advise,
* moving forward, that the built-in method be used. But to preserve our original API, it will
* simply call this method, knowing it exists.
*
* @private
*/
Array.prototype.indexOf = Array.prototype.indexOf || function (el, offset) {
	var len = this.length >>> 0;
	
	offset = +offset || 0;
	
	if (Math.abs(offset) === Infinity) offset = 0;
	if (offset < 0) offset += len;
	if (offset < 0) offset = 0;
	
	for (; offset < len; ++offset) {
		if (this[offset] === el) return offset;
	}
	
	return -1;
};

/**
* Because our older API parameters are not consistent with other array API methods, and also
* because only [IE8 lacks integrated support]{@glossary polyfill} for
* [lastIndexOf()]{@glossary Array.lastIndexOf} we ensure it is defined (only IE8) and
* advise, moving forward, that the built-in method be used. But to preserve our original API, it
* will simply call this method, knowing it exists.
*
* @private
*/
Array.prototype.lastIndexOf = Array.prototype.lastIndexOf || function (el, offset) {
	var array = Object(this)
		, len = array.length >>> 0;
		
	if (len === 0) return -1;
	
	if (offset !== undefined) {
		offset = Number(offset);
		if (Math.abs(offset) > len) offset = len;
		if (offset === Infinity || offset === -Infinity) offset = len;
		if (offset < 0) offset += len;
	} else offset = len;
	
	for (; offset > -1; --offset) {
		if (array[offset] === el) return offset;
	}
	
	return -1;
};

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Array.findIndex()]{@glossary Array.findIndex}.
*/
Array.prototype.findIndex = Array.prototype.findIndex || function (fn, ctx) {
	for (var i=0, len=this.length >>> 0; i<len; ++i) {
		if (fn.call(ctx, this[i], i, this)) return i;
	}
	return -1;
};

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Array.find()]{@glossary Array.find}.
*/
Array.prototype.find = Array.prototype.find || function (fn, ctx) {
	for (var i=0, len=this.length >>> 0; i<len; ++i) {
		if (fn.call(ctx, this[i], i, this)) return this[i];
	}
};

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Array.forEach()]{@glossary Array.forEach}.
*/
Array.prototype.forEach = Array.prototype.forEach || function (fn, ctx) {
	for (var i=0, len=this.length >>> 0; i<len; ++i) fn.call(ctx, this[i], this);
};

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Array.map()]{@glossary Array.map}.
*/
Array.prototype.map = Array.prototype.map || function (fn, ctx) {
	var ret = [];
	for (var i=0, len=this.length >>> 0; i<len; ++i) {
		ret.push(fn.call(ctx, this[i], i, this));
	}
	return ret;
};

/**
* A [polyfill]{@glossary polyfill} for platforms that don't support
* [Array.filter()]{@glossary Array.filter}.
*/
Array.prototype.filter = Array.prototype.filter || function (fn, ctx) {
	var ret = [];
	for (var i=0, len=this.length >>> 0; i<len; ++i) {
		fn.call(ctx, this[i], i, this) && ret.push(this[i]);
	}
	return ret;
};

/**
* An Enyo convenience method reference to [Array.indexOf()]{@glossary Array.indexOf}.
* 
* This also supports the legacy Enyo argument order `el.indexOf(array, offset)` and can
* differentiate between this and the standard `array.indexOf(el, offset)`.
*
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
*
* @public
*/
exports.indexOf = function (array, el, offset) {
	if (!(array instanceof Array)) return el.indexOf(array, offset);
	return array.indexOf(el, offset);
};

/**
* An Enyo convenience method reference to [Array.lastIndexOf()]{@glossary Array.lastIndexOf}.
* 
* This also supports the legacy Enyo argument order `el.lastIndexOf(array, offset)` and can
* differentiate between this and the standard `array.lastIndexOf(el, offset)`.
*
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
*
* @public
*/
exports.lastIndexOf = function (array, el, offset) {
	if (!(array instanceof Array)) return el.lastIndexOf(array, offset);
	return array.lastIndexOf(el, offset);
};

/**
* An Enyo convenience method reference to [Array.findIndex()]{@glossary Array.findIndex}.
* 
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
* 
* @public
*/
exports.findIndex = function (array, fn, ctx) {
	return array.findIndex(fn, ctx);
};

/**
* An Enyo convenience method reference to [Array.find()]{@glossary Array.find}.
* 
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
* 
* @method enyo.find
* @public
*/
var find = exports.find = function (array, fn, ctx) {
	return array.find(fn, ctx);
};

/**
* @alias enyo.find
* @method enyo.where
* @public
*/
exports.where = find;

/**
* An Enyo convenience method reference to [Array.forEach()]{@glossary Array.forEach}.
* 
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
* 
* @public
*/
exports.forEach = function (array, fn, ctx) {
	return array.forEach(fn, ctx);
};

/**
* An Enyo convenience method reference to [Array.map()]{@glossary Array.map}.
*
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
*
* @public
*/
exports.map = function (array, fn, ctx) {
	return array.map(fn, ctx);
};

/**
* An Enyo convenience method reference to [Array.filter()]{@glossary Array.filter}.
*
* **When possible, you should use the native equivalent.**
* 
* This method supports the same arguments as the native version, plus an extra argument at the
* beginning referring to the [array]{@glossary Array} to run this method on.
*
* @public
*/
exports.filter = function (array, fn, ctx) {
	return array.filter(fn, ctx);
};

/**
* When given an [array]{@glossary Array} of [objects]{@glossary Object},
* searches through the array's objects; each object with a property name matching
* `prop` has its value for that property compiled into a result array, which is
* eventually returned. For each array object that doesn't have a matching property,
* an `undefined` placeholder element is added to the result array, such that the
* returned result array has the same length as the passed-in `array` parameter.
* 
* @param {Array} array - The [array]{@glossary Array} of [objects]{@glossary Object}
*                      in which the `prop` will be searched for.
* @param {String} prop - A string containing the name of the property to search for.
* @returns {Array} An array of all the values of the named property from
*                     objects contained in the `array`.
* @public
*/
exports.pluck = function (array, prop) {
	if (!(array instanceof Array)) {
		var tmp = array;
		array = prop;
		prop = tmp;
	}
	
	var ret = [];
	for (var i=0, len=array.length >>> 0; i<len; ++i) {
		ret.push(array[i]? array[i][prop]: undefined);
	}
	return ret;
};

/**
* Concatenates a variable number of [arrays]{@glossary Array}, removing any duplicate
* entries.
* 
* @returns {Array} The unique values from all [arrays]{@glossary Array}.
* @public
*/
exports.merge = function (/* _arrays_ */) {
	var ret = [],
		values = Array.prototype.concat.apply([], arguments);
	for (var i=0, len=values.length >>> 0; i<len; ++i) {
		if (!~ret.indexOf(values[i])) ret.push(values[i]);
	}
	return ret;
};

/**
* Clones an existing [Array]{@glossary Array}, or converts an array-like
* object into an Array.
* 
* If `offset` is non-zero, the cloning starts from that index in the source
* Array. The clone may be appended to an existing Array by passing in the
* existing Array as `initialArray`.
* 
* Array-like objects have `length` properties, and support square-bracket
* notation `([])`. Array-like objects often do not support Array methods
* such as `push()` or `concat()`, and so must be converted to Arrays before
* use.
* 
* The special `arguments` variable is an example of an array-like object.
*
* @public
*/
var cloneArray = exports.cloneArray = function (array, offset, initialArray) {
	var ret = initialArray || [];
	for(var i = offset || 0, l = array.length; i<l; i++){
		ret.push(array[i]);
	}
	// Alternate smarter implementation:
	// return Array.prototype.slice.call(array, offset);
	// Array.of
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
	return ret;
};

/**
* @alias cloneArray
* @method enyo.toArray
* @public
*/
exports.toArray = cloneArray;

/**
* Within a given [array]{@glossary Array}, removes the first
* [strictly equal to]{@glossary ===} occurrence of `el`.
* Note that `array` is modified directly.
*
* @param {Array} array - The [Array]{@glossary Array} to look through.
* @param {*} el - The element to search for and remove.
* @public
*/
exports.remove = function (array, el) {
	if (!(array instanceof Array)) {
		var tmp = array;
		array = el;
		el = tmp;
	}
	
	var i = array.indexOf(el);
	if (-1 < i) array.splice(i, 1);
	return array;
};

/**
* This regex pattern is used by the [enyo.isRtl()]{@link enyo.isRtl} function.
* 
* Arabic: \u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFE
* Hebrew: \u0590-\u05FF\uFB1D-\uFB4F
* 
* @private
*/
var rtlPattern = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFE\u0590-\u05FF\uFB1D-\uFB4F]/;

/**
* Takes content `str` and determines whether or not it is [RTL]{@glossary RTL}.
*
* @param {String} str - A [String]{@glossary String} to check the [RTL]{@glossary RTL}-ness of.
* @return {Boolean} `true` if `str` should be RTL; `false` if not.
* @public
*/
exports.isRtl = function (str) {
	return rtlPattern.test(str);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1}],49:[function(require,module,exports){
require('../../enyo');

var
	States = require('./States');

/**
* Provides generic API methods related to using {@link enyo.States}.
*
* @mixin enyo.StateSupport
* @public
*/
module.exports = {
	
	/**
	* @private
	*/
	name: 'StateSupport',
	
	/**
	* The given status. This property will be modified by the other API methods of
	* {@link enyo.StateSupport}.
	*
	* @type enyo.States
	* @default null
	*/
	status: null,
	
	/**
	* Will remove any [error flags]{@link enyo.States.ERROR} from the given
	* [status]{@link enyo.StateSupport.status}.
	*
	* @public
	*/
	clearError: function () {
		this.status = this.status & ~States.ERROR;
	},
	
	/**
	* Convenience method to avoid using [bitwise]{@glossary bitwise} comparison for the
	* [status]{@link enyo.StateSupport.status}. Determines whether the current status
	* (or the optional passed-in value) is an [error state]{@link enyo.States.ERROR}.
	* The passed-in value will only be used if it is a [Number]{@glossary Number}.
	*
	* @param {enyo.States} [status] - The specific value to compare as an
	*	[error state]{@link enyo.States.ERROR}.
	* @returns {Boolean} Whether the value is an [error state]{@link enyo.States.ERROR} or not.
	* @public
	*/
	isError: function (status) {
		return !! ((isNaN(status) ? this.status : status) & States.ERROR);
	},
	
	/**
	* Convenience method to avoid using [bitwise]{@glossary bitwise} comparison for the
	* [status]{@link enyo.StateSupport.status}. Determines whether the current status
	* (or the optional passed-in value) is a [busy state]{@link enyo.States.BUSY}. The
	* passed-in value will only be used if it is a [Number]{@glossary Number}.
	*
	* @param {enyo.States} [status] - The specific value to compare as a
	*	[busy state]{@link enyo.States.BUSY}.
	* @returns {Boolean} Whether the value is a [busy state]{@link enyo.States.BUSY} or not.
	* @public
	*/
	isBusy: function (status) {
		return !! ((isNaN(status) ? this.status : status) & States.BUSY);
	},
	
	/**
	* Convenience method to avoid using [bitwise]{@glossary bitwise} comparison for the
	* [status]{@link enyo.StateSupport.status}. Determines whether the current status
	* (or the optional passed-in value) is a [ready state]{@link enyo.States.READY}. The
	* passed-in value will only be used if it is a [Number]{@glossary Number}.
	*
	* @param {enyo.States} [status] - The specific value to compare as a
	*	[ready state]{@link enyo.States.READY}.
	* @returns {Boolean} Whether the value is a [ready state]{@link enyo.States.BUSY} or not.
	* @public
	*/
	isReady: function (status) {
		return !! ((isNaN(status) ? this.status : status) & States.READY);
	}
};
},{"../../enyo":1,"./States":50}],19:[function(require,module,exports){
require('../../enyo');

var
	utils = require('./utils');

var
	eventTable = {};

/**
* @private
*/
function addListener(obj, e, fn, ctx) {

	obj.listeners().push({
		event: e,
		method: fn,
		ctx: ctx || obj
	});
	
	return obj;
}

/**
* @private
*/
function removeListener(obj, e, fn, ctx) {
	var listeners = obj.listeners()
		, idx;
		
	if (listeners.length) {
		idx = listeners.findIndex(function (ln) {
			return ln.event == e && ln.method === fn && (ctx? ln.ctx === ctx: true);
		});
		idx >= 0 && listeners.splice(idx, 1);
	}
	
	return obj;
}

/**
* @private
*/
function emit(obj, args) {
	var len = args.length
		, e = args[0]
		, listeners = obj.listeners(e);
		
	if (listeners.length) {
		if (len > 1) {
			args = utils.toArray(args);
			args.unshift(obj);
		} else {
			args = [obj, e];
		}

		for (var i=0, ln; (ln=listeners[i]); ++i) ln.method.apply(ln.ctx, args);
		
		return true;
	}
	
	return false;
}

/**
* {@link enyo.EventEmitter} is a {@glossary mixin} that adds support for
* registered {@glossary event} listeners. These events are different from
* bubbled events (e.g., DOM events and [handlers]{@link enyo.Component#handlers}).
* When [emitted]{@link enyo.EventEmitter#emit}, these events **do not bubble**
* and will only be handled by [registered listeners]{@link enyo.EventEmitter#on}.
*
* @mixin enyo.EventEmitter
* @public
*/
module.exports = {
	
	/**
	* @private
	*/
	name: 'EventEmitter',
	
	/**
	* @private
	*/
	_silenced: false,
	
	/**
	* @private
	*/
	_silenceCount: 0,
	
	/**
	* Disables propagation of [events]{@glossary event}. This is a counting
	* semaphor and [unsilence()]{@link enyo.EventEmitter#unsilence} will need to
	* be called the same number of times that this method is called.
	*
	* @see enyo.EventEmitter.unsilence
	* @returns {this} The callee for chaining.
	* @public
	*/
	silence: function () {
		this._silenced = true;
		this._silenceCount++;
		return this;
	},
	
	/**
	* Enables propagation of [events]{@glossary event}. This is a counting
	* semaphor and this method will need to be called the same number of times
	* that [silence()]{@link enyo.EventEmitter#silence} was called.
	*
	* @see enyo.EventEmitter.silence
	* @returns {this} The callee for chaining.
	* @public
	*/
	unsilence: function (force) {
		if (force) {
			this._silenceCount = 0;
			this._silenced = false;
		} else {
			this._silenceCount && this._silenceCount--;
			this._silenceCount === 0 && (this._silenced = false);
		}
		return this;
	},
	
	/**
	* Determines whether the callee is currently [silenced]{@link enyo.EventEmitter#silence}.
	*
	* @returns {Boolean} Whether or not the callee is
	*	[silenced]{@link enyo.EventEmitter.silence}.
	* @public
	*/
	isSilenced: function () {
		return this._silenced;
	},
	
	/**
	* @alias enyo.EventEmitter.on
	* @deprecated
	* @public
	*/
	addListener: function (e, fn, ctx) {
		return addListener(this, e, fn, ctx);
	},
	
	/**
	* Adds an {@glossary event} listener. Until [removed]{@link enyo.EventEmitter#off},
	* this listener will fire every time the event is
	* [emitted]{@link enyo.EventEmitter#emit}.
	*
	* @param {String} e - The {@glossary event} name to register for.
	* @param {Function} fn - The listener.
	* @param {Object} [ctx] - The optional context under which to execute the listener.
	* @returns {this} The callee for chaining.
	* @public
	*/
	on: function (e, fn, ctx) {
		return addListener(this, e, fn, ctx);
	},
	
	/**
	* @alias enyo.EventEmitter.off
	* @deprecated
	* @public
	*/
	removeListener: function (e, fn, ctx) {
		return removeListener(this, e, fn, ctx);
	},
	
	/**
	* Removes an {@glossary event} listener.
	*
	* @param {String} e - The {@glossary event} name.
	* @param {Function} fn - The listener to unregister.
	* @param {Object} [ctx] - If the listener was registered with a context, it
	* should be provided when unregistering as well.
	* @returns {this} The callee for chaining.
	* @public
	*/
	off: function (e, fn, ctx) {
		return removeListener(this, e, fn, ctx);
	},
	
	/**
	* Removes all listeners, or all listeners for a given {@glossary event}.
	*
	* @param {String} [e] - The optional target {@glossary event}.
	* @returns {this} The callee for chaining.
	*/
	removeAllListeners: function (e) {
		var euid = this.euid
			, loc = euid && eventTable[euid];
		
		if (loc) {
			if (e) {
				eventTable[euid] = loc.filter(function (ln) {
					return ln.event != e;
				});
			} else {
				eventTable[euid] = null;
			}
		}
		
		return this;
	},
	
	/**
	* Primarily intended for internal use, this method returns an immutable copy
	* of all listeners, or all listeners for a particular {@glossary event} (if any).
	*
	* @param {String} [e] - The targeted {@glossary event}.
	* @returns {Object[]} Event listeners are stored in [hashes]{@glossary Object}.
	*	The return value will be an [array]{@glossary Array} of these hashes
	* if any listeners exist.
	* @public
	*/
	listeners: function (e) {
		var euid = this.euid || (this.euid = utils.uid('e'))
			, loc = eventTable[euid] || (eventTable[euid] = []);
		
		return !e? loc: loc.filter(function (ln) {
			return ln.event == e || ln.event == '*';
		});
	},
	
	/**
	* @alias enyo.EventEmitter.emit
	* @deprecated
	* @public
	*/
	triggerEvent: function () {
		return !this._silenced? emit(this, arguments): false;
	},
	
	/**
	* Emits the named {@glossary event}. All subsequent arguments will be passed
	* to the event listeners.
	*
	* @param {String} e - The {@glossary event} to emit.
	* @param {...*} args All subsequent arguments will be passed to the event listeners.
	* @returns {Boolean} Whether or not any listeners were notified.
	* @public
	*/
	emit: function () {
		return !this._silenced? emit(this, arguments): false;
	}
};
},{"../../enyo":1,"./utils":75}],20:[function(require,module,exports){
require('../../enyo');

var
	utils = require('./utils');

/**
* An [XHR2]{@linkplain http://www.w3.org/TR/XMLHttpRequest/} FormData implementation.
* It is used to send `multipart/form-data` [Ajax]{@glossary ajax} requests. The
* internal `enyo.Blob` [kind]{@glossary kind} is the content provider for file-parts.
*
* Note that in Internet Explorer < 10, both {@link enyo.FormData} and `enyo.Blob` are
* limited to [string]{@glossary String} content and `enyo.Blob` may only be
* instantiated using an [array]{@glossary Array} or [string]{@glossary String}.
*
* This implementation is inspired by
* [html5-formdata]{@linkplain https://github.com/francois2metz/html5-formdata/blob/master/formdata.js}.
*
* ```
* Emulate FormData for some browsers
* MIT License
* (c) 2010 Francois de Metz
* ```
*
* @class enyo.FormData
* @public
*/
exports = null;

if (typeof FormData != 'undefined') {
	try {
		new FormData();
		
		exports = module.exports = FormData;
	// Android Chrome 18 will throw an error trying to create this
	} catch (e) {}
}

if (!exports) {

	/*jshint -W082 */
	function FormData() {
		this.fake = true;
		this._fields = [];
		// This generates a 50 character boundary similar to
		// those used by Firefox.  They are optimized for
		// boyer-moore parsing.
		this.boundary = '--------------------------';
		for (var i = 0; i < 24; i++) {
			this.boundary += Math.floor(Math.random() * 10).toString(16);
		}
	}
	FormData.prototype.getContentType = function() {
		return "multipart/form-data; boundary=" + this.boundary;
	};
	FormData.prototype.append = function(key, value, filename) {
		this._fields.push([key, value, filename]);
	};
	FormData.prototype.toString = function() {
		var boundary = this.boundary;
		var body = "";
		utils.forEach(this._fields, function(field) {
			body += "--" + boundary + "\r\n";
			if (field[2] || field[1].name) {
				// file upload
				var file = field[1], filename = field[2] || file.name;
				body += "Content-Disposition: form-data; name=\""+ field[0] +"\"; filename=\""+ filename +"\"\r\n";
				body += "Content-Type: "+ file.type +"\r\n\r\n";
				body += file.getAsBinary() + "\r\n";
			} else {
				// key-value field
				body += "Content-Disposition: form-data; name=\""+ field[0] +"\";\r\n\r\n";
				body += field[1] + "\r\n";
			}
		});
		body += "--" + boundary +"--";
		return body;
	};
	/*jshint +W082 */
	
	module.exports = FormData;
}
},{"../../enyo":1,"./utils":75}],71:[function(require,module,exports){
require('../../enyo');

var utils = require('./utils');

/**
* Determines OS versions of platforms that need special treatment. Can have one of the following
* properties:
*
* * android
* * androidChrome (Chrome on Android, standard starting in 4.1)
* * androidFirefox
* * ie
* * ios
* * webos
* * windowsPhone
* * blackberry
* * tizen
* * safari (desktop version)
* * chrome (desktop version)
* * firefox (desktop version)
* * firefoxOS
*
* If the property is defined, its value will be the major version number of the platform.
*
* Example:
* ```javascript
* // android 2 does not have 3d css
* if (enyo.platform.android < 3) {
* 	t = 'translate(30px, 50px)';
* } else {
* 	t = 'translate3d(30px, 50px, 0)';
* }
* this.applyStyle('-webkit-transform', t);
* ```
*
* @name enyo.platform
*/
exports = module.exports = 
	/** @lends enyo.platform */ {
	//* `true` if the platform has native single-finger [events]{@glossary event}.
	touch: Boolean(('ontouchstart' in window) || window.navigator.msMaxTouchPoints),
	//* `true` if the platform has native double-finger [events]{@glossary event}.
	gesture: Boolean(('ongesturestart' in window) || window.navigator.msMaxTouchPoints)
};

/**
* @private
*/
var ua = navigator.userAgent;
var ep = exports;
var platforms = [
	// Android 4+ using Chrome
	{platform: 'androidChrome', regex: /Android .* Chrome\/(\d+)[.\d]+/},
	// Android 2 - 4
	{platform: 'android', regex: /Android (\d+)/},
	// Kindle Fire
	// Force version to 2, (desktop mode does not list android version)
	{platform: 'android', regex: /Silk\/1./, forceVersion: 2, extra: {silk: 1}},
	// Kindle Fire HD (Silk versions 2 or 3)
	// Force version to 4
	{platform: 'android', regex: /Silk\/2./, forceVersion: 4, extra: {silk: 2}},
	{platform: 'android', regex: /Silk\/3./, forceVersion: 4, extra: {silk: 3}},
	// Windows Phone 7 - 8
	{platform: 'windowsPhone', regex: /Windows Phone (?:OS )?(\d+)[.\d]+/},
	// IE 8 - 10
	{platform: 'ie', regex: /MSIE (\d+)/},
	// IE 11
	{platform: 'ie', regex: /Trident\/.*; rv:(\d+)/},
	// iOS 3 - 5
	// Apple likes to make this complicated
	{platform: 'ios', regex: /iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/},
	// webOS 1 - 3
	{platform: 'webos', regex: /(?:web|hpw)OS\/(\d+)/},
	// webOS 4 / OpenWebOS
	{platform: 'webos', regex: /WebAppManager|Isis|webOS\./, forceVersion: 4},
	// Open webOS release LuneOS
	{platform: 'webos', regex: /LuneOS/, forceVersion: 4, extra: {luneos: 1}},
	// desktop Safari
	{platform: 'safari', regex: /Version\/(\d+)[.\d]+\s+Safari/},
	// desktop Chrome
	{platform: 'chrome', regex: /Chrome\/(\d+)[.\d]+/},
	// Firefox on Android
	{platform: 'androidFirefox', regex: /Android;.*Firefox\/(\d+)/},
	// FirefoxOS
	{platform: 'firefoxOS', regex: /Mobile;.*Firefox\/(\d+)/},
	// desktop Firefox
	{platform: 'firefox', regex: /Firefox\/(\d+)/},
	// Blackberry Playbook
	{platform: 'blackberry', regex: /PlayBook/i, forceVersion: 2},
	// Blackberry 10+
	{platform: 'blackberry', regex: /BB1\d;.*Version\/(\d+\.\d+)/},
	// Tizen
	{platform: 'tizen', regex: /Tizen (\d+)/}
];
for (var i = 0, p, m, v; (p = platforms[i]); i++) {
	m = p.regex.exec(ua);
	if (m) {
		if (p.forceVersion) {
			v = p.forceVersion;
		} else {
			v = Number(m[1]);
		}
		ep[p.platform] = v;
		if (p.extra) {
			utils.mixin(ep, p.extra);
		}
		ep.platformName = p.platform;
		break;
	}
}

},{"../../enyo":1,"./utils":75}],56:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	platform = require('./platform'),
	utils = require('./utils');

var ms = Math.round(1000/60);
var prefix = ['webkit', 'moz', 'ms', 'o', ''];
var r = 'requestAnimationFrame';
var c = 'cancel' + utils.cap(r);

/*
* Fallback on setTimeout
*
* @private
*/
var _requestFrame = function(inCallback) {
	return global.setTimeout(inCallback, ms);
};

/*
* Fallback on clearTimeout
*
* @private
*/
var _cancelFrame = function(inId) {
	return global.clearTimeout(inId);
};

for (var i = 0, pl = prefix.length, p, wc, wr; (p = prefix[i]) || i < pl; i++) {
	// if we're on ios 6 just use setTimeout, requestAnimationFrame has some kinks currently
	if (platform.ios >= 6) {
		break;
	}

	// if prefixed, becomes Request and Cancel
	wc = p ? (p + utils.cap(c)) : c;
	wr = p ? (p + utils.cap(r)) : r;
	// Test for cancelRequestAnimationFrame, because some browsers (Firefix 4-10) have a request without a cancel
	if (global[wc]) {
		_cancelFrame = global[wc];
		_requestFrame = global[wr];
		if (p == 'webkit') {
			/*
				Note: In Chrome, the first return value of webkitRequestAnimationFrame is 0.
				We make 1 bogus call so the first used return value of webkitRequestAnimationFrame is > 0, as the spec requires.
				This makes it so that the requestId is always truthy.
				(we choose to do this rather than wrapping the native function to avoid the overhead)
			*/
			_cancelFrame(_requestFrame(utils.nop));
		}
		break;
	}
}
/**
* Requests an animation callback.
*
* On compatible browsers, if `node` is defined, the [callback]{@glossary callback} will
* fire only if `node` is visible.
*
* @param {Function} callback - A [callback]{@glossary callback} to be executed on the
*                            animation frame.
* @param {Node} node - The DOM node to request the animation frame for.
* @returns {Object} A request id to be used with
*                     [enyo.cancelRequestAnimationFrame()]{@link enyo.cancelRequestAnimationFrame}.
* @public
*/
exports.requestAnimationFrame = function(callback, node) {
	return _requestFrame(callback, node);
};
/**
* Cancels a requested animation callback with the specified id.
*
* @public
*/
exports.cancelRequestAnimationFrame = function(inId) {
	return _cancelFrame(inId);
};

/**
* A set of interpolation functions for animations, similar in function to CSS3
* transitions.
*
* These are intended for use with {@link enyo.easedLerp}. Each easing function
* accepts one (1) [Number]{@glossary Number} parameter and returns one (1)
* [Number]{@glossary Number} value.
*
* @namespace enyo.easing
* @public
*/
exports.easing = /** @lends enyo.easing */ {
	/**
	* cubicIn
	*
	* @public
	*/
	cubicIn: function(n) {
		return Math.pow(n, 3);
	},
	/**
	* cubicOut
	*
	* @public
	*/
	cubicOut: function(n) {
		return Math.pow(n - 1, 3) + 1;
	},
	/**
	* expoOut
	*
	* @public
	*/
	expoOut: function(n) {
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},
	/**
	* quadInOut
	*
	* @public
	*/
	quadInOut: function(n) {
		n = n * 2;
		if (n < 1) {
			return Math.pow(n, 2) / 2;
		}
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},
	/**
	* linear
	*
	* @public
	*/
	linear: function(n) {
		return n;
	}
};

/**
* Gives an interpolation of an animated transition's distance from 0 to 1.
*
* Given a start time (`t0`) and an animation duration (`duration`), this
* method applies the `easing` function to the percentage of time elapsed
* divided by duration, capped at 100%.
*
* @param {Number} t0 - Start time.
* @param {Number} duration - Duration in milliseconds.
* @param {Function} easing - An easing [function]{@glossary Function} reference from
*	{@link enyo.easing}.
* @param {Boolean} reverse - Whether the animation will run in reverse.
* @returns {Number} The resulting position, capped at a maximum of 100%.
* @public
*/
exports.easedLerp = function(t0, duration, easing, reverse) {
	var lerp = (utils.perfNow() - t0) / duration;
	if (reverse) {
		return lerp >= 1 ? 0 : (1 - easing(1 - lerp));
	} else {
		return lerp >= 1 ? 1 : easing(lerp);
	}
};

/**
* Gives an interpolation of an animated transition's distance from
* `startValue` to `valueChange`.
*
* Applies the `easing` function with a wider range of variables to allow for
* more complex animations.
*
* @param {Number} t0 - Start time.
* @param {Number} duration - Duration in milliseconds.
* @param {Function} easing - An easing [function]{@glossary Function} reference from
*	{@link enyo.easing}.
* @param {Boolean} reverse - Whether the animation will run in reverse.
* @param {Number} time
* @param {Number} startValue - Starting value.
* @param {Number} valueChange
* @returns {Number} The resulting position, capped at a maximum of 100%.
* @public
*/
exports.easedComplexLerp = function(t0, duration, easing, reverse, time, startValue, valueChange) {
	var lerp = (utils.perfNow() - t0) / duration;
	if (reverse) {
		return easing(1 - lerp, time, startValue, valueChange, duration);
	} else {
		return easing(lerp, time, startValue, valueChange, duration);
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./platform":71,"./utils":75}],58:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	roots = require('./roots'),
	utils = require('./utils'),
	platform = require('./platform');

/**
* @namespace enyo.dom
*/
var dom = module.exports =
	/** @lends enyo.dom */ {

	/**
	* Shortcut for `document.getElementById()` if `id` is a string; otherwise,
	* returns `id`. Uses `global.document` unless a document is specified in the
	* (optional) `doc` parameter.
	*
	* ```javascript
	* // find 'node' if it's a string id, or return it unchanged if it's already a node reference
	* var domNode = enyo.dom.byId(node);
	* ```
	*
	* @param {String} id - The document element ID to get.
	* @param {Node} [doc] - A [node]{@glossary Node} to search in. Default is the whole
	*	document.
	* @returns {Element} A reference to a DOM element.
	* @public
	*/
	byId: function(id, doc){
		return (typeof id == 'string') ? (doc || document).getElementById(id) : id;
	},

	/**
	* Returns a string with ampersand, less-than, and greater-than characters replaced with HTML
	* entities, e.g.,
	* ```
	* '&lt;code&gt;'This &amp; That'&lt;/code&gt;'
	* ```
	* becomes
	* ```
	* '&amp;lt;code&amp;gt;'This &amp;amp; That'&amp;lt;/code&amp;gt;'
	* ```
	*
	* @param {String} text - A string with entities you'd like to escape/convert.
	* @returns {String} A string that is properly escaped (the above characters.)
	* @public
	*/
	escape: function(text) {
		return text !== null ? String(text).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : '';
	},

	/**
	* Returns an object describing the geometry of this node.
	*
	* @param {Node} n - The [node]{@glossary Node} to measure.
	* @returns {Object} An object containing the properties `top`, `left`,
	* `height`, and `width`.
	* @public
	*/
	getBounds: function(n) {
		if (n) {
			return {left: n.offsetLeft, top: n.offsetTop, width: n.offsetWidth, height: n.offsetHeight};
		}
		else {
			return null;
		}
	},

	/**
	* This is designed to be copied into the `computedStyle` object.
	*
	* @private
	*/
	_ie8GetComputedStyle: function(prop) {
		var re = /(\-([a-z]){1})/g;
		if (prop === 'float') {
			prop = 'styleFloat';
		} else if (re.test(prop)) {
			prop = prop.replace(re, function () {
				return arguments[2].toUpperCase();
			});
		}
		return this[prop] !== undefined ? this[prop] : null;
	},

	/**
	* @private
	*/
	getComputedStyle: function(node) {
		if(platform.ie < 9 && node && node.currentStyle) {
			//simple global.getComputedStyle polyfill for IE8
			var computedStyle = utils.clone(node.currentStyle);
			computedStyle.getPropertyValue = this._ie8GetComputedStyle;
			computedStyle.setProperty = function() {
				return node.currentStyle.setExpression.apply(node.currentStyle, arguments);
			};
			computedStyle.removeProperty = function() {
				return node.currentStyle.removeAttribute.apply(node.currentStyle, arguments);
			};
			return computedStyle;
		} else {
			return global.getComputedStyle && node && global.getComputedStyle(node, null);
		}
	},

	/**
	* @private
	*/
	getComputedStyleValue: function(node, property, computedStyle) {
		var s   = computedStyle || this.getComputedStyle(node),
			nIE = platform.ie;

		s = s ? s.getPropertyValue(property) : null;

		if (nIE) {
			var oConversion = {
				'thin'   : (nIE > 8 ? 2 : 1) + 'px',
				'medium' : (nIE > 8 ? 4 : 3) + 'px',
				'thick'  : (nIE > 8 ? 6 : 5) + 'px',
				'none'   : '0'
			};
			if (typeof oConversion[s] != 'undefined') {
				s = oConversion[s];
			}

			if (s == 'auto') {
				switch (property) {
				case 'width':
					s = node.offsetWidth;
					break;
				case 'height':
					s = node.offsetHeight;
					break;
				}
			}
		}

		return s;
	},

	/**
	* @private
	*/
	getFirstElementByTagName: function(tagName) {
		var e = document.getElementsByTagName(tagName);
		return e && e[0];
	},

	/**
	* @private
	*/
	applyBodyFit: function() {
		var h = this.getFirstElementByTagName('html');
		if (h) {
			this.addClass(h, 'enyo-document-fit');
		}
		dom.addBodyClass('enyo-body-fit');
		dom.bodyIsFitting = true;
	},

	/**
	* @private
	*/
	getWindowWidth: function() {
		if (global.innerWidth) {
			return global.innerWidth;
		}
		if (document.body && document.body.offsetWidth) {
			return document.body.offsetWidth;
		}
		if (document.compatMode=='CSS1Compat' &&
			document.documentElement &&
			document.documentElement.offsetWidth ) {
			return document.documentElement.offsetWidth;
		}
		return 320;
	},

	/**
	* @private
	*/
	getWindowHeight: function() {
		if (global.innerHeight) {
			return global.innerHeight;
		}
		if (document.body && document.body.offsetHeight) {
			return document.body.offsetHeight;
		}
		if (document.compatMode=='CSS1Compat' &&
			document.documentElement &&
			document.documentElement.offsetHeight ) {
			return document.documentElement.offsetHeight;
		}
		return 480;
	},

	/**
	* The proportion by which the `body` tag differs from the global size, in both X and Y
	* dimensions. This is relevant when we need to scale the whole interface down from 1920x1080
	* (1080p) to 1280x720 (720p), for example.
	*
	* @private
	*/
	_bodyScaleFactorY: 1,
	_bodyScaleFactorX: 1,
	updateScaleFactor: function() {
		var bodyBounds = this.getBounds(document.body);
		this._bodyScaleFactorY = bodyBounds.height / this.getWindowHeight();
		this._bodyScaleFactorX = bodyBounds.width / this.getWindowWidth();
	},

	/**
	* @private
	*/
	// Workaround for lack of compareDocumentPosition support in IE8
	// Code MIT Licensed, John Resig; source: http://ejohn.org/blog/comparing-document-position/
	compareDocumentPosition: function(a, b) {
		return a.compareDocumentPosition ?
		a.compareDocumentPosition(b) :
		a.contains ?
			(a != b && a.contains(b) && 16) +
			(a != b && b.contains(a) && 8) +
			(a.sourceIndex >= 0 && b.sourceIndex >= 0 ?
				(a.sourceIndex < b.sourceIndex && 4) +
				(a.sourceIndex > b.sourceIndex && 2) :
				1) +
			0 :
			0;
	},

	/**
	* @private
	*/
	// moved from FittableLayout.js into common protected code
	_ieCssToPixelValue: function(node, value) {
		var v = value;
		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
		var s = node.style;
		// store style and runtime style values
		var l = s.left;
		var rl = node.runtimeStyle && node.runtimeStyle.left;
		// then put current style in runtime style.
		if (rl) {
			node.runtimeStyle.left = node.currentStyle.left;
		}
		// apply given value and measure its pixel value
		s.left = v;
		v = s.pixelLeft;
		// finally restore previous state
		s.left = l;
		if (rl) {
			s.runtimeStyle.left = rl;
		}
		return v;
	},

	/**
	* @private
	*/
	_pxMatch: /px/i,
	getComputedBoxValue: function(node, prop, boundary, computedStyle) {
		var s = computedStyle || this.getComputedStyle(node);
		if (s && (!platform.ie || platform.ie >= 9)) {
			var p = s.getPropertyValue(prop + '-' + boundary);
			return p === 'auto' ? 0 : parseInt(p, 10);
		} else if (node && node.currentStyle) {
			var v = node.currentStyle[prop + utils.cap(boundary)];
			if (!v.match(this._pxMatch)) {
				v = this._ieCssToPixelValue(node, v);
			}
			return parseInt(v, 0);
		}
		return 0;
	},

	/**
	* Gets the boundaries of a [node's]{@glossary Node} `margin` or `padding` box.
	*
	* @param {Node} node - The [node]{@glossary Node} to measure.
	* @param {Node} box - The boundary to measure from ('padding' or 'margin').
	* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and
	*	`left`.
	* @public
	*/
	calcBoxExtents: function(node, box) {
		var s = this.getComputedStyle(node);
		return {
			top: this.getComputedBoxValue(node, box, 'top', s),
			right: this.getComputedBoxValue(node, box, 'right', s),
			bottom: this.getComputedBoxValue(node, box, 'bottom', s),
			left: this.getComputedBoxValue(node, box, 'left', s)
		};
	},

	/**
	* Gets the calculated padding of a node. Shortcut for
	* [enyo.dom.calcBoxExtents()]{@link enyo.dom.calcBoxExtents}.
	*
	* @param {Node} node - The [node]{@glossary Node} to measure.
	* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and
	*	`left`.
	* @public
	*/
	calcPaddingExtents: function(node) {
		return this.calcBoxExtents(node, 'padding');
	},

	/**
	* Gets the calculated margin of a node. Shortcut for
	* [enyo.dom.calcBoxExtents()]{@link enyo.dom.calcBoxExtents}.
	*
	* @param {Node} node - The [node]{@glossary Node} to measure.
	* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and
	*	`left`.
	* @public
	*/
	calcMarginExtents: function(node) {
		return this.calcBoxExtents(node, 'margin');
	},
	/**
	* Returns an object like `{top: 0, left: 0, bottom: 100, right: 100, height: 10, width: 10}`
	* that represents the object's position relative to `relativeToNode` (suitable for absolute
	* positioning within that parent node). Negative values mean part of the object is not
	* visible. If you leave `relativeToNode` as `undefined` (or it is not a parent element), then
	* the position will be relative to the viewport and suitable for absolute positioning in a
	* floating layer.
	*
	* @param {Node} node - The [node]{@glossary Node} to measure.
	* @param {Node} relativeToNode - The [node]{@glossary Node} to measure the distance from.
	* @returns {Object} An object containing the properties `top`, `right`, `bottom`, `left`,
	*	`height`, and `width`.
	* @public
	*/
	calcNodePosition: function(targetNode, relativeToNode) {
		// Parse upward and grab our positioning relative to the viewport
		var top = 0,
			left = 0,
			node = targetNode,
			width = node.offsetWidth,
			height = node.offsetHeight,
			transformProp = dom.getStyleTransformProp(),
			xregex = /translateX\((-?\d+)px\)/i,
			yregex = /translateY\((-?\d+)px\)/i,
			borderLeft = 0, borderTop = 0,
			totalHeight = 0, totalWidth = 0,
			offsetAdjustLeft = 0, offsetAdjustTop = 0;

		if (relativeToNode) {
			totalHeight = relativeToNode.offsetHeight;
			totalWidth = relativeToNode.offsetWidth;
		} else {
			totalHeight = (document.body.parentNode.offsetHeight > this.getWindowHeight() ? this.getWindowHeight() - document.body.parentNode.scrollTop : document.body.parentNode.offsetHeight);
			totalWidth = (document.body.parentNode.offsetWidth > this.getWindowWidth() ? this.getWindowWidth() - document.body.parentNode.scrollLeft : document.body.parentNode.offsetWidth);
		}

		if (node.offsetParent) {
			do {
				// Adjust the offset if relativeToNode is a child of the offsetParent
				// For IE 8 compatibility, have to use integer 8 instead of Node.DOCUMENT_POSITION_CONTAINS
				if (relativeToNode && this.compareDocumentPosition(relativeToNode, node.offsetParent) & 8) {
					offsetAdjustLeft = relativeToNode.offsetLeft;
					offsetAdjustTop = relativeToNode.offsetTop;
				}
				// Ajust our top and left properties based on the position relative to the parent
				left += node.offsetLeft - (node.offsetParent ? node.offsetParent.scrollLeft : 0) - offsetAdjustLeft;
				if (transformProp && xregex.test(node.style[transformProp])) {
					left += parseInt(node.style[transformProp].replace(xregex, '$1'), 10);
				}
				top += node.offsetTop - (node.offsetParent ? node.offsetParent.scrollTop : 0) - offsetAdjustTop;
				if (transformProp && yregex.test(node.style[transformProp])) {
					top += parseInt(node.style[transformProp].replace(yregex, '$1'), 10);
				}
				// Need to correct for borders if any exist on parent elements
				if (node !== targetNode) {
					if (node.currentStyle) {
						// Oh IE, we do so love working around your incompatibilities
						borderLeft = parseInt(node.currentStyle.borderLeftWidth, 10);
						borderTop = parseInt(node.currentStyle.borderTopWidth, 10);
					} else if (global.getComputedStyle) {
						borderLeft = parseInt(global.getComputedStyle(node, '').getPropertyValue('border-left-width'), 10);
						borderTop = parseInt(global.getComputedStyle(node, '').getPropertyValue('border-top-width'), 10);
					} else {
						// No computed style options, so try the normal style object (much less robust)
						borderLeft = parseInt(node.style.borderLeftWidth, 10);
						borderTop = parseInt(node.style.borderTopWidth, 10);
					}
					if (borderLeft) {
						left += borderLeft;
					}
					if (borderTop) {
						top += borderTop;
					}
				}
				// Continue if we have an additional offsetParent, and either don't have a relativeToNode or the offsetParent is contained by the relativeToNode (if offsetParent contains relativeToNode, then we have already calculated up to the node, and can safely exit)
				// For IE 8 compatibility, have to use integer 16 instead of Node.DOCUMENT_POSITION_CONTAINED_BY
			} while ((node = node.offsetParent) && (!relativeToNode || this.compareDocumentPosition(relativeToNode, node) & 16));
		}
		return {
			'top': top,
			'left': left,
			'bottom': totalHeight - top - height,
			'right': totalWidth - left - width,
			'height': height,
			'width': width
		};
	},

	/**
	* Sets the `innerHTML` property of the specified `node` to `html`.
	*
	* @param {Node} node - The [node]{@glossary Node} to set.
	* @param {String} html - An HTML string.
	* @public
	*/
	setInnerHtml: function(node, html) {
		node.innerHTML = html;
	},

	/**
	* Checks a [DOM]{@glossary Node} [node]{@glossary Node} for a specific CSS class.
	*
	* @param {Node} node - The [node]{@glossary Node} to set.
	* @param {String} s - The class name to check for.
	* @returns {(Boolean|undefined)} `true` if `node` has the `s` class; `undefined`
	* if there is no `node` or it has no `className` property.
	* @public
	*/
	hasClass: function(node, s) {
		if (!node || !node.className) { return; }
		return (' ' + node.className + ' ').indexOf(' ' + s + ' ') >= 0;
	},

	/**
	* Uniquely adds a CSS class to a DOM node.
	*
	* @param {Node} node - The [node]{@glossary Node} to set.
	* @param {String} s - The class name to add.
	* @public
	*/
	addClass: function(node, s) {
		if (node && !this.hasClass(node, s)) {
			var ss = node.className;
			node.className = (ss + (ss ? ' ' : '') + s);
		}
	},

	/**
	* Removes a CSS class from a DOM node if it exists.
	*
	* @param {Node} node - The [node]{@glossary Node} from which to remove the class.
	* @param {String} s - The class name to remove from `node`.
	* @public
	*/
	removeClass: function(node, s) {
		if (node && this.hasClass(node, s)) {
			var ss = node.className;
			node.className = (' ' + ss + ' ').replace(' ' + s + ' ', ' ').slice(1, -1);
		}
	},

	/**
	* Adds a class to `document.body`. This defers the actual class change if nothing has been
	* rendered into `body` yet.
	*
	* @param {String} s - The class name to add to the document's `body`.
	* @public
	*/
	addBodyClass: function(s) {
		if (!utils.exists(roots.roots) || roots.roots.length === 0) {
			if (dom._bodyClasses) {
				dom._bodyClasses.push(s);
			} else {
				dom._bodyClasses = [s];
			}
		}
		else {
			dom.addClass(document.body, s);
		}
	},

	/**
	* Returns an object describing the absolute position on the screen, relative to the top left
	* corner of the screen. This function takes into account account absolute/relative
	* `offsetParent` positioning, `scroll` position, and CSS transforms (currently
	* `translateX`, `translateY`, and `matrix3d`).
	*
	* ```javascript
	* {top: ..., right: ..., bottom: ..., left: ..., height: ..., width: ...}
	* ```
	*
	* Values returned are only valid if `hasNode()` is truthy. If there's no DOM node for the
	* object, this returns a bounds structure with `undefined` as the value of all fields.
	*
	* @param {Node} n - The [node]{@glossary Node} to measure.
	* @returns {Object} An object containing the properties `top`, `right`, `bottom`, `left`,
	*	`height`, and `width`.
	* @public
	*/
	getAbsoluteBounds: function(targetNode) {
		return utils.clone(targetNode.getBoundingClientRect());
	},

	/**
	* @private
	*/
	flushBodyClasses: function() {
		if (dom._bodyClasses) {
			for (var i = 0, c; (c=dom._bodyClasses[i]); ++i) {
				dom.addClass(document.body, c);
			}
			dom._bodyClasses = null;
		}
	},

	/**
	* @private
	*/
	_bodyClasses: null,

	/**
	* Convert to various unit formats. Useful for converting pixels to a resolution-independent
	* measurement method, like "rem". Other units are available if defined in the
	* [enyo.dom.unitToPixelFactors]{@link enyo.dom.unitToPixelFactors} object.
	*
	* ```javascript
	* // Do calculations and get back the desired CSS unit.
	* var frameWidth = 250,
	*     frameWithMarginInches = enyo.dom.unit( 10 + frameWidth + 10, 'in' ),
	*     frameWithMarginRems = enyo.dom.unit( 10 + frameWidth + 10, 'rem' );
	* // '2.8125in' == frameWithMarginInches
	* // '22.5rem' == frameWithMarginRems
	* ```
	*
	* @param {(String|Number)} pixels - The the pixels or math to convert to the unit.
	*	("px" suffix in String format is permitted. ex: `'20px'`)
	* @param {(String)} toUnit - The name of the unit to convert to.
	* @returns {(Number|undefined)} Resulting conversion, in case of malformed input, `undefined`
	* @public
	*/
	unit: function (pixels, toUnit) {
		if (!toUnit || !this.unitToPixelFactors[toUnit]) return;
		if (typeof pixels == 'string' && pixels.substr(-2) == 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2), 10);
		if (typeof pixels != 'number') return;

		return (pixels / this.unitToPixelFactors[toUnit]) + '' + toUnit;
	},

	/**
	* Object that stores all of the pixel conversion factors to each keyed unit.
	*
	* @public
	*/
	unitToPixelFactors: {
		'rem': 12,
		'in': 96
	}
};

// override setInnerHtml for Windows 8 HTML applications
if (typeof global.MSApp !== 'undefined') {
	dom.setInnerHtml = function(node, html) {
		global.MSApp.execUnsafeLocalFunction(function() {
			node.innerHTML = html;
		});
	};
}

// use faster classList interface if it exists
if (document.head && document.head.classList) {
	dom.hasClass = function(node, s) {
		if (node) {
			return node.classList.contains(s);
		}
	};
	dom.addClass = function(node, s) {
		if (node) {
			return node.classList.add(s);
		}
	};
	dom.removeClass = function (node, s) {
		if (node) {
			return node.classList.remove(s);
		}
	};
}

/**
* Allows bootstrapping in environments that do not have a global object right away.
*
* @param {Function} func - The function to run
* @public
*/
dom.requiresWindow = function(func) {
	func();
};


var cssTransformProps = ['transform', '-webkit-transform', '-moz-transform', '-ms-transform', '-o-transform'],
	styleTransformProps = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'];

/**
* @private
*/
dom.calcCanAccelerate = function() {
	/* Android 2 is a liar: it does NOT support 3D transforms, even though Perspective is the best check */
	if (platform.android <= 2) {
		return false;
	}
	var p$ = ['perspective', 'WebkitPerspective', 'MozPerspective', 'msPerspective', 'OPerspective'];
	for (var i=0, p; (p=p$[i]); i++) {
		if (typeof document.body.style[p] != 'undefined') {
			return true;
		}
	}
	return false;
};
/**
* @private
*/
dom.getCssTransformProp = function() {
	if (this._cssTransformProp) {
		return this._cssTransformProp;
	}
	var i = utils.indexOf(this.getStyleTransformProp(), styleTransformProps);
	this._cssTransformProp = cssTransformProps[i];
	return this._cssTransformProp;
};

/**
* @private
*/
dom.getStyleTransformProp = function() {
	if (this._styleTransformProp || !document.body) {
		return this._styleTransformProp;
	}
	for (var i = 0, p; (p = styleTransformProps[i]); i++) {
		if (typeof document.body.style[p] != 'undefined') {
			this._styleTransformProp = p;
			return this._styleTransformProp;
		}
	}
};

/**
* @private
*/
dom.domTransformsToCss = function(inTransforms) {
	var n, v, text = '';
	for (n in inTransforms) {
		v = inTransforms[n];
		if ((v !== null) && (v !== undefined) && (v !== '')) {
			text +=  n + '(' + v + ') ';
		}
	}
	return text;
};

/**
* @private
*/
dom.transformsToDom = function(control) {
	var css = this.domTransformsToCss(control.domTransforms),
		styleProp;

	if (control.hasNode()) {
		styleProp = this.getStyleTransformProp();
	} else {
		styleProp = this.getCssTransformProp();
	}

	if (styleProp) control.applyStyle(styleProp, css);
};

/**
* Returns `true` if the platform supports CSS3 Transforms.
*
* @returns {Boolean} `true` if platform supports CSS `transform` property;
* otherwise, `false`.
* @public
*/
dom.canTransform = function() {
	return Boolean(this.getStyleTransformProp());
};

/**
* Returns `true` if platform supports CSS3 3D Transforms.
*
* Typically used like this:
* ```
* if (dom.canAccelerate()) {
* 	dom.transformValue(this.$.slidingThing, 'translate3d', x + ',' + y + ',' + '0')
* } else {
* 	dom.transformValue(this.$.slidingThing, 'translate', x + ',' + y);
* }
* ```
*
* @returns {Boolean} `true` if platform supports CSS3 3D Transforms;
* otherwise, `false`.
* @public
*/
dom.canAccelerate = function() {
	return (this.accelerando !== undefined) ? this.accelerando : document.body && (this.accelerando = this.calcCanAccelerate());
};

/**
* Applies a series of transforms to the specified {@link enyo.Control}, using
* the platform's prefixed `transform` property.
*
* **Note:** Transforms are not commutative, so order is important.
*
* Transform values are updated by successive calls, so
* ```javascript
* dom.transform(control, {translate: '30px, 40px', scale: 2, rotate: '20deg'});
* dom.transform(control, {scale: 3, skewX: '-30deg'});
* ```
*
* is equivalent to:
* ```javascript
* dom.transform(control, {translate: '30px, 40px', scale: 3, rotate: '20deg', skewX: '-30deg'});
* ```
*
* When applying these transforms in a WebKit browser, this is equivalent to:
* ```javascript
* control.applyStyle('-webkit-transform', 'translate(30px, 40px) scale(3) rotate(20deg) skewX(-30deg)');
* ```
*
* And in Firefox, this is equivalent to:
* ```javascript
* control.applyStyle('-moz-transform', 'translate(30px, 40px) scale(3) rotate(20deg) skewX(-30deg)');
* ```
*
* @param {enyo.Control} control - The {@link enyo.Control} to transform.
* @param {Object} transforms - The set of transforms to apply to `control`.
* @public
*/
dom.transform = function(control, transforms) {
	var d = control.domTransforms = control.domTransforms || {};
	utils.mixin(d, transforms);
	this.transformsToDom(control);
};

/**
* Applies a single transform to the specified {@link enyo.Control}.
*
* Example:
* ```
* tap: function(inSender, inEvent) {
* 	var c = inEvent.originator;
* 	var r = c.rotation || 0;
* 	r = (r + 45) % 360;
* 	c.rotation = r;
* 	dom.transformValue(c, 'rotate', r);
* }
* ```
*
* This will rotate the tapped control by 45 degrees clockwise.
*
* @param {enyo.Control} control - The {@link enyo.Control} to transform.
* @param {String} transform - The name of the transform function.
* @param {(String|Number)} value - The value to apply to the transform.
* @public
*/
dom.transformValue = function(control, transform, value) {
	var d = control.domTransforms = control.domTransforms || {};
	d[transform] = value;
	this.transformsToDom(control);
};

/**
* Applies a transform that should trigger GPU compositing for the specified
* {@link enyo.Control}. By default, the acceleration is only applied if the
* browser supports it. You may also optionally force-set `value` directly, to
* be applied to `translateZ(value)`.
*
* @param {enyo.Control} control - The {@link enyo.Control} to accelerate.
* @param {(String|Number)} [value] - An optional value to apply to the acceleration transform
*	property.
* @public
*/
dom.accelerate = function(control, value) {
	var v = value == 'auto' ? this.canAccelerate() : value;
	this.transformValue(control, 'translateZ', v ? 0 : null);
};


/**
 * The CSS `transition` property name for the current browser/platform, e.g.:
 *
 * * `-webkit-transition`
 * * `-moz-transition`
 * * `transition`
 *
 * @type {String}
 * @private
 */
dom.transition = (platform.ios || platform.android || platform.chrome || platform.androidChrome || platform.safari)
	? '-webkit-transition'
	: (platform.firefox || platform.firefoxOS || platform.androidFirefox)
		? '-moz-transition'
		: 'transition';
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./platform":71,"./roots":74,"./utils":75}],67:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	json = require('./json'),
	utils = require('./utils'),
	platform = require('./platform');

/**
* These platforms only allow one argument for [console.log()]{@glossary console.log}:
*
* * android
* * ios
* * webos
*
* @private
*/
var dumbConsole = Boolean(platform.android || platform.ios || platform.webos);

/**
* Internally used methods and properties associated with logging.
*
* @namespace exports.logging
* @public
*/
exports = module.exports = /** @lends exports.logging */ {
	
	/**
	* The log level to use. Can be a value from -1 to 99, where -1 disables all
	* logging, 0 is 'error', 10 is 'warn', and 20 is 'log'. It is preferred that
	* this value be set using the [exports.setLogLevel()]{@link enyo~setLogLevel}
	* method.
	*
	* @type {Number}
	* @default 99
	* @public
	*/
	level: 99,
	
	/**
	* The known levels.
	*
	* @private
	*/
	levels: {log: 20, warn: 10, error: 0},
	
	/**
	* @private
	*/
	shouldLog: function (fn) {
		var ll = parseInt(this.levels[fn], 0);
		return (ll <= this.level);
	},
	
	/**
	* @private
	*/
	validateArgs: function (args) {
		// gracefully handle and prevent circular reference errors in objects
		for (var i=0, l=args.length, item; (item=args[i]) || i<l; i++) {
			try {
				if (typeof item === 'object') {
					args[i] = json.stringify(item);
				}
			} catch (e) {
				args[i] = 'Error: ' + e.message;
			}
		}
	},
	
	/**
	* @private
	*/
	_log: function (fn, args) {
		// avoid trying to use console on IE instances where the object hasn't been
		// created due to the developer tools being unopened
		var console = global.console;
		if (typeof console === 'undefined') {
            return;
        }
		//var a$ = utils.logging.formatArgs(fn, args);
		var a$ = utils.isArray(args) ? args : utils.cloneArray(args);
		if (platform.androidFirefox) {
			// Firefox for Android's console does not handle objects with circular references
			this.validateArgs(a$);
		}
		if (dumbConsole) {
			// at least in early versions of webos, console.* only accept a single argument
			a$ = [a$.join(' ')];
		}
		var fn$ = console[fn];
		if (fn$ && fn$.apply) {
			// some consoles support 'warn', 'info', and so on
			fn$.apply(console, a$);
		} else if (console.log.apply) {
			// some consoles support console.log.apply
			console.log.apply(console, a$);
		} else {
			// otherwise, do our own formatting
			console.log(a$.join(' '));
		}
	},
	
	/**
	* This is exposed elsewhere.
	*
	* @private
	*/
	log: function (fn, args) {

		if (fn != 'log' && fn != 'warn' && fn != 'error') {
			args = Array.prototype.slice.call(arguments);
			fn = 'log';
		}

		var console = global.console;
		if (typeof console !== 'undefined') {
			if (this.shouldLog(fn)) {
				this._log(fn, args);
			}
		}
	}
};

/**
* Sets the log level to the given value. This will restrict the amount of output depending on
* the settings. The higher the value, the more output that will be allowed. The default is
* 99. The value, -1, would silence all logging, even 'error' (0).
* Without the 'see': {@link exports.log}.
*
* @see exports.logging.level
* @see exports.log
* @see exports.warn
* @see exports.error
* @param {Number} level - The level to set logging to.
*/
exports.setLogLevel = function (level) {
	var ll = parseInt(level, 0);
	if (isFinite(ll)) {
		this.level = ll;
	}
};

/**
* A wrapper for [console.log()]{@glossary console.log}, compatible
* across supported platforms. Will output only if the current
* [log level]{@link exports.logging.level} allows it. [Object]{@glossary Object}
* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}
* automatically.
*
* @utility
* @see {@glossary console.log}
* @param {...*} - The arguments to be logged.
* @public
*/

/**
* A wrapper for [console.warn()]{@glossary console.warn}, compatible
* across supported platforms. Will output only if the current
* [log level]{@link exports.logging.level} allows it. [Object]{@glossary Object}
* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}
* automatically.
*
* @utility
* @see {@glossary console.warn}
* @param {...*} - The arguments to be logged.
* @public
*/
exports.warn = function () {
	this.log('warn', arguments);
};

/**
* A wrapper for [console.error()]{@glossary console.error}, compatible
* across supported platforms. Will output only if the current
* [log level]{@link exports.logging.level} allows it. [Object]{@glossary Object}
* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}
* automatically.
*
* @utility
* @see {@glossary console.error}
* @param {...*} - The arguments to be logged.
* @public
*/
exports.error = function () {
	this.log('error', arguments);
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./json":65,"./platform":71,"./utils":75}],76:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	utils = require('./utils'),
	platform = require('./platform'),
	path = require('./pathResolver');

/**
* Parameters and options for the [enyo.xhr.request()]{@link enyo.xhr.request} method.
*
* @typedef {Object} enyo.xhr.request~Options
* @property {String} url - The URL to request (required).
* @property {String} method - One of `'GET'`, `'POST'`, `'DELETE'`, `'UPDATE'`, or
* custom methods; defaults to `'GET'`.
* @property {Function} callback - Optional callback method to fire when complete.
* @property {Object} body - Optional serializable body for `POST` requests.
* @property {Object} headers - Optional header overrides; defaults to `null`.
* @property {String} username - Optional username to provide for authentication purposes.
* @property {String} password - Optional password to provide for authentication purposes.
* @property {Object} xhrFields - Optional key/value pairs to apply directly to the request.
* @property {String} mimeType - Optional specification for the `MIME-Type` of the request.
* @property {Boolean} mozSystem - Optional boolean to create cross-domain XHR (Firefox OS only).
* @property {Boolean} mozAnon - Optional boolean to create anonymous XHR that does not send
*	cookies or authentication headers (Firefox OS only).
* @private
*/

/**
* An internally-used namespace for XHR-related methods and wrappers.
*
* @namespace enyo.xhr
* @private
*/
module.exports = /** @lends enyo.xhr */ {
	
	/**
	* Internally-used method to execute XHR requests.
	*
	* Note that we explicitly add a `'cache-control: no-cache'` header for iOS 6 for any
	* non-`GET` requests to work around a system bug causing non-cachable requests to be
	* cached. To disable this, use the `header` property to specify an object where
	* `cache-control` is set to `null`.
	*
	* @param {enyo.xhr.request~Options} params - The options and properties for this XHR request.
	* @returns {XMLHttpRequest} The XHR request object.
	* @private
	*/
	request: function (params) {
		var xhr = this.getXMLHttpRequest(params);
		var url = this.simplifyFileURL(path.rewrite(params.url));
		//
		var method = params.method || 'GET';
		var async = !params.sync;
		//
		if (params.username) {
			xhr.open(method, url, async, params.username, params.password);
		} else {
			xhr.open(method, url, async);
		}
		//
		utils.mixin(xhr, params.xhrFields);
		// only setup handler when we have a callback
		if (params.callback) {
			this.makeReadyStateHandler(xhr, params.callback);
		}
		//
		params.headers = params.headers || {};
		// work around iOS 6.0 bug where non-GET requests are cached
		// see http://www.einternals.com/blog/web-development/ios6-0-caching-ajax-post-requests
		if (method !== 'GET' && platform.ios && platform.ios == 6) {
			if (params.headers['cache-control'] !== null) {
				params.headers['cache-control'] = params.headers['cache-control'] || 'no-cache';
			}
		}
		// user-set headers override any platform-default
		if (xhr.setRequestHeader) {
			for (var key in params.headers) {
				if (params.headers[key]) {
					xhr.setRequestHeader(key, params.headers[key]);
				}
			}
		}
		//
		if((typeof xhr.overrideMimeType == 'function') && params.mimeType) {
			xhr.overrideMimeType(params.mimeType);
		}
		//
		xhr.send(params.body || null);
		if (!async && params.callback) {
			xhr.onreadystatechange(xhr);
		}
		return xhr;
	},
	
	/**
	* Removes any callbacks that might be set from Enyo code for an existing XHR
	* and stops the XHR from completing (if possible).
	*
	* @param {XMLHttpRequest} The - request to cancel.
	* @private
	*/
	cancel: function (xhr) {
		if (xhr.onload) {
			xhr.onload = null;
		}
		if (xhr.onreadystatechange) {
			xhr.onreadystatechange = null;
		}
		if (xhr.abort) {
			xhr.abort();
		}
	},
	
	/**
	* @private
	*/
	makeReadyStateHandler: function (inXhr, inCallback) {
		if (global.XDomainRequest && inXhr instanceof global.XDomainRequest) {
			inXhr.onload = function() {
				var data;
				if (inXhr.responseType === 'arraybuffer') {
					data = inXhr.response;
				} else if (typeof inXhr.responseText === 'string') {
					data = inXhr.responseText;
				}
				inCallback.apply(null, [data, inXhr]);
				inXhr = null;
			};
		} else {
			inXhr.onreadystatechange = function() {
				if (inXhr && inXhr.readyState == 4) {
					var data;
					if (inXhr.responseType === 'arraybuffer') {
						data = inXhr.response;
					} else if (typeof inXhr.responseText === 'string') {
						data = inXhr.responseText;
					}
					inCallback.apply(null, [data, inXhr]);
					inXhr = null;
				}
			};
		}
	},
	
	/**
	* @private
	*/
	inOrigin: function (url) {
		var a = document.createElement('a'), result = false;
		a.href = url;
		// protocol is ':' for relative URLs
		if (a.protocol === ':' ||
				(a.protocol === global.location.protocol &&
					a.hostname === global.location.hostname &&
					a.port === (global.location.port ||
						(global.location.protocol === 'https:' ? '443' : '80')))) {
			result = true;
		}
		return result;
	},
	
	/**
	* @private
	*/
	simplifyFileURL: function (url) {
		var a = document.createElement('a');
		a.href = url;
		// protocol is ':' for relative URLs
		if (a.protocol === 'file:' ||
			a.protocol === ':' && global.location.protocol === 'file:') {
			// leave off search and hash parts of the URL
			// and work around a bug in webOS 3 where the app's host has a domain string
			// in it that isn't resolved as a path
			var host = (platform.webos < 4) ? '' : a.host;
			return a.protocol + '//' + host + a.pathname;
		} else if (a.protocol === ':' && global.location.protocol === 'x-wmapp0:') {
			// explicitly return absolute URL for Windows Phone 8, as an absolute path is required for local files
			return global.location.protocol + '//' + global.location.pathname.split('/')[0] + '/' + a.host + a.pathname;
		} else {
			return url;
		}
	},
	
	/**
	* @private
	*/
	getXMLHttpRequest: function (params) {
		try {
			// only use XDomainRequest when it exists, no extra headers were set, and the
			// target URL maps to a domain other than the document origin.
			if (platform.ie < 10 && global.XDomainRequest && !params.headers &&
				!this.inOrigin(params.url) && !/^file:\/\//.test(global.location.href)) {
				return new global.XDomainRequest();
			}
		} catch(e) {}
		try {

			if (platform.firefoxOS) {
				var shouldCreateNonStandardXHR = false; // flag to decide if we're creating the xhr or not
				var xhrOptions = {};

				// mozSystem allows you to do cross-origin requests on Firefox OS
				// As seen in:
				//   https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Non-standard_properties
				if (params.mozSystem) {
					xhrOptions.mozSystem = true;
					shouldCreateNonStandardXHR = true;
				}

				// mozAnon allows you to send a request without cookies or authentication headers
				// As seen in:
				//   https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Non-standard_properties
				if (params.mozAnon) {
					xhrOptions.mozAnon = true;
					shouldCreateNonStandardXHR = true;
				}

				if (shouldCreateNonStandardXHR) {
					return new XMLHttpRequest(xhrOptions);
				}
			}

			return new XMLHttpRequest();
		} catch(e) {}
		return null;
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./pathResolver":70,"./platform":71,"./utils":75}],105:[function(require,module,exports){
var
    animation = require('../../enyo/lib/animation'),
    utils = require('../../enyo/lib/utils');

/**
* Provides static methods for easing calculations.
*
* @ui
* @public
* @todo verify this combines with enyo.easing definition
* @todo verify all these methods need to be documented
*/

var easing = module.exports = utils.mixin(animation.easing, /** @lends  enyo.easing.prototype */ {

    /**
    * @type {Number}
    * @public
    */
    easeInQuad: function (n, t, b, c, d) {
        return c*(t /= d)*t + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutQuad: function (n, t, b, c, d) {
        return -c *(t /= d)*(t-2) + b;
    },


    /**
    * @type {Number}
    * @public
    */
    easeInOutQuad: function (n, t, b, c, d) {
        if ((t /= d/2) < 1) { return c/2*t*t + b; }
        return -c/2 * ((--t)*(t-2) - 1) + b;
    },


    /**
    * @type {Number}
    * @public
    */
    easeInCubic: function (n, t, b, c, d) {
        return c*(t /= d)*t*t + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutCubic: function (n, t, b, c, d) {
        return c*((t=t/d-1)*t*t + 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutCubic: function (n, t, b, c, d) {
        if ((t /= d/2) < 1) { return c/2*t*t*t + b; }
        return c/2*((t-=2)*t*t + 2) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInQuart: function (n, t, b, c, d) {
        return c*(t /= d)*t*t*t + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutQuart: function (n, t, b, c, d) {
        return -c * ((t=t/d-1)*t*t*t - 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutQuart: function (n, t, b, c, d) {
        if ((t /= d/2) < 1) { return c/2*t*t*t*t + b; }
        return -c/2 * ((t-=2)*t*t*t - 2) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInQuint: function (n, t, b, c, d) {
        return c*(t /= d)*t*t*t*t + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutQuint: function (n, t, b, c, d) {
        return c*((t=t/d-1)*t*t*t*t + 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutQuint: function (n, t, b, c, d) {
        if ((t /= d/2) < 1) { return c/2*t*t*t*t*t + b; }
        return c/2*((t-=2)*t*t*t*t + 2) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInSine: function (n, t, b, c, d) {
        return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutSine: function (n, t, b, c, d) {
        return c * Math.sin(t/d * (Math.PI/2)) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutSine: function (n, t, b, c, d) {
        return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInExpo: function (n, t, b, c, d) {
        return (t===0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutExpo: function (n, t, b, c, d) {
        return (t===d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutExpo: function (n, t, b, c, d) {
        if (t===0) { return b; }
        if (t===d) { return b+c; }
        if ((t /= d/2) < 1) { return c/2 * Math.pow(2, 10 * (t - 1)) + b; }
        return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInCirc: function (n, t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d)*t) - 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutCirc: function (n, t, b, c, d) {
        return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutCirc: function (n, t, b, c, d) {
        if ((t /= d/2) < 1) { return -c/2 * (Math.sqrt(1 - t*t) - 1) + b; }
        return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInElastic: function (n, t, b, c, d) {
        var s = 1.70158;
        var a = c;
        var p = 0;
        if (t===0) { return b; }
        if ((t /= d)==1) { return b+c; }
        if (!p) { p=d*0.3; }
        if (a < Math.abs(c)) { a=c; s=p/4; }
        else { s = p/(2*Math.PI) * Math.asin (c/a); }
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutElastic: function (n, t, b, c, d) {
        var s = 1.70158;
        var a = c;
        var p = 0;
        if (t===0) { return b; }
        if ((t /= d)==1) { return b+c; }
        if (!p) { p=d*0.3; }
        if (a < Math.abs(c)) { a=c; s=p/4; }
        else { s = p/(2*Math.PI) * Math.asin (c/a); }
        return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutElastic: function (n, t, b, c, d) {
        var s = 1.70158;
        var a = c;
        var p = 0;
        if (t===0) { return b; }
        if ((t /= d/2)===2) { return b+c; }
        if (!p) { p=d*(0.3*1.5); }
        if (a < Math.abs(c)) { a=c; s=p/4; }
        else { s = p/(2*Math.PI) * Math.asin (c/a); }
        if (t < 1) { return -0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; }
        return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInBack: function (n, t, b, c, d) {
        var s = 1.70158;
        return c*(t /= d)*t*((s+1)*t - s) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutBack: function (n, t, b, c, d) {
        var s = 1.70158;
        return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutBack: function (n, t, b, c, d) {
        var s = 1.70158;
        if ((t /= d/2) < 1) { return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; }
        return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeInBounce: function (n, t, b, c, d) {
        return c - easing.easeOutBounce (d-t, 0, c, d) + b;
    },

    /**
    * @type {Number}
    * @public
    */
    easeOutBounce: function (n, t, b, c, d) {
        if ((t /= d) < (1/2.75)) {
            return c*(7.5625*t*t) + b;
        } else if (t < (2/2.75)) {
            return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;
        } else if (t < (2.5/2.75)) {
            return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;
        } else {
            return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;
        }
    },

    /**
    * @type {Number}
    * @public
    */
    easeInOutBounce: function (n, t, b, c, d) {
        if (t < d/2) { return easing.easeInBounce (n, t*2, 0, c, d) * 0.5 + b; }
        return easing.easeOutBounce (n, t*2-d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
});

/*

TERMS OF USE - EASING EQUATIONS

Open source under the BSD License.

Copyright  2001 Robert Penner
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this list
of conditions and the following disclaimer in the documentation and/or other materials
provided with the distribution.

Neither the name of the author nor the names of contributors may be used to endorse
or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/
},{"../../enyo/lib/animation":56,"../../enyo/lib/utils":75}],22:[function(require,module,exports){
require('../../enyo');

var
	Dom = require('./dom');

var selfClosing = {img: 1, hr: 1, br: 1, area: 1, base: 1, basefont: 1, input: 1, link: 1,
	meta: 1, command: 1, embed: 1, keygen: 1, wbr: 1, param: 1, source: 1, track: 1, col: 1};

/**
* This is the default render delegate used by {@link enyo.Control}. It
* generates the HTML [string]{@glossary String} content and correctly inserts
* it into the DOM. A string-concatenation technique is used to perform DOM
* insertion in batches.
*
* @name enyo.HTMLStringDelegate
* @type Object
* @public
*/
module.exports = {
	
	/**
	* @private
	*/
	invalidate: function (control, item) {
		switch (item) {
		case 'content':
			this.renderContent(control);
			break;
		default:
			control.tagsValid = false;
			break;
		}
	},
	
	/**
	* @private
	*/
	render: function (control) {
		if (control.parent) {
			control.parent.beforeChildRender(control);
			
			if (!control.parent.generated) return;
			if (control.tag === null) return control.parent.render();
		}
		
		if (!control.hasNode()) this.renderNode(control);
		if (control.hasNode()) {
			this.renderDom(control);
			if (control.generated) control.rendered();
		}
	},
	
	/**
	* @private
	*/
	renderInto: function (control, parentNode) {
		parentNode.innerHTML = this.generateHtml(control);
		
		if (control.generated) control.rendered();
	},
	
	/**
	* @private
	*/
	renderNode: function (control) {
		this.teardownRender(control);
		control.node = document.createElement(control.tag);
		control.addNodeToParent();
		control.set('generated', true);
	},
	
	/**
	* @private
	*/
	renderDom: function (control) {
		this.renderAttributes(control);
		this.renderStyles(control);
		this.renderContent(control);
	},
	
	/**
	* @private
	*/
	renderStyles: function (control) {
		var style = control.style;
		
		// we can safely do this knowing it will synchronize properly without a double
		// set in the DOM because we're flagging the internal property
		if (control.hasNode()) {
			control.node.style.cssText = style;
			// retrieve the parsed value for synchronization
			control.cssText = style = control.node.style.cssText;
			// now we set it knowing they will be synchronized and everybody that is listening
			// will also be updated to know about the change
			control.set('style', style);
		}
	},
	
	/**
	* @private
	*/
	renderAttributes: function (control) {
		var attrs = control.attributes,
			node = control.hasNode(),
			key,
			val;
		
		if (node) {
			for (key in attrs) {
				val = attrs[key];
				if (val === null || val === false || val === "") {
					node.removeAttribute(key);
				} else {
					node.setAttribute(key, val);
				}
			}
		}
	},
	
	/**
	* @private
	*/
	renderContent: function (control) {
		if (control.generated) this.teardownChildren(control);
		if (control.hasNode()) control.node.innerHTML = this.generateInnerHtml(control);
	},
	
	/**
	* @private
	*/
	generateHtml: function (control) {
		var content,
			html;
		
		if (control.canGenerate === false) {
			return '';
		}
		// do this first in case content generation affects outer html (styles or attributes)
		content = this.generateInnerHtml(control);
		// generate tag, styles, attributes
		html = this.generateOuterHtml(control, content);
		// NOTE: 'generated' is used to gate access to findNodeById in
		// hasNode, because findNodeById is expensive.
		// NOTE: we typically use 'generated' to mean 'created in DOM'
		// but that has not actually happened at this point.
		// We set 'generated = true' here anyway to avoid having to walk the
		// control tree a second time (to set it later).
		// The contract is that insertion in DOM will happen synchronously
		// to generateHtml() and before anybody should be calling hasNode().
		control.set('generated', true);
		return html;
	},
	
	/**
	* @private
	*/
	generateOuterHtml: function (control, content) {
		if (!control.tag) return content;
		if (!control.tagsValid) this.prepareTags(control);
		return control._openTag + content + control._closeTag;
	},
	
	/**
	* @private
	*/
	generateInnerHtml: function (control) {
		var allowHtml = control.allowHtml,
			content;
		
		// flow can alter the way that html content is rendered inside
		// the container regardless of whether there are children.
		control.flow();
		if (control.children.length) return this.generateChildHtml(control);
		else {
			content = control.get('content');
			return allowHtml ? content : Dom.escape(content);
		}
	},
	
	/**
	* @private
	*/
	generateChildHtml: function (control) {
		var child,
			html = '',
			i = 0,
			delegate;
		
		for (; (child = control.children[i]); ++i) {
			delegate = child.renderDelegate || this;
			html += delegate.generateHtml(child);
		}
		
		return html;
	},
	
	/**
	* @private
	*/
	prepareTags: function (control) {
		var html = '';
		
		// open tag
		html += '<' + control.tag + (control.style ? ' style="' + control.style + '"' : '');
		html += this.attributesToHtml(control.attributes);
		if (selfClosing[control.tag]) {
			control._openTag = html + '/>';
			control._closeTag = '';
		} else {
			control._openTag = html + '>';
			control._closeTag = '</' + control.tag + '>';
		}
		
		control.tagsValid = true;
	},
	
	/**
	* @private
	*/
	attributesToHtml: function(attrs) {
		var key,
			val,
			html = '';
			
		for (key in attrs) {
			val = attrs[key];
			if (val != null && val !== false && val !== '') {
				html += ' ' + key + '="' + this.escapeAttribute(val) + '"';
			}
		}
		
		return html;
	},
	
	/**
	* @private
	*/
	escapeAttribute: function (text) {
		if (typeof text != 'string') return text;
	
		return String(text).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');
	},
	
	/**
	* @private
	*/
	teardownRender: function (control) {
		if (control.generated) this.teardownChildren(control);
		control.node = null;
		control.set('generated', false);
	},
	
	/**
	* @private
	*/
	teardownChildren: function (control) {
		var child,
			i = 0;
			
		for (; (child = control.children[i]); ++i) {
			child.teardownRender();
		}
	}
};
},{"../../enyo":1,"./dom":58}],73:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	Dom = require('./dom');

var _baseScreenType = 'standard',
	_riRatio,
	_screenType,
	_screenTypes = [ {name: 'standard', pxPerRem: 16, width: global.innerWidth,  height: global.innerHeight, aspectRatioName: 'standard'} ],	// Assign one sane value in case defineScreenTypes is never run.
	_screenTypeObject;

var getScreenTypeObject = function (type) {
	type = type || _screenType;
	if (type == _screenType && _screenTypeObject) {
		return _screenTypeObject;
	}
	return _screenTypes.filter(function (elem) {
		return (type == elem.name);
	})[0];
};

/**
* @namespace ri
*/
var ri = module.exports = {
	/**
	* Setup screen resolution scaling capabilities by defining all of the screens you're working
	* with. These should be in the order of smallest to largest (according to width). Running
	* this also initializes the rest of this resolution code.
	*
	* In the arguments, the following properties are required: 'name', 'pxPerRem', 'width',
	* 'aspectRatioName'. The property 'base' defines the primary or default resoultion that
	* everything else will be based upon.
	*
	* ```
	* ri.defineScreenTypes([
	* 	{name: 'vga',     pxPerRem: 8,  width: 640,  height: 480,  aspectRatioName: 'standard'},
	* 	{name: 'xga',     pxPerRem: 16, width: 1024, height: 768,  aspectRatioName: 'standard'},
	* 	{name: 'hd',      pxPerRem: 16, width: 1280, height: 720,  aspectRatioName: 'hdtv'},
	* 	{name: 'fhd',     pxPerRem: 24, width: 1920, height: 1080, aspectRatioName: 'hdtv', base: true},
	* 	{name: 'uw-uxga', pxPerRem: 24, width: 2560, height: 1080, aspectRatioName: 'cinema'},
	* 	{name: 'uhd',     pxPerRem: 48, width: 3840, height: 2160, aspectRatioName: 'hdtv'}
	* ]);
	* ```
	*
	* @param {Array} types An array of objects with arguments like the example
	* @public
	*/
	defineScreenTypes: function (types) {
		_screenTypes = types;
		for (var i = 0; i < _screenTypes.length; i++) {
			if (_screenTypes[i]['base']) _baseScreenType = _screenTypes[i].name;
		}
		ri.init();
	},

	/**
	* Fetches the best-matching screen type name for the current screen size. The "best" screen type
	* is determined by the screen type name that is the closest to the screen resolution without
	* going over. ("The Price is Right" style.)
	*
	* @param {Object} [rez] - Optional measurement scheme. Must have "height" and "width" properties.
	* @returns {String} Screen type, like "fhd", "uhd", etc.
	* @public
	*/
	getScreenType: function (rez) {
		rez = rez || {
			height: global.innerHeight,
			width: global.innerWidth
		};
		var i,
			types = _screenTypes,
			bestMatch = types[types.length - 1].name;

		// loop thorugh resolutions
		for (i = types.length - 1; i >= 0; i--) {
			// find the one that matches our current size or is smaller. default to the first.
			if (rez.width <= types[i].width) {
				bestMatch = types[i].name;
			}
		}
		// return the name of the resolution if we find one.
		return bestMatch;
	},

	/**
	* @private
	*/
	updateScreenBodyClasses: function (type) {
		type = type || _screenType;
		if (type) {
			Dom.addBodyClass('enyo-res-' + type.toLowerCase());
			var scrObj = getScreenTypeObject(type);
			if (scrObj.aspectRatioName) {
				Dom.addBodyClass('enyo-aspect-ratio-' + scrObj.aspectRatioName.toLowerCase());
			}
			return type;
		}
	},

	/**
	* @private
	*/
	getRiRatio: function (type) {
		type = type || _screenType;
		if (type) {
			var ratio = this.getUnitToPixelFactors(type) / this.getUnitToPixelFactors(_baseScreenType);
			if (type == _screenType) {
				// cache this if it's for our current screen type.
				_riRatio = ratio;
			}
			return ratio;
		}
		return 1;
	},

	/**
	* @private
	*/
	getUnitToPixelFactors: function (type) {
		type = type || _screenType;
		if (type) {
			return getScreenTypeObject(type).pxPerRem;
		}
		return 1;
	},

	/**
	* Calculates the aspect ratio of the screen type provided. If none is provided the current
	* screen type is used.
	*
	* @param {String} type Screen type to get the aspect ratio of. Providing nothing uses the
	*	current screen type.
	* @returns {Number} The calculated screen ratio (1.333, 1.777, 2.333, etc)
	* @public
	*/
	getAspectRatio: function (type) {
		var scrObj = getScreenTypeObject(type);
		if (scrObj.width && scrObj.height) {
			return (scrObj.width / scrObj.height);
		}
		return 1;
	},

	/**
	* Returns the name of the aspect ration given the screen type or the default screen type if
	* none is proided.
	*
	* @param {String} type Screen type to get the aspect ratio of. Providing nothing uses the
	*	current screen type.
	* @returns {String} The name of the type of screen ratio
	* @public
	*/
	getAspectRatioName: function (type) {
		var scrObj = getScreenTypeObject(type);
		 return scrObj.aspectRatioName || 'standard';
	},

	/**
	* Takes a provided pixel value and preforms a scaling operation on the number based on the
	* current screen type.
	*
	* @param {Number} px The amount of standard-resolution pixels to scale to the current screen
	*	resolution.
	* @returns {Number} The scaled value based on the current screen scaling factor.
	* @public
	*/
	scale: function (px) {
		return (_riRatio || this.getRiRatio()) * px;
	},

	/**
	* The default configurable [options]{@link ri.selectSrc#options}.
	*
	* @typedef {Object} ri.selectSrc~src
	* @property {String} hd - HD / 720p Resolution image asset source URI/URL
	* @property {String} fhd - FHD / 1080p Resolution image asset source URI/URL
	* @property {String} uhd - UHD / 4K Resolution image asset source URI/URL
	*
	* @typedef {String} ri.selectSrc~src - Image asset source URI/URL
	*/

	/**
	* Image src chooser. A simple utility method to select the ideal image asset from a set of
	* assets, based on various screen resolutions: HD (720p), FHD (1080p), UHD (4k). When provided
	* with a src argument, multiResSrc will choose the best image with respect to the current screen
	* resolution. `src` may be either the traditional string, which will pass straight through, or a
	* hash/object of screen types and their asset sources (keys:screen and values:src). The image
	* sources will be used chosen when the screen resolution is less than or equal to the provided
	* screen types.
	*
	* ```
	* // Take advantage of the multi-rez mode
	* {kind: 'moon.Image', src: {
	* 	'hd': 'http://lorempixel.com/64/64/city/1/',
	* 	'fhd': 'http://lorempixel.com/128/128/city/1/',
	* 	'uhd': 'http://lorempixel.com/256/256/city/1/'
	* }, alt: 'Multi-rez'},
	* // Standard string `src`
	* {kind: 'moon.Image', src: http://lorempixel.com/128/128/city/1/', alt: 'Large'},
	* ```
	*
	* @param {(String|moon.ri.selectSrc~src)} src A string containing a single image src or a
	*	key/value hash/object containing keys representing screen types (hd, fhd, uhd, etc) and
	*	values containing the asset src for that target screen resolution.
	* @returns {String} The choosen src given the string or list provided.
	* @public
	*/
	selectSrc: function (src) {
		if (typeof src != 'string' && src) {
			var i, t,
				newSrc = src.fhd || src.uhd || src.hd,
				types = _screenTypes;

			// loop through resolutions
			for (i = types.length - 1; i >= 0; i--) {
				t = types[i].name;
				if (_screenType == t && src[t]) newSrc = src[t];
			}

			src = newSrc;
		}
		return src;
	},

	/**
	* This will need to be re-run any time the screen size changes, so all the values can be
	* re-cached.
	*
	* @public
	*/
	// Later we can wire this up to a screen resize event so it doesn't need to be called manually.
	init: function () {
		_screenType = this.getScreenType();
		_screenTypeObject = getScreenTypeObject();
		this.updateScreenBodyClasses();
		Dom.unitToPixelFactors.rem = this.getUnitToPixelFactors();
		_riRatio = this.getRiRatio();
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./dom":58}],66:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	logger = require('./logger'),
	utils = require('./utils'),
	options = require('./options');

var defaultCtor = null;

/**
* Creates a JavaScript [constructor]{@glossary constructor} function with
* a prototype defined by `props`. **All constructors must have a unique name.**
*
* `enyo.kind()` makes it easy to build a constructor-with-prototype (like a
* class) that has advanced features like prototype-chaining
* ([inheritance]{@glossary inheritance}).
*
* A plug-in system is included for extending the abilities of the
* [kind]{@glossary kind} generator, and constructors are allowed to
* perform custom operations when subclassed.
*
* If you make changes to `enyo.kind()`, be sure to add or update the appropriate
* [unit tests](@link https://github.com/enyojs/enyo/tree/master/tools/test/core/tests).
*
* For more information, see the documentation on
* [Kinds]{@linkplain $dev-guide/key-concepts/kinds.html} in the Enyo Developer Guide.
*
* @namespace enyo.kind
* @param {Object} props - A [hash]{@glossary Object} of properties used to define and create
*	the [kind]{@glossary kind}
* @public
*/
var kind = exports = module.exports = function (props) {
	// extract 'name' property
	var name = props.name || '';
	delete props.name;
	// extract 'kind' property
	var hasKind = ('kind' in props);
	var kindName = props.kind;
	delete props.kind;
	// establish base class reference
	var base = constructorForKind(kindName);
	var isa = base && base.prototype || null;
	// if we have an explicit kind property with value undefined, we probably
	// tried to reference a kind that is not yet in scope
	if (hasKind && kindName === undefined || base === undefined) {
		var problem = kindName === undefined ? 'undefined kind' : 'unknown kind (' + kindName + ')';
		throw 'enyo.kind: Attempt to subclass an ' + problem + '. Check dependencies for [' + (name || '<unnamed>') + '].';
	}
	// make a boilerplate constructor
	var ctor = kind.makeCtor();
	// semi-reserved word 'constructor' causes problems with Prototype and IE, so we rename it here
	if (props.hasOwnProperty('constructor')) {
		props._constructor = props.constructor;
		delete props.constructor;
	}
	// create our prototype
	//ctor.prototype = isa ? enyo.delegate(isa) : {};
	utils.setPrototype(ctor, isa ? utils.delegate(isa) : {});
	// there are special cases where a base class has a property
	// that may need to be concatenated with a subclasses implementation
	// as opposed to completely overwriting it...
	kind.concatHandler(ctor, props);

	// put in our props
	utils.mixin(ctor.prototype, props);
	// alias class name as 'kind' in the prototype
	// but we actually only need to set this if a new name was used,
	// not if it is inheriting from a kind anonymously
	if (name) {
		ctor.prototype.kindName = name;
	}
	// this is for anonymous constructors
	else {
		ctor.prototype.kindName = base && base.prototype? base.prototype.kindName: '';
	}
	// cache superclass constructor
	ctor.prototype.base = base;
	// reference our real constructor
	ctor.prototype.ctor = ctor;
	// support pluggable 'features'
	utils.forEach(kind.features, function(fn){ fn(ctor, props); });
	
	if (name) kindCtors[name] = ctor;
	
	return ctor;
};

exports.setDefaultCtor = function (ctor) {
	defaultCtor = ctor;
};

var getDefaultCtor = exports.getDefaultCtor = function () {
	return defaultCtor;
};

/**
* @private
*/
var concatenated = exports.concatenated = [];

/**
* Creates a singleton of a given [kind]{@glossary kind} with a given
* definition. **The `name` property will be the instance name of the singleton
* and must be unique.**
*
* ```javascript
*	enyo.singleton({
*		kind: 'enyo.Control',
*		name: 'app.MySingleton',
*		published: {
*			value: 'foo'
*		},
*		makeSomething: function() {
*			//...
*		}
*	});
*
*	app.MySingleton.makeSomething();
*	app.MySingleton.setValue('bar');
*```
*
* @public
*/
exports.singleton = function (conf, context) {
	// extract 'name' property (the name of our singleton)
	var name = conf.name;
	delete(conf.name);
	// create an unnamed kind and save its constructor's function
	var Kind = kind(conf);
	var inst;
	// create the singleton with the previous name and constructor
	utils.setPath.call(context || global, name, (inst = new Kind()));
	return inst;
};

/**
* @private
*/
kind.makeCtor = function () {
	var enyoConstructor = function () {
		if (!(this instanceof enyoConstructor)) {
			throw 'enyo.kind: constructor called directly, not using "new"';
		}

		// two-pass instantiation
		var result;
		if (this._constructor) {
			// pure construction
			result = this._constructor.apply(this, arguments);
		}
		// defer initialization until entire constructor chain has finished
		if (this.constructed) {
			// post-constructor initialization
			this.constructed.apply(this, arguments);
		}

		if (result) {
			return result;
		}
	};
	return enyoConstructor;
};

/**
* Classes referenced by name may omit this namespace (e.g., "Button" instead of "enyo.Button")
*
* @private
*/
kind.defaultNamespace = 'enyo';

/**
* Feature hooks for the oop system
*
* @private
*/
kind.features = [];

/**
* Used internally by several mechanisms to allow safe and normalized handling for extending a
* [kind's]{@glossary kind} super-methods. It can take a
* [constructor]{@glossary constructor}, a [prototype]{@glossary Object.prototype}, or an
* instance.
*
* @private
*/
kind.extendMethods = function (ctor, props, add) {
	var proto = ctor.prototype || ctor,
		b = proto.base;
	if (!proto.inherited && b) {
		proto.inherited = kind.inherited;
	}
	// rename constructor to _constructor to work around IE8/Prototype problems
	if (props.hasOwnProperty('constructor')) {
		props._constructor = props.constructor;
		delete props.constructor;
	}
	// decorate function properties to support inherited (do this ex post facto so that
	// ctor.prototype is known, relies on elements in props being copied by reference)
	for (var n in props) {
		var p = props[n];
		if (isInherited(p)) {
			// ensure that if there isn't actually a super method to call, it won't
			// fail miserably - while this shouldn't happen often, it is a sanity
			// check for mixin-extensions for kinds
			if (add) {
				p = proto[n] = p.fn(proto[n] || utils.nop);
			} else {
				p = proto[n] = p.fn(b? (b.prototype[n] || utils.nop): utils.nop);
			}
		}
		if (utils.isFunction(p)) {
			if (add) {
				proto[n] = p;
				p.displayName = n + '()';
			} else {
				p._inherited = b? b.prototype[n]: null;
				// FIXME: we used to need some extra values for inherited, then inherited got cleaner
				// but in the meantime we used these values to support logging in Object.
				// For now we support this legacy situation, by suppling logging information here.
				p.displayName = proto.kindName + '.' + n + '()';
			}
		}
	}
};
kind.features.push(kind.extendMethods);

/**
* Called by {@link enyo.Object} instances attempting to access super-methods
* of a parent class ([kind]{@glossary kind}) by calling
* `this.inherited(arguments)` from within a kind method. This can only be done
* safely when there is known to be a super class with the same method.
*
* @private
*/
kind.inherited = function (originals, replacements) {
	// one-off methods are the fast track
	var target = originals.callee;
	var fn = target._inherited;

	// regardless of how we got here, just ensure we actually
	// have a function to call or else we throw a console
	// warning to notify developers they are calling a
	// super method that doesn't exist
	if ('function' === typeof fn) {
		var args = originals;
		if (replacements) {
			// combine the two arrays, with the replacements taking the first
			// set of arguments, and originals filling up the rest.
			args = [];
			var i = 0, l = replacements.length;
			for (; i < l; ++i) {
				args[i] = replacements[i];
			}
			l = originals.length;
			for (; i < l; ++i) {
				args[i] = originals[i];
			}
		}
		return fn.apply(this, args);
	} else {
		logger.warn('enyo.kind.inherited: unable to find requested ' +
			'super-method from -> ' + originals.callee.displayName + ' in ' + this.kindName);
	}
};

// dcl inspired super-inheritance

/**
* @private
*/
var Inherited = function (fn) {
	this.fn = fn;
};

/**
* When defining a method that overrides an existing method in a [kind]{@glossary kind}, you
* can wrap the definition in this function and it will decorate it appropriately for inheritance
* to work.
*
* The older `this.inherited(arguments)` method still works, but this version results in much
* faster code and is the only one supported for kind [mixins]{@glossary mixin}.
*
* @param {Function} fn - A [function]{@glossary Function} that takes a single
*   argument (usually named `sup`) and returns a function where
*   `sup.apply(this, arguments)` is used as a mechanism to make the
*   super-call.
* @public
*/
var inherit = exports.inherit = function (fn) {
	return new Inherited(fn);
};

/**
* @private
*/
var isInherited = exports.isInherited = function (fn) {
	return fn && (fn instanceof Inherited);
};


//
// 'statics' feature
//
kind.features.push(function(ctor, props) {
	// install common statics
	if (!ctor.subclass) {
		ctor.subclass = kind.statics.subclass;
	}
	if (!ctor.extend) {
		ctor.extend = kind.statics.extend;
	}
	// move props statics to constructor
	if (props.statics) {
		utils.mixin(ctor, props.statics);
		delete ctor.prototype.statics;
	}
	// also support protectedStatics which won't interfere with defer
	if (props.protectedStatics) {
		utils.mixin(ctor, props.protectedStatics);
		delete ctor.prototype.protectedStatics;
	}
	// allow superclass customization
	var base = ctor.prototype.base;
	while (base) {
		base.subclass(ctor, props);
		base = base.prototype.base;
	}
});

/**
* @private
*/
kind.statics = {

	/**
	* A [kind]{@glossary kind} may set its own `subclass()` method as a
	* static method for its [constructor]{@glossary constructor}. Whenever
	* it is subclassed, the constructor and properties will be passed through
	* this method for special handling of important features.
	*
	* @param {Function} ctor - The [constructor]{@glossary constructor} of the
	*	[kind]{@glossary kind} being subclassed.
	* @param {Object} props - The properties of the kind being subclassed.
	* @memberof enyo.kind
	* @public
	*/
	subclass: function (ctor, props) {},

	/**
	* Allows for extension of the current [kind]{@glossary kind} without
	* creating a new kind. This method is available on all
	* [constructors]{@glossary constructor}, although calling it on a
	* [deferred]{@glossary deferred} constructor will force it to be
	* resolved at that time. This method does not re-run the
	* {@link enyo.kind.features} against the constructor or instance.
	*
	* @param {Object|Object[]} props A [hash]{@glossary Object} or [array]{@glossary Array}
	*	of [hashes]{@glossary Object}. Properties will override
	*	[prototype]{@glossary Object.prototype} properties. If a
	*	method that is being added already exists, the new method will
	*	supersede the existing one. The method may call
	*	`this.inherited()` or be wrapped with `kind.inherit()` to call
	*	the original method (this chains multiple methods tied to a
	*	single [kind]{@glossary kind}).
	* @param {Object} [target] - The instance to be extended. If this is not specified, then the
	*	[constructor]{@glossary constructor} of the
	*	[object]{@glossary Object} this method is being called on will
	*	be extended.
	* @returns {Object} The constructor of the class, or specific
	*	instance, that has been extended.
	* @memberof enyo.kind
	* @public
	*/
	extend: function (props, target) {
		var ctor = this
			, exts = utils.isArray(props)? props: [props]
			, proto, fn;

		fn = function (key, value) {
			return !(typeof value == 'function' || isInherited(value)) && concatenated.indexOf(key) === -1;
		};

		proto = target || ctor.prototype;
		for (var i=0, ext; (ext=exts[i]); ++i) {
			concatHandler(proto, ext, true);
			kind.extendMethods(proto, ext, true);
			utils.mixin(proto, ext, {filter: fn});
		}

		return target || ctor;
	}
};

/**
* @private
*/
var concatHandler = exports.concatHandler = function (ctor, props, instance) {
	var proto = ctor.prototype || ctor
		, base = proto.ctor;

	while (base) {
		if (base.concat) base.concat(ctor, props, instance);
		base = base.prototype.base;
	}
};

/**
* Factory for [kinds]{@glossary kind} identified by [strings]{@glossary String}.
*
* @private
*/
var kindCtors = exports._kindCtors = {};

/**
* @private
*/
var constructorForKind = exports.constructorForKind = function (kind) {
	if (kind === null) {
		return kind;
	} else if (kind === undefined) {
		return getDefaultCtor();
	}
	else if (utils.isFunction(kind)) {
		return kind;
	}

	// use memoized constructor if available...
	var ctor = kindCtors[kind];
	if (ctor) {
		return ctor;
	}
	// otherwise look it up and memoize what we find
	//
	// if kind is an object in enyo, say "Control", then ctor = enyo["Control"]
	// if kind is a path under enyo, say "Heritage.Button", then ctor = enyo["Heritage.Button"] || enyo.Heritage.Button
	// if kind is a fully qualified path, say "enyo.Heritage.Button", then ctor = enyo["enyo.Heritage.Button"] || enyo.enyo.Heritage.Button || enyo.Heritage.Button
	//
	// Note that kind "Foo" will resolve to enyo.Foo before resolving to global "Foo".
	// This is important so "Image" will map to built-in Image object, instead of enyo.Image control.
	ctor = Theme[kind] || (global.enyo && gobal.enyo[kind]) || utils.getPath.call(global, 'enyo.' + kind) || global[kind] || utils.getPath.call(global, kind);

	// If what we found at this namespace isn't a function, it's definitely not a kind constructor
	if (!utils.isFunction(ctor)) {
		throw '[' + kind + '] is not the name of a valid kind.';
	}
	kindCtors[kind] = ctor;
	return ctor;
};

/**
* Namespace for current theme (`enyo.Theme.Button` references the Button specialization for the
* current theme).
*
* @private
*/
var Theme = exports.Theme = {};

/**
* @private
*/
exports.registerTheme = function (ns) {
	utils.mixin(Theme, ns);
};

/**
* @private
*/
exports.createFromKind = function (nom, param) {
	var Ctor = nom && constructorForKind(nom);
	if (Ctor) {
		return new Ctor(param);
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./logger":67,"./options":69,"./utils":75}],6:[function(require,module,exports){
require('../../enyo');

var kind = require('./kind');

/**
* An internally-used support {@glossary mixin} that is applied to all
* [components]{@link enyo.Component} of an {@link enyo.Application} instance
* (and to their components, recursively). This mixin adds an `app` property to
* each component--a local reference to the `enyo.Application` instance that
* the component belongs to.
* 
* @mixin enyo.ApplicationSupport
* @protected
*/
module.exports = {

	/**
	* @private
	*/
	name: 'ApplicationSupport',

	/**
	* @private
	*/
	adjustComponentProps: kind.inherit(function (sup) {
		return function (props) {
			props.app = props.app || this.app;
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			// release the reference to the application
			this.app = null;
			sup.apply(this, arguments);
		};
	})

};
},{"../../enyo":1,"./kind":66}],8:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

/**
* All {@link enyo.Binding} instances are stored in this list and may be retrieved via the
* {@link enyo.Binding.find} method using an {@link enyo.Binding#id} identifier.
*
* @name enyo.bindings
* @public
*/
var bindings = [];

var DIRTY_FROM = 0x01
	, DIRTY_TO = 0x02;

/**
* Used to determine if an {@link enyo.Binding} is actually ready.
*
* @private
*/
function ready (binding) {
	var rdy = binding.ready;
	
	if (!rdy) {
		
		var from = binding.from || '',
			to = binding.to || '',
			source = binding.source,
			target = binding.target,
			owner = binding.owner,
			twoWay = !binding.oneWay,
			toTarget;
		
		if (typeof from != 'string') from = '';
		if (typeof to != 'string') to = '';
		
		if (!source) {
			
			// the worst case scenario here is for backward compatibility purposes
			// we have to at least be able to derive the source via the from string
			if (from[0] == '^') {
				
				// this means we're reaching for a global
				var fromParts = from.split('.');
				from = fromParts.pop();
				source = utils.getPath(fromParts.join('.').slice(1));
				
			} else {
				source = owner;
			}
			
		}
		
		if (!target) {
			
			// same worst case as above, for backwards compatibility purposes
			// we have to at least be able to derive the target via the to string
			if (to[0] == '^') {
				
				// this means we're reaching for a global
				var toParts = to.split('.');
				to = toParts.pop();
				target = utils.getPath(toParts.join('.').slice(1));
			} else {
				target = owner;
			}
		}
		
		// we do this so we don't overwrite the originals in case we need to reset later
		binding._target = target;
		binding._source = source;
		binding._from = from[0] == '.'? from.slice(1): from;
		binding._to = to[0] == '.'? to.slice(1): to;
		
		if (!twoWay) {
			toTarget = binding._to.split('.');
			if (toTarget.length > 2) {
				toTarget.pop();
				binding._toTarget = toTarget.join('.');
			}
		}
		
		// now our sanitization
		rdy = !! (
			(source && (typeof source == 'object')) &&
			(target && (typeof target == 'object')) &&
			(from) &&
			(to)
		);
	}
	
	/*jshint -W093 */
	return (binding.ready = rdy);
	/*jshint +W093 */
}

/**
* The details for an {@link enyo.Binding#transform} [function]{@glossary Function}, 
* including the available parameters and how they can be used.
* 
* @callback enyo.Binding~Transform
* @param {*} value - The value being synchronized.
* @param {Number} direction - The direction of synchronization; will be either
* 	1 (source value has changed and will be written to target) or 2 (target
* 	value has changed and will be written to source).
* @param {Object} binding - A reference to the associated [binding]{@link enyo.Binding}. In cases 
* 	where the binding should be interrupted and not propagate the synchronization at all, call
* 	the [stop()]{@link enyo.Binding#stop} method on the passed-in binding reference.
*/

/**
* {@link enyo.Binding} is a mechanism used to keep properties synchronized. A 
* binding may be used to link two properties on different
* [objects]{@glossary Object}, or even two properties on the same object.
* Once a binding has been established, it will wait for change notifications;
* when a notification arrives, the binding will synchronize the value between
* the two ends. Note that bindings may be either
* [one-way]{@link enyo.Binding#oneWay} (the default) or
* [two-way]{@link enyo.Binding#oneWay}.
* 
* Usually, you will not need to create Binding objects arbitrarily, but will
* instead rely on the public [BindingSupport API]{@link enyo.BindingSupport},
* which is applied to [enyo.Object]{@link enyo.Object} and so is available on
* all of its [subkinds]{@glossary subkind}.
* 
* @class enyo.Binding
* @public
*/
var Binding = module.exports = kind(
	/** @lends enyo.Binding.prototype */ {
	
	name: 'enyo.Binding',
	
	/**
	* @private
	*/
	kind: null,
	
	/**
	* @private
	*/

	
	/**
	* If a [binding]{@link enyo.Binding} is one-way, this flag should be `true` (the default). 
	* If this flag is set to `false`, the binding will be two-way.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	oneWay: true,
	
	/**
	* If the [binding]{@link enyo.Binding} was able to resolve both ends (i.e., its 
	* [source]{@link enyo.Binding#source} and [target]{@link enyo.Binding#target} 
	* [objects]{@glossary Object}), this value will be `true`. Setting this manually will
	* have undesirable effects.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	connected: false,
	
	/**
	* This property is used extensively for various purposes within a
	* [binding]{@link enyo.Binding}. One primary purpose is to serve as a root
	* [object]{@glossary Object} from which to	search for the binding's ends (the
	* [source]{@link enyo.Binding#source} and/or [target]{@link enyo.Binding#target}).
	* If the owner created the binding, it will also be responsible for destroying 
	* it (automatically).
	*
	* @type {enyo.Object}
	* @default null
	* @public
	*/
	owner: null,
	
	/**
	* By default, a [binding]{@link enyo.Binding} will attempt to connect to both ends 
	* ([source]{@link enyo.Binding#source} and [target]{@link enyo.Binding#target}). If this 
	* process should be deferred, set this flag to `false`.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	autoConnect: true,
	
	/**
	* By default, a [binding]{@link enyo.Binding} will attempt to synchronize its values from 
	* its [source]{@link enyo.Binding#source} to its [target]{@link enyo.Binding#target}. If 
	* this process should be deferred, set this flag to `false`.
	* 
	* @type {Boolean}
	* @default true
	* @public
	*/
	autoSync: true,
	
	/**
	* Set this only to a reference for an [object]{@glossary Object} to use
	* as the source for the [binding]{@link enyo.Binding}. If this is not a
	* [bindable]{@link enyo.BindingSupport} object, the source will be derived
	* from the [from]{@link enyo.Binding#from} property during initialization.
	* 
	* @type {Object}
	* @default null
	* @public
	*/
	source: null,
	
	/**
	* Set this only to a reference for an [object]{@glossary Object} to use
	* as the target for the [binding]{@link enyo.Binding}. If this is not a
	* [bindable]{@link enyo.BindingSupport} object, the target will will be
	* derived from the [to]{@link enyo.Binding#to} property during initialization.
	* 
	* @type {Object}
	* @default null
	* @public
	*/
	target: null,
	
	/**
	* A path in which the property of the [source]{@link enyo.Binding#source} to
	* bind from may be found. If the source is explicitly provided and the path
	* is relative (i.e., it begins with a `"."`), it is relative to the source;
	* otherwise, it is relative to the [owner]{@link enyo.Binding#owner} of the
	* [binding]{@link enyo.Binding}. To have a binding be evaluated from the
	* global scope, prefix the path with a `"^"`. If the source and the `"^"`
	* are used in tandem, the `"^"` will be ignored and the path will be assumed
	* to be relative to the provided source.
	* 
	* @type {String}
	* @default null
	* @public
	*/
	from: null,
	
	/**
	* The `dirty` property represents the changed value state of both the property designated by
	* the [from]{@link enyo.Binding#from} path and the property designated by the 
	* [to]{@link enyo.Binding#to} path.
	*
	* @type {Number}
	* @default enyo.Binding.DIRTY_FROM
	* @public
	*/
	dirty: DIRTY_FROM,
	
	/**
	* A path in which the property of the [target]{@link enyo.Binding#target} to
	* bind from may be found. If the target is explicitly provided and the path
	* is relative (i.e., it begins with a `"."`), it is relative to the target;
	* otherwise, it is relative to the owner of the [binding]{@link enyo.Binding}.
	* To have a binding be evaluated from the global scope, prefix the path with
	* a `"^"`. If the target and the `"^"` are used in tandem, the `"^"` will be
	* ignored and the path will be assumed to be relative to the provided target.
	* 
	* @type {String}
	* @default null
	* @public
	*/
	to: null,

	/**
	* Set this to a [function]{@glossary Function} or the name of a method on
	* the [owner]{@link enyo.Binding#owner} of this [binding]{@link enyo.Binding}.
	* The transform is used to programmatically modify the value being synchronized.
	* See {@link enyo.Binding~Transform} for detailed information on the parameters
	* that are available to `transform`.
	* 
	* @type {enyo.Binding~Transform}
	* @default null
	* @public
	*/
	transform: null,
	
	/**
	* Indicates whether the [binding]{@link enyo.Binding} is currently connected.
	*
	* @returns {Boolean} `true` if connected; otherwise, `false`.
	* @public
	*/
	isConnected: function () {
		var from = this._from,
			to = this.oneWay ? (this._toTarget || this._to) : this._to,
			source = this._source,
			target = this._target,
			toChain,
			fromChain;
			
		if (from && to && source && target) {
			if (!this.oneWay || this._toTarget) toChain = target.getChains()[to];
			fromChain = source.getChains()[from];
			
			return this.connected
				&& (fromChain ? fromChain.isConnected() : true)
				&& (toChain ? toChain.isConnected() : true);
		}
		
		return false;
	},
	
	/**
	* Causes a single propagation attempt to fail. Typically not called outside
	* the scope of a [transform]{@link enyo.Binding#transform}.
	* 
	* @public
	*/
	stop: function () {
		this._stop = true;
	},
	
	/**
	* Indicates whether the [binding]{@link enyo.Binding} is actually ready.
	* 
	* @returns {Boolean} `true` if ready; otherwise, `false`.
	* @public
	*/
	isReady: function () {
		return this.ready || ready(this);
	},
	
	/**
	* Resets all properties to their original state.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	reset: function () {
		this.disconnect();
		this.ready = null;
		this._source = this._target = this._to = this._from = this._toTarget = null;
		return this;
	},
	
	/**
	* Rebuilds the entire [binding]{@link enyo.Binding}. Will synchronize if it is able to 
	* connect and the [autoSync]{@link enyo.Binding#autoSync} flag is `true`.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	rebuild: function () {
		return this.reset().connect();
	},
	
	/**
	* Connects the ends (i.e., the [source]{@link enyo.Binding#source} and
	* [target]{@link enyo.Binding#target}) of the [binding]{@link enyo.Binding}. While you
	* typically won't need to call this method, it is safe to call even when the ends are
	* already established. Note that if one or both of the ends does become connected and the
	* [autoSync]{@link enyo.Binding#autoSync} flag is `true`, the ends will automatically be
	* synchronized.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	connect: function () {
		if (!this.isConnected()) {
			if (this.isReady()) {
				this._source.observe(this._from, this._sourceChanged, this, {priority: true});
				
				// for two-way bindings we register to observe changes
				// from the target
				if (!this.oneWay) this._target.observe(this._to, this._targetChanged, this);
				else if (this._toTarget) {
					this._target.observe(this._toTarget, this._toTargetChanged, this, {priority: true});
				}
				
				// we flag it as having been connected
				this.connected = true;
				if (this.isConnected() && this.autoSync) this.sync(true);
			}
		}
		
		return this;
	},
	
	/**
	* Disconnects from the ends (i.e., the [source]{@link enyo.Binding#source} and 
	* [target]{@link enyo.Binding#target}) if a connection exists at either end. This method 
	* will most likely not need to be called directly.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	disconnect: function () {
		if (this.isConnected()) {
			this._source.unobserve(this._from, this._sourceChanged, this);
			
			// for two-way bindings we unregister the observer from
			// the target as well
			if (!this.oneWay) this._target.unobserve(this._to, this._targetChanged, this);
			else if (this._toTarget) {
				this._target.unobserve(this._toTarget, this._toTargetChanged, this);
			}
			
			this.connected = false;
		}
		
		return this;
	},
	
	/**
	* Synchronizes values from the [source]{@link enyo.Binding#source} to the
	* [target]{@link enyo.Binding#target}. This usually will not need to be called manually.
	* [Two-way bindings]{@link enyo.Binding#oneWay} will automatically synchronize from the
	* target end once they are connected.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	sync: function (force) {
		var source = this._source,
			target = this._target,
			from = this._from,
			to = this._to,
			xform = this.getTransform(),
			val;
		
		if (this.isReady() && this.isConnected()) {
				
			switch (this.dirty || (force && DIRTY_FROM)) {
			case DIRTY_TO:
				val = target.get(to);
				if (xform) val = xform.call(this.owner || this, val, DIRTY_TO, this);
				if (!this._stop) source.set(from, val, {create: false});
				break;
			case DIRTY_FROM:
				
			// @TODO: This should never need to happen but is here just in case
			// it is ever arbitrarily called not having been dirty?
			// default:
				val = source.get(from);
				if (xform) val = xform.call(this.owner || this, val, DIRTY_FROM, this);
				if (!this._stop) target.set(to, val, {create: false});
				break;
			}
			this.dirty = null;
			this._stop = null;
		}
		
		return this;
	},
	
	/**
	* Releases all of the [binding's]{@link enyo.Binding} parts and unregisters its 
	* [observers]{@link enyo.ObserverSupport}. Typically, this method will not need to be called 
	* directly unless the binding was created without an [owner]{@link enyo.Binding#owner}.
	* 
	* @returns {this} The callee for chaining.
	* @public
	*/
	destroy: function () {
		var owner = this.owner,
			idx;
		
		this.disconnect();
		this.owner = null;
		this.source = this._source = null;
		this.target = this._target = null;
		this.ready = null;
		this.destroyed = true;
		
		// @todo: remove me or postpone operation?
		idx = bindings.indexOf(this);
		if (idx > -1) bindings.splice(idx, 1);
		
		if (owner && !owner.destroyed) owner.removeBinding(this);
		
		return this;
	},
	
	/**
	* @private
	*/
	getTransform: function () {
		return this._didInitTransform ? this.transform : (function (bnd) {
			bnd._didInitTransform = true;
			
			var xform = bnd.transform,
				owner = bnd.owner,
				xformOwner = owner && owner.bindingTransformOwner;
			
			if (xform) {
				if (typeof xform == 'string') {
					if (xformOwner && xformOwner[xform]) {
						xform = xformOwner[xform];
					} else if (owner && owner[xform]) {
						xform = owner[xform];
					} else {
						xform = utils.getPath(xform);
					}
				}
				
				/*jshint -W093 */
				return (bnd.transform = (typeof xform == 'function' ? xform : null));
				/*jshint +W093 */
			}
		})(this);
	},
	
	/**
	* @private
	*/
	constructor: function (props) {
		bindings.push(this);
		
		if (props) utils.mixin(this, props);
		
		if (!this.euid) this.euid = utils.uid('b');
		if (this.autoConnect) this.connect();
	},
	
	/**
	* @private
	*/
	_sourceChanged: function (was, is, path) {
		// @TODO: Should it...would it benefit from using these passed in values?
		this.dirty = this.dirty == DIRTY_TO ? null : DIRTY_FROM;
		return this.dirty == DIRTY_FROM && this.sync();
	},
	
	/**
	* @private
	*/
	_targetChanged: function (was, is, path) {
		// @TODO: Same question as above, it seems useful but would it affect computed
		// properties or stale values?
		this.dirty = this.dirty == DIRTY_FROM ? null : DIRTY_TO;
		return this.dirty == DIRTY_TO && this.sync();
	},
	
	/**
	* @private
	*/
	_toTargetChanged: function (was, is, path) {
		this.dirty = DIRTY_FROM;
		this.reset().connect();
	}
});

/**
* Retrieves a [binding]{@link enyo.Binding} by its global id.
*
* @param {String} euid - The [Enyo global id]{@glossary EUID} by which to retrieve a 
*	[binding]{@link enyo.Binding}.
* @returns {enyo.Binding|undefined} A reference to the binding if the id 
*	is found; otherwise, it will return [undefined]{@glossary undefined}.
* 
* @static
* @public
*/
Binding.find = function (euid) {
	return bindings.find(function (ln) {
		return ln.euid == euid;
	});
};

Binding.bindings = bindings;

/**
* Possible value of the [dirty]{@link enyo.Binding#dirty} property, indicating that the value 
* of the [binding source]{@link enyo.Binding#source} has changed.
* 
* @static
* @public
BindingB.DindingIRTY_FROM = DIRTY_FROM;

/**
* Possible value of the [dirty]{@link enyo.Binding#dirty} property, indicating that the value
* of the [binding target]{@link enyo.Binding#target} has changed.
* 
* @static
* @public
*/
Binding.DIRTY_TO = DIRTY_TO;

/**
* The default [kind]{@glossary kind} that provides [binding]{@link enyo.Binding} 
* functionality.
* 
* static
* public
*/
Binding.defaultBindingKind = Binding;
},{"../../enyo":1,"./kind":66,"./utils":75}],14:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');

/**
* An internally-used {@glossary mixin} applied to {@link enyo.Component}
* instances to better support [bindings]{@link enyo.Binding}.
*
* @mixin enyo.ComponentBindingSupport
* @protected
*/
module.exports = {
	
	/**
	* @private
	*/
	name: 'ComponentBindingSupport',
	
	/**
	* @private
	*/
	adjustComponentProps: kind.inherit(function (sup) {
		return function (props) {
			sup.apply(this, arguments);
			props.bindingTransformOwner || (props.bindingTransformOwner = this.getInstanceOwner());
		};
	})
};
},{"../../enyo":1,"./kind":66}],15:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var extend = kind.statics.extend;
	
kind.concatenated.push('computed');

/**
* @private
*/
function getComputedValue (obj, path) {
	var cache = obj._getComputedCache(path)
		, isCached = obj._isComputedCached(path);
	
	// in the end, for efficiency and completeness in other situations
	// it is better to know the returned value of all computed properties
	// but in cases where they are set as cached we will sometimes use
	// that value
	if (cache.dirty || cache.dirty === undefined) {
		isCached && (cache.dirty = false);
		cache.previous = cache.value;
		cache.value = obj[path]();
	}
	
	return cache.value;
}

/**
* @private
*/
function queueComputed (obj, path) {
	var queue = obj._computedQueue || (obj._computedQueue = [])
		, deps = obj._computedDependencies[path];
		
	if (deps) {
		for (var i=0, dep; (dep=deps[i]); ++i) {
			if (!queue.length || -1 == queue.indexOf(dep)) queue.push(dep);
		}
	}
}

/**
* @private
*/
function flushComputed (obj) {
	var queue = obj._computedQueue;
	obj._computedQueue = null;
	if (queue && obj.isObserving()) {
		for (var i=0, ln; (ln=queue[i]); ++i) {
			obj.notify(ln, obj._getComputedCache(ln).value, getComputedValue(obj, ln));
		}
	}
}

/**
* A {@glossary mixin} that adds API methods to support
* [computed properties]{@glossary "computed property"}. Unlike other support mixins,
* this mixin does not need to be explicitly included by a [kind]{@glossary kind}. If the
* `computed` [array]{@glossary Array} is found in a kind definition, this mixin will
* automatically be included.
*
* @mixin enyo.ComputedSupport
* @public
*/
var ComputedSupport = module.exports = {
	
	/**
	* @private
	*/
	name: 'ComputedSupport',
	
	/**
	* @private
	*/
	_computedRecursion: 0,
	
	/**
	* Primarily intended for internal use, this method determines whether the
	* given path is a known [computed property]{@glossary "computed property"}.
	*
	* @param {String} path - The property or path to test.
	* @returns {Boolean} Whether or not the `path` is a
	*	[computed property]{@glossary "computed property"}.
	* @public
	*/
	isComputed: function (path) {
		// if it exists it will be explicitly one of these cases and it is cheaper than hasOwnProperty
		return this._computed && (this._computed[path] === true || this._computed[path] === false);
	},
	
	/**
	* Primarily intended for internal use, this method determines whether the
	* given path is a known dependency of a
	* [computed property]{@glossary "computed property"}.
	*
	* @param {String} path - The property or path to test.
	* @returns {Boolean} Whether or not the `path` is a dependency of a
	*	[computed property]{@glossary "computed property"}.
	* @public
	*/
	isComputedDependency: function (path) {
		return !! (this._computedDependencies? this._computedDependencies[path]: false);
	},
	
	/**
	* @private
	*/
	get: kind.inherit(function (sup) {
		return function (path) {
			return this.isComputed(path)? getComputedValue(this, path): sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	set: kind.inherit(function (sup) {
		return function (path) {
			// we do not accept parameters for computed properties
			return this.isComputed(path)? this: sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	notifyObservers: function () {
		return this.notify.apply(this, arguments);
	},
	
	/**
	* @private
	*/
	notify: kind.inherit(function (sup) {
		return function (path, was, is) {
			this.isComputedDependency(path) && queueComputed(this, path);
			this._computedRecursion++;
			sup.apply(this, arguments);
			this._computedRecursion--;
			this._computedQueue && this._computedRecursion === 0 && flushComputed(this);
			return this;
		};
	}),
	
	/**
	* @private
	*/
	_isComputedCached: function (path) {
		return this._computed[path];
	},
	
	/**
	* @private
	*/
	_getComputedCache: function (path) {
		var cache = this._computedCache || (this._computedCache = {});
		return cache[path] || (cache[path] = {});
	}
};


/**
* Hijack the original so we can add additional default behavior.
*/
var sup = kind.concatHandler;

// @NOTE: It seems like a lot of work but it really won't happen that much and the more
// we push to kind-time the better for initialization time

/**
* @private
*/
kind.concatHandler = function (ctor, props, instance) {

	sup.call(this, ctor, props, instance);

	// only matters if there are computed properties to manage
	if (props.computed) {
		
		var proto = ctor.prototype || ctor
			, computed = proto._computed? Object.create(proto._computed): {}
			, dependencies = proto._computedDependencies? Object.create(proto._computedDependencies): {};
		
		// if it hasn't already been applied we need to ensure that the prototype will
		// actually have the computed support mixin present, it will not apply it more
		// than once to the prototype
		extend(ComputedSupport, proto);
	
		// @NOTE: This is the handling of the original syntax provided for computed properties in 2.3.ish...
		// All we do here is convert it to a structure that can be used for the other scenario and preferred
		// computed declarations format
		if (!props.computed || !(props.computed instanceof Array)) {
			(function () {
				var tmp = [], deps, name, conf;
				// here is the slow iteration over the properties...
				for (name in props.computed) {
					// points to the dependencies of the computed method
					deps = props.computed[name];
					/*jshint -W083 */
					conf = deps && deps.find(function (ln) {
						// we deliberately remove the entry here and forcibly return true to break
						return typeof ln == 'object'? (utils.remove(deps, ln) || true): false;
					});
					/*jshint +W083 */
					// create a single entry now for the method/computed with all dependencies
					tmp.push({method: name, path: deps, cached: conf? conf.cached: null});
				}
				
				// note that we only do this one so even for a mixin that is evaluated several
				// times this would only happen once
				props.computed = tmp;
			}());
		}
		
		var addDependency = function (path, dep) {
			// its really an inverse look at the original
			var deps;
			
			if (dependencies[path] && !dependencies.hasOwnProperty(path)) dependencies[path] = dependencies[path].slice();
			deps = dependencies[path] || (dependencies[path] = []);
			deps.push(dep);
		};
		
		// now we handle the new computed properties the way we intended to
		for (var i=0, ln; (ln=props.computed[i]); ++i) {
			// if the entry already exists we are merely updating whether or not it is
			// now cached
			computed[ln.method] = !! ln.cached;
			// we must now look to add an entry for any given dependencies and map them
			// back to the computed property they will trigger
			/*jshint -W083 */
			if (ln.path && ln.path instanceof Array) ln.path.forEach(function (dep) { addDependency(dep, ln.method); });
			/*jshint +W083 */
			else if (ln.path) addDependency(ln.path, ln.method);
		}
		
		// arg, free the key from the properties so it won't be applied later...
		// delete props.computed;
		// make sure to reassign the correct items to the prototype
		proto._computed = computed;
		proto._computedDependencies = dependencies;
	}
};
},{"../../enyo":1,"./kind":66,"./utils":75}],26:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');

/**
* {@link enyo.Layout} is the base [kind]{@glossary kind} for layout
* kinds. Layout kinds are used by {@link enyo.UiComponent}-based
* [controls]{@link enyo.Control} to allow for arranging of child controls by
* setting the [layoutKind]{@link enyo.UiComponent#layoutKind} property.
* 
* Derived kinds will usually provide their own
* [layoutClass]{@link enyo.Layout#layoutClass} property to affect the CSS
* rules used, and may also implement the [flow()]{@link enyo.Layout#flow}
* and [reflow()]{@link enyo.Layout#reflow} methods. `flow()` is called
* during control rendering, while `reflow()` is called when the associated
* control is resized.
*
* @class enyo.Layout
* @public
*/
module.exports = kind(
	/** @lends enyo.Layout.prototype */ {

	name: 'enyo.Layout',

	/**
	* @private
	*/
	kind: null,

	/** 
	* CSS class that's added to the [control]{@link enyo.Control} using this 
	* [layout]{@link enyo.Layout} [kind]{@glossary kind}.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	layoutClass: '',
	
	/**
	* @private
	*/
	constructor: function (container) {
		this.container = container;
		if (container) {
			container.addClass(this.layoutClass);
		}
	},

	/**
	* @private
	*/
	destroy: function () {
		if (this.container) {
			this.container.removeClass(this.layoutClass);
		}
	},
	
	/**
	* Called during static property layout (i.e., during rendering).
	*
	* @public
	*/
	flow: function () {
	},

	/** 
	* Called during dynamic measuring layout (i.e., during a resize).
	*
	* @public
	*/
	reflow: function () {
	}
});
},{"../../enyo":1,"./kind":66}],28:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

/**
* An abstract linked-list node.
*
* @class enyo.LinkedListNode
* @private
*/
module.exports = kind(
	/** @lends enyo.LinkedListNode.prototype */ {
	
	/**
	* @private
	*/
	kind: null,
	
	/**
	* @private
	*/

	
	/**
	* @private
	*/
	prev: null,
	
	/**
	* @private
	*/
	next: null,
	
	/**
	* @private
	*/
	copy: function () {
		var cpy = new this.ctor();
		cpy.prev = this.prev;
		cpy.next = this.next;
		return cpy;
	},
	
	/**
	* @private
	*/
	constructor: function (props) {
		props && utils.mixin(this, props);
	},
	
	/**
	* @private
	*/
	destroy: function () {
		// clear reference to previous node
		this.prev = null;
		
		// if we have a reference to our next node
		// we continue down the chain
		this.next && this.next.destroy();
		
		// clear our reference to the next node
		this.next = null;
	}
});
},{"../../enyo":1,"./kind":66,"./utils":75}],29:[function(require,module,exports){
require('../../enyo');


var
	utils = require('./utils'),
	kind = require('./kind'),
	logger = require('./logger');

kind.concatenated.push('mixins');

var sup = kind.statics.extend;

/**
* @private
*/
var extend = kind.statics.extend = function extend (args, target) {
	if (utils.isArray(args)) return utils.forEach(args, function (ln) { extend.call(this, ln, target); }, this);
	if (typeof args == 'string') apply(target || this.prototype, args);
	else {
		if (args.mixins) feature(target || this, args);
	
		// this allows for mixins to apply mixins which...is less than ideal but possible
		if (args.name) apply(target || this.prototype, args);
		else sup.apply(this, arguments);
	}
};

/**
* Applies, with safeguards, a given mixin to an object.
*
* @private
*/
function apply (proto, props) {
	var applied = proto._mixins? (proto._mixins = proto._mixins.slice()): (proto._mixins = [])
		, name = utils.isString(props)? props: props.name
		, idx = utils.indexOf(name, applied);
	if (idx < 0) {
		name == props && (props = utils.getPath(name));
		// if we could not resolve the requested mixin (should never happen)
		// we throw a simple little error
		// @TODO: Normalize error format
		!props && logger.error('Could not find the mixin ' + name);
		
		// it should be noted that this ensures it won't recursively re-add the same mixin but
		// since it is possible for mixins to apply mixins the names will be out of order
		// this name is pushed on but the nested mixins are applied before this one
		name && applied.push(name);
		
		props = utils.clone(props);
		
		// we need to temporarily move the constructor if it has one so it
		// will override the correct method - this is a one-time permanent
		// runtime operation so subsequent additions of the mixin don't require
		// it again
		if (props.hasOwnProperty('constructor')) {
			props._constructor = props.constructor;
			delete props.constructor;
		}
		
		delete props.name;
		extend(props, proto);
		
		// now put it all back the way it was
		props.name = name;
	}
}

/**
* @private
*/
function feature (ctor, props) {
	if (props.mixins) {
		var proto = ctor.prototype || ctor
			, mixins = props.mixins;
		
		// delete props.mixins;
		// delete proto.mixins;
		
		proto._mixins && (proto._mixins = proto._mixins.slice());
		utils.forEach(mixins, function (ln) { apply(proto, ln); });
	}
}

kind.features.push(feature);

/**
* An internally-used support {@glossary mixin} that adds API methods to aid in
* using and applying mixins to [kinds]{@glossary kind}.
*
* @mixin enyo.MixinSupport
* @protected
*/
module.exports = {
	
	/**
	* @private
	*/
	name: 'MixinSupport',
	
	/**
	* Extends the instance with the given properties.
	*
	* @param {Object} props - The property [hash]{@glossary Object} from which to extend
	*	the callee.
	*/
	extend: function (props) {
		props && apply(this, props);
	},
	
	/**
	* @private
	*/
	importProps: kind.inherit(function (sup) {
		return function (props) {
			props && props.mixins && feature(this, props);
			
			sup.apply(this, arguments);
		};
	})
};
},{"../../enyo":1,"./kind":66,"./logger":67,"./utils":75}],48:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	logger = require('./logger');

/**
* All of the known, instanced [sources]{@link enyo.Source}, by name.
*
* @name enyo~sources
* @type {Object}
* @readonly
*/
var sources = {};

/**
* This is an abstract base class. A [source]{@link enyo.Source} is a communication
* layer used by data layer [kinds]{@glossary kind} to retrieve and persist data and
* application state via its abstract API methods.
*
* @class enyo.Source
* @public
*/
var Source = module.exports = kind(
	/** @lends enyo.Source.prototype */ {
	
	name: 'enyo.Source',
	
	/**
	* @private
	*/
	kind: null,
	
	/**
	* @private
	*/

	
	/**
	* When initialized, the source should be passed properties to set on itself.
	* These properties should include the name by which it will be referenced in
	* the application.
	*
	* @param {Object} [props] - The properties to set on itself.
	* @public
	*/
	constructor: function (props) {
		if (props) this.importProps(props);
		// automatic coersion of name removing prefix
		this.name || (this.name = this.kindName.replace(/^(.*)\./, ""));
		// now add to the global registry of sources
		sources[this.name] = this;
	},
	
	/**
	* Overload this method to handle retrieval of data. This method should accept an options
	* [hash]{@glossary Object} with additional configuration properties, including `success`
	* and `error` callbacks to handle the result.
	*
	* @virtual
	* @param {(enyo.Model|enyo.Collection)} model The [model]{@link enyo.Model} or
	*	[collection]{@link enyo.Collection} to be retrieved.
	* @param {Object} opts - The configuration options [hash]{@glossary Object}, including
	*	`success` and `error` callbacks.
	*/
	fetch: function (model, opts) {
		//
	},
	
	/**
	* Overload this method to handle persisting of data. This method should accept an options
	* [hash]{@glossary Object} with additional configuration properties, including `success`
	* and `error` callbacks to handle the result.
	*
	* @virtual
	* @param {(enyo.Model|enyo.Collection)} model The [model]{@link enyo.Model} or
	*	[collection]{@link enyo.Collection} to be persisted.
	* @param {Object} opts - The configuration options [hash]{@glossary Object}, including
	*	`success` and `error` callback.
	*/
	commit: function (model, opts) {
		//
	},
	
	/**
	* Overload this method to handle deletion of data. This method should accept an options
	* [hash]{@glossary Object} with additional configuration properties, including `success`
	* and `error` callbacks to handle the result. If called without parameters, it will
	* instead destroy itself and be removed from [enyo.sources]{@link enyo~sources}, rendering
	* itself unavailable for further operations.
	*
	* @param {(enyo.Model|enyo.Collection)} model The [model]{@link enyo.Model} or
	*	[collection]{@link enyo.Collection} to be deleted.
	* @param {Object} opts - The configuration options [hash]{@glossary Object}, including
	*	`success` and `error` callbacks.
	*/
	destroy: function (model, opts) {
		
		// if called with no parameters we actually just breakdown the source and remove
		// it as being available
		if (!arguments.length) {
			sources[this.name] = null;
			this.name = null;
		}
	},
	
	/**
	* Overload this method to handle querying of data based on the passed-in constructor. This
	* method should accept an options [hash]{@glossary Object} with additional configuration
	* properties, including `success` and `error` callbacks to handle the result.
	*
	* @virtual
	* @param {Function} ctor - The constructor for the [kind]{@glossary kind} of
	*	{@link enyo.Model} or {@link enyo.Collection} to be queried.
	* @param {Object} opts - The configuration options [hash]{@glossary Object}, including
	*	`success` and `error` callbacks.
	*/
	find: function (ctor, opts) {
		//
	},
	
	/**
	* @private
	*/
	importProps: function (props) {
		props && utils.mixin(this, props);
	},
	
	/**
	* @see enyo.getPath
	* @method
	* @public
	*/
	get: utils.getPath,
	
	/**
	* @see enyo.setPath
	* @method
	* @public
	*/
	set: utils.setPath
});

/**
* Creates an instance of {@link enyo.Source} with the given properties. These
* properties should include a `kind` property with the name of the
* [kind]{@glossary kind} of source and a `name` for the instance. This static
* method is also available on all [subkinds]{@glossary subkind} of
* `enyo.Source`. The instance will automatically be added to the
* [enyo.sources]{@link enyo~sources} [object]{@glossary Object} and may be
* referenced by its `name`.
*
* @name enyo.Source.create
* @static
* @method
* @param {Object} props - The properties to pass to the constructor for the requested
*	[kind]{@glossary kind} of [source]{@link enyo.Source}.
* @returns {enyo.Source} An instance of the requested kind of source.
* @public
*/
Source.create = function (props) {
	var Ctor = (props && props.kind) || this;
	
	if (typeof Ctor == 'string') Ctor = kind.constructorForKind(Ctor);
	
	return new Ctor(props);
};

/**
* @static
* @private
*/
Source.concat = function (ctor, props) {
	
	// force noDefer so that we can actually set this method on the constructor
	if (props) props.noDefer = true;
	
	ctor.create = Source.create;
};

/**
* @static
* @private
*/
Source.execute = function (action, model, opts) {
	var source = opts.source || model.source,
	
		// we need to be able to bind the success and error callbacks for each of the
		// sources we'll be using
		options = utils.clone(opts, true),
		nom = source,
		msg;
	
	if (source) {
		
		// if explicitly set to true then we need to use all available sources in the
		// application
		if (source === true) {
			
			for (nom in sources) {
				source = sources[nom];
				if (source[action]) {
					
					// bind the source name to the success and error callbacks
					options.success = opts.success.bind(null, nom);
					options.error = opts.error.bind(null, nom);
					
					source[action](model, options);
				}
			}
		}
		
		// if it is an array of specific sources to use we, well, will only use those!
		else if (source instanceof Array) {
			source.forEach(function (nom) {
				var src = typeof nom == 'string' ? sources[nom] : nom;
				
				if (src && src[action]) {
					// bind the source name to the success and error callbacks
					options.success = opts.success.bind(null, src.name);
					options.error = opts.error.bind(null, src.name);
					
					src[action](model, options);
				}
			});
		}
		
		// if it is an instance of a source
		else if (source instanceof Source && source[action]) {
			
			// bind the source name to the success and error callbacks
			options.success = opts.success.bind(null, source.name);
			options.error = opts.error.bind(null, source.name);
			
			source[action](model, options);
		}
		
		// otherwise only one was specified and we attempt to use that
		else if ((source = enyo.sources[nom]) && source[action]) {
			
			// bind the source name to the success and error callbacks
			options.success = opts.success.bind(null, nom);
			options.error = opts.error.bind(null, nom);
			
			source[action](model, options);
		}
		
		// we could not resolve the requested source
		else {
			msg = 'enyo.Source.execute(): requested source(s) could not be found for ' +
				model.kindName + '.' + action + '()';
			
			logger.warn(msg);
			
			// we need to fail the attempt and let it be handled
			opts.error(nom ? typeof nom == 'string' ? nom : nom.name : 'UNKNOWN', msg);
		}
	} else {
		msg = 'enyo.Source.execute(): no source(s) provided for ' + model.kindName + '.' +
			action + '()';
			
		logger.warn(msg);
		
		// we need to fail the attempt and let it be handled
		opts.error(nom ? typeof nom == 'string' ? nom : nom.name : 'UNKNOWN', msg);
	}
};

Source.sources = sources;
},{"../../enyo":1,"./kind":66,"./logger":67,"./utils":75}],60:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	platform = require('./platform');

module.exports = function (Control) {
	/**
	* {@link enyo.FloatingLayer} is a [control]{@link enyo.Control} that provides a layer for
	* controls that should be displayed above an [application]{@link enyo.Application}. The
	* `floatingLayer` singleton can be set as a control's parent to have the control float
	* above the application, e.g.:
	*
	* ```
	* create: kind.inherit(function (sup) {
	*	return function() {
	*		sup.apply(this, arguments);
	*		this.setParent(enyo.floatingLayer);
	*	}
	* });
	* ```
	*
	* Note: `enyo.FloatingLayer` is not meant to be instantiated by users.
	*
	* @class enyo.FloatingLayer
	* @extends enyo.Control
	* @ui
	* @protected
	*/
	return kind(
		/** @lends enyo.FloatingLayer.prototype */ {

		/**
		* @private
		*/
		kind: Control,

		/**
		* @private
		*/
		classes: 'enyo-fit enyo-clip enyo-untouchable',

		/**
		* @method
		* @private
		*/
		create: kind.inherit(function (sup) {
			return function() {
				sup.apply(this, arguments);
				this.setParent(null);

				if (platform.ie < 11) {
					this.removeClass('enyo-fit');
				}
			};
		}),

		/**
		* Detects when [node]{@glossary Node} is detatched due to `document.body` being stomped.
		*
		* @method
		* @private
		*/
		hasNode: kind.inherit(function (sup) {
			return function() {
				sup.apply(this, arguments);
				if (this.node && !this.node.parentNode) {
					this.teardownRender();
				}
				return this.node;
			};
		}),

		/**
		* @method
		* @private
		*/
		render: kind.inherit(function (sup) {
			return function() {
				this.parentNode = document.body;
				return sup.apply(this, arguments);
			};
		}),

		/**
		* @private
		*/
		generateInnerHtml: function () {
			return '';
		},

		/**
		* @private
		*/
		beforeChildRender: function () {
			if (!this.hasNode()) {
				this.render();
			}
		},

		/**
		* @private
		*/
		teardownChildren: function () {
		}
	});
};
},{"../../enyo":1,"./kind":66,"./platform":71,"./utils":75}],96:[function(require,module,exports){
var
	animation = require('../../../enyo/lib/animation'),
	dom = require('../../../enyo/lib/dom'),
	kind = require('../../../enyo/lib/kind'),
	logger = require('../../../enyo/lib/logger'),
	platform = require('../../../enyo/lib/platform'),
	utils = require('../../../enyo/lib/utils');

/**
* enyo.List was too large for the parser so we have to split it up. For now, we're arbitrarily
* splitting the methods into another file. A more appropriate refactoring is required.
*/

module.exports = /** @lends enyo.List.prototype */ {
	/**
	* @method
	* @private
	*/
	importProps: kind.inherit(function (sup) {
		return function (props) {
			// force touch on desktop when we have reorderable items to work around
			// problems with native scroller
			if (props && props.reorderable) {
				this.touch = true;
			}
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			this.pageSizes = [];
			this.orientV = this.orient == 'v';
			this.vertical = this.orientV ? 'default' : 'hidden';
			sup.apply(this, arguments);
			this.$.generator.orient = this.orient;
			this.getStrategy().translateOptimized = true;
			this.$.port.addRemoveClass('horizontal',!this.orientV);
			this.$.port.addRemoveClass('vertical',this.orientV);
			this.$.page0.addRemoveClass('vertical',this.orientV);
			this.$.page1.addRemoveClass('vertical',this.orientV);
			this.bottomUpChanged();  // Initializes pageBound also
			this.noSelectChanged();
			this.multiSelectChanged();
			this.toggleSelectedChanged();
			// setup generator to default to 'full-list' values
			this.$.generator.setRowOffset(0);
			this.$.generator.setCount(this.count);
		};
	}),

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function () {
			this.createReorderTools();
			sup.apply(this, arguments);
			this.createSwipeableComponents();
		};
	}),

	/**
	* @private
	*/
	createReorderTools: function () {
		this.createComponent({
			name: 'reorderContainer',
			classes: 'enyo-list-reorder-container',
			ondown: 'sendToStrategy',
			ondrag: 'sendToStrategy',
			ondragstart: 'sendToStrategy',
			ondragfinish: 'sendToStrategy',
			onflick: 'sendToStrategy'
		});
	},

	/**
	* Adjusts the parent control so [listTools]{@link enyo.List#listTools} are
	* created inside the strategy. This is necessary for strategies like
	* {@link enyo.TouchScrollStrategy}, which wrap their contents with
	* additional DOM nodes.
	*
	* @see {@link enyo.Scroller.createStrategy}
	* @method
	* @private
	*/
	createStrategy: kind.inherit(function (sup) {
		return function () {
			this.controlParentName = 'strategy';
			sup.apply(this, arguments);
			this.createChrome(this.listTools);
			this.controlParentName = 'client';
			this.discoverControlParent();
		};
	}),

	/**
	* @private
	*/
	createSwipeableComponents: function () {
		for (var i=0;i<this.swipeableComponents.length;i++) {
			this.$.swipeableComponents.createComponent(this.swipeableComponents[i], {owner: this.owner});
		}
	},

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.$.generator.node = this.$.port.hasNode();
			this.$.generator.generated = true;
			this.reset();
		};
	}),

	/**
	* @method
	* @private
	*/
	handleResize: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.refresh();
		};
	}),

	/**
	* @private
	*/
	bottomUpChanged: function () {
		this.$.generator.bottomUp = this.bottomUp;
		this.$.page0.applyStyle(this.pageBound, null);
		this.$.page1.applyStyle(this.pageBound, null);

		if (this.orientV) {
			this.pageBound = this.bottomUp ? 'bottom' : 'top';
		} else {
			if (this.rtl) {
				this.pageBound = this.bottomUp ? 'left' : 'right';
			} else {
				this.pageBound = this.bottomUp ? 'right' : 'left';
			}
		}

		if (!this.orientV && this.bottomUp){
			this.$.page0.applyStyle('left', 'auto');
			this.$.page1.applyStyle('left', 'auto');
		}

		if (this.hasNode()) {
			this.reset();
		}
	},

	/**
	* @private
	*/
	noSelectChanged: function () {
		this.$.generator.setNoSelect(this.noSelect);
	},

	/**
	* @private
	*/
	multiSelectChanged: function () {
		this.$.generator.setMultiSelect(this.multiSelect);
	},

	/**
	* @private
	*/
	toggleSelectedChanged: function () {
		this.$.generator.setToggleSelected(this.toggleSelected);
	},

	/**
	* @private
	*/
	countChanged: function () {
		if (this.hasNode()) {
			this.updateMetrics();
		}
	},

	/**
	* Re-dispatches events from the reorder tools to the scroll strategy.
	*
	* @private
	*/
	sendToStrategy: function (sender, event) {
		this.$.strategy.dispatchEvent('on' + event.type, event, sender);
	},

	/**
	* Calculates page metrics (size, number of pages) and resizes the port.
	*
	* @private
	*/
	updateMetrics: function () {
		this.defaultPageSize = this.rowsPerPage * (this.rowSize || 100);
		this.pageCount = Math.ceil(this.count / this.rowsPerPage);
		this.portSize = 0;
		for (var i=0; i < this.pageCount; i++) {
			this.portSize += this.getPageSize(i);
		}
		this.adjustPortSize();
	},

	/**
	* Handles hold pulse events. Used to delay before running hold logic.
	*
	* @private
	*/
	holdpulse: function (sender, event) {
		// don't activate if we're not supporting reordering or if we've already
		// activated the reorder logic
		if (!this.getReorderable() || this.isReordering()) {
			return;
		}
		// first pulse event that exceeds our minimum hold time activates
		if (event.holdTime >= this.reorderHoldTimeMS) {
			// determine if we should handle the hold event
			if (this.shouldStartReordering(sender, event)) {
				this.startReordering(event);
				return false;
			}
		}
	},

	/**
	* Handles DragStart events.
	*
	* @private
	*/
	dragstart: function (sender, event) {
		// stop dragstart from propagating if we're in reorder mode
		if (this.isReordering()) {
			return true;
		}
		if (this.isSwipeable()) {
			return this.swipeDragStart(sender, event);
		}
	},

	/**
	* Determines whether we should handle the drag event.
	*
	* @private
	*/
	drag: function (sender, event) {
		if (this.shouldDoReorderDrag(event)) {
			event.preventDefault();
			this.reorderDrag(event);
			return true;
		} else if (this.isSwipeable()) {
			event.preventDefault();
			this.swipeDrag(sender, event);
			return true;
		}
	},

	/**
	* Handles DragFinish events.
	*
	* @private
	*/
	dragfinish: function (sender, event) {
		if (this.isReordering()) {
			this.finishReordering(sender, event);
		} else if (this.isSwipeable()) {
			this.swipeDragFinish(sender, event);
		}
	},

	/**
	* Handles up events.
	*
	* @private
	*/
	up: function (sender, event) {
		if (this.isReordering()) {
			this.finishReordering(sender, event);
		}
	},

	/**
	* Calculates the record indices for `pageNumber` and generates the markup
	* for that page.
	*
	* @private
	*/
	generatePage: function (pageNumber, target) {
		this.page = pageNumber;
		var r = this.rowsPerPage * this.page;
		this.$.generator.setRowOffset(r);
		var rpp = Math.min(this.count - r, this.rowsPerPage);
		this.$.generator.setCount(rpp);
		var html = this.$.generator.generateChildHtml();
		target.setContent(html);
		// prevent reordering row from being draw twice
		if (this.getReorderable() && this.draggingRowIndex > -1) {
			this.hideReorderingRow();
		}
		var bounds = target.getBounds();
		var pageSize = this.orientV ? bounds.height : bounds.width;
		// if rowSize is not set, use the height or width from the first generated page
		if (!this.rowSize && pageSize > 0) {
			this.rowSize = Math.floor(pageSize / rpp);
			this.updateMetrics();
		}
		// update known page sizes
		if (!this.fixedSize) {
			var s0 = this.getPageSize(pageNumber);
			if (s0 != pageSize && pageSize > 0) {
				this.pageSizes[pageNumber] = pageSize;
				this.portSize += pageSize - s0;
			}
		}
	},

	/**
	* Maps a row index number to the page number where it would be found.
	*
	* @private
	*/
	pageForRow: function (index) {
		return Math.floor(index / this.rowsPerPage);
	},

	/**
	 * Updates the list pages to show the correct rows for the requested `top` position.
	 *
	 * @param  {Number} top - Position in pixels from the top.
	 * @private
	 */
	update: function (top) {
		var updated = false;
		// get page info for position
		var pi = this.positionToPageInfo(top);
		// zone line position
		var pos = pi.pos + this.scrollerSize/2;
		// leap-frog zone position
		var k = Math.floor(pos/Math.max(pi.size, this.scrollerSize) + 1/2) + pi.no;
		// which page number for page0 (even number pages)?
		var p = (k % 2 === 0) ? k : k-1;
		if (this.p0 != p && this.isPageInRange(p)) {
			this.removedInitialPage = this.removedInitialPage || (this.draggingRowPage == this.p0);
			this.generatePage(p, this.$.page0);
			this.positionPage(p, this.$.page0);
			this.p0 = p;
			updated = true;
			this.p0RowBounds = this.getPageRowSizes(this.$.page0);
		}
		// which page number for page1 (odd number pages)?
		p = (k % 2 === 0) ? Math.max(1, k-1) : k;
		// position data page 1
		if (this.p1 != p && this.isPageInRange(p)) {
			this.removedInitialPage = this.removedInitialPage || (this.draggingRowPage == this.p1);
			this.generatePage(p, this.$.page1);
			this.positionPage(p, this.$.page1);
			this.p1 = p;
			updated = true;
			this.p1RowBounds = this.getPageRowSizes(this.$.page1);
		}
		if (updated) {
			// reset generator back to 'full-list' values
			this.$.generator.setRowOffset(0);
			this.$.generator.setCount(this.count);
			if (!this.fixedSize) {
				this.adjustBottomPage();
				this.adjustPortSize();
			}
		}
	},

	/**
	* Calculates the height and width of each row for a page.
	*
	* @param {enyo.Control} page - Page control.
	* @private
	*/
	getPageRowSizes: function (page) {
		var rows = {};
		var allDivs = page.hasNode().querySelectorAll('div[data-enyo-index]');
		for (var i=0, index, bounds; i < allDivs.length; i++) {
			index = allDivs[i].getAttribute('data-enyo-index');
			if (index !== null) {
				bounds = dom.getBounds(allDivs[i]);
				rows[parseInt(index, 10)] = {height: bounds.height, width: bounds.width};
			}
		}
		return rows;
	},

	/**
	* Updates row bounds when rows are re-rendered.
	*
	* @private
	*/
	updateRowBounds: function (index) {
		if (this.p0RowBounds[index]) {
			this.updateRowBoundsAtIndex(index, this.p0RowBounds, this.$.page0);
		} else if (this.p1RowBounds[index]) {
			this.updateRowBoundsAtIndex(index, this.p1RowBounds, this.$.page1);
		}
	},

	/**
	* @private
	*/
	updateRowBoundsAtIndex: function (index, rows, page) {
		var rowDiv = page.hasNode().querySelector('div[data-enyo-index="' + index + '"]');
		var bounds = dom.getBounds(rowDiv);
		rows[index].height = bounds.height;
		rows[index].width = bounds.width;
	},

	/**
	* Updates the list for the given `position`.
	*
	* @param {Number} position - Position in pixels.
	* @private
	*/
	updateForPosition: function (position) {
		this.update(this.calcPos(position));
	},

	/**
	* Adjusts the position if the list is [bottomUp]{@link enyo.List#bottomUp}.
	*
	* @param {Number} position - Position in pixels.
	* @private
	*/
	calcPos: function (position) {
		return (this.bottomUp ? (this.portSize - this.scrollerSize - position) : position);
	},

	/**
	* Determines which page is on the bottom and positions it appropriately.
	*
	* @private
	*/
	adjustBottomPage: function () {
		var bp = this.p0 >= this.p1 ? this.$.page0 : this.$.page1;
		this.positionPage(bp.pageNo, bp);
	},

	/**
	* Updates the size of the port to be the greater of the size of the scroller or
	* the `portSize`.
	*
	* @private
	*/
	adjustPortSize: function () {
		this.scrollerSize = this.orientV ? this.getBounds().height : this.getBounds().width;
		var s = Math.max(this.scrollerSize, this.portSize);
		this.$.port.applyStyle((this.orientV ? 'height' : 'width'), s + 'px');
		if (!this.orientV) {
			this.$.port.applyStyle('height', this.getBounds().height + 'px');
		}
	},

	/**
	* @private
	*/
	positionPage: function (pageNumber, target) {
		target.pageNo = pageNumber;
		var p = this.pageToPosition(pageNumber);
		target.applyStyle(this.pageBound, p + 'px');
	},

	/**
	* Calculates the position of `page`.
	*
	* @param {Number} page - Page number.
	* @private
	*/
	pageToPosition: function (page) {
		var p = 0;
		while (page > 0) {
			page--;
			p += this.getPageSize(page);
		}
		return p;
	},

	/**
	 * Retrieves the metrics for a page covering `position`.
	 *
	 * @param  {Number} position - Position in pixels.
	 * @return {enyo.List~PageInfo}
	 * @private
	 */
	positionToPageInfo: function (position) {
		var page = -1;
		var p = this.calcPos(position);
		var s = this.defaultPageSize;
		while (p >= 0) {
			page++;
			s = this.getPageSize(page);
			p -= s;
		}
		page = Math.max(page, 0);
		return {
			no: page,
			size: s,
			pos: p + s,
			startRow: (page * this.rowsPerPage),
			endRow: Math.min((page + 1) * this.rowsPerPage - 1, this.count - 1)
		};
	},

	/**
	* Determines if `page` is a valid page number.
	*
	* @param {Number} page - Page number.
	* @private
	*/
	isPageInRange: function (page) {
		return page == Math.max(0, Math.min(this.pageCount-1, page));
	},

	/**
	* Calculates the size of a page. The size is estimated if the page has not
	* yet been rendered.
	*
	* @private
	*/
	getPageSize: function (pageNumber) {
		var size = this.pageSizes[pageNumber];
		// estimate the size based on how many rows are in this page
		if (!size) {
			var firstRow = this.rowsPerPage * pageNumber;
			var numRows = Math.min(this.count - firstRow, this.rowsPerPage);
			size = this.defaultPageSize * (numRows / this.rowsPerPage);
		}
		// can never return size of 0, as that would lead to infinite loops
		return Math.max(1, size);
	},

	/**
	* Resets pages and removes all rendered rows.
	*
	* @private
	*/
	invalidatePages: function () {
		this.p0 = this.p1 = null;
		this.p0RowBounds = {};
		this.p1RowBounds = {};
		// clear the html in our render targets
		this.$.page0.setContent('');
		this.$.page1.setContent('');
	},

	/**
	* Resets page and row sizes.
	*
	* @private
	*/
	invalidateMetrics: function () {
		this.pageSizes = [];
		this.rowSize = 0;
		this.updateMetrics();
	},

	/**
	* When the list is scrolled, ensures that the correct rows are rendered and
	* that the reordering controls are positioned correctly.
	*
	* @see {@link enyo.Scroller.scroll}
	* @method
	* @private
	*/
	scroll: kind.inherit(function (sup) {
		return function (sender, event) {
			var r = sup.apply(this, arguments);
			var pos = this.orientV ? this.getScrollTop() : this.getScrollLeft();
			if (this.lastPos === pos) {
				return r;
			}
			this.lastPos = pos;
			this.update(pos);
			if (this.pinnedReorderMode) {
				this.reorderScroll(sender, event);
			}
			return r;
		};
	}),

	/**
	* Updates the list rows when the scroll top is set explicitly.
	*
	* @see {@link enyo.Scroller.setScrollTop}
	* @method
	* @public
	*/
	setScrollTop: kind.inherit(function (sup) {
		return function (scrollTop) {
			this.update(scrollTop);
			sup.apply(this, arguments);
			this.twiddle();
		};
	}),

	/**
	* @private
	*/
	getScrollPosition: function () {
		return this.calcPos(this[(this.orientV ? 'getScrollTop' : 'getScrollLeft')]());
	},

	/**
	* @private
	*/
	setScrollPosition: function (position) {
		this[(this.orientV ? 'setScrollTop' : 'setScrollLeft')](this.calcPos(position));
	},

	/**
	* Scrolls the list so that the last item is visible.
	*
	* @method
	* @public
	*/
	scrollToBottom: kind.inherit(function (sup) {
		return function () {
			this.update(this.getScrollBounds().maxTop);
			sup.apply(this, arguments);
		};
	}),

	/**
	* Scrolls to the specified row.
	*
	* @param {Number} row - The index of the row to scroll to.
	* @public
	*/
	scrollToRow: function (row) {
		var page = this.pageForRow(row);
		var h = this.pageToPosition(page);
		// update the page
		this.updateForPosition(h);
		// call pageToPosition again and this time should return the right pos since the page info is populated
		h = this.pageToPosition(page);
		this.setScrollPosition(h);
		if (page == this.p0 || page == this.p1) {
			var rowNode = this.$.generator.fetchRowNode(row);
			if (rowNode) {
				// calc row offset
				var offset = (this.orientV ? rowNode.offsetTop : rowNode.offsetLeft);
				if (this.bottomUp) {
					offset = this.getPageSize(page) - (this.orientV ? rowNode.offsetHeight : rowNode.offsetWidth) - offset;
				}
				var p = this.getScrollPosition() + offset;
				this.setScrollPosition(p);
			}
		}
	},

	/**
	* Scrolls to the beginning of the list.
	*
	* @public
	*/
	scrollToStart: function () {
		this[this.bottomUp ? (this.orientV ? 'scrollToBottom' : 'scrollToRight') : 'scrollToTop']();
	},

	/**
	* Scrolls to the end of the list.
	*
	* @public
	*/
	scrollToEnd: function () {
		this[this.bottomUp ? (this.orientV ? 'scrollToTop' : 'scrollToLeft') : (this.orientV ? 'scrollToBottom' : 'scrollToRight')]();
	},

	/**
	* Re-renders the list at the current position.
	*
	* @public
	*/
	refresh: function () {
		this.invalidatePages();
		this.update(this[(this.orientV ? 'getScrollTop' : 'getScrollLeft')]());
		this.stabilize();

		//FIXME: Necessary evil for Android 4.0.4 refresh bug
		if (platform.android === 4) {
			this.twiddle();
		}
	},

	/**
	* Re-renders the list from the beginning.  This is used when changing the
	* data model for the list.  This also clears the selection state.
	*
	* @public
	*/
	reset: function () {
		this.getSelection().clear();
		this.invalidateMetrics();
		this.invalidatePages();
		this.stabilize();
		this.scrollToStart();
	},

	/**
	* Returns the {@link enyo.Selection} component that
	* manages the selection state for this list.
	*
	* @return {enyo.Selection} - The component that manages selection state for this list.
	* @public
	*/
	getSelection: function () {
		return this.$.generator.getSelection();
	},

	/**
	* Sets the selection state for the given row index.
	*
	* Modifying selection will not automatically re-render the row, so call
	* [renderRow()]{@link enyo.List#renderRow} or [refresh()]{@link enyo.List#refresh}
	* to update the view.
	*
	* @param {Number} index - The index of the row whose selection state is to be set.
	* @param {*} [data]     - Data value stored in the selection object.
	* @public
	*/
	select: function (index, data) {
		return this.getSelection().select(index, data);
	},

	/**
	* Clears the selection state for the given row index.
	*
	* Modifying selection will not automatically re-render the row, so call
	* [renderRow()]{@link enyo.List#renderRow} or [refresh()]{@link enyo.List#refresh}
	* to update the view.
	*
	* @param {Number} index - The index of the row whose selection state is to be cleared.
	* @public
	*/
	deselect: function (index) {
		return this.getSelection().deselect(index);
	},

	/**
	* Gets the selection state for the given row index.
	*
	* @param {Number} index - The index of the row whose selection state is
	* to be retrieved.
	* @return {Boolean} `true` if the given row is currently selected; otherwise, `false`.
	* @public
	*/
	isSelected: function (index) {
		return this.$.generator.isSelected(index);
	},

	/**
	* Re-renders the specified row. Call this method after making
	* modifications to a row, to force it to render.
	*
	* @param {Number} index - The index of the row to be re-rendered.
	* @public
    */
    renderRow: function (index) {
		this.$.generator.renderRow(index);
    },

	/**
 	* Handler for `onRenderRow` events. Updates row bounds when rows are re-rendered.
	*
	* @private
	*/
	rowRendered: function (sender, event) {
		this.updateRowBounds(event.rowIndex);
	},

	/**
	* Prepares a row to become interactive.
	*
	* @param {Number} index - The index of the row to be prepared.
	* @public
	*/
	prepareRow: function (index) {
		this.$.generator.prepareRow(index);
	},

	/**
	* Restores the row to being non-interactive.
	*
	* @public
	*/
	lockRow: function () {
		this.$.generator.lockRow();
	},

	/**
	* Performs a set of tasks by running the function `func` on a row (which
	* must be interactive at the time the tasks are performed). Locks the	row
	* when done.
	*
	* @param {Number} index   - The index of the row to be acted upon.
	* @param {function} func  - The function to perform.
	* @param {Object} context - The context to which the function is bound.
	* @public
	*/
	performOnRow: function (index, func, context) {
		this.$.generator.performOnRow(index, func, context);
	},

	/**
	* @private
	*/
	animateFinish: function (sender) {
		this.twiddle();
		return true;
	},
	/**
	* FIXME: Android 4.04 has issues with nested composited elements; for example, a
	* SwipeableItem, can incorrectly generate taps on its content when it has slid off the
	* screen; we address this BUG here by forcing the Scroller to 'twiddle' which corrects the
	* bug by provoking a dom update.
	*
	* @private
	*/
	twiddle: function () {
		var s = this.getStrategy();
		utils.call(s, 'twiddle');
	},

	/**
	* Returns page0 or page1 control depending on pageNumber odd/even status
	*
	* @param {Number} pageNumber  - Index of page.
	* @param {Boolean} checkRange - Whether to force checking `pageNumber` against
	* currently active pages.
	* @return {enyo.Control}      - Page control for `pageNumber`.
	* @private
	*/
	pageForPageNumber: function (pageNumber, checkRange) {
		if (pageNumber % 2 === 0) {
			return (!checkRange || (pageNumber === this.p0)) ? this.$.page0 : null;
		}
		else {
			return (!checkRange || (pageNumber === this.p1)) ? this.$.page1 : null;
		}
		return null;
	},
	/**
		---- Reorder functionality ------------
	*/

	/**
	* Determines whether the hold event should be handled as a reorder hold.
	*
	* @private
	*/
	shouldStartReordering: function (sender, event) {
		if (!this.getReorderable() ||
			event.rowIndex == null ||
			event.rowIndex < 0 ||
			this.pinnedReorderMode ||
			event.index == null ||
			event.index < 0) {
			return false;
		}
		return true;
	},

	/**
	* Processes hold event and prepares for reordering.
	*
	* @fires enyo.List#onSetupReorderComponents
	* @private
	*/
	startReordering: function (event) {
		// disable drag to scroll on strategy
		this.$.strategy.listReordering = true;

		this.buildReorderContainer();
		this.doSetupReorderComponents({index: event.index});
		this.styleReorderContainer(event);

		this.draggingRowIndex = this.placeholderRowIndex = event.rowIndex;
		this.draggingRowPage = this.pageForRow(this.draggingRowIndex);
		this.removeDraggingRowNode = event.dispatchTarget.retainNode(event.target);
		this.removedInitialPage = false;
		this.itemMoved = false;
		this.initialPageNumber = this.currentPageNumber = this.pageForRow(event.rowIndex);
		this.prevScrollTop = this.getScrollTop();

		// fill row being reordered with placeholder
		this.replaceNodeWithPlaceholder(event.rowIndex);
	},

	/**
	* Fills reorder container with draggable reorder components defined by the
	* application.
	*
	* @private
	*/
	buildReorderContainer: function () {
		this.$.reorderContainer.destroyClientControls();
		for (var i=0;i<this.reorderComponents.length;i++) {
			this.$.reorderContainer.createComponent(this.reorderComponents[i], {owner:this.owner});
		}
		this.$.reorderContainer.render();
	},

	/**
	* Prepares floating reorder container.
	*
	* @param {Object} e - Event object.
	* @private
	*/
	styleReorderContainer: function (e) {
		this.setItemPosition(this.$.reorderContainer, e.rowIndex);
		this.setItemBounds(this.$.reorderContainer, e.rowIndex);
		this.$.reorderContainer.setShowing(true);
		if (this.centerReorderContainer) {
			this.centerReorderContainerOnPointer(e);
		}
	},

	/**
	* Copies the innerHTML of `node` into a new component inside of
	* `reorderContainer`.
	*
	* @param {Node} node - The source node.
	* @private
	*/
	appendNodeToReorderContainer: function (node) {
		this.$.reorderContainer.createComponent({allowHtml: true, content: node.innerHTML}).render();
	},

	/**
	* Centers the floating reorder container on the user's pointer.
	*
	* @param {Object} e - Event object.
	* @private
	*/
	centerReorderContainerOnPointer: function (e) {
		var containerPosition = dom.calcNodePosition(this.hasNode());
		var bounds = this.$.reorderContainer.getBounds();
		var x = e.pageX - containerPosition.left - parseInt(bounds.width, 10)/2;
		var y = e.pageY - containerPosition.top + this.getScrollTop() - parseInt(bounds.height, 10)/2;
		if (this.getStrategyKind() != 'ScrollStrategy') {
			x -= this.getScrollLeft();
			y -= this.getScrollTop();
		}
		this.positionReorderContainer(x, y);
	},

	/**
	* Moves the reorder container to the specified `x` and `y` coordinates.
	* Animates and kicks off timer to turn off animation.
	*
	* @param {Number} x - The `left` position.
	* @param {Number} y - The `top` position.
	* @private
	*/
	positionReorderContainer: function (x,y) {
		this.$.reorderContainer.addClass('enyo-animatedTopAndLeft');
		this.$.reorderContainer.addStyles('left:'+x+'px;top:'+y+'px;');
		this.setPositionReorderContainerTimeout();
	},

	/**
	* Sets a timeout to remove animation class from reorder container.
	*
	* @private
	*/
	setPositionReorderContainerTimeout: function () {
		this.clearPositionReorderContainerTimeout();
		this.positionReorderContainerTimeout = setTimeout(this.bindSafely(
			function () {
				this.$.reorderContainer.removeClass('enyo-animatedTopAndLeft');
				this.clearPositionReorderContainerTimeout();
			}), 100);
	},

	/**
	* @private
	*/
	clearPositionReorderContainerTimeout: function () {
		if (this.positionReorderContainerTimeout) {
			clearTimeout(this.positionReorderContainerTimeout);
			this.positionReorderContainerTimeout = null;
		}
	},

	/**
	* Determines whether we should handle the drag event.
	*
	* @private
	*/
	shouldDoReorderDrag: function () {
		if (!this.getReorderable() || this.draggingRowIndex < 0 || this.pinnedReorderMode) {
			return false;
		}
		return true;
	},

	/**
	* Handles the drag event as a reorder drag.
	*
	* @private
	*/
	reorderDrag: function (event) {
		// position reorder node under mouse/pointer
		this.positionReorderNode(event);

		// determine if we need to auto-scroll the list
		this.checkForAutoScroll(event);

		// if the current index the user is dragging over has changed, move the placeholder
		this.updatePlaceholderPosition(event.pageY);
	},

	/**
	* Determines the row index at `pageY` (if it exists) and moves the placeholder
	* to that index.
	*
	* @param {Number} pageY - Position from top in pixels.
	* @private
	*/
	updatePlaceholderPosition: function (pageY) {
		var index = this.getRowIndexFromCoordinate(pageY);
		if (index !== -1) {
			// cursor moved over a new row, so determine direction of movement
			if (index >= this.placeholderRowIndex) {
				this.movePlaceholderToIndex(Math.min(this.count, index + 1));
			}
			else {
				this.movePlaceholderToIndex(index);
			}
		}
	},

	/**
	* Positions the reorder node based on the `dx` and `dy` of the drag event.
	*
	* @private
	*/
	positionReorderNode: function (e) {
		var reorderNodeBounds = this.$.reorderContainer.getBounds();
		var left = reorderNodeBounds.left + e.ddx;
		var top = reorderNodeBounds.top + e.ddy;
		top = (this.getStrategyKind() == 'ScrollStrategy') ? top + (this.getScrollTop() - this.prevScrollTop) : top;
		this.$.reorderContainer.addStyles('top: '+top+'px ; left: '+left+'px');
		this.prevScrollTop = this.getScrollTop();
	},

	/**
	* Checks whether the list should scroll when dragging and, if so, starts the
	* scroll timeout timer. Auto-scrolling happens when the user drags an item
	* within the top/bottom boundary percentage defined in
	* [dragToScrollThreshold]{@link enyo.List#dragToScrollThreshold}.
	*
	* @param {Object} event - Drag event.
	* @private
	*/
	checkForAutoScroll: function (event) {
		var position = dom.calcNodePosition(this.hasNode());
		var bounds = this.getBounds();
		var perc;
		this.autoscrollPageY = event.pageY;
		if (event.pageY - position.top < bounds.height * this.dragToScrollThreshold) {
			perc = 100*(1 - ((event.pageY - position.top) / (bounds.height * this.dragToScrollThreshold)));
			this.scrollDistance = -1*perc;
		} else if (event.pageY - position.top > bounds.height * (1 - this.dragToScrollThreshold)) {
			perc = 100*((event.pageY - position.top - bounds.height*(1 - this.dragToScrollThreshold)) / (bounds.height - (bounds.height * (1 - this.dragToScrollThreshold))));
			this.scrollDistance = 1*perc;
		} else {
			this.scrollDistance = 0;
		}
		// stop scrolling if distance is zero (i.e., user isn't scrolling to the edges of
		// the list); otherwise, start it if not already started
		if (this.scrollDistance === 0) {
			this.stopAutoScrolling();
		} else {
			if (!this.autoScrollTimeout) {
				this.startAutoScrolling();
			}
		}
	},

	/**
	* Stops auto-scrolling.
	*
	* @private
	*/
	stopAutoScrolling: function () {
		if (this.autoScrollTimeout) {
			clearTimeout(this.autoScrollTimeout);
			this.autoScrollTimeout = null;
		}
	},

	/**
	* Starts auto-scrolling.
	*
	* @private
	*/
	startAutoScrolling: function () {
		this.autoScrollTimeout = setInterval(this.bindSafely(this.autoScroll), this.autoScrollTimeoutMS);
	},

	/**
	* Scrolls the list by the distance specified in
	* [scrollDistance]{@link enyo.List#scrollDistance}.
	*
	* @private
	*/
	autoScroll: function () {
		if (this.scrollDistance === 0) {
			this.stopAutoScrolling();
		} else {
			if (!this.autoScrollTimeout) {
				this.startAutoScrolling();
			}
		}
		this.setScrollPosition(this.getScrollPosition() + this.scrollDistance);
		this.positionReorderNode({ddx: 0, ddy: 0});

		// if the current index the user is dragging over has changed, move the placeholder
		this.updatePlaceholderPosition(this.autoscrollPageY);
	},

	/**
	* Moves the placeholder (i.e., the gap between rows) to the row currently
	* under the user's pointer. This provides a visual cue, showing the user
	* where the item being dragged will go if it is dropped.
	*
	* @param {Number} index - The row index.
	*/
	movePlaceholderToIndex: function (index) {
		var node, nodeParent;
		if (index < 0) {
			return;
		}
		else if (index >= this.count) {
			node = null;
			nodeParent = this.pageForPageNumber(this.pageForRow(this.count - 1)).hasNode();
		}
		else {
			node = this.$.generator.fetchRowNode(index);
			nodeParent = node.parentNode;
		}
		// figure next page for placeholder
		var nextPageNumber = this.pageForRow(index);

		// don't add pages beyond the original page count
		if (nextPageNumber >= this.pageCount) {
			nextPageNumber = this.currentPageNumber;
		}

		// move the placeholder to just after our 'index' node
		nodeParent.insertBefore(
			this.placeholderNode,
			node);

		if (this.currentPageNumber !== nextPageNumber) {
			// if moving to different page, recalculate page sizes and reposition pages
			this.updatePageSize(this.currentPageNumber);
			this.updatePageSize(nextPageNumber);
			this.updatePagePositions(nextPageNumber);
		}

		// save updated state
		this.placeholderRowIndex = index;
		this.currentPageNumber = nextPageNumber;

		// remember that we moved an item (to prevent pinning at the wrong time)
		this.itemMoved = true;
	},

	/**
	* Turns off reordering. If the user didn't drag the item being reordered
	* outside of its original position, enters pinned reorder mode.
	*
	* @private
	*/
	finishReordering: function (sender, event) {
		if (!this.isReordering() || this.pinnedReorderMode || this.completeReorderTimeout) {
			return;
		}
		this.stopAutoScrolling();
		// enable drag-scrolling on strategy
		this.$.strategy.listReordering = false;
		// animate reorder container to proper position and then complete
		// reordering actions
		this.moveReorderedContainerToDroppedPosition(event);
		this.completeReorderTimeout = setTimeout(
			this.bindSafely(this.completeFinishReordering, event), 100);

		event.preventDefault();
		return true;
	},

	/**
	* @private
	*/
	moveReorderedContainerToDroppedPosition: function () {
		var offset = this.getRelativeOffset(this.placeholderNode, this.hasNode());
		var top = (this.getStrategyKind() == 'ScrollStrategy') ? offset.top : offset.top - this.getScrollTop();
		var left = offset.left - this.getScrollLeft();
		this.positionReorderContainer(left, top);
	},

	/**
	* After the reordered item has been animated to its position, completes
	* the reordering logic.
	*
	* @private
	*/
	completeFinishReordering: function (event) {
		this.completeReorderTimeout = null;
		// adjust placeholderRowIndex to now be the final resting place
		if (this.placeholderRowIndex > this.draggingRowIndex) {
			this.placeholderRowIndex = Math.max(0, this.placeholderRowIndex - 1);
		}
		// if the user dropped the item in the same location where it was picked up, and they
		// didn't move any other items in the process, pin the item and go into pinned reorder mode
		if (this.draggingRowIndex == this.placeholderRowIndex &&
			this.pinnedReorderComponents.length && !this.pinnedReorderMode && !this.itemMoved) {
			this.beginPinnedReorder(event);
			return;
		}
		this.removeDraggingRowNode();
		this.removePlaceholderNode();
		this.emptyAndHideReorderContainer();
		// clear this early to prevent scroller code from using disappeared placeholder
		this.pinnedReorderMode = false;
		this.reorderRows(event);
		this.draggingRowIndex = this.placeholderRowIndex = -1;
		this.refresh();
	},

	/**
	* Enters pinned reorder mode.
	*
	* @fires enyo.List#onSetupPinnedReorderComponents
	* @private
	*/
	beginPinnedReorder: function (event) {
		this.buildPinnedReorderContainer();
		this.doSetupPinnedReorderComponents(utils.mixin(event, {index: this.draggingRowIndex}));
		this.pinnedReorderMode = true;
		this.initialPinPosition = event.pageY;
	},

	/**
	* Clears contents of reorder container, then hides.
	*
	* @private
	*/
	emptyAndHideReorderContainer: function () {
		this.$.reorderContainer.destroyComponents();
		this.$.reorderContainer.setShowing(false);
	},

	/**
	* Fills reorder container with pinned controls.
	*
	* @private
	*/
	buildPinnedReorderContainer: function () {
		this.$.reorderContainer.destroyClientControls();
		for (var i=0;i<this.pinnedReorderComponents.length;i++) {
			this.$.reorderContainer.createComponent(this.pinnedReorderComponents[i], {owner:this.owner});
		}
		this.$.reorderContainer.render();
	},

	/**
	* Swaps the rows that were reordered, and sends up reorder event.
	*
	* @fires enyo.List#onReorder
	* @private
	*/
	reorderRows: function (event) {
		// send reorder event
		this.doReorder(this.makeReorderEvent(event));
		// update display
		this.positionReorderedNode();
		// fix indices for reordered rows
		this.updateListIndices();
	},

	/**
	* Adds `reorderTo` and `reorderFrom` properties to the reorder event.
	*
	* @private
	*/
	makeReorderEvent: function (event) {
		event.reorderFrom = this.draggingRowIndex;
		event.reorderTo = this.placeholderRowIndex;
		return event;
	},

	/**
	* Moves the node being reordered to its new position and shows it.
	*
	* @private
	*/
	positionReorderedNode: function () {
		// only do this if the page with the initial item is still rendered
		if (!this.removedInitialPage) {
			var insertNode = this.$.generator.fetchRowNode(this.placeholderRowIndex);
			if (insertNode) {
				insertNode.parentNode.insertBefore(this.hiddenNode, insertNode);
				this.showNode(this.hiddenNode);
			}
			this.hiddenNode = null;
			if (this.currentPageNumber != this.initialPageNumber) {
				var mover, movee;
				var currentPage = this.pageForPageNumber(this.currentPageNumber);
				var otherPage = this.pageForPageNumber(this.currentPageNumber + 1);
				// if moved down, move current page's firstChild to the end of previous page
				if (this.initialPageNumber < this.currentPageNumber) {
					mover = currentPage.hasNode().firstChild;
					otherPage.hasNode().appendChild(mover);
				// if moved up, move current page's lastChild before previous page's firstChild
				} else {
					mover = currentPage.hasNode().lastChild;
					movee = otherPage.hasNode().firstChild;
					otherPage.hasNode().insertBefore(mover, movee);
				}
				this.correctPageSizes();
				this.updatePagePositions(this.initialPageNumber);
			}
		}
	},

	/**
	* Updates indices of list items as needed to preserve reordering.
	*
	* @private
	*/
	updateListIndices: function () {
		// don't do update if we've moved further than one page, refresh instead
		if (this.shouldDoRefresh()) {
			this.refresh();
			this.correctPageSizes();
			return;
		}

		var from = Math.min(this.draggingRowIndex, this.placeholderRowIndex);
		var to = Math.max(this.draggingRowIndex, this.placeholderRowIndex);
		var direction = (this.draggingRowIndex - this.placeholderRowIndex > 0) ? 1 : -1;
		var node, i, newIndex, currentIndex;

		if (direction === 1) {
			node = this.$.generator.fetchRowNode(this.draggingRowIndex);
			if (node) {
				node.setAttribute('data-enyo-index', 'reordered');
			}
			for (i=(to-1),newIndex=to;i>=from;i--) {
				node = this.$.generator.fetchRowNode(i);
				if (!node) {
					continue;
				}
				currentIndex = parseInt(node.getAttribute('data-enyo-index'), 10);
				newIndex = currentIndex + 1;
				node.setAttribute('data-enyo-index', newIndex);
			}
			node = this.hasNode().querySelector('[data-enyo-index="reordered"]');
			node.setAttribute('data-enyo-index', this.placeholderRowIndex);

		} else {
			node = this.$.generator.fetchRowNode(this.draggingRowIndex);
			if (node) {
				node.setAttribute('data-enyo-index', this.placeholderRowIndex);
			}
			for (i=(from+1), newIndex=from;i<=to;i++) {
				node = this.$.generator.fetchRowNode(i);
				if (!node) {
					continue;
				}
				currentIndex = parseInt(node.getAttribute('data-enyo-index'), 10);
				newIndex = currentIndex - 1;
				node.setAttribute('data-enyo-index', newIndex);
			}
		}
	},

	/**
	* Determines whether an item was reordered far enough that it warrants a refresh.
	*
	* @private
	*/
	shouldDoRefresh: function () {
		return (Math.abs(this.initialPageNumber - this.currentPageNumber) > 1);
	},

	/**
	* Gets node height, width, top, and left values.
	*
	* @private
	*/
	getNodeStyle: function (index) {
		var node = this.$.generator.fetchRowNode(index);
		if (!node) {
			return;
		}
		var offset = this.getRelativeOffset(node, this.hasNode());
		var dimensions = dom.getBounds(node);
		return {h: dimensions.height, w: dimensions.width, left: offset.left, top: offset.top};
	},

	/**
	* Gets offset relative to a positioned ancestor node.
	*
	* @private
	*/
	getRelativeOffset: function (n, p) {
		var ro = {top: 0, left: 0};
		if (n !== p && n.parentNode) {
			do {
				ro.top += n.offsetTop || 0;
				ro.left += n.offsetLeft || 0;
				n = n.offsetParent;
			} while (n && n !== p);
		}
		return ro;
	},

	/**
	* Hides the DOM node for the row at `index` and inserts the placeholder node before it.
	*
	* @param {Number} index - The index of the row whose DOM node will be hidden.
	* @private
	*/
	replaceNodeWithPlaceholder: function (index) {
		var node = this.$.generator.fetchRowNode(index);
		if (!node) {
			logger.log('No node - ' + index);
			return;
		}
		// create and style placeholder node
		this.placeholderNode = this.createPlaceholderNode(node);
		// hide existing node
		this.hiddenNode = this.hideNode(node);
		// insert placeholder node where original node was
		var currentPage = this.pageForPageNumber(this.currentPageNumber);
		currentPage.hasNode().insertBefore(this.placeholderNode, this.hiddenNode);
	},

	/**
	* Creates and returns a placeholder node with dimensions matching those of
	* the passed-in node.
	*
	* @param {Node} node - Node on which to base the placeholder dimensions.
	* @private
	*/
	createPlaceholderNode: function (node) {
		var placeholderNode = this.$.placeholder.hasNode().cloneNode(true);
		var nodeDimensions = dom.getBounds(node);
		placeholderNode.style.height = nodeDimensions.height + 'px';
		placeholderNode.style.width = nodeDimensions.width + 'px';
		return placeholderNode;
	},

	/**
	* Removes the placeholder node from the DOM.
	*
	* @private
	*/
	removePlaceholderNode: function () {
		this.removeNode(this.placeholderNode);
		this.placeholderNode = null;
	},

	/**
	* Removes the passed-in node from the DOM.
	*
	* @private
	*/
	removeNode: function (node) {
		if (!node || !node.parentNode) {
			return;
		}
		node.parentNode.removeChild(node);
	},

	/**
	* Updates `this.pageSizes` to support the placeholder node's jumping
	* from one page to the next.
	*
	* @param {Number} pageNumber
	* @private
	*/
	updatePageSize: function (pageNumber) {
		if (pageNumber < 0) {
			return;
		}
		var pageControl = this.pageForPageNumber(pageNumber, true);
		if (pageControl) {
			var s0 = this.pageSizes[pageNumber];
			// FIXME: use height/width depending on orientation
			var pageSize = Math.max(1, pageControl.getBounds().height);
			this.pageSizes[pageNumber] = pageSize;
			this.portSize += pageSize - s0;
		}
	},

	/**
	* Repositions [currentPageNumber]{@link enyo.List#currentPageNumber} and
	* `nextPageNumber` pages to support the placeholder node's jumping from one
	* page to the next.
	*
	* @param {Number} nextPageNumber [description]
	* @private
	*/
	updatePagePositions: function (nextPageNumber) {
		this.positionPage(this.currentPageNumber, this.pageForPageNumber(this.currentPageNumber));
		this.positionPage(nextPageNumber, this.pageForPageNumber(nextPageNumber));
	},

	/**
	* Corrects page sizes array after reorder is complete.
	*
	* @private
	*/
	correctPageSizes: function () {
		var initPageNumber = this.initialPageNumber%2;
		this.updatePageSize(this.currentPageNumber, this.$['page'+this.currentPage]);
		if (initPageNumber != this.currentPageNumber) {
			this.updatePageSize(this.initialPageNumber, this.$['page'+initPageNumber]);
		}
	},

	/**
	* Hides a DOM node.
	*
	* @private
	*/
	hideNode: function (node) {
		node.style.display = 'none';
		return node;
	},

	/**
	* Shows a DOM node.
	*
	* @private
	*/
	showNode: function (node) {
		node.style.display = 'block';
		return node;
	},

	/**
	* Called by client code to finalize a pinned mode reordering, e.g., when the "Drop"
	* button is pressed on the pinned placeholder row.
	*
	* @todo Seems incorrect to have an event on the signature for a public API
	* @param {Object} event - A mouse/touch event.
	* @public
	*/
	dropPinnedRow: function (event) {
		// animate reorder container to proper position and then complete reording actions
		this.moveReorderedContainerToDroppedPosition(event);
		this.completeReorderTimeout = setTimeout(
			this.bindSafely(this.completeFinishReordering, event), 100);
		return;
	},

	/**
	* Called by client code to cancel a pinned mode reordering.
	*
	* @todo Seems incorrect to have an event on the signature for a public API
	* @param {Object} event - A mouse/touch event.
	* @public
	*/
	cancelPinnedMode: function (event) {
		// make it look like we're dropping in original location
		this.placeholderRowIndex = this.draggingRowIndex;
		this.dropPinnedRow(event);
	},

	/**
	* Returns the row index that is under the given `y`-position on the page.  If the
	* position is off the end of the list, `this.count` is returned. If the position
	* is before the start of the list, `-1` is returned.
	*
	* @param {Number} y - `y` position in pixels in relation to the page.
	* @return {Number}  - The index of the row at the specified position.
	* @private
	*/
	getRowIndexFromCoordinate: function (y) {
		// FIXME: this code only works with vertical lists
		var cursorPosition = this.getScrollTop() + y - dom.calcNodePosition(this.hasNode()).top;
		// happens if we try to drag past top of list
		if (cursorPosition < 0) {
			return -1;
		}
		var pageInfo = this.positionToPageInfo(cursorPosition);
		var rows = (pageInfo.no == this.p0) ? this.p0RowBounds : this.p1RowBounds;
		// might have only rendered one page, so catch that here
		if (!rows) {
			return this.count;
		}
		var posOnPage = pageInfo.pos;
		var placeholderHeight = this.placeholderNode ? dom.getBounds(this.placeholderNode).height : 0;
		var totalHeight = 0;
		for (var i=pageInfo.startRow; i <= pageInfo.endRow; ++i) {
			// do extra check for row that has placeholder as we'll return -1 here for no match
			if (i === this.placeholderRowIndex) {
				// for placeholder
				totalHeight += placeholderHeight;
				if (totalHeight >= posOnPage) {
					return -1;
				}
			}
			// originally dragged row is hidden, so don't count it
			if (i !== this.draggingRowIndex) {
				totalHeight += rows[i].height;
				if (totalHeight >= posOnPage) {
					return i;
				}
			}
		}
		return i;
	},

	/**
	* Gets the position of a node (identified via index) on the page.
	*
	* @return {Object} The position of the row node.
	* @private
	*/
	getIndexPosition: function (index) {
		return dom.calcNodePosition(this.$.generator.fetchRowNode(index));
	},

	/**
	* Sets the specified control's position to match that of the list row at `index`.
	*
	* @param {enyo.Control} item - The control to reposition.
	* @param {Number} index      - The index of the row whose position is to be matched.
	* @private
	*/
	setItemPosition: function (item, index) {
		var clonedNodeStyle = this.getNodeStyle(index);
		var top = (this.getStrategyKind() == 'ScrollStrategy') ? clonedNodeStyle.top : clonedNodeStyle.top - this.getScrollTop();
		var styleStr = 'top:'+top+'px; left:'+clonedNodeStyle.left+'px;';
		item.addStyles(styleStr);
	},

	/**
	* Sets the specified control's width and height to match those of the list row at `index`.
	*
	* @param {enyo.Control} item - The control to reposition.
	* @param {Number} index      - The index of the row whose width and height are to be matched.
	* @private
	*/
	setItemBounds: function (item, index) {
		var clonedNodeStyle = this.getNodeStyle(index);
		var styleStr = 'width:'+clonedNodeStyle.w+'px; height:'+clonedNodeStyle.h+'px;';
		item.addStyles(styleStr);
	},

	/**
	* When in pinned reorder mode, repositions the pinned placeholder when the
	* user has scrolled far enough.
	*
	* @private
	*/
	reorderScroll: function (sender, e) {
		// if we are using the standard scroll strategy, we have to move the pinned row with the scrolling
		if (this.getStrategyKind() == 'ScrollStrategy') {
			this.$.reorderContainer.addStyles('top:'+(this.initialPinPosition+this.getScrollTop()-this.rowSize)+'px;');
		}
		// y coordinate on screen of the pinned item doesn't change as we scroll things
		this.updatePlaceholderPosition(this.initialPinPosition);
	},

	/**
	* @private
	*/
	hideReorderingRow: function () {
		var hiddenNode = this.hasNode().querySelector('[data-enyo-index="' + this.draggingRowIndex + '"]');
		// hide existing node
		if (hiddenNode) {
			this.hiddenNode = this.hideNode(hiddenNode);
		}
	},

	/**
	* @private
	*/
	isReordering: function () {
		return (this.draggingRowIndex > -1);
	},

	/**
		---- Swipeable functionality ------------
	*/

	/**
	* @private
	*/
	isSwiping: function () {
		// we're swiping when the index is set and we're not in the middle of completing or backing out a swipe
		return (this.swipeIndex != null && !this.swipeComplete && this.swipeDirection != null);
	},

	/**
	* When a drag starts, gets the direction of the drag as well as the index
	* of the item being dragged, and resets any pertinent values. Then kicks
	* off the swipe sequence.
	*
	* @private
	*/
	swipeDragStart: function (sender, event) {
		// if we're not on a row or the swipe is vertical or if we're in the middle of reordering, just say no
		if (event.index == null || event.vertical) {
			return true;
		}

		// if we are waiting to complete a swipe, complete it
		if (this.completeSwipeTimeout) {
			this.completeSwipe(event);
		}

		// reset swipe complete flag
		this.swipeComplete = false;

		if (this.swipeIndex != event.index) {
			this.clearSwipeables();
			this.swipeIndex = event.index;
		}
		this.swipeDirection = event.xDirection;

		// start swipe sequence only if we are not currently showing a persistent item
		if (!this.persistentItemVisible) {
			this.startSwipe(event);
		}

		// reset dragged distance (for dragfinish)
		this.draggedXDistance = 0;
		this.draggedYDistance = 0;

		return true;
	},

	/**
	* When a drag is in progress, updates the position of the swipeable
	* container based on the `ddx` of the event.
	*
	* @private
	*/
	swipeDrag: function (sender, event) {
		// if a persistent swipeableItem is still showing, handle it separately
		if (this.persistentItemVisible) {
			this.dragPersistentItem(event);
			return this.preventDragPropagation;
		}
		// early exit if there's no matching dragStart to set item
		if (!this.isSwiping()) {
			return false;
		}
		// apply new position
		this.dragSwipeableComponents(this.calcNewDragPosition(event.ddx));
		// save dragged distance (for dragfinish)
		this.draggedXDistance = event.dx;
		this.draggedYDistance = event.dy;
		// save last meaningful (non-zero) and new direction (for swipeDragFinish)
		if (event.xDirection != this.lastSwipeDirection && event.xDirection) {
			this.lastSwipeDirection = event.xDirection;
		}
		return true;
	},

	/*
	* When the current drag completes, decides whether to complete the swipe
	* based on how far the user pulled the swipeable container.
	*
	* @private
	*/
	swipeDragFinish: function (sender, event) {
		// if a persistent swipeableItem is still showing, complete drag away or bounce
		if (this.persistentItemVisible) {
			this.dragFinishPersistentItem(event);
		// early exit if there's no matching dragStart to set item
		} else if (!this.isSwiping()) {
			return false;
		// otherwise if user dragged more than 20% of the width, complete the swipe. if not, back out.
		} else {
			var percentageDragged = this.calcPercentageDragged(this.draggedXDistance);
			if ((percentageDragged > this.percentageDraggedThreshold) && (this.lastSwipeDirection === this.swipeDirection)) {
				this.swipe(this.fastSwipeSpeedMS);
			} else {
				this.backOutSwipe(event);
			}
		}

		return this.preventDragPropagation;
	},

	/**
	* Reorder takes precedence over swipes, and not having it turned on or swipeable controls
	* defined also disables this.
	*
	* @private
	*/
	isSwipeable: function () {
		return this.enableSwipe && this.$.swipeableComponents.controls.length !== 0 &&
			!this.isReordering() && !this.pinnedReorderMode;
	},

	/**
	* Positions the swipeable components block at the current row.
	*
	* @param {Number} index      - The row index.
	* @param {Number} xDirection - Value of `xDirection` from drag event (`1` = right,
	* `-1` = left).
	* @private
	*/
	positionSwipeableContainer: function (index, xDirection) {
		var node = this.$.generator.fetchRowNode(index);
		if (!node) {
			return;
		}
		var offset = this.getRelativeOffset(node, this.hasNode());
		var dimensions = dom.getBounds(node);
		var x = (xDirection == 1) ? -1*dimensions.width : dimensions.width;
		this.$.swipeableComponents.addStyles('top: '+offset.top+'px; left: '+x+'px; height: '+dimensions.height+'px; width: '+dimensions.width+'px;');
	},

	/**
	* Calculates new position for the swipeable container based on the user's
	* drag action. Don't allow the container to drag beyond either edge.
	*
	* @param {Number} dx - Amount of change in `x` position.
	* @return {Number}
	* @private
	*/
	calcNewDragPosition: function (dx) {
		var parentBounds = this.$.swipeableComponents.getBounds();
		var xPos = parentBounds.left;
		var dimensions = this.$.swipeableComponents.getBounds();
		var xlimit = (this.swipeDirection == 1) ? 0 : -1*dimensions.width;
		var x = (this.swipeDirection == 1)
			? (xPos + dx > xlimit)
				? xlimit
				: xPos + dx
			: (xPos + dx < xlimit)
				? xlimit
				: xPos + dx;
		return x;
	},

	/**
	* Positions the swipeable components.
	*
	* @param {Number} x - New `left` position.
	* @private
	*/
	dragSwipeableComponents: function (x) {
		this.$.swipeableComponents.applyStyle('left',x+'px');
	},

	/**
	* Begins swiping sequence by positioning the swipeable container and
	* bubbling the `setupSwipeItem` event.
	*
	* @param {Object} e - Event
	* @fires enyo.List#onSetupSwipeItem
	* @private
	*/
	startSwipe: function (e) {
		// modify event index to always have this swipeItem value
		e.index = this.swipeIndex;
		this.positionSwipeableContainer(this.swipeIndex, e.xDirection);
		this.$.swipeableComponents.setShowing(true);
		this.setPersistentItemOrigin(e.xDirection);
		this.doSetupSwipeItem(e);
	},

	/**
	* If a persistent swipeableItem is still showing, drags it away or bounces it.
	*
	* @param {Object} e - Event
	* @private
	*/
	dragPersistentItem: function (e) {
		var xPos = 0;
		var x = (this.persistentItemOrigin == 'right')
			? Math.max(xPos, (xPos + e.dx))
			: Math.min(xPos, (xPos + e.dx));
		this.$.swipeableComponents.applyStyle('left',x+'px');
	},

	/**
	* If a persistent swipeableItem is still showing, completes drag away or bounce.
	*
	* @param {Object} e - Event
	* @private
	*/
	dragFinishPersistentItem: function (e) {
		var completeSwipe = (this.calcPercentageDragged(e.dx) > 0.2);
		var dir = (e.dx > 0) ? 'right' : (e.dx < 0) ? 'left' : null;
		if (this.persistentItemOrigin == dir) {
			if (completeSwipe) {
				this.slideAwayItem();
			} else {
				this.bounceItem(e);
			}
		} else {
			this.bounceItem(e);
		}
	},

	/**
	* @private
	*/
	setPersistentItemOrigin: function (xDirection) {
		this.persistentItemOrigin = xDirection == 1 ? 'left' : 'right';
	},

	/**
	* @private
	*/
	calcPercentageDragged: function (dx) {
		return Math.abs(dx/this.$.swipeableComponents.getBounds().width);
	},

	/**
	* Completes a swipe animation in the specified number of milliseconds.
	*
	* @param {Number} speed - Time in milliseconds.
	* @private
	*/
	swipe: function (speed) {
		this.swipeComplete = true;
		this.animateSwipe(0, speed);
	},

	/**
	* @private
	*/
	backOutSwipe: function () {
		var dimensions = this.$.swipeableComponents.getBounds();
		var x = (this.swipeDirection == 1) ? -1*dimensions.width : dimensions.width;
		this.animateSwipe(x, this.fastSwipeSpeedMS);
		this.swipeDirection = null;
	},

	/**
	* Returns persisted swipeable components to being visible if not dragged back
	* beyond threshold.
	*
	* @private
	*/
	bounceItem: function () {
		var bounds = this.$.swipeableComponents.getBounds();
		if (bounds.left != bounds.width) {
			this.animateSwipe(0, this.normalSwipeSpeedMS);
		}
	},

	/**
	* Animates the swipeable components away starting from their current position.
	*
	* @private
	*/
	slideAwayItem: function () {
		var $item = this.$.swipeableComponents;
		var parentWidth = $item.getBounds().width;
		var xPos = (this.persistentItemOrigin == 'left') ? -1*parentWidth : parentWidth;
		this.animateSwipe(xPos, this.normalSwipeSpeedMS);
		this.persistentItemVisible = false;
		this.setPersistSwipeableItem(false);
	},

	/**
	* Hides the swipeable components.
	*
	* @private
	*/
	clearSwipeables: function () {
		this.$.swipeableComponents.setShowing(false);
		this.persistentItemVisible = false;
		this.setPersistSwipeableItem(false);
	},

	/**
	* Completes swipe and hides active swipeable item.
	*
	* @fires enyo.List#onSwipeComplete
	* @private
	*/
	completeSwipe: function () {
		if (this.completeSwipeTimeout) {
			clearTimeout(this.completeSwipeTimeout);
			this.completeSwipeTimeout = null;
		}
		// if this wasn't a persistent item, hide it upon completion and send swipe complete event
		if (!this.getPersistSwipeableItem()) {
			this.$.swipeableComponents.setShowing(false);
			// if the swipe was completed, update the current row and bubble swipeComplete event
			if (this.swipeComplete) {
				this.doSwipeComplete({index: this.swipeIndex, xDirection: this.swipeDirection});
			}
		} else {
			// persistent item will only be visible if the swipe was completed
			if (this.swipeComplete) {
				this.persistentItemVisible = true;
			}
		}
		this.swipeIndex = null;
		this.swipeDirection = null;
	},

	/**
	* Animates a swipe starting from the current position to the specified new
	* position `(targetX)` over the specified length of time `(totalTimeMS)`.
	*
	* @param {Number} targetX     - The target `left` position.
	* @param {Number} totalTimeMS - Time in milliseconds.
	* @private
	*/
	animateSwipe: function (targetX, totalTimeMS) {
		var t0 = utils.now();
		var $item = this.$.swipeableComponents;
		var origX = parseInt($item.getBounds().left, 10);
		var xDelta = targetX - origX;

		this.stopAnimateSwipe();

		var fn = this.bindSafely(function () {
			var t = utils.now() - t0;
			var percTimeElapsed = t/totalTimeMS;
			var currentX = origX + (xDelta)*Math.min(percTimeElapsed,1);

			// set new left
			$item.applyStyle('left', currentX+'px');

			// schedule next frame
			this.job = animation.requestAnimationFrame(fn);

			// potentially override animation TODO

			// go until we've hit our total time
			if (t/totalTimeMS >= 1) {
				this.stopAnimateSwipe();
				this.completeSwipeTimeout = setTimeout(this.bindSafely(function () {
					this.completeSwipe();
				}), this.completeSwipeDelayMS);
			}
		});

		this.job = animation.requestAnimationFrame(fn);
	},

	/**
	* Cancels the active swipe animation.
	*
	* @private
	*/
	stopAnimateSwipe: function () {
		if (this.job) {
			this.job = animation.cancelRequestAnimationFrame(this.job);
		}
	}
};
},{"../../../enyo/lib/animation":56,"../../../enyo/lib/dom":58,"../../../enyo/lib/kind":66,"../../../enyo/lib/logger":67,"../../../enyo/lib/platform":71,"../../../enyo/lib/utils":75}],9:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	Binding = require('./Binding');

kind.concatenated.push('bindings');

/**
* An internally-used {@glossary mixin} that is added to {@link enyo.Object}
* and its [subkinds]{@glossary subkind}. It includes public and protected API
* methods for working with [bindings]{@link enyo.Binding}.
*
* @mixin enyo.BindingSupport
* @protected
*/
exports = module.exports = {
	
	/**
	* @private
	*/
	name: 'BindingSupport',
	
	/**
	* @private
	*/
	_bindingSupportInitialized: false,
	
	/**
	* Imperatively creates a [binding]{@link enyo.Binding}. Merges a variable
	* number of [hashes]{@glossary Object} and instantiates a binding that
	* will have its [owner]{@link enyo.Binding#owner} property set to the callee
	* (the current {@link enyo.Object}). Bindings created in this way will be
	* [destroyed]{@link enyo.Binding#destroy} when their `owner` is
	* [destroyed]{@link enyo.Object#destroy}.
	*
	* @param {...Object} props A variable number of [hashes]{@glossary Object} that will
	*	be merged into the properties applied to the {@link enyo.Binding} instance.
	* @returns {this} The callee for chaining.
	* @public
	*/
	binding: function () {
		var args = utils.toArray(arguments)
			, props = utils.mixin(args)
			, bindings = this.bindings || (this.bindings = [])
			, Ctor, bnd;
			
		props.owner = props.owner || this;
		Ctor = props.kind = props.kind || this.defaultBindingKind || Binding.defaultBindingKind;
		
		if (this._bindingSupportInitialized) {
			utils.isString(Ctor) && (Ctor = props.kind = kind.constructorForKind(Ctor));
			bnd = new Ctor(props);
			bindings.push(bnd);
			return bnd;
		} else bindings.push(props);
		
		return this;
	},
	
	/**
	* Removes and [destroys]{@link enyo.Binding#destroy} all of, or a subset of,
	* the [bindings]{@link enyo.Binding} belonging to the callee.
	*
	* @param {enyo.Binding[]} [subset] - The optional [array]{@glossary Array} of
	*	[bindings]{@link enyo.Binding} to remove.
	* @returns {this} The callee for chaining.
	* @public
	*/
	clearBindings: function (subset) {
		var bindings = subset || (this.bindings && this.bindings.slice());
		bindings.forEach(function (bnd) {
			bnd.destroy();
		});
		
		return this;
	},
	
	/**
	* Removes a single {@link enyo.Binding} from the callee. (This does not
	* [destroy]{@link enyo.Binding#destroy} the binding.) Also removes the
	* [owner]{@link enyo.Binding#owner} reference if it is the callee.
	*
	* It should be noted that when a binding is destroyed, it is automatically
	* removed from its owner.
	*
	* @param {enyo.Binding} binding - The {@link enyo.Binding} instance to remove.
	* @returns {this} The callee for chaining.
	* @public
	*/
	removeBinding: function (binding) {
		utils.remove(binding, this.bindings);
		
		if (binding.owner === this) binding.owner = null;
		
		return this;
	},
	
	/**
	* @private
	*/
	constructed: kind.inherit(function (sup) {
		return function () {
			var bindings = this.bindings;
			this._bindingSupportInitialized = true;
			bindings && (this.bindings = []) && bindings.forEach(function (def) {
				this.binding(def);
			}, this);
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.bindings && this.bindings.length && this.clearBindings();
			this.bindings = null;
		};
	})
};

/**
	Hijack the original so we can add additional default behavior.
*/
var sup = kind.concatHandler
	, flags = {ignore: true};

/**
* @private
*/
kind.concatHandler = function (ctor, props, instance) {
	var proto = ctor.prototype || ctor
		, kind = props && (props.defaultBindingKind || Binding.defaultBindingKind)
		, defaults = props && props.bindingDefaults;
	
	sup.call(this, ctor, props, instance);
	if (props.bindings) {
		props.bindings.forEach(function (bnd) {
			defaults && utils.mixin(bnd, defaults, flags);
			bnd.kind || (bnd.kind = kind); 
		});
		
		proto.bindings = proto.bindings? proto.bindings.concat(props.bindings): props.bindings;
		delete props.bindings;
	}
};
},{"../../enyo":1,"./Binding":8,"./kind":66,"./utils":75}],39:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	Binding = require('./Binding');

/**
* The {@link enyo.RepeaterChildSupport} [mixin]{@glossary mixin} contains methods and
* properties that are automatically applied to all children of {@link enyo.DataRepeater}
* to assist in selection support. (See {@link enyo.DataRepeater} for details on how to
* use selection support.) This mixin also [adds]{@link enyo.Repeater#decorateEvent} the
* `model`, `child` ([control]{@link enyo.Control} instance), and `index` properties to
* all [events]{@glossary event} emitted from the repeater's children.
*
* @mixin enyo.RepeaterChildSupport
* @public
*/
module.exports = {

	/*
	* @private
	*/
	name: 'RepeaterChildSupport',

	/**
	* Indicates whether the current child is selected in the [repeater]{@link enyo.DataRepeater}.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	selected: false,

	/**
	* Setting cachePoint: true ensures that events from the repeater child's subtree will
	* always bubble up through the child, allowing the events to be decorated with repeater-
	* related metadata and references.
	*
	* @type {Boolean}
	* @default true
	* @private
	*/
	cachePoint: true,
	
	/*
	* @method
	* @private
	*/
	selectedChanged: kind.inherit(function (sup) {
		return function () {
			if (this.repeater.selection) {
				this.addRemoveClass(this.selectedClass || 'selected', this.selected);
				// for efficiency purposes, we now directly call this method as opposed to
				// forcing a synchronous event dispatch
				var idx = this.repeater.collection.indexOf(this.model);
				if (this.selected && !this.repeater.isSelected(this.model)) {
					this.repeater.select(idx);
				} else if (!this.selected && this.repeater.isSelected(this.model)) {
					this.repeater.deselect(idx);
				}
			}
			sup.apply(this, arguments);
		};
	}),

	/*
	* @method
	* @private
	*/
	decorateEvent: kind.inherit(function (sup) {
		return function (sender, event) {
			event.model = this.model;
			event.child = this;
			event.index = this.repeater.collection.indexOf(this.model);
			sup.apply(this, arguments);
		};
	}),

	/*
	* @private
	*/
	_selectionHandler: function () {
		if (this.repeater.selection && !this.get('disabled')) {
			if (this.repeater.selectionType != 'group' || !this.selected) {
				this.set('selected', !this.selected);
			}
		}
	},
	/**
	* Deliberately used to supersede the default method and set 
	* [owner]{@link enyo.Component#owner} to this [control]{@link enyo.Control} so that there 
	* are no name collisions in the instance [owner]{@link enyo.Component#owner}, and also so 
	* that [bindings]{@link enyo.Binding} will correctly map to names.
	*
	* @method
	* @private
	*/
	createClientComponents: kind.inherit(function () {
		return function (components) {
			this.createComponents(components, {owner: this});
		};
	}),
	/**
	* Used so that we don't stomp on any built-in handlers for the `ontap`
	* {@glossary event}.
	*
	* @method
	* @private
	*/
	dispatchEvent: kind.inherit(function (sup) {
		return function (name, event, sender) {
			var owner;
			
			// if the event is coming from a child of the repeater-child (this...) and has a
			// delegate assigned to it there is a distinct possibility it is supposed to be
			// targeting the instanceOwner of repeater-child not the repeater-child itself
			// so we have to check this case and treat it as expected - if there is a handler
			// and it returns true then we must skip the normal flow
			if (event.originator !== this && event.delegate && event.delegate.owner === this) {
				if (typeof this[name] != 'function') {
					// ok we don't have the handler here let's see if our owner does
					owner = this.getInstanceOwner();
					if (owner && owner !== this) {
						if (typeof owner[name] == 'function') {
							// alright it appears that we're supposed to forward this to the
							// next owner instead
							return owner.dispatch(name, event, sender);
						}
					}
				}
			}
			
			if (!event._fromRepeaterChild) {
				if (!!~utils.indexOf(name, this.repeater.selectionEvents)) {
					this._selectionHandler();
					event._fromRepeaterChild = true;
				}
			}
			return sup.apply(this, arguments);
		};
	}),

	/*
	* @method
	* @private
	*/
	constructed: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			var r = this.repeater,
				s = r.selectionProperty;
			// this property will only be set if the instance of the repeater needs
			// to track the selected state from the view and model and keep them in sync
			if (s) {
				var bnd = this.binding({
					from: 'model.' + s,
					to: 'selected',
					oneWay: false/*,
					kind: enyo.BooleanBinding*/
				});
				this._selectionBindingId = bnd.euid;
			}
		};
	}),

	/*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			if (this._selectionBindingId) {
				var b$ = Binding.find(this._selectionBindingId);
				if (b$) {
					b$.destroy();
				}
			}
			sup.apply(this, arguments);
		};
	}),

	/*
	* @private
	*/
	_selectionBindingId: null
};
},{"../../enyo":1,"./Binding":8,"./kind":66,"./utils":75}],78:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	utils = require('../../../enyo/lib/utils'),
	platform = require('../../../enyo/lib/platform');

var
	Layout = require('../../../enyo/lib/Layout'),
	Dom = require('../../../enyo/lib/dom');

/**
* {@link enyo.Arranger} is an {@link enyo.Layout} that considers one of the
* controls it lays out as active. The other controls are placed relative to
* the active control as makes sense for the layout.
*
* `enyo.Arranger` supports dynamic layouts, meaning it's possible to transition
* between an arranger's layouts	via animation. Typically, arrangers should lay out
* controls using CSS transforms, since these are optimized for animation. To
* support this, the controls in an arranger are absolutely positioned, and
* the Arranger kind has an [accelerated]{@link enyo.Arranger#accelerated} property,
* which marks controls for CSS compositing. The default setting of `'auto'` ensures
* that this will occur if enabled by the platform.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.Arranger
* @extends enyo.Layout
* @public
*/
var Arranger = module.exports = kind(
	/** @lends  enyo.Arranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Arranger',

	/**
	* @private
	*/
	kind: Layout,

	/**
	* @private
	*/
	layoutClass: 'enyo-arranger',

	/**
	* Flag indicating whether the Arranger should lay out controls using CSS
	* compositing. The default setting `('auto')` will mark controls for compositing
	* if the platform supports it.
	*
	* @type {String|Boolean}
	* @default 'auto'
	* @protected
	*/
	accelerated: 'auto',

	/**
	* A property of the drag event, used to calculate the amount that a drag will
	* move the layout.
	*
	* @type {String}
	* @default 'ddx'
	* @private
	*/
	dragProp: 'ddx',

	/**
	* A property of the drag event, used to calculate the direction of the drag.
	*
	* @type {String}
	* @default 'xDirection'
	* @private
	*/
	dragDirectionProp: 'xDirection',

	/**
	* A property of the drag event, used to calculate whether a drag should occur.
	*
	* @type {String}
	* @default 'horizontal'
	* @private
	*/
	canDragProp: 'horizontal',

	/**
	* If set to `true`, transitions between non-adjacent arrangements will go
	* through the intermediate arrangements. This is useful when direct
	* transitions between arrangements would be visually jarring.
	*
	* @type {Boolean}
	* @default false
	* @protected
	*/
	incrementalPoints: false,

	/**
	* Called when removing an arranger (e.g., when switching a Panels control to a
	* different `arrangerKind`). Subkinds should implement this function to reset
	* whatever properties they've changed on child controls. Note that you **must**
	* call the superkind implementation in your subkind's `destroy()` function.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				c._arranger = null;
			}
			sup.apply(this, arguments);
		};
	}),

	/**
	* Arranges the given array of `controls` in the layout specified by `index`. When
	* implementing this method, rather than applying styling directly to controls, call
	* [arrangeControl()]{@link enyo.Arranger#arrangeControl} and pass in an arrangement
	* object with styling settings. The styles will then be applied via
	* [flowControl()]{@link enyo.Arranger#flowControl}.
	*
	* @param {enyo.Control[]} controls
	* @param {Number} index
	* @virtual
	* @protected
	*/
	arrange: function (controls, index) {
	},

	/**
	* Sizes the controls in the layout. This method is called only at reflow time.
	* Note that the sizing operation has been separated from the layout done in
	* [arrange()]{@link enyo.Arranger#arrange} because it is expensive and not suitable
	* for dynamic layout.
	*
	* @virtual
	* @protected
	*/
	size: function () {
	},

	/**
	* Called when a layout transition begins. Implement this method to perform
	* tasks that should only occur when a transition starts; for example, some
	* controls might be shown or hidden. In addition, the `transitionPoints`
	* array may be set on the container to dictate the named arrangements
	* between which the transition occurs.
	*
	* @protected
	*/
	start: function () {
		var f = this.container.fromIndex, t = this.container.toIndex;
		var p$ = this.container.transitionPoints = [f];
		// optionally add a transition point for each index between from and to.
		if (this.incrementalPoints) {
			var d = Math.abs(t - f) - 2;
			var i = f;
			while (d >= 0) {
				i = i + (t < f ? -1 : 1);
				p$.push(i);
				d--;
			}
		}
		p$.push(this.container.toIndex);
	},

	/**
	* Called when a layout transition completes. Implement this method to
	* perform tasks that should only occur when a transition ends; for
	* example, some controls might be shown or hidden.
	*
	* @virtual
	* @protected
	*/
	finish: function () {
	},

	/**
	* Called when dragging the layout, this method returns the difference in
	* pixels between the arrangement `a0` for layout setting `i0`	and
	* arrangement `a1` for layout setting `i1`. This data is used to calculate
	* the percentage that a drag should move the layout between two active states.
	*
	* @param {Number} i0 - The initial layout setting.
	* @param {Object} a0 - The initial arrangement.
	* @param {Number} i1 - The target layout setting.
	* @param {Object} a1 - The target arrangement.
	* @virtual
	* @protected
	*/
	calcArrangementDifference: function (i0, a0, i1, a1) {
	},

	/**
	* @private
	*/
	canDragEvent: function (event) {
		return event[this.canDragProp];
	},

	/**
	* @private
	*/
	calcDragDirection: function (event) {
		return event[this.dragDirectionProp];
	},

	/**
	* @private
	*/
	calcDrag: function (event) {
		return event[this.dragProp];
	},

	/**
	* @private
	*/
	drag: function (dp, an, a, bn, b) {
		var f = this.measureArrangementDelta(-dp, an, a, bn, b);
		return f;
	},

	/**
	* @private
	*/
	measureArrangementDelta: function (x, i0, a0, i1, a1) {
		var d = this.calcArrangementDifference(i0, a0, i1, a1);
		var s = d ? x / Math.abs(d) : 0;
		s = s * (this.container.fromIndex > this.container.toIndex ? -1 : 1);
		return s;
	},

	/**
	* Arranges the panels, with the panel at `index` being designated as active.
	*
	* @param  {Number} index - The index of the active panel.
	* @private
	*/
	_arrange: function (index) {
		// guard against being called before we've been rendered
		if (!this.containerBounds) {
			this.reflow();
		}
		var c$ = this.getOrderedControls(index);
		this.arrange(c$, index);
	},

	/**
	* Arranges `control` according to the specified `arrangement`.
	*
	* Note that this method doesn't actually modify `control` but rather sets the
	* arrangement on a private member of the control to be retrieved by
	* {@link enyo.Panels}.
	*
	* @param  {enyo.Control} control
	* @param  {Object} arrangement
	* @private
	*/
	arrangeControl: function (control, arrangement) {
		control._arranger = utils.mixin(control._arranger || {}, arrangement);
	},

	/**
	* Called before HTML is rendered. Applies CSS to panels to ensure GPU acceleration if
	* [accelerated]{@link enyo.Arranger#accelerated} is `true`.
	*
	* @private
	*/
	flow: function () {
		this.c$ = [].concat(this.container.getPanels());
		this.controlsIndex = 0;
		for (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {
			Dom.accelerate(c, !c.preventAccelerate && this.accelerated);
			if (platform.safari) {
				// On Safari-desktop, sometimes having the panel's direct child set to accelerate isn't sufficient
				// this is most often the case with Lists contained inside another control, inside a Panels
				var grands=c.children;
				for (var j=0, kid; (kid=grands[j]); j++) {
					Dom.accelerate(kid, this.accelerated);
				}
			}
		}
	},

	/**
	* Called during "rendered" phase to [size]{@link enyo.Arranger#size} the controls.
	*
	* @private
	*/
	reflow: function () {
		var cn = this.container.hasNode();
		this.containerBounds = cn ? {width: cn.clientWidth, height: cn.clientHeight} : {};
		this.size();
	},

	/**
	* If the {@link enyo.Panels} has an arrangement, flows each control according to that
	* arrangement.
	*
	* @private
	*/
	flowArrangement: function () {
		var a = this.container.arrangement;
		if (a) {
			for (var i=0, c$=this.container.getPanels(), c; (c=c$[i]) && (a[i]); i++) {
				this.flowControl(c, a[i]);
			}
		}
	},
	/**
	* Lays out the given `control` according to the settings stored in the
	* `arrangement` object. By default, `flowControl()` will apply settings for
	* `left`, `top`, and `opacity`. This method should only be implemented to apply
	* other settings made via [arrangeControl()]{@link enyo.Arranger#arrangeControl}.
	*
	* @param {enyo.Control} control - The control to be laid out.
	* @param {Object} arrangement - An object whose members specify the layout settings.
	* @protected
	*/
	flowControl: function (control, arrangement) {
		Arranger.positionControl(control, arrangement);
		var o = arrangement.opacity;
		if (o != null) {
			Arranger.opacifyControl(control, o);
		}
	},

	/**
	* Gets an array of controls arranged in state order.
	* note: optimization, dial around a single array.
	*
	* @param  {Number} index     - The index of the active panel.
	* @return {enyo.Control[]}   - Ordered array of controls.
	* @private
	*/
	getOrderedControls: function (index) {
		var whole = Math.floor(index);
		var a = whole - this.controlsIndex;
		var sign = a > 0;
		var c$ = this.c$ || [];
		for (var i=0; i<Math.abs(a); i++) {
			if (sign) {
				c$.push(c$.shift());
			} else {
				c$.unshift(c$.pop());
			}
		}
		this.controlsIndex = whole;
		return c$;
	}
});

/**
* Positions a control via transform--`translateX/translateY` if supported,
* falling back to `left/top` if not.
*
* @lends enyo.Arranger
* @param  {enyo.Control} control - The control to position.
* @param  {Object} bounds        - The new bounds for `control`.
* @param  {String} unit          - The unit for `bounds` members.
* @public
*/
Arranger.positionControl = function (control, bounds, unit) {
	unit = unit || 'px';
	if (!this.updating) {
		// IE10 uses setBounds because of control hit caching problems seem in some apps
		if (Dom.canTransform() && !control.preventTransform && !platform.android && platform.ie !== 10) {
			var l = bounds.left, t = bounds.top;
			l = utils.isString(l) ? l : l && (l + unit);
			t = utils.isString(t) ? t : t && (t + unit);
			Dom.transform(control, {translateX: l || null, translateY: t || null});
		} else {
			// If a previously positioned control has subsequently been marked with
			// preventTransform, we need to clear out any old translation values.
			if (Dom.canTransform() && control.preventTransform) {
				Dom.transform(control, {translateX: null, translateY: null});
			}
			control.setBounds(bounds, unit);
		}
	}
},

/**
* Sets the opacity value for a given control.
*
* @lends enyo.Arranger
* @param  {enyo.Control} inControl - The control whose opacity is to be set.
* @param  {Number} inOpacity - The new opacity value for the control.
* @public
*/
Arranger.opacifyControl = function (inControl, inOpacity) {
	var o = inOpacity;
	// FIXME: very high/low settings of opacity can cause a control to
	// blink so cap this here.
	o = o > 0.99 ? 1 : (o < 0.01 ? 0 : o);
	// note: we only care about ie8
	if (platform.ie < 9) {
		inControl.applyStyle('filter', 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + (o * 100) + ')');
	} else {
		inControl.applyStyle('opacity', o);
	}
}
},{"../../../enyo/lib/Layout":26,"../../../enyo/lib/dom":58,"../../../enyo/lib/kind":66,"../../../enyo/lib/platform":71,"../../../enyo/lib/utils":75}],83:[function(require,module,exports){
var
    kind = require('../../../enyo/lib/kind'),
    Layout = require('../../../enyo/lib/Layout');

/**
* {@link enyo.ContextualLayout} provides the base positioning logic for a contextual
* layout strategy. This layout strategy is intended for use with a popup in a
* decorator/activator scenario, in which the popup is positioned relative to
* the activator, e.g.:
*
* ```
* {kind: 'onyx.ContextualPopupDecorator', components: [
*   {content: 'Show Popup'},
*   {kind: 'onyx.ContextualPopup',
*       title: 'Sample Popup',
*       actionButtons: [
*           {content: 'Button 1', classes: 'onyx-button-warning'},
*           {content: 'Button 2'}
*       ],
*       components: [
*           {content: 'Sample component in popup'}
*       ]
*   }
* ]}
* ```
*
* The decorator contains the popup and activator, with the activator being the
* first child component (i.e., the "Show Popup" button). The contextual layout
* strategy is applied because, in the definition of `onyx.ContextualPopup`,
* its `layoutKind` property is set to `enyo.ContextualLayout`.
*
* Note that a popup using ContextualLayout as its `layoutKind` is expected to
* declare several specific properties:
*
* - `vertFlushMargin` - The vertical flush layout margin, i.e., how close the
* popup's edge may come to the vertical screen edge (in pixels) before
* being laid out "flush" style.
* - `horizFlushMargin` - The horizontal flush layout margin, i.e., how close
* the popup's edge may come to the horizontal screen edge (in pixels)
* before being laid out "flush" style.
* - `widePopup` - A popup wider than this value (in pixels) is considered wide
* for layout calculation purposes.
* - `longPopup` - A popup longer than this value (in pixels) is considered long
* for layout calculation purposes.
* - `horizBuffer` - Horizontal flush popups are not allowed within this buffer
* area (in pixels) on the left or right screen edge.
* - `activatorOffset` - The popup activator's offset on the page (in pixels);
* this should be calculated whenever the popup is to be shown.
*
* @typedef {Object} enyo.ContextualLayout
*
* @class enyo.ContextualLayout
* @extends enyo.Layout
* @public
*/

module.exports = kind(
    /** @lends  enyo.ContextualLayout.prototype */ {

    /**
    * @private
    */
    name: 'enyo.ContextualLayout',

    /**
	* @private
	*/
    kind: Layout,

    /**
    * Adjusts the popup's position, as well as the nub location and direction.
    *
    * @public
    */
    adjustPosition: function () {
        if (this.container.showing && this.container.hasNode()) {
            /****ContextualPopup positioning rules:
                1. Activator Location:
                    a. If activator is located in a corner then position using a flush style.
                        i.  Attempt vertical first.
                        ii. Horizontal if vertical doesn't fit.
                    b. If not in a corner then check if the activator is located in one of the 4 "edges" of the view & position the
                        following way if so:
                        i.   Activator is in top edge, position popup below it.
                        ii.  Activator is in bottom edge, position popup above it.
                        iii. Activator is in left edge, position popup to the right of it.
                        iv.  Activator is in right edge, position popup to the left of it.

                2. Screen Size - the pop-up should generally extend in the direction where theres room for it.
                    Note: no specific logic below for this rule since it is built into the positioning functions, ie we attempt to never
                    position a popup where there isn't enough room for it.

                3. Popup Size:
                    i.  If popup content is wide, use top or bottom positioning.
                    ii. If popup content is long, use horizontal positioning.

                4. Favor top or bottom:
                    If all the above rules have been followed and location can still vary then favor top or bottom positioning.

                5. If top or bottom will work, favor bottom.
                    Note: no specific logic below for this rule since it is built into the vertical position functions, ie we attempt to
                    use a bottom position for the popup as much possible. Additionally within the vetical position function we center the
                    popup if the activator is at the vertical center of the view.
            ****/
            this.resetPositioning();
            var innerWidth = this.getViewWidth();
            var innerHeight = this.getViewHeight();

            //These are the view "flush boundaries"
            var topFlushPt = this.container.vertFlushMargin;
            var bottomFlushPt = innerHeight - this.container.vertFlushMargin;
            var leftFlushPt = this.container.horizFlushMargin;
            var rightFlushPt = innerWidth - this.container.horizFlushMargin;

            //Rule 1 - Activator Location based positioning
            //if the activator is in the top or bottom edges of the view, check if the popup needs flush positioning
            if ((this.offset.top + this.offset.height) < topFlushPt || this.offset.top > bottomFlushPt) {
                //check/try vertical flush positioning	(rule 1.a.i)
                if (this.applyVerticalFlushPositioning(leftFlushPt, rightFlushPt)) {
                    return;
                }

                //if vertical doesn't fit then check/try horizontal flush (rule 1.a.ii)
                if (this.applyHorizontalFlushPositioning(leftFlushPt, rightFlushPt)) {
                    return;
                }

                //if flush positioning didn't work then try just positioning vertically (rule 1.b.i & rule 1.b.ii)
                if (this.applyVerticalPositioning()){
                    return;
                }
            //otherwise check if the activator is in the left or right edges of the view & if so try horizontal positioning
            } else if ((this.offset.left + this.offset.width) < leftFlushPt || this.offset.left > rightFlushPt) {
                //if flush positioning didn't work then try just positioning horizontally (rule 1.b.iii & rule 1.b.iv)
                if (this.applyHorizontalPositioning()){
                    return;
                }
            }

            //Rule 2 - no specific logic below for this rule since it is inheritent to the positioning functions, ie we attempt to never
            //position a popup where there isn't enough room for it.

            //Rule 3 - Popup Size based positioning
            var clientRect = this.getBoundingRect(this.container.node);

            //if the popup is wide then use vertical positioning
            if (clientRect.width > this.container.widePopup) {
                if (this.applyVerticalPositioning()){
                    return;
                }
            }
            //if the popup is long then use horizontal positioning
            else if (clientRect.height > this.container.longPopup) {
                if (this.applyHorizontalPositioning()){
                    return;
                }
            }

            //Rule 4 - Favor top or bottom positioning
            if (this.applyVerticalPositioning()) {
                return;
            }
            //but if thats not possible try horizontal
            else if (this.applyHorizontalPositioning()){
                return;
            }

            //Rule 5 - no specific logic below for this rule since it is built into the vertical position functions, ie we attempt to
            //         use a bottom position for the popup as much possible.
        }
    },
    //

    /**
    * Determines whether the popup will fit onscreen if moved below or above the activator.
    *
    * @return {Boolean} `true` if popup will fit onscreen; otherwise, `false`.
    * @public
    */
    initVerticalPositioning: function () {
        this.resetPositioning();
        this.container.addClass('vertical');

        var clientRect = this.getBoundingRect(this.container.node);
        var innerHeight = this.getViewHeight();

        if (this.container.floating){
            if (this.offset.top < (innerHeight / 2)) {
                this.applyPosition({top: this.offset.top + this.offset.height, bottom: 'auto'});
                this.container.addClass('below');
            } else {
                this.applyPosition({top: this.offset.top - clientRect.height, bottom: 'auto'});
                this.container.addClass('above');
            }
        } else {
            //if the popup's bottom goes off the screen then put it on the top of the invoking control
            if ((clientRect.top + clientRect.height > innerHeight) && ((innerHeight - clientRect.bottom) < (clientRect.top - clientRect.height))){
                this.container.addClass('above');
            } else {
                this.container.addClass('below');
            }
        }

        //if moving the popup above or below the activator puts it past the edge of the screen then vertical doesn't work
        clientRect = this.getBoundingRect(this.container.node);
        if ((clientRect.top + clientRect.height) > innerHeight || clientRect.top < 0){
            return false;
        }

        return true;
    },

    /**
    * Moves the popup below or above the activating control.
    *
    * @return {Boolean} `false` if popup was not moved because it would not fit onscreen
    * in the new position; otherwise, `true`.
    * @public
    */
    applyVerticalPositioning: function () {
        //if we can't fit the popup above or below the activator then forget vertical positioning
        if (!this.initVerticalPositioning()) {
            return false;
        }

        var clientRect = this.getBoundingRect(this.container.node);
        var innerWidth = this.getViewWidth();

        if (this.container.floating){
            //Get the left edge delta to horizontally center the popup
            var centeredLeft = this.offset.left + this.offset.width/2 - clientRect.width/2;
            if (centeredLeft + clientRect.width > innerWidth) {//popup goes off right edge of the screen if centered
                this.applyPosition({left: this.offset.left + this.offset.width - clientRect.width});
                this.container.addClass('left');
            } else if (centeredLeft < 0) {//popup goes off left edge of the screen if centered
                this.applyPosition({left:this.offset.left});
                this.container.addClass('right');
            } else {//center the popup
                this.applyPosition({left: centeredLeft});
            }

        } else {
            //Get the left edge delta to horizontally center the popup
            var centeredLeftDelta = this.offset.left + this.offset.width/2 - clientRect.left - clientRect.width/2;
            if (clientRect.right + centeredLeftDelta > innerWidth) {//popup goes off right edge of the screen if centered
                this.applyPosition({left: this.offset.left + this.offset.width - clientRect.right});
                this.container.addRemoveClass('left', true);
            } else if (clientRect.left + centeredLeftDelta < 0) {//popup goes off left edge of the screen if centered
                this.container.addRemoveClass('right', true);
            } else {//center the popup
                this.applyPosition({left: centeredLeftDelta});
            }
        }

        return true;
    },

    /**
    * Positions the popup vertically flush with the activating control.
    *
    * @param {Number} leftFlushPt - Left side cutoff.
    * @param {Number} rightFlushPt - Right side cutoff.
    * @return {Boolean} `false` if popup will not fit onscreen in new position;
    * otherwise, `true`.
    * @public
    */
    applyVerticalFlushPositioning: function (leftFlushPt, rightFlushPt) {
        //if we can't fit the popup above or below the activator then forget vertical positioning
        if (!this.initVerticalPositioning()) {
            return false;
        }

        var clientRect = this.getBoundingRect(this.container.node);
        var innerWidth = this.getViewWidth();

        //If the activator's right side is within our left side cut off use flush positioning
        if ((this.offset.left + this.offset.width/2) < leftFlushPt){
            //if the activator's left edge is too close or past the screen left edge
            if (this.offset.left + this.offset.width/2 < this.container.horizBuffer){
                this.applyPosition({left:this.container.horizBuffer + (this.container.floating ? 0 : -clientRect.left)});
            } else {
                this.applyPosition({left:this.offset.width/2  + (this.container.floating ? this.offset.left : 0)});
            }

            this.container.addClass('right');
            this.container.addClass('corner');
            return true;
        }
        //If the activator's left side is within our right side cut off use flush positioning
        else if (this.offset.left + this.offset.width/2 > rightFlushPt) {
            if ((this.offset.left+this.offset.width/2) > (innerWidth-this.container.horizBuffer)){
                this.applyPosition({left:innerWidth - this.container.horizBuffer - clientRect.right});
            } else {
                this.applyPosition({left: (this.offset.left + this.offset.width/2) - clientRect.right});
            }
            this.container.addClass('left');
            this.container.addClass('corner');
            return true;
        }

        return false;
    },

    /**
    * Determines whether popup will fit onscreen if moved to the left or right of the
    * activator.
    *
    * @return {Boolean} `true` if the popup will fit onscreen; otherwise, `false`.
    * @public
    */
    initHorizontalPositioning: function () {
        this.resetPositioning();

        var clientRect = this.getBoundingRect(this.container.node);
        var innerWidth = this.getViewWidth();

        //adjust horizontal positioning of the popup & nub vertical positioning
        if (this.container.floating){
            if ((this.offset.left + this.offset.width) < innerWidth/2) {
                this.applyPosition({left: this.offset.left + this.offset.width});
                this.container.addRemoveClass('left', true);
            } else {
                this.applyPosition({left: this.offset.left - clientRect.width});
                this.container.addRemoveClass('right', true);
            }
        } else {
            if (this.offset.left - clientRect.width > 0) {
                this.applyPosition({left: this.offset.left - clientRect.left - clientRect.width});
                this.container.addRemoveClass('right', true);
            } else {
                this.applyPosition({left: this.offset.width});
                this.container.addRemoveClass('left', true);
            }
        }
        this.container.addRemoveClass('horizontal', true);

        //if moving the popup left or right of the activator puts it past the edge of the screen then horizontal won't work
        clientRect = this.getBoundingRect(this.container.node);
        if (clientRect.left < 0 || (clientRect.left + clientRect.width) > innerWidth){
            return false;
        }
        return true;

    },

    /**
    * Moves the popup to the left or right of the activating control.
    *
    * @return {Boolean} `false` if popup was not moved because it would not fit onscreen
    * in the new position; otherwise, `true`.
    * @public
    */
    applyHorizontalPositioning: function () {
        //if we can't fit the popup left or right of the activator then forget horizontal positioning
        if (!this.initHorizontalPositioning()) {
            return false;
        }

        var clientRect = this.getBoundingRect(this.container.node);
        var innerHeight = this.getViewHeight();
        var activatorCenter = this.offset.top + this.offset.height/2;

        if (this.container.floating){
            //if the activator's center is within 10% of the center of the view, vertically center the popup
            if ((activatorCenter >= (innerHeight/2 - 0.05 * innerHeight)) && (activatorCenter <= (innerHeight/2 + 0.05 * innerHeight))) {
                this.applyPosition({top: this.offset.top + this.offset.height/2 - clientRect.height/2, bottom: 'auto'});
            } else if (this.offset.top + this.offset.height < innerHeight/2) { //the activator is in the top 1/2 of the screen
                this.applyPosition({top: this.offset.top, bottom: 'auto'});
                this.container.addRemoveClass('high', true);
            } else { //otherwise the popup will be positioned in the bottom 1/2 of the screen
                this.applyPosition({top: this.offset.top - clientRect.height + this.offset.height*2, bottom: 'auto'});
                this.container.addRemoveClass('low', true);
            }
        } else {
            //if the activator's center is within 10% of the center of the view, vertically center the popup
            if ((activatorCenter >= (innerHeight/2 - 0.05 * innerHeight)) && (activatorCenter <= (innerHeight/2 + 0.05 * innerHeight))) {
                this.applyPosition({top: (this.offset.height - clientRect.height)/2});
            } else if (this.offset.top + this.offset.height < innerHeight/2) { //the activator is in the top 1/2 of the screen
                this.applyPosition({top: -this.offset.height});
                this.container.addRemoveClass('high', true);
            } else { //otherwise the popup will be positioned in the bottom 1/2 of the screen
                this.applyPosition({top: clientRect.top - clientRect.height - this.offset.top + this.offset.height});
                this.container.addRemoveClass('low', true);
            }
        }
        return true;
    },


    /**
    * Positions the popup horizontally flush with the activating control.
    *
    * @param {Number} leftFlushPt - Left side cutoff.
    * @param {Number} rightFlushPt - Right side cutoff.
    * @return {Boolean} `false` if popup will not fit onscreen in new position;
    * otherwise, `true`.
    * @public
    */
    applyHorizontalFlushPositioning: function (leftFlushPt, rightFlushPt) {
        //if we can't fit the popup left or right of the activator then forget horizontal positioning
        if (!this.initHorizontalPositioning()) {
            return false;
        }

        var clientRect = this.getBoundingRect(this.container.node);
        var innerHeight = this.getViewHeight();

        //adjust vertical positioning (high or low nub & popup position)
        if (this.container.floating){
            if (this.offset.top < (innerHeight/2)){
                this.applyPosition({top: this.offset.top + this.offset.height/2});
                this.container.addRemoveClass('high', true);
            } else {
                this.applyPosition({top:this.offset.top + this.offset.height/2 - clientRect.height});
                this.container.addRemoveClass('low', true);
            }
        } else {
            if (((clientRect.top + clientRect.height) > innerHeight) && ((innerHeight - clientRect.bottom) < (clientRect.top - clientRect.height))) {
                this.applyPosition({top: clientRect.top - clientRect.height - this.offset.top - this.offset.height/2});
                this.container.addRemoveClass('low', true);
            } else {
                this.applyPosition({top: this.offset.height/2});
                this.container.addRemoveClass('high', true);
            }
        }

        //If the activator's right side is within our left side cut off use flush positioning
        if ((this.offset.left + this.offset.width) < leftFlushPt){
            this.container.addClass('left');
            this.container.addClass('corner');
            return true;
        }
        //If the activator's left side is within our right side cut off use flush positioning
        else if (this.offset.left > rightFlushPt) {
            this.container.addClass('right');
            this.container.addClass('corner');
            return true;
        }

        return false;
    },

    /**
    * Retrieves an object with properties describing the bounding rectangle for the
    * passed-in DOM node.
    *
    * @param  {String} inNode - DOM node for which to retrieve the bounding rectangle.
    * @return {Object} Object with properties describing the DOM node's bounding rectangle.
    * @private
    */
    getBoundingRect:  function (inNode){
        // getBoundingClientRect returns top/left values which are relative to the viewport and not absolute
        var o = inNode.getBoundingClientRect();
        if (!o.width || !o.height) {
            return {
                left: o.left,
                right: o.right,
                top: o.top,
                bottom: o.bottom,
                width: o.right - o.left,
                height: o.bottom - o.top
            };
        }
        return o;
    },

    /**
    * @private
    */
    getViewHeight: function () {
        return (window.innerHeight === undefined) ? document.documentElement.clientHeight : window.innerHeight;
    },

    /**
    * @private
    */
    getViewWidth: function () {
        return (window.innerWidth === undefined) ? document.documentElement.clientWidth : window.innerWidth;
    },

    /**
    * @private
    */
    applyPosition: function (inRect) {
        var s = '';
        for (var n in inRect) {
            s += (n + ':' + inRect[n] + (isNaN(inRect[n]) ? '; ' : 'px; '));
        }
        this.container.addStyles(s);
    },

    /**
    * @private
    */
    resetPositioning: function () {
        this.container.removeClass('right');
        this.container.removeClass('left');
        this.container.removeClass('high');
        this.container.removeClass('low');
        this.container.removeClass('corner');
        this.container.removeClass('below');
        this.container.removeClass('above');
        this.container.removeClass('vertical');
        this.container.removeClass('horizontal');

        this.applyPosition({left: 'auto'});
        this.applyPosition({top: 'auto'});
    },

    /**
    * @private
    */
    reflow: function () {
        this.offset = this.container.activatorOffset;
        this.adjustPosition();
    }
});
},{"../../../enyo/lib/Layout":26,"../../../enyo/lib/kind":66}],27:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');

var
	LinkedListNode = require('./LinkedListNode');

/**
* An abstract linked-list.
*
* @class enyo.LinkedList
* @private
*/
module.exports = kind(
	/** @lends enyo.LinkedList.prototype */ {
	
	/**
	* @private
	*/
	kind: null,
	
	/**
	* @private
	*/

	
	/**
	* @private
	*/
	nodeKind: LinkedListNode,
	
	/**
	* @private
	*/
	head: null,
	
	/**
	* @private
	*/
	tail: null,
	
	/**
	* @private
	*/
	length: 0,
	
	/**
	* @private
	*/
	clear: function () {
		if (this.head) {
			// this will trigger a chain event down the list
			this.head.destroy();
		}
		this.head = null;
		this.tail = null;
		this.length = 0;			
	},
	
	/**
	* @private
	*/
	slice: function (fromNode, toNode) {
		var node = fromNode || this.head
			, list = new this.ctor()
			, cpy;
		
		// ensure we have a final node or our tail
		toNode = toNode || this.tail;
		
		if (node && node !== toNode) {
			do {
				cpy = node.copy();
				list.appendNode(cpy);
			} while ((node = node.next) && node !== toNode);
		}
		
		return list;
	},
	
	/**
	* @private
	*/
	destroy: function () {
		this.clear();
		this.destroyed = true;
	},
	
	/**
	* @private
	*/
	createNode: function (props) {
		return new this.nodeKind(props);
	},
	
	/**
	* @private
	*/
	deleteNode: function (node) {
		this.removeNode(node);
		
		// can't chain destruct because we removed its chain references
		node.destroy();
		return this;
	},
	
	/**
	* @private
	*/
	removeNode: function (node) {
		var prev = node.prev
			, next = node.next;
			
		prev && (prev.next = next);
		next && (next.prev = prev);
		this.length--;
		node.next = node.prev = null;
		return this;
	},
	
	/**
	* @private
	*/
	appendNode: function (node, targetNode) {
		targetNode = targetNode || this.tail;
		
		if (targetNode) {
			if (targetNode.next) {
				node.next = targetNode.next;
			}
			
			targetNode.next = node;
			node.prev = targetNode;
			
			if (targetNode === this.tail) {
				this.tail = node;
			}
			
			this.length++;
		} else {
			
			this.head = this.tail = node;
			node.prev = node.next = null;
			this.length = 1;
		}
		return this;
	},
	
	/**
	* @private
	*/
	find: function (fn, ctx, targetNode) {
		var node = targetNode || this.head;
		if (node) {
			do {
				if (fn.call(ctx || this, node, this)) {
					return node;
				}
			} while ((node = node.next));
		}
		// if no node qualified it returns false
		return false;
	},
	
	/**
	* @private
	*/
	forward: function (fn, ctx, targetNode) {
		var node = targetNode || this.head;
		if (node) {
			do {
				if (fn.call(ctx || this, node, this)) {
					break;
				}
			} while ((node = node.next));
		}
		// returns the last node (if any) that was processed in the chain
		return node;
	},
	
	/**
	* @private
	*/
	backward: function (fn, ctx, targetNode) {
		var node = targetNode || this.tail;
		if (node) {
			do {
				if (fn.call(ctx || this, node, this)) {
					break;
				}
			} while ((node = node.prev));
		}
		// returns the last node (if any) that was processed in the chain
		return node;
	},
	
	/**
	* @private
	*/
	constructor: function () {
		this.nodeType = kind.constructorForKind(this.nodeType);
	}
});
},{"../../enyo":1,"./LinkedListNode":28,"./kind":66}],33:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	LinkedListNode = require('./LinkedListNode');

function get (base, prop) {
	return base && /*isObject(base)*/ (typeof base == 'object')? (
		base.get? base.get(prop): base[prop]
	): undefined;
}

/**
* An internally used {@glossary kind}.
*
* @class enyo.ObserverChainNode
* @extends enyo.LinkedListNode
* @private
*/
module.exports = kind(
	/** @lends enyo.ObserverChainNode.prototype */ {

	/**
	* @private
	*/
	kind: LinkedListNode,

	/**
	* @private
	*/

	
	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.connect();
		};
	}),
	
	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			this.disconnect();
			sup.apply(this, arguments);
			this.observer = null;
			this.list = null;
			this.object = null;
		};
	}),
	
	/**
	* @private
	*/
	connect: function () {
		var obj = this.object
			, obs = this._changed
			, prop = this.property;
		if (obj) {
			if (obj.observe) obj.observe(prop, obs, this, {noChain: true, priority: true});
			this.connected = true;
			this.list.connected++;
		}
	},
	
	/**
	* @private
	*/
	disconnect: function () {
		var obj = this.object
			, obs = this._changed
			, prop = this.property
			, was = this.connected;
		obj && obj.unobserve && obj.unobserve(prop, obs, this);
		this.connected = null;
		if (was) this.list.connected--;
	},
	
	/**
	* @private
	*/
	setObject: function (object) {
		var cur = this.object
			, prop = this.property
			, was, is;
		
		if (cur !== object) {
			this.disconnect();
			this.object = object;
			this.connect();
			
			if (this.list.tail === this) {
				was = get(cur, prop);
				is = get(object, prop);
				// @TODO: It would be better to somehow cache values
				// such that it could intelligently derive the difference
				// without needing to continuously look it up with get
				was !== is && this.list.observed(this, was, is);
			}
		}
	},
	
	/**
	* @private
	*/
	_changed: function (was, is) {
		this.list.observed(this, was, is);
	}
});
},{"../../enyo":1,"./LinkedListNode":28,"./kind":66,"./utils":75}],79:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	Arranger = require('./Arranger');


/**
* {@link enyo.CardArranger} is an {@link enyo.Arranger} that displays only
* one active control. The non-active controls are hidden with
* `setShowing(false)`. Transitions between arrangements are handled by fading
* from one control to the next.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.CardArranger
* @extends enyo.Arranger
* @public
*/
module.exports = kind(
	/** @lends  enyo.CardArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.CardArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	* @private
	*/
	layoutClass: 'enyo-arranger enyo-arranger-fit',

	/**
	* @see {@link enyo.Arranger.calcArrangementDifference}
	* @protected
	*/
	calcArrangementDifference: function (i0, a0, i1, a1) {
		return this.containerBounds.width;
	},

	/**
	* Applies opacity to the activation and deactivation of panels. Expects the passed-in
	* array of controls to be ordered such that the first control in the array is the active
	* panel.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		for (var i=0, c, v; (c=controls[i]); i++) {
			v = (i === 0) ? 1 : 0;
			this.arrangeControl(c, {opacity: v});
		}
	},

	/**
	* Shows the active panel at the start of transition. Also triggers a resize on
	* the active panel if it wasn't previously showing.
	*
	* @see {@link enyo.Arranger.start}
	* @method
	* @protected
	*/
	start: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				var wasShowing=c.showing;
				c.setShowing(i == this.container.fromIndex || i == (this.container.toIndex));
				if (c.showing && !wasShowing) {
					c.resize();
				}
			}
		};
	}),

	/**
	* Hides all non-active panels when the transition completes.
	*
	* @see {@link enyo.Arranger.finish}
	* @method
	* @protected
	*/
	finish: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				c.setShowing(i == this.container.toIndex);
			}
		};
	}),

	/**
	* Ensures all panels are showing and visible when the arranger is destroyed.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				Arranger.opacifyControl(c, 1);
				if (!c.showing) {
					c.setShowing(true);
				}
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/kind":66,"./Arranger":78}],81:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom');

var
	Arranger = require('./Arranger');

/**
* {@link enyo.CarouselArranger} is an {@link enyo.Arranger} that displays
* the active control, along with some number of inactive controls to fill the
* available space. The active control is positioned on the left side of the
* container, and the rest of the views are laid out to the right.
*
* One of the controls may have `fit: true` set, in which case it will take up
* any remaining space after all of the other controls have been sized.
*
* For best results with CarouselArranger, you should set a minimum width for
* each control via a CSS style, e.g., `min-width: 25%` or `min-width: 250px`.
*
* Transitions between arrangements are handled by sliding the new controls in
* from the right and sliding the old controls off to the left.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.CarouselArranger
* @extends enyo.Arranger
* @public
*/
module.exports = kind(
	/** @lends enyo.CarouselArranger */ {

	/**
	* @private
	*/
	name: 'enyo.CarouselArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	* Calculates the size of each panel. Considers the padding of the container by calling
	* {@link enyo.dom#calcPaddingExtents} and control margin by calling
	* {@link enyo.dom#calcMarginExtents}. If the container is larger than the combined sizes of
	* the controls, one control may be set to fill the remaining space by setting its `fit`
	* property to `true`. If multiple controls have `fit: true` set, the last control to be so
	* marked will have precedence.
	*
	* @protected
	*/
	size: function () {
		var c$ = this.container.getPanels();
		var padding = this.containerPadding = this.container.hasNode() ? dom.calcPaddingExtents(this.container.node) : {};
		var pb = this.containerBounds;
		var i, e, s, m, c;
		pb.height -= padding.top + padding.bottom;
		pb.width -= padding.left + padding.right;
		// used space
		var fit;
		for (i=0, s=0; (c=c$[i]); i++) {
			m = dom.calcMarginExtents(c.hasNode());
			c.width = c.getBounds().width;
			c.marginWidth = m.right + m.left;
			s += (c.fit ? 0 : c.width) + c.marginWidth;
			if (c.fit) {
				fit = c;
			}
		}
		if (fit) {
			var w = pb.width - s;
			fit.width = w >= 0 ? w : fit.width;
		}
		for (i=0, e=padding.left; (c=c$[i]); i++) {
			c.setBounds({top: padding.top, bottom: padding.bottom, width: c.fit ? c.width : null});
		}
	},

	/**
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		if (this.container.wrap) {
			this.arrangeWrap(controls, arrangement);
		} else {
			this.arrangeNoWrap(controls, arrangement);
		}
	},

	/**
	* A non-wrapping carousel arranges the controls from left to right without regard to the
	* ordered array passed via `controls`. `arrangement` will contain the index of the active
	* panel.
	*
	* @private
	*/
	arrangeNoWrap: function (controls, arrangement) {
		var i, aw, cw, c;
		var c$ = this.container.getPanels();
		var s = this.container.clamp(arrangement);
		var nw = this.containerBounds.width;
		// do we have enough content to fill the width?
		for (i=s, cw=0; (c=c$[i]); i++) {
			cw += c.width + c.marginWidth;
			if (cw > nw) {
				break;
			}
		}
		// if content width is less than needed, adjust starting point index and offset
		var n = nw - cw;
		var o = 0;
		if (n > 0) {
			for (i=s-1, aw=0; (c=c$[i]); i--) {
				aw += c.width + c.marginWidth;
				if (n - aw <= 0) {
					o = (n - aw);
					s = i;
					break;
				}
			}
		}
		// arrange starting from needed index with detected offset so we fill space
		var w, e;
		for (i=0, e=this.containerPadding.left + o; (c=c$[i]); i++) {
			w = c.width + c.marginWidth;
			if (i < s) {
				this.arrangeControl(c, {left: -w});
			} else {
				this.arrangeControl(c, {left: Math.floor(e)});
				e += w;
			}
		}
	},

	/**
	* Arranges `controls` from left to right such that the active panel is always the
	* leftmost, with subsequent panels positioned to its right.
	*
	* @private
	*/
	arrangeWrap: function (controls, arrangement) {
		for (var i=0, e=this.containerPadding.left, c; (c=controls[i]); i++) {
			this.arrangeControl(c, {left: e});
			e += c.width + c.marginWidth;
		}
	},

	/**
	* Calculates the change in `left` position between the two arrangements `a0` and `a1`.
	* @protected
	*/
	calcArrangementDifference: function (i0, a0, i1, a1) {
		var i = Math.abs(i0 % this.c$.length);
		return a0[i].left - a1[i].left;
	},

	/**
	* Resets the size and position of all panels.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				Arranger.positionControl(c, {left: null, top: null});
				c.applyStyle('top', null);
				c.applyStyle('bottom', null);
				c.applyStyle('left', null);
				c.applyStyle('width', null);
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"./Arranger":78}],84:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom');

var
	Arranger = require('./Arranger');

/**
* {@link enyo.DockRightArranger} is an {@link enyo.Arranger} that displays the
* active control, along with some number of inactive controls to fill the
* available space. The active control is positioned on the right side of the
* container and the rest of the views are laid out to the right.
*
* For best results with DockRightArranger, you should set a minimum width
* for each control via a CSS style, e.g., `min-width: 25%` or
* `min-width: 250px`.
*
* Transitions between arrangements are handled by sliding the new control	in
* from the right. If the width of the old control(s) can fit within the
* container, they will slide to the left. If not, they will collapse to the left.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.DockRightArranger
* @extends enyo.Arranger
* @public
*/
module.exports = kind(
	/** @lends enyo.DockRightArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.DockRightArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	* If `true`, the base panel (i.e., the panel at index `0`) will fill the width
	* of the container, while newer controls will slide in and collapse on top of it.
	*
	* @type {Boolean}
	* @default  false
	* @public
	*/
	basePanel: false,

	/**
	* Panels will overlap by this number of pixels.
	*
	* Note that this is imported from the container at construction time.
	*
	* @type {Number}
	* @default  0
	* @public
	*/
	overlap: 0,

	/**
	* The column width in pixels.
	*
	* Note that this is imported from the container at construction time.
	*
	* @type {Number}
	* @default  0
	* @public
	*/
	layoutWidth: 0,

	/**
	* @method
	* @private
	*/
	constructor: function () {
		Arranger.prototype._constructor.apply(this, arguments);
		this.overlap = this.container.overlap != null ? this.container.overlap : this.overlap;
		this.layoutWidth = this.container.layoutWidth != null ? this.container.layoutWidth : this.layoutWidth;
	},

	/**
	* @see {@link enyo.Arranger.size}
	* @protected
	*/
	size: function () {
		var c$ = this.container.getPanels();
		var padding = this.containerPadding = this.container.hasNode() ? dom.calcPaddingExtents(this.container.node) : {};
		var pb = this.containerBounds;
		var i, m, c;
		pb.width -= padding.left + padding.right;
		var nw = pb.width;
		var len = c$.length;
		var offset;
		// panel arrangement positions
		this.container.transitionPositions = {};

		for (i=0; (c=c$[i]); i++) {
			c.width = ((i===0) && (this.container.basePanel)) ? nw : c.getBounds().width;
		}

		for (i=0; (c=c$[i]); i++) {

			if ((i===0) && (this.container.basePanel)) {
				c.setBounds({width: nw});
			}
			c.setBounds({top: padding.top, bottom: padding.bottom});

			for (var j=0; (c=c$[j]); j++) {
				var xPos;
				// index 0 always should always be left-aligned at 0px
				if ((i===0) && (this.container.basePanel)) {
					xPos = 0;
				// else newer panels should be positioned off the viewport
				} else if (j < i) {
					xPos = nw;
				// else active panel should be right-aligned
				} else if (i === j) {
					offset = nw > this.layoutWidth ? this.overlap : 0;
					xPos = (nw - c$[i].width) + offset;
				} else {
					break;
				}
				this.container.transitionPositions[i + '.' + j] = xPos;
			}

			if (j < len) {
				var leftAlign = false;
				for (var k=i+1; k<len; k++) {
					offset = 0;
					// position panel to left: 0px
					if (leftAlign) {
						offset = 0;
					// else if next panel cannot fit within container
					} else if ( (c$[i].width + c$[k].width - this.overlap) > nw ) {
					//} else if ( (c$[i].width + c$[k].width) > nw ) {
						offset = 0;
						leftAlign = true;
					} else {
						offset = c$[i].width - this.overlap;
						for (m=i; m<k; m++) {
							var _w = offset + c$[m+1].width - this.overlap;
							if (_w < nw) {
								offset = _w;
							} else {
								offset = nw;
								break;
							}
						}
						offset = nw - offset;
					}
					this.container.transitionPositions[i + '.' + k] = offset;
				}
			}

		}
	},

	/**
	* Sets the `left` position for each panel according to the `arrangement`.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var i, c;
		var c$ = this.container.getPanels();
		var s = this.container.clamp(arrangement);

		for (i=0; (c=c$[i]); i++) {
			var xPos = this.container.transitionPositions[i + '.' + s];
			this.arrangeControl(c, {left: xPos});
		}
	},

	/**
	* Calculates the difference in width between the panels at `i0` and `i1`.
	*
	* @see {@link enyo.Arranger.calcArrangementDifference}
	* @protected
	*/
	calcArrangementDifference: function (i0, a0, i1, a1) {
		var p = this.container.getPanels();
		var w = (i0 < i1) ? p[i1].width : p[i0].width;
		return w;
	},

	/**
	* Resets the position of the panels.
	*
	* @method
	* @private
	*/
	destroy: function () {
		var c$ = this.container.getPanels();
		for (var i=0, c; (c=c$[i]); i++) {
			Arranger.positionControl(c, {left: null, top: null});
			c.applyStyle('top', null);
			c.applyStyle('bottom', null);
			c.applyStyle('left', null);
			c.applyStyle('width', null);
		}
		Arranger.prototype.destroy.apply(this, arguments);
	}
});
},{"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"./Arranger":78}],90:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	Arranger = require('./Arranger');

/**
* {@link enyo.GridArranger} is an {@link enyo.Arranger} that arranges
* controls in a grid. The active control is positioned at the top-left of the
* grid and the other controls are laid out from left to right and then from
* top to bottom.
*
* Transitions between arrangements are handled by moving the active control to
* the end of the grid and shifting the other controls	to the left, or by
* moving it up to the previous row, to fill the space.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*/
module.exports = kind(
	/** @lends enyo.GridArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.GridArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	* @see {@link enyo.Arranger.incrementalPoints}
	* @private
	*/
	incrementalPoints: true,

	/**
	 * The column width in pixels.
	 *
	 * @type {Number}
	 * @default 100
	 * @public
	 */
	colWidth: 100,

	/**
	 * The column height in pixels.
	 *
	 * @type {Number}
	 * @default 100
	 * @public
	 */
	colHeight: 100,

	/**
	* Sizes each panel to be [colWidth]{@link enyo.GridArranger#colWidth} pixels wide
	* and [colHeight]{@link enyo.GridArranger#colHeight} pixels high.
	*
	* @see {@link enyo.Arranger.size}
	* @protected
	*/
	size: function () {
		var c$ = this.container.getPanels();
		var w=this.colWidth, h=this.colHeight;
		for (var i=0, c; (c=c$[i]); i++) {
			c.setBounds({width: w, height: h});
		}
	},

	/**
	* Calculates the number of columns based on the container's width and
	* [colWidth]{@link enyo.GridArranger#colWidth}. Each row is positioned
	* starting at the top-left of the container.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var w=this.colWidth, h=this.colHeight;
		var cols = Math.max(1, Math.floor(this.containerBounds.width / w));
		var c;
		for (var y=0, i=0; i<controls.length; y++) {
			for (var x=0; (x<cols) && (c=controls[i]); x++, i++) {
				this.arrangeControl(c, {left: w*x, top: h*y});
			}
		}
	},

	/**
	* If the control is moving between rows, adjusts its opacity during the transition.
	*
	* @see {@link enyo.Arranger.flowControl}
	* @method
	* @protected
	*/
	flowControl: kind.inherit(function (sup) {
		return function (inControl, inA) {
			sup.apply(this, arguments);
			Arranger.opacifyControl(inControl, inA.top % this.colHeight !== 0 ? 0.25 : 1);
		};
	}),

	/**
	* @see {@link enyo.Arranger.calcArrangementDifference}
	* @protected
	*/
	calcArrangementDifference: function (inI0, inA0, inI1, inA1) {
		return this.colWidth;
	},

	/**
	* Resets position of panels.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				Arranger.positionControl(c, {left: null, top: null});
				c.applyStyle('left', null);
				c.applyStyle('top', null);
				c.applyStyle('height', null);
				c.applyStyle('width', null);
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/kind":66,"./Arranger":78}],94:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	Arranger = require('./Arranger');

/**
* {@link enyo.LeftRightArranger} is an {@link enyo.Arranger} that displays
* the active control and some of the previous and next controls. The active
* control is centered horizontally in the container, and the previous and next
* controls are laid out to the left and right, respectively.
*
* Transitions between arrangements are handled by sliding the new control in
* from the right and sliding the active control out to the left.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.LeftRightArranger
* @extends enyo.Arranger
* @public
*/
module.exports = kind(
	/** @lends enyo.LeftRightArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.LeftRightArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	 * The margin width (i.e., how much of the previous and next controls
	 * are visible) in pixels.
	 *
	 * Note that this is imported from the container at construction time.
	 *
	 * @type {Number}
	 * @default 40
	 * @public
	 */
	margin: 40,

	/**
	 * The axis along which the panels will animate.
	 *
	 * @type {String}
	 * @readOnly
	 * @default 'width'
	 * @protected
	 */
	axisSize: 'width',

	/**
	 * The axis along which the panels will **not** animate.
	 *
	 * @type {String}
	 * @readOnly
	 * @default 'height'
	 * @protected
	 */
	offAxisSize: 'height',

	/**
	 * The axis position at which the panel will animate.
	 *
	 * @type {String}
	 * @readOnly
	 * @default 'left'
	 * @protected
	 */
	axisPosition: 'left',

	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.margin = this.container.margin != null ? this.container.margin : this.margin;
		};
	}),

	/**
	* Sizes the panels such that they fill [offAxisSize]{@link enyo.LeftRightArranger#offAxisSize}
	* and yield [margin]{@link enyo.LeftRightArranger#margin} pixels on each side of
	* [axisSize]{@link enyo.LeftRightArranger#axisSize}.
	*
	* @see {@link enyo.Arranger.size}
	* @protected
	*/
	size: function () {
		var c$ = this.container.getPanels();
		var port = this.containerBounds[this.axisSize];
		var box = port - this.margin -this.margin;
		for (var i=0, b, c; (c=c$[i]); i++) {
			b = {};
			b[this.axisSize] = box;
			b[this.offAxisSize] = '100%';
			c.setBounds(b);
		}
	},

	/**
	* To prevent a panel that is switching sides (to maintain the balance) from overlapping
	* the active panel during the animation, updates the `z-index` of the switching panel
	* to ensure that it stays behind the other panels.
	*
	* @todo Could use some optimization in its `for` loop (e.g. .length lookup and calc)
	* @see {@link enyo.Arranger.start}
	* @method
	* @protected
	*/
	start: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);

			var s = this.container.fromIndex;
			var f = this.container.toIndex;
			var c$ = this.getOrderedControls(f);
			var o = Math.floor(c$.length/2);

			for (var i=0, c; (c=c$[i]); i++) {
				if (s > f){
					if (i == (c$.length - o)){
						c.applyStyle('z-index', 0);
					} else {
						c.applyStyle('z-index', 1);
					}
				} else {
					if (i == (c$.length-1 - o)){
						c.applyStyle('z-index', 0);
					} else {
						c.applyStyle('z-index', 1);
					}
				}
			}
		};
	}),

	/**
	* Balances the panels laid out to each side of the active panel
	* such that, for a set of `n` panels, `floor(n/2)` are before and `ceil(n/2)` are after
	* the active panel.
	*
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var i,c,b;
		if (this.container.getPanels().length==1){
			b = {};
			b[this.axisPosition] = this.margin;
			this.arrangeControl(this.container.getPanels()[0], b);
			return;
		}
		var o = Math.floor(this.container.getPanels().length/2);
		var c$ = this.getOrderedControls(Math.floor(arrangement)-o);
		var box = this.containerBounds[this.axisSize] - this.margin - this.margin;
		var e = this.margin - box * o;
		for (i=0; (c=c$[i]); i++) {
			b = {};
			b[this.axisPosition] = e;
			this.arrangeControl(c, b);
			e += box;
		}
	},

	/**
	* Calculates the difference along the
	* [axisPosition]{@link enyo.LeftRightArranger#axisPosition} (e.g., `'left'`).
	*
	* @param {Number} inI0 - The initial layout setting.
	* @param {Object} inA0 - The initial arrangement.
	* @param {Number} inI1 - The target layout setting.
	* @param {Object} inA1 - The target arrangement.
	* @protected
	*/
	calcArrangementDifference: function (inI0, inA0, inI1, inA1) {
		if (this.container.getPanels().length==1){
			return 0;
		}

		var i = Math.abs(inI0 % this.c$.length);
		//enyo.log(inI0, inI1);
		return inA0[i][this.axisPosition] - inA1[i][this.axisPosition];
	},

	/**
	* Resets the positioning and opacity of panels.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				Arranger.positionControl(c, {left: null, top: null});
				Arranger.opacifyControl(c, 1);
				c.applyStyle('left', null);
				c.applyStyle('top', null);
				c.applyStyle('height', null);
				c.applyStyle('width', null);
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/kind":66,"./Arranger":78}],103:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	Arranger = require('./Arranger');

/**
* {@link enyo.SpiralArranger} is an {@link enyo.Arranger} that arranges
* controls in a spiral. The active control is positioned on top and the other
* controls are laid out in a spiral pattern below.
*
* Transitions between arrangements are handled by rotating the new control up
* from below and rotating the active control down to the end of the spiral.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class  enyo.SpiralArranger
* @extends enyo.Arranger
* @public
*/
module.exports = kind(
	/** @lends enyo.SpiralArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.SpiralArranger',

	/**
	* @private
	*/
	kind: Arranger,

	/**
	* @see {@link enyo.Arranger.incrementalPoints}
	* @private
	*/
	incrementalPoints: true,

	/**
	* The amount of space between successive controls
	*
	* @private
	*/
	inc: 20,

	/**
	* Sizes each panel to one third of the container.
	*
	* @see  {@link enyo.Arranger.size}
	* @protected
	*/
	size: function () {
		var c$ = this.container.getPanels();
		var b = this.containerBounds;
		var w = this.controlWidth = b.width/3;
		var h = this.controlHeight = b.height/3;
		for (var i=0, c; (c=c$[i]); i++) {
			c.setBounds({width: w, height: h});
		}
	},

	/**
	* Arranges panels in a spiral with the active panel at the center.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var s = this.inc;
		for (var i=0, l=controls.length, c; (c=controls[i]); i++) {
			var x = Math.cos(i/l * 2*Math.PI) * i * s + this.controlWidth;
			var y = Math.sin(i/l * 2*Math.PI) * i * s + this.controlHeight;
			this.arrangeControl(c, {left: x, top: y});
		}
	},

	/**
	* Applies descending `z-index` values to each panel, starting with the active panel.
	*
	* @see {@link enyo.Arranger.start}
	* @method
	* @protected
	*/
	start: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			var c$ = this.getOrderedControls(this.container.toIndex);
			for (var i=0, c; (c=c$[i]); i++) {
				c.applyStyle('z-index', c$.length - i);
			}
		};
	}),

	/**
	* @see {@link enyo.Arranger.calcArrangementDifference}
	* @protected
	*/
	calcArrangementDifference: function (inI0, inA0, inI1, inA1) {
		return this.controlWidth;
	},

	/**
	* Resets position and z-index of all panels.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				c.applyStyle('z-index', null);
				Arranger.positionControl(c, {left: null, top: null});
				c.applyStyle('left', null);
				c.applyStyle('top', null);
				c.applyStyle('height', null);
				c.applyStyle('width', null);
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/kind":66,"./Arranger":78}],32:[function(require,module,exports){
require('../../enyo');

var
	utils = require('./utils'),
	kind = require('./kind');

var
	LinkedList = require('./LinkedList'),
	ObserverChainNode = require('./ObserverChainNode');

function get (base, prop) {
	return base && /*isObject(base)*/ (typeof base == 'object')? (
		base.get? base.get(prop): base[prop]
	): undefined;
}

/**
* An internally used {@glossary kind}.
*
* @class enyo.ObserverChain
* @extends enyo.LinkedList
* @private
*/
module.exports = kind(
	/** @lends enyo.ObserverChain.prototype */ {

	/**
	* @private
	*/
	kind: LinkedList,

	/**
	* @private
	*/
	nodeKind: ObserverChainNode,

	/**
	* @private
	*/

	
	/**
	* @private
	*/
	connected: 0,
	
	/**
	* @method
	* @private
	*/
	constructor: function (path, object) {
		this.object = object;
		this.path = path;
		this.parts = path.split('.');
		this.createChain();
	},
	
	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.object = null;
			this.parts = null;
			this.path = null;
		};
	}),
	
	/**
	* @private
	*/
	rebuild: function (target) {
		if (!this.rebuilding) {
			this.rebuilding = true;
			this.forward(function (node) {
				if (node !== this.head) {
					var src = node.prev.object
						, prop = node.prev.property;
					node.setObject(get(src, prop));
				}
			}, this, target);
			this.rebuilding = false;
		}
	},
	
	/**
	* @private
	*/
	isConnected: function () {
		return !! (this.connected === this.length && this.length);
	},
	
	/**
	* @private
	*/
	buildPath: function (target) {
		var str = '';
		
		this.backward(function (node) {
			str = node.property + (str? ('.' + str): str);
		}, this, target);
		
		return str;
	},
	
	/**
	* @private
	*/
	createChain: function () {
		var parts = this.parts
			, next = this.object
			, $ = false
			, node, prop;
			
		for (var i=0; (prop=parts[i]); ++i) {
			
		// forEach(parts, function (prop, idx) {
			// we create a special case for the $ hash property
			if (prop == '$') {
				$ = true;
			} else {
				// in cases where the chain has the $ property we arbitrarily
				// force it onto our current nodes property and let the special handling
				// in ObserverChainNode and ObserverSupport handle the rest
				$ && (prop = '$.' + prop);
				node = this.createNode({property: prop, object: next, list: this});
				this.appendNode(node);
				next = get(next, prop);
				$ = false;
			}
		// }, this);
		}
	},
	
	/**
	* @private
	*/
	observed: function (node, was, is) {
		this.object.stopNotifications();
		// @NOTE: About the following two cases, they are mutually exclusive and this seems perfect
		// that we don't see double notifications
		// @TODO: Only notify if it was the full property path? This is far more efficient after
		// testing but not as flexible...
		node === this.tail /*&& was !== is*/ && this.object.notify(this.buildPath(node), was, is);
		// @TODO: It seems the same case across the board that the rebuild only needs to take place
		// from the beginning to the second-to-last elem
		node !== this.tail && was !== is && this.rebuild(node);
		this.object.startNotifications();
	}
});
},{"../../enyo":1,"./LinkedList":27,"./ObserverChainNode":33,"./kind":66,"./utils":75}],80:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	Arranger = require('./Arranger'),
	CardArranger = require('./CardArranger');

/**
* {@link enyo.CardSlideInArranger} is an {@link enyo.Arranger} that
* displays only one active control. The non-active controls are hidden with
* `setShowing(false)`. Transitions between arrangements are handled by
* sliding the new control	over the current one.
*
* Note that CardSlideInArranger always slides controls in from the right. If
* you want an arranger that slides to the right and left, try
* {@link enyo.LeftRightArranger}.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class enyo.CardSlideInArranger
* @extends enyo.CardArranger
* @public
*/
module.exports = kind(
	/** @lends  enyo.CardSlideInArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.CardSlideInArranger',

	/**
	* @private
	*/
	kind: CardArranger,

	/**
	* Shows the active panel at the start of transition. Also triggers a resize on
	* the active panel if it wasn't previously showing.
	*
	* @todo Seems like poor variable reuse of `i`
	* @todo Should inherit from super and omit the `for` block
	* @see {@link enyo.Arranger.start}
	* @protected
	*/
	start: function () {
		var c$ = this.container.getPanels();
		for (var i=0, c; (c=c$[i]); i++) {
			var wasShowing=c.showing;
			c.setShowing(i == this.container.fromIndex || i == (this.container.toIndex));
			if (c.showing && !wasShowing) {
				c.resize();
			}
		}
		var l = this.container.fromIndex;
		i = this.container.toIndex;
		this.container.transitionPoints = [
			i + '.' + l + '.s',
			i + '.' + l + '.f'
		];
	},

	/**
	* @todo  This method is an exact copy of CardArranger. Since it's calling the super,
	* 	the work is being done twice, so this method should be removed.
	* @see {@link enyo.Arranger.finish}
	* @method
	* @protected
	*/
	finish: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				c.setShowing(i == this.container.toIndex);
			}
		};
	}),

	/**
	* Parses the transition point value to position the panels to slide in from the right.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var p = arrangement.split('.'),
			f = p[0],
			s = p[1],
			starting = (p[2] == 's'),
			b = this.containerBounds.width;

		for (var i=0, c$=this.container.getPanels(), c, v; (c=c$[i]); i++) {
			v = b;
			if (s == i) {
				v = starting ? 0 : -b;
			}
			if (f == i) {
				v = starting ? b : 0;
			}
			if (s == i && s == f) {
				v = 0;
			}
			this.arrangeControl(c, {left: v});
		}
	},

	/**
	* Resets the `left` position of all panels.
	*
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var c$ = this.container.getPanels();
			for (var i=0, c; (c=c$[i]); i++) {
				Arranger.positionControl(c, {left: null});
			}
			sup.apply(this, arguments);
		};
	})
});
},{"../../enyo/lib/kind":66,"./Arranger":78,"./CardArranger":79}],82:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	CarouselArranger = require('./CarouselArranger');

/**
* {@link enyo.CollapsingArranger} is an {@link enyo.Arranger} that displays the
* active control, along with some number of inactive	controls to fill the
* available space. The active control is positioned on the left side of the
* container and the rest of the views are laid out to the right. The last
* control, if visible, will expand to fill whatever space is not taken up by
* the previous controls.
*
* For best results with CollapsingArranger, you should set a minimum width
* for each control via a CSS style, e.g., `min-width: 25%` or
* `min-width: 250px`.
*
* Transitions between arrangements are handled by sliding the new control	in
* from the right and collapsing the old control to the left.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class enyo.CollapsingArranger
* @extends enyo.CarouselArranger
* @public
*/
module.exports = kind(
	/** @lends enyo.CollapsingArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.CollapsingArranger',

	/**
	* @private
	*/
	kind: CarouselArranger,

	/**
	* The distance (in pixels) that each panel should be offset from the left
	* when it is selected. This allows controls on the underlying panel to the
	* left of the selected one to be partially revealed.
	*
	* Note that this is imported from the container at construction time.
	*
	* @public
	*/
	peekWidth: 0,

	/**
	* If a panel is added or removed after construction, ensures that any control
	* marked to fill remaining space (via its `_fit` member) is reset.
	*
	* @see {@link enyo.Arranger.size}
	* @method
	* @protected
	*/
	size: kind.inherit(function (sup) {
		return function () {
			this.clearLastSize();
			sup.apply(this, arguments);
		};
	}),

	/**
	* Resets any panel marked to fill remaining space that isn't, in fact, the last panel.
	*
	* @private
	*/
	clearLastSize: function () {
		for (var i=0, c$=this.container.getPanels(), c; (c=c$[i]); i++) {
			if (c._fit && i != c$.length-1) {
				c.applyStyle('width', null);
				c._fit = null;
			}
		}
	},

	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.peekWidth = this.container.peekWidth != null ? this.container.peekWidth : this.peekWidth;
		};
	}),

	/**
	* Arranges controls from left to right starting with first panel. If
	* [peekWidth]{@link enyo.CollapsingArranger#peekWidth} is set, any visible control
	* whose index is less than `arrangement` (the active panel's index) will be revealed
	* by `peekWidth` pixels.
	*
	* @see {@link enyo.Arranger.arrange}
	* @protected
	*/
	arrange: function (controls, arrangement) {
		var c$ = this.container.getPanels();
		for (var i=0, e=this.containerPadding.left, c, n=0; (c=c$[i]); i++) {
			if(c.getShowing()){
				this.arrangeControl(c, {left: e + n * this.peekWidth});
				if (i >= arrangement) {
					e += c.width + c.marginWidth - this.peekWidth;
				}
				n++;
			} else {
				this.arrangeControl(c, {left: e});
				if (i >= arrangement) {
					e += c.width + c.marginWidth;
				}
			}
			// FIXME: overdragging-ish
			if (i == c$.length - 1 && arrangement < 0) {
				this.arrangeControl(c, {left: e - arrangement});
			}
		}
	},

	/**
	* Calculates the change in `left` position of the last panel between the two
	* arrangements `a0` and `a1`.
	*
	* @see {@link enyo.Arranger.calcArrangementDifference}
	* @private
	*/
	calcArrangementDifference: function (i0, a0, i1, a1) {
		var i = this.container.getPanels().length-1;
		return Math.abs(a1[i].left - a0[i].left);
	},

	/**
	* If the container's `realtimeFit` property is `true`, resizes the last panel to
	* fill the space. This ensures that when dragging or animating to the last index,
	* there is never blank space to the right of the last panel. If `realtimeFit` is
	* falsy, the last panel is not resized until the
	* [finish()]{@link enyo.CollapsingArranger#finish} method is called.
	*
	* @see {@link enyo.Arranger.flowControls}
	* @method
	* @private
	*/
	flowControl: kind.inherit(function (sup) {
		return function (inControl, inA) {
			sup.apply(this, arguments);
			if (this.container.realtimeFit) {
				var c$ = this.container.getPanels();
				var l = c$.length-1;
				var last = c$[l];
				if (inControl == last) {
					this.fitControl(inControl, inA.left);
				}
			}

		};
	}),

	/**
	* Ensures that the last panel fills the remaining space when a transition completes.
	*
	* @see {@link enyo.Arranger.finish}
	* @method
	* @private
	*/
	finish: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			if (!this.container.realtimeFit && this.containerBounds) {
				var c$ = this.container.getPanels();
				var a$ = this.container.arrangement;
				var l = c$.length-1;
				var c = c$[l];
				this.fitControl(c, a$[l].left);
			}
		};
	}),

	/**
	* Resizes the given `control` to match the width of the container minus the
	* given `offset`.
	*
	* @param {enyo.Control} control - The control that should fit in the remaining space.
	* @param {Number} offset        - The left offset of the control with respect to the
	* container.
	* @private
	*/
	fitControl: function (control, offset) {
		control._fit = true;
		control.applyStyle('width', (this.containerBounds.width - offset) + 'px');
		control.resize();
	}
});
},{"../../enyo/lib/kind":66,"./CarouselArranger":81}],104:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	LeftRightArranger = require('./LeftRightArranger');

/**
* {@link enyo.TopBottomArranger} is an {@link enyo.Arranger} that displays
* the active control and some of the previous and next controls. The active
* control is centered vertically in the container, and the previous and next
* controls are laid out above and below, respectively.
*
* Transitions between arrangements are handled by sliding the new control in
* from the bottom and sliding the active control out the top.
*
* For more information, see the documentation on
* [Arrangers]{@linkplain $dev-guide/building-apps/layout/arrangers.html} in the
* Enyo Developer Guide.
*
* @class enyo.TopBottomArranger
* @extends enyo.LeftRightArranger
* @public
*/
module.exports = kind(
	/** @lends enyo.TopBottomArranger.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.TopBottomArranger',

	/**
	* @private
	*/
	kind: LeftRightArranger,

	/**
	* @see {@link enyo.Arranger.dragProp}
	* @private
	*/
	dragProp: 'ddy',

	/**
	* @see {@link enyo.Arranger.dragDirectionProp}
	* @private
	*/
	dragDirectionProp: 'yDirection',

	/**
	* @see {@link enyo.Arranger.canDragProp}
	* @private
	*/
	canDragProp: 'vertical',

	/**
	* @see {@link enyo.LeftRightArranger.axisSize}
	* @protected
	*/
	axisSize: 'height',

	/**
	* @see {@link enyo.LeftRightArranger.offAxisSize}
	* @protected
	*/
	offAxisSize: 'width',

	/**
	* @see {@link enyo.LeftRightArranger.axisPosition}
	* @protected
	*/
	axisPosition: 'top'
});
},{"../../enyo/lib/kind":66,"./LeftRightArranger":94}],34:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	ObserverChain = require('./ObserverChain');

var observerTable = {};
	
kind.concatenated.push("observers");

/**
* Responds to changes in one or more properties.
* [Observers]{@link enyo.ObserverSupport~observer} may be registered in
* several different ways. See the {@link enyo.ObserverSupport} documentation
* for more details. Also note that, while observers should not be called
* directly, if defined on a [kind]{@glossary kind}, they may be
* overloaded for special behavior.
*
* @see enyo.ObserverSupport
* @see enyo.ObserverSupport.observe
* @callback enyo.ObserverSupport~Observer
* @param {*} was - The previous value of the property that has changed.
* @param {*} is - The current value of the property that has changed.
* @param {String} prop - The name of the property that has changed.
* @public
*/

/**
* @private
*/
function addObserver (path, fn, ctx, opts) {
	
	var observers = this.getObservers(),
		chains = this.getChains(),
		parts = path.split('.'),
		prio = opts && opts.priority,
		entries,
		noChain;
		
	noChain = (opts && opts.noChain) ||
			chains[path] ||
			parts.length < 2 ||
			(parts.length === 2 && path[0] == '$');
	
	if (observers[path] && !observers.hasOwnProperty(path)) {
		observers[path] = observers[path].slice();
	}
	
	entries = observers[path] || (observers[path] = []);
	entries[prio ? 'unshift' : 'push']({method: fn, ctx: ctx || this});
	
	if (!noChain) {
		this.getChains()[path] = new ObserverChain(path, this);
	}
	
	return this;
}

/**
* @private
*/
function removeObserver (obj, path, fn, ctx) {
	var observers = obj.getObservers(path)
		, chains = obj.getChains()
		, idx, chain;
		
	if (observers && observers.length) {
		idx = observers.findIndex(function (ln) {
			return ln.method === fn && (ctx? ln.ctx === ctx: true);
		});
		idx > -1 && observers.splice(idx, 1);
	}
	
	if ((chain = chains[path]) && !observers.length) {
		chain.destroy();
	}
	
	return obj;
}

/**
* @private
*/
function notifyObservers (obj, path, was, is, opts) {
	if (obj.isObserving()) {
		var observers = obj.getObservers(path);
		
		if (observers && observers.length) {
			for (var i=0, ln; (ln=observers[i]); ++i) {
				if (typeof ln.method == "string") obj[ln.method](was, is, path, opts);
				else ln.method.call(ln.ctx || obj, was, is, path, opts);
			}
		}
	} else enqueue(obj, path, was, is, opts);
	
	return obj;
}

/**
* @private
*/
function enqueue (obj, path, was, is, opts) {
	if (obj._notificationQueueEnabled) {
		var queue = obj._notificationQueue || (obj._notificationQueue = {})
			, ln = queue[path] || (queue[path] = {});
	
		ln.was = was;
		ln.is = is;
		ln.opts = opts;
	}
}

/**
* @private
*/
function flushQueue (obj) {
	var queue = obj._notificationQueue
		, path, ln;
	
	if (queue) {
		obj._notificationQueue = null;
		
		for (path in queue) {
			ln = queue[path];
			obj.notify(path, ln.was, ln.is, ln.opts);
		}
	}
}
	
/**
* Adds support for notifications on property changes. Most
* [kinds]{@glossary kind} (including all kinds that inherit from
* {@link enyo.Object}) already have this {@glossary mixin} applied.
* This allows for
* [observers]{@link enyo.ObserverSupport~Observer} to be
* [declared]{@link enyo.ObserverSupport.observers} or "implied" (see below).
*
* Implied observers are not declared, but derived from their `name`. They take
* the form `<property>Changed`, where `<property>` is the property to
* [observe]{@link enyo.ObserverSupport.observe}. For example:
*
* ```javascript
* enyo.kind({
* 	name: 'MyKind',
*
* 	// some local property
* 	value: true,
*
* 	// and the implied observer of that property
* 	valueChanged: function (was, is) {
* 		// do something now that it has changed
* 		enyo.log('value was "' + was + '" but now it is "' + is + '"');
* 	}
* });
*
* var mine = new MyKind();
* mine.set('value', false); // -> value was "true" but now it is "false"
* ```
*
* Using the `observers` property for its declarative syntax, an observer may
* observe any property (or properties), regardless of its `name`. For example:
*
* ```javascript
* enyo.kind({
* 	name: 'MyKind',
*
* 	// some local property
* 	value: true,
*
* 	// another local property
* 	count: 1,
*
* 	// declaring the observer
* 	observers: [
* 		// the path can be a single string or an array of strings
* 		{method: 'myObserver', path: ['value', 'count']}
* 	],
*
* 	// now this observer will be notified of changes to both properties
* 	myObserver: function (was, is, prop) {
* 		// do something now that it changed
* 		enyo.log(prop + ' was "' + was + '" but now it is "' + is + '"');
* 	}
* });
*
* var mine = new MyKind();
* mine.set('value', false); // -> value was "true" but now it is "false"
* mine.set('count', 2); // -> count was "1" but now it is "2"
* ```
*
* While observers may be [notified]{@link enyo.ObserverSupport.notify} of
* changes to multiple properties, this is not a typical use case for implied
* observers, since, by convention, they are only registered for the named
* property.
*
* There is one additional way to use observers, if necessary. You may use the
* API methods [observe()]{@link enyo.ObserverSupport.observe} and
* [unobserve()]{@link enyo.ObserverSupport.unobserve} to dynamically
* register and unregister observers as needed. For example:
*
* ```javascript
* var object = new enyo.Object({value: true});
* var observer = function (was, is) {
* 	enyo.log('value was "' + was + '" but now it is "' + is + '"');
* };
*
* object.observe('value', observer);
* object.set('value', false); // -> value was "true" but now it is "false"
* object.unobserve('value', observer);
* object.set('value', true); // no output because there is no observer
* ```
*
* Be sure to read the documentation for these API methods; proper usage of
* these methods is important for avoiding common pitfalls and memory leaks.
*
* @mixin enyo.ObserverSupport
* @public
*/
var ObserverSupport = module.exports = /** @lends enyo.ObserverSupport */ {
	
	/**
	* @private
	*/
	name: "ObserverSupport",
	
	/**
	* @private
	*/
	_observing: true,
	
	/**
	* @private
	*/
	_observeCount: 0,
	
	/**
	* @private
	*/
	_notificationQueue: null,
	
	/**
	* @private
	*/
	_notificationQueueEnabled: true,
	
	/**
	* Determines whether `_observing` is enabled. If
	* [stopNotifications()]{@link enyo.ObserverSupport.stopNotifications} has
	* been called, then this will return `false`.
	*
	* @see enyo.ObserverSupport.stopNotifications
	* @see enyo.ObserverSupport.startNotifications
	* @returns {Boolean} Whether or not the callee is observing.
	*/
	isObserving: function () {
		return this._observing;
	},
	
	/**
	* Returns an immutable list of [observers]{@link enyo.ObserverSupport~Observer}
	* for the given `path`, or all observers for the callee.
	*
	* @param {String} [path] - Path or property path for which
	* [observers]{@link enyo.ObserverSupport~Observer} will be returned. If not
	* specified, all observers for the callee will be returned.
	*
	* @returns {enyo.ObserverSupport~Observer[]} The immutable
	* [array]{@glossary Array} of observers.
	* @public
	*/
	getObservers: function (path) {
		var euid = this.euid || (this.euid = utils.uid('o')),
			ret,
			loc;
			
		loc = observerTable[euid] || (observerTable[euid] = (
			this._observers? Object.create(this._observers): {}
		));
		
		if (!path) return loc;
		
		ret = loc[path];
		
		// if the special property exists...
		if (loc['*']) ret = ret ? ret.concat(loc['*']) : loc['*'].slice();
		return ret;
	},
	
	/**
	* @private
	*/
	getChains: function () {
		return this._observerChains || (this._observerChains = {});
	},
	
	/**
	* @deprecated
	* @alias enyo.ObserverSupport.observe
	* @public
	*/
	addObserver: function () {
		// @NOTE: In this case we use apply because of internal variable use of parameters
		return addObserver.apply(this, arguments);
	},
	
	/**
	* Registers an [observer]{@link enyo.ObserverSupport~Observer} to be
	* [notified]{@link enyo.ObserverSupport.notify} when the given property has
	* been changed. It is important to note that it is possible to register the
	* same observer multiple times (although this is never the intention), so
	* care should be taken to avoid that scenario. It is also important to
	* understand how observers are stored and unregistered
	* ([unobserved]{@link enyo.ObserverSupport.unobserve}). The `ctx` (context)
	* parameter is stored with the observer reference. **If used when
	* registering, it should also be used when unregistering.**
	*
	* @see enyo.ObserverSupport.unobserve
	* @param {String} path - The property or property path to observe.
	* @param {enyo.ObserverSupport~Observer} fn - The
	*	[observer]{@link enyo.ObserverSupport~Observer} method that responds to changes.
	* @param {*} [ctx] - The `this` (context) under which to execute the observer.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	observe: function () {
		// @NOTE: In this case we use apply because of internal variable use of parameters
		return addObserver.apply(this, arguments);
	},
	
	/**
	* @deprecated
	* @alias enyo.ObserverSupport.unobserve
	* @public
	*/
	removeObserver: function (path, fn, ctx) {
		return removeObserver(this, path, fn);
	},
	
	/**
	* Unregisters an [observer]{@link enyo.ObserverSupport~Observer}. If a `ctx`
	* (context) was supplied to [observe()]{@link enyo.ObserverSupport.observe},
	* then it should also be supplied to this method.
	*
	* @see enyo.ObserverSupport.observe
	* @param {String} path - The property or property path to unobserve.
	* @param {enyo.ObserverSupport~Observer} fn - The
	*	[observer]{@link enyo.ObserverSupport~Observer} method that responds to changes.
	* @param {*} [ctx] - The `this` (context) under which to execute the observer.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	unobserve: function (path, fn, ctx) {
		return removeObserver(this, path, fn, ctx);
	},
	
	/**
	* Removes all [observers]{@link enyo.ObserverSupport~Observer} from the
	* callee. If a `path` parameter is provided, observers will only be removed
	* from that path (or property).
	*
	* @param {String} [path] - A property or property path from which to remove all
	*	[observers]{@link enyo.ObserverSupport~Observer}.
	* @returns {this} The callee for chaining.
	*/
	removeAllObservers: function (path) {
		var euid = this.euid
			, loc = euid && observerTable[euid];
		
		if (loc) {
			if (path) {
				loc[path] = null;
			} else {
				observerTable[euid] = null;
			}
		}
		
		return this;
	},
	
	/**
	* @deprecated
	* @alias enyo.ObserverSupport.notify
	* @public
	*/
	notifyObservers: function (path, was, is, opts) {
		return notifyObservers(this, path, was, is, opts);
	},
	
	/**
	* Triggers any [observers]{@link enyo.ObserverSupport~Observer} for the
	* given `path`. The previous and current values must be supplied. This
	* method is typically called automatically, but it may also be called
	* forcibly by [setting]{@link enyo.Object#set} a value with the
	* `force` option.
	*
	* @param {String} path - The property or property path to notify.
	* @param {*} was - The previous value.
	* @param {*} is - The current value.
	* @returns {this} The callee for chaining.
	*/
	notify: function (path, was, is, opts) {
		return notifyObservers(this, path, was, is, opts);
	},
	
	/**
	* Stops all [notifications]{@link enyo.ObserverSupport.notify} from
	* propagating. By default, all notifications will be queued and flushed once
	* [startNotifications()]{@link enyo.ObserverSupport.startNotifications}
	* has been called. Setting the optional `noQueue` flag will also disable the
	* queue, or you can use the
	* [disableNotificationQueue()]{@link enyo.ObserverSupport.disableNotificationQueue} and
	* [enableNotificationQueue()]{@link enyo.ObserverSupport.enableNotificationQueue}
	* API methods. `startNotifications()` will need to be called the same number
	* of times that this method has been called.
	*
	* @see enyo.ObserverSupport.startNotifications
	* @see enyo.ObserverSupport.disableNotificationQueue
	* @see enyo.ObserverSupport.enableNotificationQueue
	* @param {Boolean} [noQueue] - If `true`, this will also disable the notification queue.
	* @returns {this} The callee for chaining.
	*/
	stopNotifications: function (noQueue) {
		this._observing = false;
		this._observeCount++;
		noQueue && this.disableNotificationQueue();
		return this;
	},
	
	/**
	* Starts [notifications]{@link enyo.ObserverSupport.notify} if they have
	* been [disabled]{@link enyo.ObserverSupport.stopNotifications}. If the
	* notification queue was not disabled, this will automatically flush the
	* queue of all notifications that were encountered while stopped. This
	* method must be called the same number of times that
	* [stopNotifications()]{@link enyo.ObserverSupport.stopNotifications} was
	* called.
	*
	* @see enyo.ObserverSupport.stopNotifications
	* @see enyo.ObserverSupport.disableNotificationQueue
	* @see enyo.ObserverSupport.enableNotificationQueue
	* @param {Boolean} [queue] - If `true` and the notification queue is disabled,
	* the queue will be re-enabled.
	* @returns {this} The callee for chaining.
	*/
	startNotifications: function (queue) {
		this._observeCount && this._observeCount--;
		this._observeCount === 0 && (this._observing = true);
		queue && this.enableNotificationQueue();
		this.isObserving() && flushQueue(this);
		return this;
	},
	
	/**
	* Re-enables the notification queue, if it was disabled.
	*
	* @see enyo.ObserverSupport.disableNotificationQueue
	* @returns {this} The callee for chaining.
	*/
	enableNotificationQueue: function () {
		this._notificationQueueEnabled = true;
		return this;
	},
	
	/**
	* If the notification queue is enabled (the default), it will be disabled
	* and any notifications in the queue will be removed.
	*
	* @see enyo.ObserverSupport.enableNotificationQueue
	* @returns {this} The callee for chaining.
	*/
	disableNotificationQueue: function () {
		this._notificationQueueEnabled = false;
		this._notificationQueue = null;
		return this;
	},
	
	/**
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			var chains, chain, path, entries, i;
			
			// if there are any observers that need to create dynamic chains
			// we look for and instance those now
			if (this._observerChains) {
				chains = this._observerChains;
				this._observerChains = {};
				for (path in chains) {
					entries = chains[path];
					for (i = 0; (chain = entries[i]); ++i) this.observe(path, chain.method);
				}
			}
			
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			var chains = this._observerChains,
				path,
				chain;
			
			sup.apply(this, arguments);
			
			if (chains) {
				for (path in chains) {
					chain = chains[path];
					chain.destroy();
				}
				
				this._observerChains = null;
			}
		};
	})
	
};

/**
* Hijack the original so we can add additional default behavior.
*
* @private
*/
var sup = kind.concatHandler;

// @NOTE: It seems like a lot of work but it really won't happen that much and the more
// we push to kind-time the better for initialization time

/** @private */
kind.concatHandler = function (ctor, props, instance) {
	
	sup.call(this, ctor, props, instance);
	
	if (props === ObserverSupport) return;

	var proto = ctor.prototype || ctor
		, observers = proto._observers? Object.create(proto._observers): null
		, incoming = props.observers
		, chains = proto._observerChains && Object.create(proto._observerChains);
		
	if (!observers) {
		if (proto.kindName) observers = {};
		else return;
	}
		
	if (incoming && !(incoming instanceof Array)) {
		(function () {
			var tmp = [], deps, name;
			// here is the slow iteration over the properties...
			for (name in props.observers) {
				// points to the dependencies of the computed method
				deps = props.observers[name];
				// create a single entry now for the method/computed with all dependencies
				tmp.push({method: name, path: deps});
			}
			incoming = tmp;
		}());
		// we need to ensure we don't modify the fixed array of a mixin or reused object
		// because it could wind up inadvertantly adding the same entry multiple times
	} else if (incoming) incoming = incoming.slice();
	
	// this scan is required to figure out what auto-observers might be present
	for (var key in props) {
		if (key.slice(-7) == "Changed") {
			incoming || (incoming = []);
			incoming.push({method: key, path: key.slice(0, -7)});
		}
	}
	
	var addObserverEntry = function (path, method) {
		var obs;
		// we have to make sure that the path isn't a chain because if it is we add it
		// to the chains instead
		if (path.indexOf(".") > -1) {
			if (!chains) chains = {};
			obs = chains[path] || (chains[path] = []);
			obs.push({method: method});
		} else {
			if (observers[path] && !observers.hasOwnProperty(path)) observers[path] = observers[path].slice();
			obs = observers[path] || (observers[path] = []);
			if (!obs.find(function (ln) { return ln.method == method; })) obs.push({method: method});
		}
	};
	
	if (incoming) {
		incoming.forEach(function (ln) {
			// first we determine if the path itself is an array of paths to observe
			if (ln.path && ln.path instanceof Array) ln.path.forEach(function (en) { addObserverEntry(en, ln.method); });
			else addObserverEntry(ln.path, ln.method);
		});
	}
	
	// we clear the key so it will not be added to the prototype
	// delete props.observers;
	// we update the properties to whatever their new values may be
	proto._observers = observers;
	proto._observerChains = chains;
};
},{"../../enyo":1,"./ObserverChain":32,"./kind":66,"./utils":75}],17:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	logger = require('./logger'),
	utils = require('./utils');

var
	MixinSupport = require('./MixinSupport'),
	ObserverSupport = require('./ObserverSupport'),
	BindingSupport = require('./BindingSupport');
	
/**
* Used by all [objects]{@link enyo.Object} and [subkinds]{@glossary subkind} when using the
* {@link enyo.Object#log}, {@link enyo.Object#warn} and {@link enyo.Object#error} methods.
*
* @private
*/
function log (method, args) {
	if (logger.shouldLog(method)) {
		try {
			throw new Error();
		} catch(err) {
			logger._log(method, [args.callee.caller.displayName + ': ']
				.concat(utils.cloneArray(args)));
			logger.log(err.stack);
		}
	}
}

/**
* {@link enyo.Object} lies at the heart of the Enyo framework's implementations of property
* publishing, computed properties (via the {@link enyo.ComputedSupport} {@glossary mixin}),
* and data binding (via the {@link enyo.BindingSupport} mixin and {@link enyo.Binding}
* object). It also provides several utility [functions]{@glossary Function} for its
* [subkinds]{@glossary subkind}.
*
* @class enyo.Object
* @mixes enyo.MixinSupport
* @mixes enyo.ObserverSupport
* @mixes enyo.BindingSupport
* @public
*/
var CoreObject = module.exports = kind(
	/** @lends enyo.Object.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Object',

	/**
	* @private
	*/
	kind: null,

	/**
	* @private
	*/


	/**
	* Will be `true` if the [destroy()]{@link enyo.Object#destroy} method has been called;
	* otherwise, `false`.
	*
	* @readonly
	* @type {Boolean}
	* @default false
	* @public
	*/
	destroyed: false,

	/**
	* @private
	*/
	mixins: [MixinSupport, ObserverSupport, BindingSupport],

	/**
	* @private
	*/
	constructor: function (props) {
		this.importProps(props);
	},

	/**
	* Imports the values from the given [object]{@glossary Object}. Automatically called
	* from the [constructor]{@link enyo.Object#constructor}.
	*
	* @param {Object} props - If provided, the [object]{@glossary Object} from which to
	*	retrieve [keys/values]{@glossary Object.keys} to mix in.
	* @returns {this} The callee for chaining.
	* @public
	*/
	importProps: function (props) {
		var key;

		if (props) {
			kind.concatHandler(this, props, true);
			// if props is a default hash this is significantly faster than
			// requiring the hasOwnProperty check every time
			if (!props.kindName) {
				for (key in props) {
					kind.concatenated.indexOf(key) === -1 && (this[key] = props[key]);
				}
			} else {
				for (key in props) {
					if (kind.concatenated.indexOf(key) === -1 && props.hasOwnProperty(key)) {
						this[key] = props[key];
					}
				}
			}
		}
		
		return this;
	},
	
	/**
	* Calls the [destroy()]{@link enyo.Object#destroy} method for the named {@link enyo.Object} 
	* property.
	*
	* @param {String} name - The name of the property to destroy, if possible.
	* @returns {this} The callee for chaining.
	* @public
	*/
	destroyObject: function (name) {
		if (this[name] && this[name].destroy) {
			this[name].destroy();
		}
		this[name] = null;
		
		return this;
	},
	
	/**
	* Sends a log message to the [console]{@glossary console}, prepended with the name
	* of the {@glossary kind} and method from which `log()` was invoked. Multiple
	* {@glossary arguments} are coerced to {@glossary String} and
	* [joined with spaces]{@glossary Array.join}.
	*
	* ```javascript
	* enyo.kind({
	*	name: 'MyObject',
	*	kind: 'enyo.Object',
	*	hello: function() {
	*		this.log('says', 'hi');
	*		// shows in the console: MyObject.hello: says hi
	*	}
	* });
	* ```
	* @public
	*/
	log: function () {
		var acc = arguments.callee.caller,
			nom = ((acc ? acc.displayName : '') || '(instance method)') + ':',
			args = Array.prototype.slice.call(arguments);
		args.unshift(nom);
		logger.log('log', args);
	},
	
	/**
	* Same as [log()]{@link enyo.Object#log}, except that it uses the 
	* console's [warn()]{@glossary console.warn} method (if it exists).
	*
	* @public
	*/
	warn: function () {
		log('warn', arguments);
	},
	
	/**
	* Same as [log()]{@link enyo.Object#log}, except that it uses the 
	* console's [error()]{@glossary console.error} method (if it exists).
	*
	* @public
	*/
	error: function () {
		log('error', arguments);
	},

	/**
	* Retrieves the value for the given path. The value may be retrieved as long as the given 
	* path is resolvable relative to the given {@link enyo.Object}. See
	* [enyo.getPath()]{@link enyo.getPath} for complete details.
	*
	* This method is backwards-compatible and will automatically call any existing getter
	* method that uses the "getProperty" naming convention. (Moving forward, however, Enyo code
	* should use [computed properties]{@link enyo.ComputedSupport} instead of relying on the 
	* getter naming convention.)
	*
	* @param {String} path - The path from which to retrieve a value.
	* @returns {*} The value for the given path or [undefined]{@glossary undefined} if 
	*	the path could not be completely resolved.
	* @public
	*/
	get: function () {
		return utils.getPath.apply(this, arguments);
	},
	
	/**
	* Updates the value for the given path. The value may be set as long as the
	* given path is resolvable relative to the given {@link enyo.Object}. See
	* [enyo.setPath()]{@link enyo.setPath} for complete details.
	*
	* @param {String} path - The path for which to set the given value.
	* @param {*} value - The value to set.
	* @param {Object} [opts] - An options hash.
	* @returns {this} The callee for chaining.
	* @public
	*/
	set: function () {
		return utils.setPath.apply(this, arguments);
	},

	/**
	* Binds a [callback]{@glossary callback} to this [object]{@link enyo.Object}.
	* If the object has been destroyed, the bound method will be aborted cleanly,
	* with no value returned.
	*
	* This method should generally be used instead of {@link enyo.bind} for running
	* code in the context of an instance of {@link enyo.Object} or one of its
	* [subkinds]{@glossary subkind}.
	*
	* @alias enyo.bindSafely
	* @public
	*/
	bindSafely: function () {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(this);
		return utils.bindSafely.apply(null, args);
	},
	
	/**
	* An abstract method (primarily) that sets the [destroyed]{@link enyo.Object#destroyed} 
	* property to `true`.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	destroy: function () {
		
		// Since JS objects are never truly destroyed (GC'd) until all references are
		// gone, we might have some delayed action on this object that needs access
		// to this flag.
		// Using this.set to make the property observable
		return this.set('destroyed', true);
	}
});

/**
* @private
*/
CoreObject.concat = function (ctor, props) {
	var pubs = props.published,
		cpy,
		prop;
		
	if (pubs) {
		cpy = ctor.prototype || ctor;
		for (prop in pubs) {
			// need to make sure that even though a property is 'published'
			// it does not overwrite any computed properties
			if (props[prop] && typeof props[prop] == 'function') continue;
			addGetterSetter(prop, pubs[prop], cpy);
		}
	}
};

/**
* This method creates a getter/setter for a published property of an {@link enyo.Object}, but is
* deprecated. It is maintained for purposes of backwards compatibility. The preferred method is 
* to mark public and protected (private) methods and properties using documentation or other 
* means and rely on the [get]{@link enyo.Object#get} and [set]{@link enyo.Object#set} methods of
* {@link enyo.Object} instances.
*
* @private
*/
function addGetterSetter (prop, value, proto) {
	
	// so we don't need to re-execute this over and over and over...
	var cap = utils.cap(prop),
		getName = 'get' + cap,
		setName = 'set' + cap,
		getters = proto._getters || (proto._getters = {}),
		setters = proto._setters || (proto._setters = {}),
		fn;
	
	// we assign the default value from the published block to the prototype
	// so it will be initialized properly
	proto[prop] = value;
	
	// check for a supplied getter and if there isn't one we create one otherwise
	// we mark the supplied getter in the tracking object so the global getPath will
	// know about it
	if (!(fn = proto[getName]) || typeof fn != 'function') {
		fn = proto[getName] = function () {
			return utils.getPath.fast.call(this, prop);
		};
		
		// and we mark it as generated
		fn.generated = true;
	} else if (fn && typeof fn == 'function' && !fn.generated) getters[prop] = getName;
	
	// we need to do the same thing for the setters
	if (!(fn = proto[setName]) || typeof fn != 'function') {
		fn = proto[setName] = function (val) {
			return utils.setPath.fast.call(this, prop, val);
		};
		
		// and we mark it as generated
		fn.generated = true;
	} else if (fn && typeof fn == 'function' && !fn.generated) setters[prop] = setName;
}
},{"../../enyo":1,"./BindingSupport":9,"./MixinSupport":29,"./ObserverSupport":34,"./kind":66,"./logger":67,"./utils":75}],7:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	CoreObject = require('./CoreObject');

/**
* An abstract [kind]{@glossary kind} designed to aid in handling asynchronous operations.
* It represents a task that has not yet completed. Callback functions may be registered to be
* notified when the task is complete.
*
* For more information, see the documentation on [Consuming Web
* Services]{@linkplain $dev-guide/building-apps/managing-data/consuming-web-services.html}
* in the Enyo Developer Guide.
*
* @class enyo.Async
* @extends enyo.Object
* @public
*/
var Async = module.exports = kind(
	/** @lends enyo.Async.prototype */ {
	
	name: 'enyo.Async',
	
	/**
	* @private
	*/
	kind: CoreObject,
	
	/**
	* @private
	*/
	published: {
		
		/**
		* The number of milliseconds to wait after [execution]{@link enyo.Async#go} begins
		* before failing with a timeout error. If set to `0` (the default), will not
		* automatically throw a timeout error.
		*
		* @type {Number}
		* @default 0
		* @memberof enyo.Aysnc.prototype
		* @public
		*/
		timeout: 0
	},
	
	/**
	* Will be `true` if an error has occurred and a handler calls the
	* [fail()]{@link enyo.Async#fail} method. Can be cleared using
	* [recover()]{@link enyo.Async#recover}.
	*
	* @readonly
	* @type {Boolean}
	* @default false
	* @public
	*/
	failed: false,
	
	/**
	* @private
	*/
	context: null,
	
	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.responders = [];
			this.errorHandlers = [];
			this.progressHandlers = [];
		};
	}),
	
	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			if (this.timeoutJob) {
				this.clearTimeout();
			}
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	accumulate: function (array, fn, ctx) {
		var tmp;
		
		// to preserve backward compatibility we have to accept that the order of the arguments
		// might be different
		if (ctx && typeof ctx == 'function') {
			tmp = fn;
			fn = ctx;
			ctx = tmp;
		}
		
		// we go ahead and bind the method to its context to preserve the original
		// implementation
		if (ctx) {
			if (typeof ctx == "string") {
				fn = utils.bind(fn, ctx);
			} else {
				fn = fn.bind(ctx);
			}
		}
		
		// now store it for use later
		array.push(fn);
	},
	
	/**
	* Registers a [function]{@glossary Function} to be fired when
	* [execution]{@link enyo.Async#go} is completed successfully. Parameters may be
	* in any order, to preserve backward compatibility.
	*
	* @param {Function} fn - The callback to register.
	* @param {Object} [ctx] - The optional context under which to execute the callback.
	* @returns {this} The callee for chaining.
	* @public
	*/
	response: function (fn, ctx) {
		this.accumulate(this.responders, fn, ctx);
		return this;
	},
	
	/**
	* Registers a [function]{@glossary Function} to be fired when
	* [execution]{@link enyo.Async#go} completes with an error. Parameters may be
	* in any order, to preserve backward compatibility.
	*
	* @param {Function} fn - The callback to register.
	* @param {Object} [ctx] - The optional context under which to execute the callback.
	* @returns {this} The callee for chaining.
	* @public
	*/
	error: function (fn, ctx) {
		this.accumulate(this.errorHandlers, fn, ctx);
		return this;
	},
	
	/**
	* Registers a [function]{@glossary Function} to be fired on progress events.
	* Parameters may be in any order, to preserve backward compatibility.
	*
	* @param {Function} fn - The callback to register.
	* @param {Object} [ctx] - The optional context under which to execute the callback.
	* @returns {this} The callee for chaining.
	* @public
	*/
	progress: function (fn, ctx) {
		this.accumulate(this.progressHandlers, fn, ctx);
		return this;
	},
	
	/**
	* @private
	*/
	route: function (async, value) {
		var r = this.bindSafely('respond');
		async.response(function (sender, value) {
			r(value);
		});
		var f = this.bindSafely('fail');
		async.error(function (sender, value) {
			f(value);
		});
		async.go(value);
	},
	
	/**
	* @private
	*/
	handle: function (value, handlers) {
		var r = handlers.shift();
		if (r) {
			if (r instanceof Async) {
				this.route(r, value);
			} else {
				// handler can return a new 'value'
				var v = utils.call(this.context || this, r, [this, value]);
				// ... but only if it returns something other than undefined
				v = (v !== undefined) ? v : value;
				// next handler
				(this.failed ? this.fail : this.respond).call(this, v);
			}
		}
	},
	
	/**
	* @private
	*/
	startTimer: function () {
		this.startTime = utils.perfNow();
		if (this.timeout) {
			this.timeoutJob = setTimeout(this.bindSafely('timeoutComplete'), this.timeout);
		}
	},
	
	/**
	* @private
	*/
	endTimer: function () {
		if (this.timeoutJob) {
			this.endTime = utils.perfNow();
			clearTimeout(this.timeoutJob);
			this.timeoutJob = null;
			this.latency = this.endTime - this.startTime;
		}
	},
	
	/**
	* @private
	*/
	timeoutComplete: function () {
		this.timedout = true;
		this.fail('timeout');
	},
	
	/**
	* Triggers the handler chain for valid outcomes.
	*
	* @private
	*/
	respond: function (value) {
		this.failed = false;
		this.endTimer();
		this.handle(value, this.responders);
	},

	/**
	* Fails the [task]{@link enyo.Async} and triggers the error chain. May be called from any
	* handler.
	* 
	* @param {*} err - The error value to pass to error handlers.
	* @returns {this} The callee for chaining.
	* @public
	*/
	fail: function (err) {
		this.failed = true;
		this.endTimer();
		this.handle(err, this.errorHandlers);
		
		return this;
	},
	
	/**
	* Clears the error condition ([failed]{@link enyo.Async#failed}) by setting it to `false`.
	* If called while responding to handlers, it will continue.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	recover: function () {
		this.failed = false;
		return this;
	},
	
	/**
	* @private
	*/
	sendProgress: function(current, min, max, sourceEvent) {
		var event = utils.mixin({}, sourceEvent);
		event.type = 'progress';
		event.current = current;
		event.min = min;
		event.max = max;
		for (var i = 0; i < this.progressHandlers.length; i++) {
			utils.call(this.context || this, this.progressHandlers[i], [this, event]);
		}
	},
	
	/**
	* Initiates the asynchronous routine, supplying the given value if it completes
	* successfully. This method is usually overloaded in [subkinds]{@glossary subkind}.
	*
	* @virtual
	* @param {*} - value The value to pass to responders.
	* @returns {this} The callee for chaining.
	* @public
	*/
	go: function(value) {
		this.sendProgress(0, 0, 1);
		utils.asyncMethod(this, function() {
			this.sendProgress(1, 0, 1);
			this.respond(value);
		});
		return this;
	}
});
},{"../../enyo":1,"./CoreObject":17,"./kind":66,"./utils":75}],51:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	ModelList = require('./ModelList'),
	EventEmitter = require('./EventEmitter');
	CoreObject = require('./CoreObject');

/**
* Only necessary because of the order in which mixins are applied.
*
* @class
* @private
*/
var BaseStore = kind({
	kind: CoreObject,
	mixins: [EventEmitter]
});

/**
* This method should determine whether the given [model]{@link enyo.Model}
* should be included in the filtered set for the [find()]{@link enyo.Store#find}
* method.
* 
* @callback enyo.Store~Filter
* @param {enyo.Model} model - The [model]{@link enyo.Model} to filter.
* @returns {Boolean} `true` if the model meets the filter requirements;
* otherwise, `false`.
*/

/**
* The configuration options for the [find()]{@link enyo.Store#find} method.
* 
* @typedef {Object} enyo.Store~FindOptions
* @property {Boolean} all=true - Whether or not to include more than one match for the
*	filter method. If `true`, an array of matches is returned; otherwise, a single match.
* @property {Object} context - If provided, it will be used as the `this` (context) of
*	the filter method.
*/

/**
* An anonymous kind used internally for the singleton {@link enyo.store}.
* 
* @class enyo.Store
* @mixes enyo.EventEmitter
* @extends enyo.Object
* @protected
*/
var Store = kind(
	/** @lends enyo.Store.prototype */ {
	
	name: 'enyo.Store',
	
	/**
	* @private
	*/
	kind: BaseStore,
	
	/**
	* Finds a [model (or models)]{@link enyo.Model} of a certain [kind]{@glossary kind}.
	* It uses the return value from a filter method to determine whether a particular
	* model will be included. Set the optional `all` flag to `true` to ensure that
	* the method looks for all matches; otherwise, it will return the first positive
	* match.
	* 
	* @see {@glossary Array.find}
	* @param {enyo.Model} ctor - The constructor for the [kind]{@glossary kind} of
	*	[model]{@link enyo.Model} to be filtered.
	* @param {enyo.Store~Filter} fn - The filter method.
	* @param {enyo.Store~FindOptions} [opts] - The options parameter.
	* @returns {(enyo.Model|enyo.Model[]|undefined)} If the `all` flag is `true`,
	*	returns an array of models; otherwise, returns the first model that returned
	*	that returned `true` from the filter method. Returns `undefined` if `all` is
	* `false` and no match could be found.
	* @public
	*/
	find: function (ctor, fn, opts) {
		var kindName = ctor.prototype.kindName,
			list = this.models[kindName],
			options = {all: true, context: this};
		
		// allows the method to be called with a constructor only and will return an
		// immutable copy of the array of all models of that type or an empty array
		if (arguments.length == 1 || typeof fn != 'function') {
			return list ? list.slice() : [];
		}
		
		// ensure we use defaults with any provided options
		opts = opts ? utils.mixin({}, [options, opts]) : options;
			
		if (list) return opts.all ? list.filter(fn, opts.context) : list.find(fn, opts.context);
		
		// if it happens it could not find a list for the requested kind we fudge the return
		// so it can keep on executing
		else return opts.all ? [] : undefined;
	},
	
	/**
	* This method is an alias for [find()]{@link enyo.Store#find}.
	*
	* @deprecated
	* @public
	*/
	findLocal: function () {
		return this.find.apply(this, arguments);
	},
	
	/**
	* @private
	*/
	add: function (models, opts) {
		var ctor = models && (models instanceof Array ? models[0].ctor : models.ctor),
			kindName = ctor && ctor.prototype.kindName,
			list = kindName && this.models[kindName],
			added,
			i;
			
		// if we were able to find the list then we go ahead and attempt to add the models
		if (list) {
			added = list.add(models);
			// if we successfully added models and this was a default operation (not being
			// batched by a collection or other feature) we emit the event needed primarily
			// by relational models but could be useful other places
			if (added.length && (!opts || !opts.silent)) {
				for (i = 0; i < added.length; ++i) {
					this.emit(ctor, 'add', {model: added[i]});
				}
			}
		}
		
		return this;
	},
	
	/**
	* @private
	*/
	remove: function (models, opts) {
		var ctor = models && (models instanceof Array ? models[0].ctor : models.ctor),
			kindName = ctor && ctor.prototype.kindName,
			list = kindName && this.models[kindName],
			removed,
			i;
		
		// if we were able to find the list then we go ahead and attempt to remove the models
		if (list) {
			removed = list.remove(models);
			// if we successfully removed models and this was a default operation (not being
			// batched by a collection or other feature) we emit the event. Needed primarily
			// by relational models but could be useful other places
			if (removed.length && (!opts || !opts.silent)) {
				for (i = 0; i < removed.length; ++i) {
					this.emit(ctor, 'remove', {model: removed[i]});
				}
			}
		}
		
		return this;
	},
	
	/**
	* Determines, from the given parameters, whether the [store]{@link enyo.store}
	* has a specific [model]{@link enyo.Model}.
	*
	* @param {(Function|enyo.Model)} ctor Can be the constructor for an {@link enyo.Model}
	*	or a model instance. Must be a constructor unless a model instance is passed as the
	* optional `model` parameter.
	* @param {(String|Number|enyo.Model)} [model] If the `ctor` parameter is a
	*	constructor, this may be a [Number]{@glossary Number} or a [String]{@glossary String}
	* representing a [primaryKey]{@link enyo.Model#primaryKey} for the given model, or an
	*	instance of a model.
	* @returns {Boolean} Whether or not the [store]{@link enyo.store} has the given
	*	[model]{@link enyo.Model}.
	* @public
	*/
	has: function (ctor, model) {
		var list;
		
		if (!model) {
			model = ctor;
			ctor = model.ctor;
		}
		
		list = this.models[ctor.prototype.kindName];
		return list ? list.has(model) : false;
	},
	
	/**
	* @private
	*/
	resolve: function (ctor, model) {
		var list = this.models[ctor && ctor.prototype.kindName];
		return list? list.resolve(model): undefined;
	},
	
	/**
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			
			this._scopeListeners = [];
			
			// all future sub-kinds of enyo.Model that are processed will automatically
			// create/add their entries to this object in their concat method
			this.models = {
				'enyo.Model': new ModelList()
			};
		};
	}),
	
	/**
	* @private
	*/
	scopeListeners: function (scope, e) {
		return !scope ? this._scopeListeners : this._scopeListeners.filter(function (ln) {
			return ln.scope === scope ? !e ? true : ln.event == e : false;
		});
	},
	
	/**
	* @private
	*/
	on: kind.inherit(function (sup) {
		return function (ctor, e, fn, ctx) {
			if (typeof ctor == 'function') {
				this.scopeListeners().push({
					scope: ctor,
					event: e,
					method: fn,
					ctx: ctx || this
				});
				
				return this;
			}
			
			return sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	off: kind.inherit(function (sup) {
		return function (ctor, e, fn) {
			var listeners,
				idx;
			
			if (typeof ctor == 'function') {
				listeners = this.scopeListeners(ctor);
				if (listeners.length) {
					idx = listeners.findIndex(function (ln) {
						return ln.event == e && ln.method === fn;
					});
					
					// if it found the entry we remove it
					if (idx >= 0) listeners.splice(idx, 1);
				}
				return this;
			}
		};
	}),
	
	/**
	* @private
	*/
	emit: kind.inherit(function (sup) {
		return function (ctor, e) {
			var listeners,
				args;
			
			if (typeof ctor == 'function') {
				listeners = this.scopeListeners(ctor, e);
				
				if (listeners.length) {
					args = utils.toArray(arguments).slice(1);
					args.unshift(this);
					listeners.forEach(function (ln) {
						ln.method.apply(ln.ctx, args);
					});
					return true;
				}
				return false;
			}
			
			return sup.apply(this, arguments);
		};
	})
});

/**
* A runtime database for working with [models]{@link enyo.Model}. It is primarily used
* internally by data layer [kinds]{@glossary kind} ({@link enyo.Model},
* {@link enyo.Collection}, and {@link enyo.RelationalModel}).
* 
* @see enyo.Model
* @see enyo.Collection
* @see enyo.RelationalModel
* @type enyo.Store
* @memberof enyo
* @public
*/
module.exports = new Store();
},{"../../enyo":1,"./CoreObject":17,"./EventEmitter":19,"./ModelList":31,"./kind":66,"./utils":75}],64:[function(require,module,exports){
require('../../enyo');

var
	utils = require('./utils'),
	kind = require('./kind');
	
var CoreObject = require('./CoreObject');

/**
* The {@link enyo.jobs} singleton provides a mechanism for queueing tasks
* (i.e., functions) for execution in order of priority. The execution of the
* current job stack may be blocked programmatically by setting a priority
* level (run level) below which no jobs are executed.
*
* At the moment, only {@link enyo.Animator} uses this interface, setting a
* priority of 4, which blocks all low priority tasks from executing during
* animations. To maintain backward compatibility, jobs are assigned a priority
* of 5 by default; thus they are not blocked by animations.
*
* Normally, application code will not use `enyo.jobs` directly, but will
* instead use the [job()]{@link enyo.Component#job} method of
* {@link enyo.Component}.
*
* @name enyo.jobs
* @public
*/
module.exports = kind.singleton(
	/** @lends enyo.jobs */ {
	
	kind: CoreObject,
	
	/**
	* @private
	*/
	published: /** @lends enyo.jobs */ {
		
		/**
		* The current priority level.
		*
		* @type {Number}
		* @default 0
		* @public
		*/
		priorityLevel: 0
	},
	
	/**
	* Prioritized by index.
	*
	* @private
	*/
	_jobs: [ [], [], [], [], [], [], [], [], [], [] ],
	
	/**
	* @private
	*/
	_priorities: {},
	
	/**
	* @private
	*/
	_namedJobs: {},
	
	/**
	* @private
	*/
	_magicWords: {
		'low': 3,
		'normal': 5,
		'high': 7
	},
	
	/**
	* Adds a [job]{@link enyo.job} to the job queue. If the current priority
	* level is higher than this job's priority, this job gets deferred until the
	* job level drops; if it is lower, this job is run immediately.
	*
	* @param {Function} job - The actual {@glossary Function} to execute as the
	* [job]{@link enyo.job}.
	* @param {Number} priority - The priority of the job.
	* @param {String} nom - The name of the job for later reference.
	* @public
	*/
	add: function (job, priority, nom) {
		priority = priority || 5;

		// magic words: low = 3, normal = 5, high = 7
		priority = utils.isString(priority) ? this._magicWords[priority] : priority;

		// if a job of the same name exists, remove it first (replace it)
		if(nom){
			this.remove(nom);
			this._namedJobs[nom] = priority;
		}

		// if the job is of higher priority than the current priority level then
		// there's no point in queueing it
		if(priority >= this.priorityLevel){
			job();
		} else {
			this._jobs[priority - 1].push({fkt: job, name: nom});
		}
	},
	
	/**
	* Will remove the named [job]{@link enyo.job} from the queue.
	*
	* @param {String} nom - The name of the [job]{@link enyo.job} to remove.
	* @returns {Array} An {@glossary Array} that will contain the removed job if
	* it was found, or empty if it was not found.
	* @public
	*/
	remove: function (nom) {
		var jobs = this._jobs[this._namedJobs[nom] - 1];
		if(jobs){
			for(var j = jobs.length-1; j >= 0; j--){
				if(jobs[j].name === nom){
					return jobs.splice(j, 1);
				}
			}
		}
	},
	
	/**
	* Adds a new priority level at which jobs will be executed. If it is higher than the
	* highest current priority, the priority level rises. Newly added jobs below that priority
	* level are deferred until the priority is removed (i.e., unregistered).
	*
	* @param {Number} priority - The priority value to register.
	* @param {String} id - The name of the priority.
	* @public
	*/
	registerPriority: function(priority, id) {
		this._priorities[id] = priority;
		this.setPriorityLevel( Math.max(priority, this.priorityLevel) );
	},
	
	/**
	* Removes a priority level. If the removed priority was previously the
	* highest priority, the priority level drops to the next highest priority
	* and queued jobs with a higher priority are executed.
	*
	* @param {String} id - The name of the priority level to remove.
	* @public
	*/
	unregisterPriority: function (id) {
		var highestPriority = 0;

		// remove priority
		delete this._priorities[id];

		// find new highest current priority
		for( var i in this._priorities ){
			highestPriority = Math.max(highestPriority, this._priorities[i]);
		}

		this.setPriorityLevel( highestPriority );
	},
	
	/**
	* Tries to run next job if priority level has dropped.
	*
	* @type {enyo.ObserverSupport~Observer}
	* @private
	*/
	priorityLevelChanged: function (was) {
		if(was > this.priorityLevel){
			this._doJob();
		}
	},
	
	/**
	* Finds and executes the job of highest priority; in this way, all jobs with priority
	* greater than or equal to the current level are run, in order of their priority (highest
	* to lowest).
	*
	* @private
	*/
	_doJob: function () {
		var job;
		// find the job of highest priority above the current priority level
		// and remove from the job list
		for (var i = 9; i >= this.priorityLevel; i--){
			if (this._jobs[i].length) {
				job = this._jobs[i].shift();
				break;
			}
		}

		// allow other events to pass through
		if (job) {
			job.fkt();
			delete this._namedJobs[job.name];
			setTimeout(utils.bind(this, '_doJob'), 10);
		}
	}
});
},{"../../enyo":1,"./CoreObject":17,"./kind":66,"./utils":75}],2:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	json = require('./json'),
	logger = require('./logger');

var
	AjaxProperties = require('./AjaxProperties'),
	Async = require('./Async'),
	FormData = require('./FormData'),
	Xhr = require('./xhr');
	

/**
* A cache of response properties set on the {@link enyo.Ajax} instance once it has completed
* its request.
*
* @typedef {Object} enyo.Ajax~xhrResponse
* @property {Number} status - The response status.
* @property {Object} headers - The headers used for the request.
* @property {String} body - The request body.
* @public
*/

/**
* A [kind]{@glossary kind} designed to expose the native
* [XMLHttpRequest]{@glossary XMLHttpRequest} API. Available configuration options
* are exposed by {@link enyo.AjaxProperties}.
*
* This kind does not extend {@link enyo.Component} and cannot be used
* in the [components block]{@link enyo.Component#components}.
*
* For more information, see the documentation on [Consuming Web
* Services]{@linkplain $dev-guide/building-apps/managing-data/consuming-web-services.html}
* in the Enyo Developer Guide.
*
* @class enyo.Ajax
* @extends enyo.Async
* @public
*/
var Ajax = module.exports = kind(
	/** @lends enyo.Ajax.prototype */ {
	
	name: 'enyo.Async',
	
	/**
	* @private
	*/
	kind: Async,
	
	/**
	* @private
	*/
	published: AjaxProperties,
	
	/**
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function (inParams) {
			utils.mixin(this, inParams);
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			// explicilty release any XHR refs
			this.xhr = null;
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* This will be set once a request has completed (successfully or unsuccessfully).
	* It is a cache of the response values.
	*
	* @type enyo.Ajax~xhrResponse
	* @default null
	* @public
	*/
	xhrResponse: null,
	
	/**
	* Executes the request with the given options. The parameter may be a
	* [hash]{@glossary Object} of properties or a [string]{@glossary String}. Both
	* represent the query string, with the hash being serialized and the string
	* being used directly.
	*
	* ```javascript
	* var query = {q: 'searchTerm'}; // -> "?q=searchTerm"
	* ```
	*
	* To provide a `POST` body, see {@link enyo.AjaxProperties.postBody}.
	*
	* When the request is completed, it will set the
	* [xhrResponse]{@link enyo.Ajax#xhrResponse} property.
	*
	* @see enyo.AjaxProperties
	* @see enyo.Ajax.xhrResponse
	* @see enyo.Ajax~xhrResponse
	* @param {(Object|String)} [params] - A [string]{@glossary String} or
	*	[hash]{@glossary Object} to be used as the query string.
	* @returns {this} The callee for chaining.
	* @public
	*/
	go: function (params) {
		this.failed = false;
		this.startTimer();
		this.request(params);
		return this;
	},
	
	/**
	* @private
	*/
	request: function (params) {
		var parts = this.url.split('?');
		var uri = parts.shift() || '';
		var args = parts.length ? (parts.join('?').split('&')) : [];
		//
		var query = null;
		//
		if(utils.isString(params)){
			//If params parameter is a string, use it as request body
			query = params;
		}
		else{
			//If params parameter is not a string, build a query from it
			if(params){
				query = Ajax.objectToQuery(params);
			}
		}
		//
		if (query) {
			args.push(query);
			query = null;
		}
		if (this.cacheBust) {
			args.push(Math.random());
		}
		//
		var url = args.length ? [uri, args.join('&')].join('?') : uri;
		//
		var xhr_headers = {};
		var body;
		if (this.method != 'GET') {
			body = this.postBody;
			if (this.method === 'POST' && body instanceof FormData) {
				if (body.fake) {
					xhr_headers['Content-Type'] = body.getContentType();
					body = body.toString();
				} else {
					// Nothing to do as the
					// content-type will be
					// automagically set according
					// to the FormData
				}
			} else {
				xhr_headers['Content-Type'] = this.contentType;
				if (body instanceof Object) {
					if (this.contentType.match(/^application\/json(;.*)?$/) !== null) {
						body = JSON.stringify(body);
					} else if (this.contentType === 'application/x-www-form-urlencoded') {
						body = Ajax.objectToQuery(body);
					}
					else {
						body = body.toString();
					}
				}
			}
		}
		utils.mixin(xhr_headers, this.headers);
		// don't pass in headers structure if there are no headers defined as this messes
		// up CORS code for IE8-9
		if (utils.keys(xhr_headers).length === 0) {
			xhr_headers = undefined;
		}
		//
		try {
			this.xhr = Xhr.request({
				url: url,
				method: this.method,
				callback: this.bindSafely('receive'),
				body: body,
				headers: xhr_headers,
				sync: this.sync,
				username: this.username,
				password: this.password,
				xhrFields: utils.mixin({onprogress: this.bindSafely(this.updateProgress)}, this.xhrFields),
				mimeType: this.mimeType
			});
		}
		catch (e) {
			// IE can throw errors here if the XHR would fail CORS checks,
			// so catch and turn into a failure.
			this.fail(e);
		}
	},
	
	/**
	* @private
	*/
	receive: function (inText, inXhr) {
		if (!this.failed && !this.destroyed) {
			var body;
			if (inXhr.responseType === 'arraybuffer') {
				body = inXhr.response;
			} else if (typeof inXhr.responseText === 'string') {
				body = inXhr.responseText;
			} else {
				// IE carrying a binary
				body = inXhr.responseBody;
			}
			this.xhrResponse = {
				status: inXhr.status,
				headers: Ajax.parseResponseHeaders(inXhr),
				body: body
			};
			if (this.isFailure(inXhr)) {
				this.fail(inXhr.status);
			} else {
				this.respond(this.xhrToResponse(inXhr));
			}
		}
	},
	
	/**
	* @private
	*/
	fail: kind.inherit(function (sup) {
		return function (inError) {
			// on failure, explicitly cancel the XHR to prevent
			// further responses.  cancellation also resets the
			// response headers & body,
			if (this.xhr) {
				Xhr.cancel(this.xhr);
				this.xhr = null;
			}
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* @private
	*/
	xhrToResponse: function (inXhr) {
		if (inXhr) {
			return this[(this.handleAs || 'text') + 'Handler'](inXhr);
		}
	},
	
	/**
	* @private
	*/
	isFailure: function (inXhr) {
		// if any exceptions are thrown while checking fields in the xhr,
		// assume a failure.
		try {
			if (inXhr.responseType === 'arraybuffer') {
				// if we are loading binary data, don't try to access inXhr.responseText
				// because that throws an exception on webkit. Instead, just look for
				// the response.
				if (inXhr.status === 0 && !inXhr.response) {
					return true;
				}
			} else {
				var text = '';
				// work around IE8-9 bug where accessing responseText will thrown error
				// for binary requests.
				if (typeof inXhr.responseText === 'string') {
					text = inXhr.responseText;
				}
				// Follow same failure policy as jQuery's Ajax code
				// CORS failures on FireFox will have status 0 and no responseText,
				// so treat that as failure.
				if (inXhr.status === 0 && text === '') {
					return true;
				}
			}
			// Otherwise, status 0 may be good for local file access.  We treat the range
			// 1-199 and 300+ as failure (only 200-series code are OK).
			return (inXhr.status !== 0) && (inXhr.status < 200 || inXhr.status >= 300);
		}
		catch (e) {
			return true;
		}
	},
	
	/**
	* @private
	*/
	xmlHandler: function (inXhr) {
		return inXhr.responseXML;
	},
	
	/**
	* @private
	*/
	textHandler: function (inXhr) {
		return inXhr.responseText;
	},
	
	/**
	* @private
	*/
	jsonHandler: function (inXhr) {
		var r = inXhr.responseText;
		try {
			return r && json.parse(r);
		} catch (x) {
			logger.warn('Ajax request set to handleAs JSON but data was not in JSON format');
			return r;
		}
	},
	
	/**
	* @private
	*/
	binaryHandler: function (inXhr) {
		return inXhr.response;
	}, 
	
	/**
	* @private
	*/
	updateProgress: function (event) {
		// IE8 doesn't properly support progress events and doesn't pass an object to the
		// handlers so we'll check that before continuing.
		if (event) {
			// filter out 'input' as it causes exceptions on some Firefox versions
			// due to unimplemented internal APIs
			var ev = {};
			for (var k in event) {
				if (k !== 'input') {
					ev[k] = event[k];
				}
			}
			this.sendProgress(event.loaded, 0, event.total, ev);
		}
	},
	
	/**
	* @private
	*/
	statics: {
		objectToQuery: function (/*Object*/ map) {
			var enc = encodeURIComponent;
			var pairs = [];
			var backstop = {};
			for (var name in map){
				var value = map[name];
				if (value != backstop[name]) {
					var assign = enc(name) + '=';
					if (utils.isArray(value)) {
						for (var i=0; i < value.length; i++) {
							pairs.push(assign + enc(value[i]));
						}
					} else {
						pairs.push(assign + enc(value));
					}
				}
			}
			return pairs.join('&');
		}
	},
	
	/**
	* @private
	*/
	protectedStatics: {
		parseResponseHeaders: function (xhr) {
			var headers = {};
			var headersStr = [];
			if (xhr.getAllResponseHeaders) {
				headersStr = xhr.getAllResponseHeaders().split(/\r?\n/);
			}
			for (var i = 0; i < headersStr.length; i++) {
				var headerStr = headersStr[i];
				var index = headerStr.indexOf(': ');
				if (index > 0) {
					var key = headerStr.substring(0, index).toLowerCase();
					var val = headerStr.substring(index + 2);
					headers[key] = val;
				}
			}
			return headers;
		}
	}
});
},{"../../enyo":1,"./AjaxProperties":3,"./Async":7,"./FormData":20,"./json":65,"./kind":66,"./logger":67,"./utils":75,"./xhr":76}],30:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	ObserverSupport = require('./ObserverSupport'),
	ComputedSupport = require('./ComputedSupport'),
	BindingSupport = require('./BindingSupport'),
	EventEmitter = require('./EventEmitter'),
	StateSupport = require('./StateSupport'),
	ModelList = require('./ModelList'),
	Source = require('./Source'),
	States = require('./States'),
	Store = require('./Store');

/**
* This is only necessary because of the order in which mixins are applied.
*
* @class
* @private
*/
var BaseModel = kind({
	kind: null,
	mixins: [ObserverSupport, ComputedSupport, BindingSupport, EventEmitter, StateSupport]
});

/**
* The event emitted when [attributes]{@link enyo.Model#attributes} have been modified.
* The event [object]{@glossary Object} will consist of key/value pairs of attributes
* that changed and their new values.
*
* @event enyo.Model#change
* @type {Object}
* @public
*/

/**
* The default configurable [options]{@link enyo.Model#options} used in certain API methods
* of {@link enyo.Model}.
*
* @typedef {Object} enyo.Model~Options
* @property {Boolean} silent=false - Keep events and notifications from being emitted.
* @property {Boolean} commit=false - Immediately [commit]{@link enyo.Model#commit} changes
*	after they have occurred. Also note that, if `true`, when the [model]{@link enyo.Model}
* is [destroyed]{@link enyo.Model#destroy}, it will also be destroyed via any
* [sources]{@link enyo.Model#source} it has.
* @property {Boolean} parse=false - During initialization, [parse]{@link enyo.Model#parse}
*	any given [attributes]{@link enyo.Model#attributes}; after
*	[fetching]{@link enyo.Model#fetch}, parse the data before calling
* [set()]{@link enyo.Model#set}.
* @property {Boolean} fetch=false - Automatically call [fetch()]{@link enyo.Model#fetch}
*	during initialization.
*/

/**
* The configurable options for [fetch()]{@link enyo.Model#fetch},
* [commit()]{@link enyo.Model#commit}, and [destroy()]{@link enyo.Model#destroy}.
*
* @typedef {enyo.Model~Options} enyo.Model~ActionOptions
* @property {enyo.Model~Success} success - The callback executed upon successful
*	completion.
* @property {enyo.Model~Error} error - The callback executed upon a failed attempt.
*/

/**
* @callback enyo.Model~Success
* @param {enyo.Model} model - The [model]{@link enyo.Model} that is returning successfully.
* @param {enyo.Model~ActionOptions} opts - The original options passed to the action method
*	that is returning successfully.
* @param {*} res - The result, if any, returned by the [source]{@link enyo.Source} that
*	executed it.
* @param {String} source - The name of the [source]{@link enyo.Model#source} that has
* returned successfully.
*/

/**
* @callback enyo.Model~Error
* @param {enyo.Model} model - The model that is returning an error.
* @param {String} action - The name of the action that failed, one of `'FETCHING'`,
*	`'COMMITTING'`, or `'DESTROYING'`.
* @param {enyo.Model~Options} opts - The original options passed to the action method
*	that is returning an error.
* @param {*} res - The result, if any, returned by the [source]{@link enyo.Source} that
*	executed it.
* @param {String} source - The name of the [source]{@link enyo.Model#source} that has
*	returned an error.
*/

/**
* An [object]{@glossary Object} used to represent and maintain state. Usually,
* an {@link enyo.Model} is used to expose data to the view layer. It keeps logic
* related to the data (retrieving it, updating it, storing it, etc.) out of the
* view, and the view can automatically update based on changes in the model.
* Models have the ability to work with other data layer [kinds]{@glossary kind}
* to provide more sophisticated implementations.
*
* Models have [bindable]{@link enyo.BindingSupport}
* [attributes]{@link enyo.Model#attributes}. Models differs from other
* bindable kinds in that attribute values are proxied from an internal
* [hash]{@glossary Object} instead of being set on the target properties
* directly.
*
* @see enyo.Store
* @see enyo.Collection
* @see enyo.RelationalModel
* @see enyo.ModelController
* @class enyo.Model
* @mixes enyo.ObserverSupport
* @mixes enyo.ComputedSupport
* @mixes enyo.BindingSupport
* @mixes enyo.EventEmitter
* @mixes enyo.StateSupport
* @public
*/
var Model = module.exports = kind(
	/** @lends enyo.Model.prototype */ {

	name: 'enyo.Model',

	/**
	* @private
	*/
	kind: BaseModel,

	/**
	* @private
	*/


	/**
	* Used by various [sources]{@link enyo.Model#source} as part of the
	* [URI]{@glossary URI} from which they may be [fetched]{@link enyo.Model#fetch},
	* [committed]{@link enyo.Model#commit}, or [destroyed]{@link enyo.Model#destroy}.
	* Some sources may use this property in other ways.
	*
	* @see enyo.Model.getUrl
	* @see enyo.Source
	* @see enyo.AjaxSource
	* @see enyo.JsonpSource
	* @type {String}
	* @default ''
	* @public
	*/
	url: '',

	/**
	* Implement this method to be used by [sources]{@link enyo.Model#source} to
	* dynamically derive the [URI]{@glossary URI} from which they may be
	* [fetched]{@link enyo.Model#fetch}, [committed]{@link enyo.Model#commit},
	* or [destroyed]{@link enyo.Model#destroy}. Some sources may use this
	* property in other ways. Note that, if this method is implemented, the
	* [url]{@link enyo.Model#url} will not be used.
	*
	* @see enyo.Model.url
	* @see enyo.Source
	* @see enyo.AjaxSource
	* @see enyo.JsonpSource
	* @type {Function}
	* @default null
	* @virtual
	* @public
	*/
	getUrl: null,

	/**
	* The [hash]{@glossary Object} of properties proxied by this [model]{@link enyo.Model}.
	* If defined on a [subkind]{@glossary subkind}, it may be assigned default values and
	* all instances will share its default structure. If no attributes are defined, an
	* empty [hash]{@glossary Object} will be assigned during initialization. It is not
	* necessary to pre-define the structure of a model; depending on the model's complexity,
	* pre-defining the structure may possibly hinder performance.
	*
	* It should also be noted that calls to [get()]{@link enyo.Model#get} or
	* [set()]{@link enyo.Model#set} will access and modify this property. This includes
	* the values to which (or from which) [bindings]{@link enyo.BindingSupport} are bound.
	*
	* @type {Object}
	* @default null
	* @public
	*/
	attributes: null,

	/**
	* The [source(s)]{@link enyo.Source} to use when [fetching]{@link enyo.Model#fetch},
	* [committing]{@link enyo.Model#commit}, or [destroying]{@link enyo.Model#destroy}.
	* Any method that uses sources may override this default value in its configuration
	* options. This value may be a [string]{@glossary String}, an
	* [Array]{@glossary Array} of strings, an instance of {@link enyo.Source}, or an
	* array of `enyo.Source` instances.
	*
	* @see enyo.Source
	* @see enyo.Model.fetch
	* @see enyo.Model.commit
	* @see enyo.Model.destroy
	* @type {(String|String[]|enyo.Source|enyo.Source[])}
	* @default null
	* @public
	*/
	source: null,

	/**
	* These [keys]{@glossary Object.keys} will be the only
	* [attributes]{@link enyo.Model#attributes} included if the
	* [model]{@link enyo.Model} is [committed]{@link enyo.Model#commit}. This
	* directly modifies the result of calling [raw()]{@link enyo.Model#raw}. If
	* not defined, all keys from the [attributes]{@link enyo.Model#attributes}
	* [hash]{@glossary Object} will be used.
	*
	* @see enyo.Model.raw
	* @see enyo.Model.toJSON
	* @type {String[]}
	* @default null
	* @public
	*/
	includeKeys: null,

	/**
	* The inheritable default configuration options. These specify the behavior of particular
	* API features of {@link enyo.Model}. Any method that uses these options may override
	* the default values in its own configuration options. Note that setting an
	* [options hash]{@glossary Object} on a [subkind]{@glossary subkind} will result in
	* the new values' being merged with--not replacing--the
	* [superkind's]{@glossary superkind} own `options`.
	*
	* @type {enyo.Model~Options}
	* @public
	*/
	options: {
		silent: false,
		commit: false,
		parse: false,
		fetch: false
	},

	/**
	* The current [state(s)]{@link enyo.States} possessed by the [model]{@link enyo.Model}.
	* There are limitations as to which state(s) the model may possess at any given time.
	* By default, a model is [NEW]{@link enyo.States.NEW} and [CLEAN]{@link enyo.States.CLEAN}.
	* Note that this is **not** a [bindable]{@link enyo.BindingSupport} property.
	*
	* @see enyo.States
	* @see enyo.StateSupport
	* @type {enyo.States}
	* @readonly
	* @public
	*/
	status: States.NEW | States.CLEAN,

	/**
	* The unique attribute by which the [model]{@link enyo.Model} may be indexed. The
	* attribute's value must be unique across all instances of the specific model
	* [kind]{@glossary kind}
	*
	* @type {String}
	* @default 'id'
	* @public
	*/
	primaryKey: 'id',

	/**
	* Inspects and restructures incoming data prior to [setting]{@link enyo.Model#set} it on
	* the [model]{@link enyo.Model}. While this method may be called directly, it is most
	* often used via the [parse]{@link enyo.Model~Options.parse} option and executed
	* automatically, either during initialization or when [fetched]{@link enyo.Model#fetch}
	* (or, in some cases, both). This is a virtual method and must be provided to suit a
	* given implementation's needs.
	*
	* @see enyo.Model~Options.parse
	* @param {*} data - The incoming data that may need to be restructured or reduced prior to
	*	being [set]{@link enyo.Model#set} on the [model]{@link enyo.Model}.
	* @returns {Object} The [hash]{@glossary Object} to apply to the
	*	model via [set()]{@link enyo.Model#set}.
	* @virtual
	* @public
	*/
	parse: function (data) {
		return data;
	},

	/**
	* Returns an [Object]{@glossary Object} that represents the underlying data structure
	* of the [model]{@link enyo.Model}. This is dependent on the current
	* [attributes]{@link enyo.Model#attributes} as well as the
	* [includeKeys]{@link enyo.Model#includeKeys}.
	* [Computed properties]{@link enyo.ComputedSupport} are **never** included.
	*
	* @see enyo.Model.includeKeys
	* @see enyo.Model.attributes
	* @returns {Object} The formatted [hash]{@glossary Object} representing the underlying
	*	data structure of the [model]{@link enyo.Model}.
	* @public
	*/
	raw: function () {
		var inc = this.includeKeys
			, attrs = this.attributes
			, keys = inc || Object.keys(attrs)
			, cpy = inc? utils.only(inc, attrs): utils.clone(attrs);
		keys.forEach(function (key) {
			var ent = this.get(key);
			if (typeof ent == 'function') cpy[key] = ent.call(this);
			else if (ent && ent.raw) cpy[key] = ent.raw();
			else cpy[key] = ent;
		}, this);
		return cpy;
	},

	/**
	* Returns the [JSON]{@glossary JSON} serializable [raw()]{@link enyo.Model#raw} output
	* of the [model]{@link enyo.Model}. Will automatically be executed by
	* [JSON.parse()]{@glossary JSON.parse}.
	*
	* @see enyo.Model.raw
	* @returns {Object} The return value of [raw()]{@link enyo.Model#raw}.
	* @public
	*/
	toJSON: function () {

		// @NOTE: Because this is supposed to return a JSON parse-able object
		return this.raw();
	},

	/**
	* Restores an [attribute]{@link enyo.Model#attributes} to its previous value. If no
	* attribute is specified, all previous values will be restored.
	*
	* @see enyo.Model.set
	* @see enyo.Model.previous
	* @param {String} [prop] - The [attribute]{@link enyo.Model#attributes} to
	*	[restore]{@link enyo.Model#restore}. If not provided, all attributes will be
	* restored to their previous values.
	* @returns {this} The callee for chaining.
	* @public
	*/
	restore: function (prop) {

		// we ensure that the property is forcibly notified (when possible) to ensure that
		// bindings or other observers will know it returned to that value
		if (prop) this.set(prop, this.previous[prop], {force: true});
		else this.set(this.previous);

		return this;
	},

	/**
	* Commits the [model]{@link enyo.Model} to a [source or sources]{@link enyo.Model#source}.
	* A model cannot be [committed]{@link enyo.Model#commit} if it is in an
	* [error]{@link enyo.States.ERROR} ({@link enyo.StateSupport.isError}) or
	* [busy]{@link enyo.States.BUSY} ({@link enyo.StateSupport.isBusy})
	* [state]{@link enyo.Model#status}. While executing, it will add the
	* [COMMITTING]{@link enyo.States.COMMITTING} flag to the model's
	* [status]{@link enyo.Model#status}. Once it has completed execution, it will
	* remove this flag (even if it fails).
	*
	* @see enyo.Model.committed
	* @see enyo.Model.status
	* @param {enyo.Model~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	commit: function (opts) {
		var options,
			source,
			it = this;

		// if the current status is not one of the error or busy states we can continue
		if (!(this.status & (States.ERROR | States.BUSY))) {

			// if there were options passed in we copy them quickly so that we can hijack
			// the success and error methods while preserving the originals to use later
			options = opts ? utils.clone(opts, true) : {};

			// make sure we keep track of how many sources we're requesting
			source = options.source || this.source;
			if (source && ((source instanceof Array) || source === true)) {
				this._waiting = source.length ? source.slice() : Object.keys(enyo.sources);
			}

			options.success = function (source, res) {
				it.committed(opts, res, source);
			};

			options.error = function (source, res) {
				it.errored('COMMITTING', opts, res, source);
			};

			// set the state
			this.status = this.status | States.COMMITTING;

			// now pass this on to the source to execute as it sees fit
			Source.execute('commit', this, options);
		} else this.errored(this.status, opts);

		return this;
	},

	/**
	* Fetches the [model]{@link enyo.Model} from a
	* [source or sources]{@link enyo.Model#source}. A model cannot be
	* [fetched]{@link enyo.Model#fetch} if it is in an
	* [error]{@link enyo.States.ERROR} ({@link enyo.StateSupport.isError}) or
	* [busy]{@link enyo.States.BUSY} ({@link enyo.StateSupport.isBusy})
	* [state]{@link enyo.Model#status}. While executing, it will add the
	* [FETCHING]{@link enyo.States.FETCHING} flag to the model's
	* [status]{@link enyo.Model#status}. Once it has completed execution, it will
	* remove this flag (even if it fails).
	*
	* @see enyo.Model.fetched
	* @see enyo.Model.status
	* @param {enyo.Model~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	fetch: function (opts) {
		var options,
			source,
			it = this;

		// if the current status is not one of the error or busy states we can continue
		if (!(this.status & (States.ERROR | States.BUSY))) {

			// if there were options passed in we copy them quickly so that we can hijack
			// the success and error methods while preserving the originals to use later
			options = opts ? utils.clone(opts, true) : {};

			// make sure we keep track of how many sources we're requesting
			source = options.source || this.source;
			if (source && ((source instanceof Array) || source === true)) {
				this._waiting = source.length ? source.slice() : Object.keys(enyo.sources);
			}

			options.success = function (source, res) {
				it.fetched(opts, res, source);
			};

			options.error = function (source, res) {
				it.errored('FETCHING', opts, res, source);
			};

			// set the state
			this.status = this.status | States.FETCHING;

			// now pass this on to the source to execute as it sees fit
			Source.execute('fetch', this, options);
		} else this.errored(this.status, opts);

		return this;
	},

	/**
	* Destroys the [model]{@link enyo.Model}. By default, the model will only
	* be [destroyed]{@glossary destroy} in the client. To execute with a
	* [source or sources]{@link enyo.Model#source}, either the
	* [commit default option]{@link enyo.Model#options} must be `true` or a
	* `source` property must be explicitly provided in the `opts` parameter.
	* A model cannot be destroyed (using a source) if it is in an
	* [error]{@link enyo.States.ERROR} ({@link enyo.StateSupport.isError})
	* or [busy]{@link enyo.States.BUSY} ({@link enyo.StateSupport.isBusy})
	* [state]{@link enyo.Model#status}. While executing, it will add the
	* [DESTROYING]{@link enyo.States.DESTROYING} flag to the model's
	* [status]{@link enyo.Model#status}. Once it has completed execution, it
	* will remove this flag (even if it fails).
	*
	* @see enyo.Model.status
	* @param {enyo.Model~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	destroy: function (opts) {
		var options = opts ? utils.mixin({}, [this.options, opts]) : this.options,
			it = this,
			idx;

		// this becomes an (potentially) async operation if we are committing this destroy
		// to a source and its kind of tricky to figure out because there are several ways
		// it could be flagged to do this

		if (options.commit || options.source) {

			// if the current status is not one of the error states we can continue
			if (!(this.status & (States.ERROR | States.BUSY))) {

				// remap to the originals
				options = opts ? utils.clone(opts, true) : {};

				options.success = function (source, res) {

					if (it._waiting) {
						idx = it._waiting.findIndex(function (ln) {
							return (ln instanceof Source ? ln.name : ln) == source;
						});
						if (idx > -1) it._waiting.splice(idx, 1);
						if (!it._waiting.length) it._waiting = null;
					}

					// continue the operation this time with commit false explicitly
					if (!it._waiting) {
						options.commit = options.source = null;
						it.destroy(options);
					}
					if (opts && opts.success) opts.success(this, opts, res, source);
				};

				options.error = function (source, res) {

					if (it._waiting) {
						idx = it._waiting.findIndex(function (ln) {
							return (ln instanceof Source ? ln.name : ln) == source;
						});
						if (idx > -1) it._waiting.splice(idx, 1);
						if (!it._waiting.length) it._waiting = null;
					}

					// continue the operation this time with commit false explicitly
					if (!it._waiting) {
						options.commit = options.source = null;
						it.destroy(options);
					}

					// we don't bother setting the error state if we aren't waiting because it
					// will be cleared to DESTROYED and it would be pointless
					else this.errored('DESTROYING', opts, res, source);
				};

				this.status = this.status | States.DESTROYING;

				Source.execute('destroy', this, options);
			} else if (this.status & States.ERROR) this.errored(this.status, opts);

			// we don't allow the destroy to take place and we don't forcibly break-down
			// the collection errantly so there is an opportuniy to resolve the issue
			// before we lose access to the collection's content!
			return this;
		}


		// we flag this early so objects that receive an event and process it
		// can optionally check this to support faster cleanup in some cases
		// e.g. Collection/Store don't need to remove listeners because it will
		// be done in a much quicker way already
		this.destroyed = true;
		this.status = States.DESTROYED;
		this.unsilence(true).emit('destroy');
		this.removeAllListeners();
		this.removeAllObservers();

		// if this does not have the the batching flag (that would be set by a collection)
		// then we need to do the default of removing it from the store
		if (!opts || !opts.batching) this.store.remove(this);
	},

	/**
	* Retrieves the value for the given property or path. If the property is a
	* [computed property]{@link enyo.ComputedSupport.computed}, then it will return
	* that value; otherwise, it will attempt to retrieve the value from the
	* [attributes hash]{@link enyo.Model#attributes}.
	*
	* @param {String} path - The property to retrieve.
	* @returns {*} The value for the requested property or path, or `undefined` if
	* it cannot be found or does not exist.
	* @public
	*/
	get: function (path) {
		return this.isComputed(path) ? this._getComputed(path) : this.attributes[path];
	},

	/**
	* Sets the requested `path` or [hash]{@glossary Object} of properties on the
	* [model]{@link enyo.Model}. Properties are applied to the
	* [attributes hash]{@link enyo.Model#attributes} and are retrievable via
	* [get()]{@link enyo.Model#get}. If properties were updated and the `silent`
	* option is not `true`, this method will emit a `change` event, as well as
	* individual [notifications]{@link enyo.ObserverSupport.notify} for the
	* properties that were modified.
	*
	* @fires enyo.Model#change
	* @see enyo.ObserverSupport
	* @see enyo.BindingSupport
	* @param {(String|Object)} path - Either the property name or a [hash]{@glossary Object}
	*	of properties and values to set.
	* @param {(*|enyo.Model~Options)} is If `path` is a [string]{@glossary String},
	* this should be the value to set for the given property; otherwise, it should be
	* an optional hash of available [configuration options]{@link enyo.Model~Options}.
	* @param {enyo.Model~Options} [opts] - If `path` is a string, this should be the
	* optional hash of available configuration options; otherwise, it will not be used.
	* @returns {this} The callee for chaining.
	* @public
	*/
	set: function (path, is, opts) {
		if (!this.destroyed) {

			var attrs = this.attributes,
				options = this.options,
				changed,
				incoming,
				force,
				silent,
				key,
				value,
				commit,
				fetched;

			// the default case for this setter is accepting an object of key->value pairs
			// to apply to the model in which case the second parameter is the optional
			// configuration hash
			if (typeof path == 'object') {
				incoming = path;
				opts = opts || is;
			}

			// otherwise in order to have a single path here we flub it so it will keep on
			// going as expected
			else {
				incoming = {};
				incoming[path] = is;
			}

			// to maintain backward compatibility with the old setters that allowed the third
			// parameter to be a boolean to indicate whether or not to force notification of
			// change even if there was any
			if (opts === true) {
				force = true;
				opts = {};
			}

			opts = opts ? utils.mixin({}, [options, opts]) : options;
			silent = opts.silent;
			force = force || opts.force;
			commit = opts.commit;
			fetched = opts.fetched;

			for (key in incoming) {
				value = incoming[key];

				if (value !== attrs[key] || force) {
					// to ensure we have an object to work with
					// note that we check inside this loop so we don't have to examine keys
					// later only the local variable changed
					changed = this.changed || (this.changed = {});
					//store the previous attr value
					this.previous[key] = attrs[key];
					//set new value
					changed[key] = attrs[key] = value;
				}
			}

			if (changed) {

				// we add dirty as a value of the status but clear the CLEAN bit if it
				// was set - this would allow it to be in the ERROR state and NEW and DIRTY
				if (!fetched) this.status = (this.status | States.DIRTY) & ~States.CLEAN;

				if (!silent) this.emit('change', changed, this);

				if (commit && !fetched) this.commit(opts);

				// reset value so subsequent changes won't be added to this change-set
				this.changed = null;
			}
		}

		return this;
	},

	/**
	* A bit of hackery to facade the normal [getter]{@link enyo.ComputedSupport.get}. Note that
	* we pass an arbitrary super-method that automatically returns `undefined`, which is
	* consistent with this use case and its intended purpose.
	*
	* @private
	*/
	_getComputed: ComputedSupport.get.fn(function () { return undefined; }),

	/**
	* Initializes the [model]{@link enyo.Model}. Unlike some methods, the parameters are not
	* interchangeable. If you are not using a particular (optional) parameter, pass in `null`.
	*
	* @param {Object} [attrs] - Optionally initialize the [model]{@link enyo.Model} with some
	*	[attributes]{@link enyo.Model#attributes}.
	* @param {Object} [props] - Properties to apply directly to the [model]{@link enyo.Model} and
	*	not the [attributes hash]{@link enyo.Model#attributes}. If these properties contain an
	*	`options` property (a [hash]{@glossary Object}) it will be merged with existing
	*	[options]{@link enyo.Model#options}.
	* @param {enyo.Model~Options} [opts] - This is a one-time [options hash]{@link enyo.Model~Options} that
	*	is only used during initialization and not applied as defaults.
	* @public
	*/
	constructor: function (attrs, props, opts) {

		// in cases where there is an options hash provided in the _props_ param
		// we need to integrate it manually...
		if (props && props.options) {
			this.options = utils.mixin({}, [this.options, props.options]);
			delete props.options;
		}

		// the _opts_ parameter is a one-hit options hash it does not leave
		// behind its values as default options...
		opts = opts? utils.mixin({}, [this.options, opts]): this.options;

		// go ahead and mix all of the properties in
		props && utils.mixin(this, props);

		var noAdd = opts.noAdd
			, commit = opts.commit
			, parse = opts.parse
			, fetch = this.options.fetch
			, defaults;

		// defaults = this.defaults && (typeof this.defaults == 'function'? this.defaults(attrs, opts): this.defaults);
		defaults = this.defaults && typeof this.defaults == 'function'? this.defaults(attrs, opts): null;

		// ensure we have a unique identifier that could potentially
		// be used in remote systems
		this.euid = this.euid || utils.uid('m');

		// if necessary we need to parse the incoming attributes
		attrs = attrs? parse? this.parse(attrs): attrs: null;

		// ensure we have the updated attributes
		this.attributes = this.attributes? defaults? utils.mixin({}, [defaults, this.attributes]): utils.clone(this.attributes, true): defaults? utils.clone(defaults, true): {};
		attrs && utils.mixin(this.attributes, attrs);
		this.previous = utils.clone(this.attributes);

		// now we need to ensure we have a store and register with it
		this.store = this.store || Store;

		// @TODO: The idea here is that when batch instancing records a collection
		// should be intelligent enough to avoid doing each individually or in some
		// cases it may be useful to have a record that is never added to a store?
		if (!noAdd) this.store.add(this, opts);

		commit && this.commit();
		fetch && this.fetch();
	},

	/**
	* Overloaded. We funnel arbitrary notification updates through here, as this
	* is faster than using the built-in notification updates for batch operations.
	*
	* @private
	*/
	emit: kind.inherit(function (sup) {
		return function (e, props) {
			if (e == 'change' && props && this.isObserving()) {
				for (var key in props) this.notify(key, this.previous[key], props[key]);
			}
			return sup.apply(this, arguments);
		};
	}),

	/**
	* Overloaded to alias the (also overloaded) [emit()]{@link enyo.Model#emit} method.
	*
	* @private
	*/
	triggerEvent: function () {
		return this.emit.apply(this, arguments);
	},

	/**
	* When a [fetch]{@link enyo.Model#fetch} has completed successfully, it is returned
	* to this method. This method handles special and important behavior; it should not be
	* called directly and, when overloading, care must be taken to ensure that you call
	* the super-method. This correctly sets the [status]{@link enyo.Model#status} and, in
	* cases where multiple [sources]{@link enyo.Model#source} were used, it waits until
	* all have responded before clearing the [FETCHING]{@link enyo.States.FETCHING} flag.
	* If a [success]{@link enyo.Model~Success} callback was provided, it will be called
	* once for each source.
	*
	* @param {enyo.Model~ActionOptions} opts - The original options passed to
	*	[fetch()]{@link enyo.Model#fetch}, merged with the defaults.
	* @param {*} [res] - The result provided from the given [source]{@link enyo.Model#source},
	* if any. This will vary depending on the source.
	* @param {String} source - The name of the source that has completed successfully.
	* @public
	*/
	fetched: function (opts, res, source) {
		var idx,
			options = this.options;

		if (this._waiting) {
			idx = this._waiting.findIndex(function (ln) {
				return (ln instanceof Source ? ln.name : ln) == source;
			});
			if (idx > -1) this._waiting.splice(idx, 1);
			if (!this._waiting.length) this._waiting = null;
		}

		// normalize options so we have values and ensure it knows it was just fetched
		opts = opts ? utils.mixin({}, [options, opts]) : options;
		opts.fetched = true;

		// for a special case purge to only use the result sub-tree of the fetched data for
		// the model attributes
		if (opts.parse) res = this.parse(res);

		// note this will not add the DIRTY state because it was fetched but also note that it
		// will not clear the DIRTY flag if it was already DIRTY
		if (res) this.set(res, opts);

		// clear the FETCHING and NEW state (if it was NEW) we do not set it as dirty as this
		// action alone doesn't warrant a dirty flag that would need to be set in the set method
		if (!this._waiting) this.status = this.status & ~(States.FETCHING | States.NEW);

		// now look for an additional success callback
		if (opts.success) opts.success(this, opts, res, source);
	},

	/**
	* When a [commit]{@link enyo.Model#commit} has completed successfully, it is returned
	* to this method. This method handles special and important behavior; it should not be
	* called directly and, when overloading, care must be taken to ensure that you call the
	* super-method. This correctly sets the [status]{@link enyo.Model#status} and, in cases
	* where multiple [sources]{@link enyo.Model#source} were used, it waits until all have
	* responded before clearing the [COMMITTING]{@link enyo.States.COMMITTING} flag. If a
	* [success]{@link enyo.Model~Success} callback was provided, it will be called once for
	* each source.
	*
	* @param {enyo.Model~ActionOptions} opts - The original options passed to
	*	[commit()]{@link enyo.Model#commit}, merged with the defaults.
	* @param {*} [res] - The result provided from the given [source]{@link enyo.Model#source},
	* if any. This will vary depending on the source.
	* @param {String} source - The name of the source that has completed successfully.
	* @public
	*/
	committed: function (opts, res, source) {
		var idx;

		if (this._waiting) {
			idx = this._waiting.findIndex(function (ln) {
				return (ln instanceof Source ? ln.name : ln) == source;
			});
			if (idx > -1) this._waiting.splice(idx, 1);
			if (!this._waiting.length) this._waiting = null;
		}

		if (!this._waiting) {
			// we need to clear the COMMITTING bit and DIRTY bit as well as ensure that the
			// 'previous' hash is whatever the current attributes are
			this.previous = utils.clone(this.attributes);
			this.status = (this.status | States.CLEAN) & ~(States.COMMITTING | States.DIRTY);
		}

		if (opts && opts.success) opts.success(this, opts, res, source);
	},

	/**
	* When an action ([fetch()]{@link enyo.Model#fetch}, [commit()]{@link enyo.Model#commit},
	* or [destroy()]{@link enyo.Model#destroy}) has failed, it will be passed to this method.
	* This method handles special and important behavior; it should not be called directly
	* and, when overloading, care must be taken to ensure that you call the super-method.
	* This correctly sets the [status]{@link enyo.Model#status} to the known
	* [error state]{@link enyo.States.ERROR}, or to the
	* [unknown error state]{@link enyo.States.ERROR_UNKNOWN} if it the error state could not
	* be determined. If an [error callback]{@link enyo.Model~Error} was provided, this method
	* will execute it.
	*
	* @see enyo.StateSupport.clearError
	* @param {String} action - The action (one of `'FETCHING'`, `'COMMITTING'`, or
	* `'DESTROYING'`) that failed and is now in an [error state]{@link enyo.States.ERROR}.
	* @param {enyo.Model~ActionOptions} opts - The original options passed to the `action`
	* method, merged with the defaults.
	* @param {*} [res] - The result provided from the given [source]{@link enyo.Model#source},
	* if any. This will vary depending on the source.
	* @param {String} source - The name of the source that has returned an error.
	* @public
	*/
	errored: function (action, opts, res, source) {
		var stat,
			idx;

		// if the error action is a status number then we don't need to update it otherwise
		// we set it to the known state value
		if (typeof action == 'string') {

			// all built-in errors will pass this as their values are > 0 but we go ahead and
			// ensure that no developer used the 0x00 for an error code
			stat = STATES['ERROR_' + action];
		} else stat = action;

		if (isNaN(stat) || (stat & ~States.ERROR)) stat = States.ERROR_UNKNOWN;

		// correctly set the current status and ensure we clear any busy flags
		this.status = (this.status | stat) & ~States.BUSY;

		if (this._waiting) {
			idx = this._waiting.findIndex(function (ln) {
				return (ln instanceof Source ? ln.name : ln) == source;
			});
			if (idx > -1) this._waiting.splice(idx, 1);
			if (!this._waiting.length) this._waiting = null;
		}

		// we need to check to see if there is an options handler for this error
		if (opts && opts.error) opts.error(this, action, opts, res, source);
	}

});

/**
* @name enyo.Model.concat
* @static
* @private
*/
Model.concat = function (ctor, props) {
	var proto = ctor.prototype || ctor;

	if (props.options) {
		proto.options = utils.mixin({}, [proto.options, props.options]);
		delete props.options;
	}
};

/**
* @private
*/
kind.features.push(function (ctor) {
	if (ctor.prototype instanceof Model) {
		!Store.models[ctor.prototype.kindName] && (Store.models[ctor.prototype.kindName] = new ModelList());
	}
});
},{"../../enyo":1,"./BindingSupport":9,"./ComputedSupport":15,"./EventEmitter":19,"./ModelList":31,"./ObserverSupport":34,"./Source":48,"./StateSupport":49,"./States":50,"./Store":51,"./kind":66,"./utils":75}],13:[function(require,module,exports){
require('../../enyo');


var
	kind = require('./kind'),
	utils = require('./utils'),
	logger = require('./logger');

var
	CoreObject = require('./CoreObject'),
	ApplicationSupport = require('./ApplicationSupport'),
	ComponentBindingSupport = require('./ComponentBindingSupport'),
	Jobs = require('./jobs');

var
	kindPrefix = {},
	unnamedCounter = 0;
	
/**
* @callback enyo.Component~EventHandler
* @param {enyo.Component} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @param {Object} event - An [object]{@glossary Object} containing
*	event information.
* @returns {Boolean} A value indicating whether the event has been
*	handled or not. If `true`, then bubbling is stopped.
*/

/**
* A [hash]{@glossary Object} of references to all the [components]{@link enyo.Component}
* owned by this component. This property is updated whenever a new
* component is added; the new component may be accessed via its
* [name]{@link enyo.Component#name} property. We may also observe changes on
* properties of components referenced by the `$` property.
*
* Component access via the `$` hash:
* ```javascript
* var c = new enyo.Component({
*	name: 'me',
*	components: [
*		{kind: 'Component', name: 'other'}
*	]
* });
*
* // We can now access 'other' on the $ hash of 'c', via c.$.other
* ```
*
* Observing changes on a component referenced by the `$` property:
* ```javascript
* var c = new enyo.Component({
*	name: 'me',
*	components: [
*		{kind: 'Component', name: 'other'}
*	]
* });
*
* c.addObserver('$.other.active', function() {
*	// do something to respond to the "active" property of "other" changing
* })
*
* c.$.other.set('active', true); // this will trigger the observer to run its callback
* ```
*
* @name $
* @type {Object}
* @default null
* @memberof enyo.Component.prototype
* @readonly
* @public
*/

/**
* If `true`, this [component's]{@link enyo.Component} [owner]{@link enyo.Component#owner} will
* have a direct name reference to the owned component.
*
* @example
* var c = new enyo.Component({
*	name: 'me',
*	components: [
*		{kind: 'Component', name: 'other', publish: true}
*	]
* });
*
* // We can now access 'other' directly, via c.other
*
* @name publish
* @type {Boolean}
* @default undefined
* @memberOf enyo.Component.prototype
* @public
*/

/**
* If `true`, the [layout]{@glossary layout} strategy will adjust the size of this
* [component]{@link enyo.Component} to occupy the remaining available space.
*
* @name fit
* @type {Boolean}
* @default undefined
* @memberOf enyo.Component.prototype
* @public
*/

/**
* {@link enyo.Component} is the fundamental building block for Enyo applications.
* Components are designed to fit together, allowing complex behaviors to
* be fashioned from smaller bits of functionality.
*
* Component [constructors]{@glossary constructor} take a single
* argument (sometimes called a [component configuration]{@glossary configurationBlock}),
* a JavaScript [object]{@glossary Object} that defines various properties to be initialized on the
* component.  For example:
*
* ```javascript
* // create a new component, initialize its name property to 'me'
* var c = new enyo.Component({
*	name: 'me'
* });
* ```
*
* When a component is instantiated, items configured in its
* `components` property are instantiated, too:
*
* ```javascript
* // create a new component, which itself has a component
* var c = new enyo.Component({
*	name: 'me',
*	components: [
*		{kind: 'Component', name: 'other'}
*	]
* });
* ```
*
* In this case, when `me` is created, `other` is also created, and we say that `me` owns `other`.
* In other words, the [owner]{@link enyo.Component#owner} property of `other` equals `me`.
* Notice that you can specify the [kind]{@glossary kind} of `other` explicitly in its
* configuration block, to tell `me` what constructor to use to create `other`.
*
* Note that [kind]{@glossary kind} values may be references to actual
* kinds or string-names of kinds. Kind names that do not resolve directly to kinds
* are looked up in default namespaces. In this case, `kind: 'Component'` resolves to
* `enyo.Component`.
*
* To move a component, use the `setOwner()` method to change the
* component's owner. If you want a component to be unowned, use `setOwner(null)`.
*
* If you make changes to `enyo.Component`, be sure to add or update the appropriate
* {@linkplain https://github.com/enyojs/enyo/tree/master/tools/test/core/tests unit tests}.
*
* For more information, see the documentation on
* [Components]{@linkplain $dev-guide/key-concepts/components.html} in the
* Enyo Developer Guide.
*
* @class enyo.Component
* @extends enyo.Object
* @mixes enyo.ApplicationSupport
* @mixes enyo.ComponentBindingSupport
* @public
*/
var Component = module.exports = kind(
	/** @lends enyo.Component.prototype */ {

	name: 'enyo.Component',

	/**
	* @private
	*/
	kind: CoreObject,

	/**
	* @private
	*/


	/**
	* @private
	*/
	cachedBubble: true,

	/**
	* @private
	*/
	cachePoint: false,

	/**
	* @private
	*/
	published:
		/** @lends enyo.Component.prototype */ {

		/**
		* A unique name for the [component]{@link enyo.Component} within its
		* [owner]{@link enyo.Component#owner}. This is used to set the access name in the
		* owner's [$ hash]{@link enyo.Component#$}. If not
		* specified, a default name will be provided based on the name of the
		* [object's]{@link enyo.Object} [kind]{@glossary kind}, with a numeric
		* suffix appended if more than one instance exists in the owner.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		name: '',

		/**
		* A unique id for the [component]{@link enyo.Component}, usually automatically generated
		* based on its position within the component hierarchy, although
		* it may also be directly specified. {@link enyo.Control} uses this `id` value for the
		* DOM [id]{@link enyo.Control#id} attribute.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		id: '',

		/**
		* The [component]{@link enyo.Component} that owns this component.
		* It is usually defined implicitly at creation time based on the
		* [createComponent()]{@link enyo.Component#createComponent} call or
		* the `components` hash.
		*
		* @type {enyo.Component}
		* @default null
		* @public
		*/
		owner: null,

		/**
		* This can be a [hash]{@glossary Object} of features to apply to
		* [chrome]{@glossary chrome} [components]{@link enyo.Component} of the base
		* [kind]{@glossary kind}. They are matched by [name]{@link enyo.Component#name}
		* (if the component you wish to modify does not have a name, this will not work).
		* You can modify any properties of the component except for methods. Setting a
		* value for `componentOverrides` at runtime will have no effect.
		*
		* @type {Object}
		* @default null
		* @public
		*/
		componentOverrides: null
	},

	/**
	* @private
	*/
	defaultKind: 'Component',

	/**
	* @private
	*/
	handlers: {},

	/**
	* @private
	*/
	mixins: [ApplicationSupport, ComponentBindingSupport],

	/**
	* @private
	*/
	toString: function () {
		return this.id + ' [' + this.kindName + ']';
	},

	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function (props) {
			// initialize instance objects
			this._componentNameMap = {};
			this.$ = {};
			this.cachedBubbleTarget = {};
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	constructed: kind.inherit(function (sup) {
		return function (props) {
			// perform initialization
			this.create(props);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	create: function () {
		// stop and queue all of the notifications happening synchronously to allow
		// responders to only do single passes on work traversing the tree
		this.stopNotifications();
		this.ownerChanged();
		this.initComponents();
		// release the kraken!
		this.startNotifications();
	},

	/**
	* @private
	*/
	initComponents: function () {
		// The _components_ property in kind declarations is renamed to
		// _kindComponents_ by the Component subclass mechanism.  This makes it
		// easy for the developer to distinguish kindComponents from the components
		// in _this.components_, without having to worry about the actual difference.
		//
		// Specifically, the difference is that kindComponents are constructed as
		// owned by this control (whereas components in _this.components_ are not).
		// In addition, kindComponents are marked with the _isChrome: true_ flag.
		this.createChrome(this.kindComponents);
		this.createClientComponents(this.components);
	},

	/**
	* @private
	*/
	createChrome: function (comps) {
		this.createComponents(comps, {isChrome: true});
	},

	/**
	* @private
	*/
	createClientComponents: function (comps) {
		this.createComponents(comps, {owner: this.getInstanceOwner()});
	},

	/**
	* @private
	*/
	getInstanceOwner: function () {
		return (!this.owner || this.owner.notInstanceOwner) ? this : this.owner;
	},

	/**
	* Removes this [component]{@link enyo.Component} from its
	* [owner]{@link enyo.Component#owner} (setting `owner` to `null`)
	* and does any necessary cleanup. The component is flagged with
	* `destroyed: true`. Usually, the component will be suitable for garbage
	* collection after being destroyed, unless user code keeps a reference
	* to it.
	*
	* @returns {this} The callee for chaining.
	* @method
	* @public
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			this.destroyComponents();
			this.setOwner(null);
			sup.apply(this, arguments);
			this.stopAllJobs();
			return this;
		};
	}),

	/**
	* Destroys all owned [components]{@link enyo.Component}.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	destroyComponents: function () {
		var comps = this.getComponents(),
			comp,
			i;

		for (i = 0; i < comps.length; ++i) {
			comp = comps[i];
			// @todo: previous comment said list might be stale and ownership may have caused
			// components to be destroyed as a result of some inner-container...look into this
			// because that seems incorrect or avoidable
			if (!comp.destroyed) comp.destroy();
		}

		return this;
	},

	/**
	* @private
	*/
	makeId: function() {
		var delim = '_', pre = this.owner && this.owner.getId(),
			baseName = this.name || ('@@' + (++unnamedCounter));
		return (pre ? pre + delim : '') + baseName;
	},

	/**
	* @private
	*/
	ownerChanged: function (was) {
		if (was && was.removeComponent) was.removeComponent(this);
		if (this.owner && this.owner.addComponent) this.owner.addComponent(this);
		if (!this.id) this.id = this.makeId();
	},

	/**
	* @private
	*/
	nameComponent: function (comp) {
		var pre = prefixFromKindName(comp.kindName),
			last = this._componentNameMap[pre] || 0,
			nom;

		do {
			nom = pre + (++last > 1 ? String(last) : '');
		} while (this.$[nom]);

		this._componentNameMap[pre] = Number(last);
		/*jshint -W093 */
		return (comp.name = nom);
	},

	/**
	* Adds a [component]{@link enyo.Component} to the list of components
	* owned by the current component (i.e., [this.$]{@link enyo.Component#$}).
	*
	* @param {enyo.Component} comp - The [component]{@link enyo.Component} to add.
	* @returns {this} The callee for chaining.
	* @public
	*/
	addComponent: function (comp) {
		var nom = comp.get('name');

		// if there is no name we have to come up with a generic name
		if (!nom) nom = this.nameComponent(comp);

		// if there already was a component by that name we issue a warning
		// @todo: if we're going to name rules being violated we need to normalize this approach
		// and ensure we have one for every warning/error we throw
		if (this.$[nom]) this.warn(
			'Duplicate component name ' + nom + ' in owner ' + this.id + ' violates ' +
			'unique-name-under-owner rule, replacing existing component in the hash and ' +
			'continuing, but this is an error condition and should be fixed.'
		);

		this.$[nom] = comp;
		this.notify('$.' + nom, null, comp);

		// if the component has the `publish` true property then we also create a reference to
		// it directly on the owner (this)
		if (comp.publish) {
			this[nom] = comp;

			// and to ensure that bindings are aware we have to notify them as well
			this.notify(nom, null, comp);
		}

		return this;
	},

	/**
	* Removes the passed-in [component]{@link enyo.Component} from those known
	* to be owned by this component. The component will be removed from the
	* [$ hash]{@link enyo.Component#$}, and from the [owner]{@link enyo.Component#owner}
	* directly if [publish]{@link enyo.Component#publish} is set to `true`.
	*
	* @param {enyo.Component} comp - The component to remove.
	* @returns {this} The callee for chaining.
	* @public
	*/
	removeComponent: function (comp) {
		var nom = comp.get('name');

		// remove it from the hash if it existed
		delete this.$[nom];

		// if it was published remove it from the component proper
		if (comp.publish) delete this[nom];

		return this;
	},

	/**
	* Returns an [array]{@glossary Array} of owned [components]{@link enyo.Component}; in
	* other words, converts the [$ hash]{@link enyo.Component#$} into an array
	* and returns the array.
	*
	* @returns {enyo.Component[]} The [components]{@link enyo.Component} found in the
	*	[$ hash]{@link enyo.Component#$}.
	* @public
	*/
	getComponents: function () {
		return utils.values(this.$);
	},

	/**
	* @private
	*/
	adjustComponentProps: function (props) {
		if (this.defaultProps) utils.mixin(props, this.defaultProps, {ignore: true});
		props.kind = props.kind || props.isa || this.defaultKind;
		props.owner = props.owner || this;
	},

	/**
	* @private
	*/
	_createComponent: function (props, ext) {
		var def = ext ? utils.mixin({}, [ext, props]) : utils.clone(props);

		// always adjust the properties according to the needs of the kind and parent kinds
		this.adjustComponentProps(def);

		// pass along for the final stage
		return Component.create(def);
	},

	/**
	* Creates and returns a [component]{@link enyo.Component} as defined by the combination of
	* a base and an additional property [hash]{@glossary Object}. The properties provided
	* in the standard property hash override those provided in the
	* additional property hash.
	*
	* The created component passes through initialization machinery
	* provided by the creating component, which may supply special
	* handling. Unless the [owner]{@link enyo.Component#owner} is explicitly specified, the new
	* component will be owned by the instance on which this method is called.
	*
	* @example
	* // Create a new component named 'dynamic', owned by 'this'
	* // (will be available as this.$.dynamic).
	* this.createComponent({name: 'dynamic'});
	*
	* @example
	* // Create a new component named 'another' owned by 'other'
	* // (will be available as other.$.another).
	* this.createComponent({name: 'another'}, {owner: other});
	*
	* @param {Object} props - The declarative [kind]{@glossary kind} definition.
	* @param {Object} ext - Additional properties to be applied (defaults).
	* @returns {enyo.Component} The instance created with the given parameters.
	* @public
	*/
	createComponent: function (props, ext) {
		// createComponent and createComponents both delegate to the protected method
		// (_createComponent), allowing overrides to customize createComponent and
		// createComponents separately.
		return this._createComponent(props, ext);
	},

	/**
	* Creates [components]{@link enyo.Component} as defined by the [arrays]{@glossary Array}
	* of base and additional property [hashes]{@glossary Object}. The standard and
	* additional property hashes are combined as described in
	* [createComponent()]{@link enyo.Component#createComponent}.
	*
	* @example
	* // ask foo to create components 'bar' and 'zot', but set the owner of
	* // both components to 'this'.
	* this.$.foo.createComponents([
	*	{name: 'bar'},
	*	{name: 'zot'}
	* ], {owner: this});
	*
	* @param {Object[]} props The array of {@link enyo.Component} definitions to be created.
	* @param {Object} ext - Additional properties to be supplied as defaults for each.
	* @returns {enyo.Component[]} The array of [components]{@link enyo.Component} that were
	*	created.
	* @public
	*/
	createComponents: function (props, ext) {
		var comps = [],
			comp,
			i;

		if (props) {
			for (i = 0; i < props.length; ++i) {
				comp = props[i];
				comps.push(this._createComponent(comp, ext));
			}
		}

		return comps;
	},

	/**
	* @private
	*/
	getBubbleTarget: function (nom, event) {
		if (event.delegate) return this.owner;
		else {
			return (
				this.bubbleTarget
				|| (this.cachedBubble && this.cachedBubbleTarget[nom])
				|| this.owner
			);
		}
	},

	/**
	* Bubbles an {@glossary event} up an [object]{@glossary Object} chain,
	* starting with `this`.
	*
	* A handler for an event may be specified. See {@link enyo.Component~EventHandler}
	* for complete details.
	*
	* @param {String} nom - The name of the {@glossary event} to bubble.
	* @param {Object} [event] - The event [object]{@glossary Object} to be passed along
	* while bubbling.
	* @param {enyo.Component} [sender=this] - The {@link enyo.Component} responsible for
	*	bubbling the event.
	* @returns {Boolean} `false` if unhandled or uninterrupted; otherwise, `true`.
	* @public
	*/
	bubble: function (nom, event, sender) {
		if (!this._silenced) {
			event = event || {};
			event.lastHandledComponent = null;
			event.bubbling = true;
			// deliberately done this way
			if (event.originator == null) event.originator = sender || this;
			return this.dispatchBubble(nom, event, sender || this);
		}
		return false;
	},

	/**
	* Bubbles an {@glossary event} up an [object]{@glossary Object} chain,
	* starting **above** `this`.
	*
	* A handler for an event may be specified. See {@link enyo.Component~EventHandler}
	* for complete details.
	*
	* @param {String} nom - The name of the {@glossary event}.
	* @param {Object} [event] - The event properties to pass along while bubbling.
	* @returns {Boolean} `false` if unhandled or uninterrupted; otherwise, `true`.
	* @public
	*/
	bubbleUp: function (nom, event) {
		var next;

		if (!this._silenced) {
			event = event || {};
			event.bubbling = true;
			next = this.getBubbleTarget(nom, event);
			if (next) {
				// use delegate as sender if it exists to preserve illusion
				// that event is dispatched directly from that, but we still
				// have to bubble to get decorations
				return next.dispatchBubble(nom, event, event.delegate || this);
			}
		}
		return false;
	},

	/**
	* Sends an {@glossary event} to a named [delegate]{@glossary delegate}.
	* This [object]{@glossary Object} may dispatch an event to
	* itself via a [handler]{@link enyo.Component~EventHandler}, or to its
	* [owner]{@link enyo.Component#owner} via an event property, e.g.:
	*
	*	handlers {
	*		// 'tap' events dispatched to this.tapHandler
	*		ontap: 'tapHandler'
	*	}
	*
	*	// 'tap' events dispatched to 'tapHandler' delegate in this.owner
	*	ontap: 'tapHandler'
	*
	* @private
	*/
	dispatchEvent: function (nom, event, sender) {
		var delegate,
			ret;

		if (!this._silenced) {
			// if the event has a delegate associated with it we grab that
			// for reference
			// NOTE: This is unfortunate but we can't use a pooled object here because
			// we don't know where to release it
			delegate = (event || (event = {})).delegate;

			// bottleneck event decoration w/ optimization to avoid call to empty function
			if (this.decorateEvent !== Component.prototype.decorateEvent) {
				this.decorateEvent(nom, event, sender);
			}

			// first, handle any delegated events intended for this object
			if (delegate && delegate.owner === this) {
				// the most likely case is that we have a method to handle this
				if (this[nom] && 'function' === typeof this[nom]) {
					return this.dispatch(nom, event, sender);
				}
				// but if we don't, just stop the event from going further
				return false;
			}

			// for non-delgated events, try the handlers block if possible
			if (!delegate) {
				var bHandler = this.handlers && this.handlers[nom];
				var bDelegatedFunction = this[nom] && utils.isString(this[nom]);
				var cachePoint = this.cachePoint || bHandler || bDelegatedFunction || this.id === "master" ;

				if (event.bubbling) {
					if (event.lastHandledComponent && cachePoint) {
						event.lastHandledComponent.cachedBubbleTarget[nom] = this;
						event.lastHandledComponent = null;
					}
					if (!event.lastHandledComponent && this.id !== "master") {
						event.lastHandledComponent = this;
					}
				}
				if (bHandler && this.dispatch(bHandler, event, sender)) {
					return true;
				}
				if (bDelegatedFunction) {
					// we dispatch it up as a special delegate event with the
					// component that had the delegation string property stored in
					// the 'delegate' property
					event.delegate = this;
					ret = this.bubbleUp(this[nom], event, sender);
					delete event.delegate;
					return ret;
				}
			}
		}
		return false;
	},

	/**
	* Internal - try dispatching {@glossary event} to self; if that fails,
	* [bubble it up]{@link enyo.Component#bubbleUp} the tree.
	*
	* @private
	*/
	dispatchBubble: function (nom, event, sender) {
		if (!this._silenced) {
			// Try to dispatch from here, stop bubbling on truthy return value
			if (this.dispatchEvent(nom, event, sender)) {
				return true;
			}
			// Bubble to next target
			return this.bubbleUp(nom, event, sender);
		}
		return false;
	},

	/**
	* @private
	*/
	decorateEvent: function (nom, event, sender) {
		// an event may float by us as part of a dispatchEvent chain
		// both call this method so intermediaries can decorate inEvent
	},

	/**
	* @private
	*/
	stopAllJobs: function () {
		var job;

		if (this.__jobs) for (job in this.__jobs) this.stopJob(job);
	},

	/**
	* Dispatches the {@glossary event} to named [delegate]{@glossary delegate} `nom`,
	* if it exists. [Subkinds]{@glossary subkind} may re-route dispatches. Note that
	* both 'handlers' events and events delegated from owned controls arrive here.
	* If you need to handle these types of events differently, you may also need to
	* override [dispatchEvent()]{@link enyo.Component#dispatchEvent}.
	*
	* @param {String} nom - The method name to dispatch the {@glossary event}.
	* @param {Object} [event] - The event [object]{@glossary Object} to pass along.
	* @param {enyo.Component} [sender=this] - The originator of the event.
	* @public
	*/
	dispatch: function (nom, event, sender) {
		var fn;

		if (!this._silenced) {
			fn = nom && this[nom];
			if (fn && typeof fn == 'function') {
				// @todo: deprecate sender
				return fn.call(this, sender || this, event);
			}
		}
		return false;
	},

	/**
	* Triggers the [handler]{@link enyo.Component~EventHandler} for a given
	* {@glossary event} type.
	*
	* @example
	* myControl.triggerHandler('ontap');
	*
	* @param {String} nom - The name of the {@glossary event} to trigger.
	* @param {Object} [event] - The event object to pass along.
	* @param {enyo.Component} [sender=this] - The originator of the event.
	* @returns {Boolean} `false` if unhandled or uninterrupted, `true` otherwise.
	* @public
	*/
	triggerHandler: function () {
		return this.dispatchEvent.apply(this, arguments);
	},

	/**
	* Sends a message to myself and all of my [components]{@link enyo.Component}.
	* You can stop a waterfall into components owned by a receiving object
	* by returning a truthy value from the {@glossary event}
	* [handler]{@link enyo.Component~EventHandler}.
	*
	* @param {String} nom - The name of the {@glossary event} to waterfall.
	* @param {Object} [event] - The event [object]{@glossary Object} to pass along.
	* @param {enyo.Component} [sender=this] - The originator of the event.
	* @returns {this} The callee for chaining.
	* @public
	*/
	waterfall: function(nom, event, sender) {
		if (!this._silenced) {
			event = event || {};
			event.bubbling = false;

			// give the locals an opportunity to interrupt the event
			if (this.dispatchEvent(nom, event, sender)) return true;

			// otherwise carry on
			this.waterfallDown(nom, event, sender || this);
		}

		return this;
	},

	/**
	* Sends a message to all of my [components]{@link enyo.Component}, but not myself. You can
	* stop a [waterfall]{@link enyo.Component#waterfall} into [components]{@link enyo.Component}
	* owned by a receiving [object]{@glossary Object} by returning a truthy value from the
	* {@glossary event} [handler]{@link enyo.Component~EventHandler}.
	*
	* @param {String} nom - The name of the {@glossary event}.
	* @param {Object} [event] - The event [object]{@glossary Object} to pass along.
	* @param {enyo.Component} [sender=this] - The event originator.
	* @returns {this} The callee for chaining.
	* @public
	*/
	waterfallDown: function(nom, event, sender) {
		var comp;
		event = event || {};
		event.bubbling = false;

		if (!this._silenced) {
			for (comp in this.$) this.$[comp].waterfall(nom, event, sender || this);
		}

		return this;
	},

	/**
	* @private
	*/
	_silenced: false,

	/**
	* @private
	*/
	_silenceCount: 0,

	/**
	* Sets a flag that disables {@glossary event} propagation for this
	* [component]{@link enyo.Component}. Also increments an internal counter that tracks
	* the number of times the [unsilence()]{@link enyo.Component#unsilence} method must
	* be called before event propagation will continue.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	silence: function () {
		this._silenced = true;
		this._silenceCount += 1;

		return this;
	},

	/**
	* Determines if the [object]{@glossary Object} is currently
	* [silenced]{@link enyo.Component#_silenced}, which will prevent propagation of
	* [events]{@glossary event} (of any kind).
	*
	* @returns {Boolean} `true` if silenced; otherwise, `false`.
	* @public
	*/
	isSilenced: function () {
		return this._silenced;
	},

	/**
	* Allows {@glossary event} propagation for this [component]{@link enyo.Component}
	* if the internal silence counter is `0`; otherwise, decrements the counter by one.
	* For event propagation to resume, this method must be called one time each call to
	* [silence()]{@link enyo.Component#silence}.
	*
	* @returns {Boolean} `true` if the {@link enyo.Component} is now unsilenced completely;
	*	`false` if it remains silenced.
	* @public
	*/
	unsilence: function () {
		if (0 !== this._silenceCount) --this._silenceCount;
		if (0 === this._silenceCount) this._silenced = false;
		return !this._silenced;
	},

	/**
	* Creates a new [job]{@link enyo.job} tied to this instance of the
	* [component]{@link enyo.Component}. If the component is
	* [destroyed]{@link enyo.Component#destroy}, any jobs associated with it
	* will be stopped.
	*
	* If you start a job with the same name as a pending job,
	* the original job will be stopped; this can be useful for resetting
	* timeouts.
	*
	* You may supply a priority level (1-10) at which the job should be
	* executed. The default level is `5`. Setting the priority lower than `5` (or setting it to
	* the string `"low"`) will defer the job if an animation is in progress,
	* which can help to avoid stuttering.
	*
	* @param {String} nom - The name of the [job]{@link enyo.job} to start.
	* @param {(Function|String)} job - Either the name of a method or a
	*	[function]{@glossary Function} to execute as the requested job.
	* @param {Number} wait - The number of milliseconds to wait before starting
	*	the job.
	* @param {Number} [priority=5] The priority value to be associated with this
	*	job.
	* @returns {this} The callee for chaining.
	* @public
	*/
	startJob: function (nom, job, wait, priority) {
		var jobs = (this.__jobs = this.__jobs || {});
		priority = priority || 5;
		// allow strings as job names, they map to local method names
		if (typeof job == 'string') job = this[job];
		// stop any existing jobs with same name
		this.stopJob(nom);
		jobs[nom] = setTimeout(this.bindSafely(function() {
			Jobs.add(this.bindSafely(job), priority, nom);
		}), wait);

		return this;
	},

	/**
	* Stops a [component]{@link enyo.Component}-specific [job]{@link enyo.job} before it has
	* been activated.
	*
	* @param {String} nom - The name of the [job]{@link enyo.job} to be stopped.
	* @returns {this} The callee for chaining.
	* @public
	*/
	stopJob: function (nom) {
		var jobs = (this.__jobs = this.__jobs || {});
		if (jobs[nom]) {
			clearTimeout(jobs[nom]);
			delete jobs[nom];
		}
		Jobs.remove(nom);
	},

	/**
	* Executes the specified [job]{@link enyo.job} immediately, then prevents
	* any other calls to `throttleJob()` with the same job name from running for
	* the specified amount of time.
	*
	* @param {String} nom - The name of the [job]{@link enyo.job} to throttle.
	* @param {(Function|String)} job - Either the name of a method or a
	*	[function]{@glossary Function} to execute as the requested job.
	* @param {Number} wait - The number of milliseconds to wait before executing the
	*	job again.
	* @returns {this} The callee for chaining.
	* @public
	*/
	throttleJob: function (nom, job, wait) {
		var jobs = (this.__jobs = this.__jobs || {});
		// if we still have a job with this name pending, return immediately
		if (!jobs[nom]) {
			// allow strings as job names, they map to local method names
			if (typeof job == 'string') job = this[job];
			job.call(this);
			jobs[nom] = setTimeout(this.bindSafely(function() {
				this.stopJob(nom);
			}), wait);
		}
		return this;
	}
});

/**
* @private
*/
kind.setDefaultCtor(Component);

/**
* Creates new instances from [config]{@glossary configurationBlock}
* [objects]{@glossary Object}. This method looks up the proper
* [constructor]{@glossary constructor} based on the provided [kind]{@glossary kind}
* attribute.
*
* @name enyo.create
* @param {Object} props - The properties that define the [kind]{@glossary kind}.
* @returns {*} An instance of the requested [kind]{@glossary kind}.
* @public
*/
Component.create = function (props) {
	var theKind,
		Ctor;

	if (!props.kind && props.hasOwnProperty('kind')) throw new Error(
		'enyo.create: Attempt to create a null kind. Check dependencies for [' + props.name + ']'
	);

	theKind = props.kind || props.isa || kind.getDefaultCtor();
	Ctor = kind.constructorForKind(theKind);

	if (!Ctor) {
		logger.error('No constructor found for kind ' + theKind);
		Ctor = Component;
	}

	return new Ctor(props);
};

/**
* @name enyo.Component.subclass
* @static
* @private
*/
Component.subclass = function (ctor, props) {
	// Note: To reduce API surface area, sub-components are declared only as
	// 'components' in both kind and instance declarations.
	//
	// However, 'components' from kind declarations must be handled separately
	// at creation time.
	//
	// We rename the property here to avoid having
	// to interrogate the prototype at creation time.
	//
	var proto = ctor.prototype;
	//
	if (props.components) {
		proto.kindComponents = props.components;
		delete proto.components;
	} else {
		// Feature to mixin overrides of super-kind component properties from named hash
		// (only applied when the sub-kind doesn't supply its own components block)
		if (props.componentOverrides) {
			proto.kindComponents = Component.overrideComponents(
				proto.kindComponents,
				props.componentOverrides,
				proto.defaultKind
			);
		}
	}
};

/**
* @name enyo.Component.concat
* @static
* @private
*/
Component.concat = function (ctor, props) {
	var proto = ctor.prototype || ctor,
		handlers;
	if (props.handlers) {
		handlers = proto.handlers ? utils.clone(proto.handlers) : {};
		proto.handlers = utils.mixin(handlers, props.handlers);
		delete props.handlers;
	}
	if (props.events) Component.publishEvents(proto, props);
};

/**
* @name enyo.Component.overrideComponents
* @static
* @private
*/
Component.overrideComponents = function (components, overrides, defaultKind) {
	var fn = function (k, v) { return !(utils.isFunction(v) || kind.isInherited(v)); };
	components = utils.clone(components);
	for (var i=0; i<components.length; i++) {
		var c = utils.clone(components[i]);
		var o = overrides[c.name];
		var ctor = kind.constructorForKind(c.kind || defaultKind);
		if (o) {

			// NOTE: You cannot overload mixins, observers or computed properties from
			// component overrides
			kind.concatHandler(c, o);
			var b = (c.kind && ((typeof c.kind == 'string' && utils.getPath(c.kind)) || (typeof c.kind == 'function' && c.kind))) || kind.getDefaultCtor();
			while (b) {
				if (b.concat) { b.concat(c, o, true); }
				b = b.prototype.base;
			}
			// All others just mix in
			utils.mixin(c, o, {filter: fn});
		}
		if (c.components) {
			c.components = Component.overrideComponents(c.components, overrides, ctor.prototype.defaultKind);
		}
		components[i] = c;
	}
	return components;
};

/**
* @name enyo.Component.publishEvents
* @static
* @private
*/
Component.publishEvents = function (ctor, props) {
	var events = props.events,
		event,
		proto;
	if (events) {
		proto = ctor.prototype || ctor;
		for (event in events) Component.addEvent(event, events[event], proto);
	}
};

/**
* @name enyo.Component.addEvent
* @static
* @private
*/
Component.addEvent = function (nom, val, proto) {
	var v, fn;
	if (!utils.isString(val)) {
		v = val.value;
		fn = val.caller;
	} else {
		if (nom.slice(0, 2) != 'on') {
			logger.warn('enyo.Component.addEvent: event names must start with "on". ' + proto.kindName + ' ' +
				'event "' + nom + '" was auto-corrected to "on' + nom + '".');
			nom = 'on' + nom;
		}
		v = val;
		fn = 'do' + utils.cap(nom.slice(2));
	}
	proto[nom] = v;
	if (!proto[fn]) {
		proto[fn] = function(payload, other) {
			// bubble this event

			// if the second parameter exists then we use that - this is for a single case
			// where a named event delegates happent to point to an auto generated event
			// bubbler like this one - in that case the first parameter is actually the
			// sender
			var e = other || payload;
			if (!e) {
				e = {};
			}
			var d = e.delegate;
			// delete payload.delegate;
			e.delegate = undefined;
			if (!utils.exists(e.type)) {
				e.type = nom;
			}
			this.bubble(nom, e);
			if (d) {
				e.delegate = d;
			}
		};
	}
};

/**
* @private
*/
function prefixFromKindName (nom) {
	var pre = kindPrefix[nom],
		last;

	if (!pre) {
		last = nom.lastIndexOf('.');
		pre = (last >= 0) ? nom.slice(last+1) : nom;
		pre = pre.charAt(0).toLowerCase() + pre.slice(1);
		kindPrefix[nom] = pre;
	}

	return pre;
}
},{"../../enyo":1,"./ApplicationSupport":6,"./ComponentBindingSupport":14,"./CoreObject":17,"./jobs":64,"./kind":66,"./logger":67,"./utils":75}],25:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	Async = require('./Async'),
	Ajax = require('./Ajax');

/**
* {@link enyo.JsonpRequest} is an [Async]{@link enyo.Async} task specifically designed
* to wrap {@glossary JSONP} requests to a remote server. Be sure to read about the use
* cases for JSONP requests, along with the documentation on [Consuming Web
* Services]{@linkplain $dev-guide/building-apps/managing-data/consuming-web-services.html}
* in the Enyo Developer Guide.
*
* @class enyo.JsonpRequest
* @extends enyo.Async
* @public
*/
var JsonpRequest = module.exports = kind(
	/** @lends enyo.JsonpRequest.prototype */ {
	
	name: 'enyo.JsonpRequest',
	
	/**
	* @private
	*/
	kind: Async,
	
	/**
	* @private
	*/
	published: {
		
		/**
		* The URL for the service.
		*
		* @memberof enyo.JsonpRequest.prototype
		* @type {String}
		* @default ''
		* @public
		*/
		url: '',
		
		/**
		* The optional character set to use to interpret the return data.
		*
		* @memberof enyo.JsonpRequest.prototype
		* @type {String}
		* @default null
		* @public
		*/
		charset: null,
		
		/**
		* The name of the [function]{@glossary Function} that is included in the
		* encoded arguments and used to wrap the return value from the server.
		* This may also be set to `null` in some cases.
		*
		* @see enyo.JsonpRequest.overrideCallback
		* @memberof enyo.JsonpRequest.prototype
		* @type {String}
		* @default 'callback'
		* @public
		*/
		callbackName: 'callback',
		
		/**
		* When `true`, a random number is appended as a parameter for GET requests
		* to (attempt to) force a new fetch of the resource instead of reusing a
		* local cache.
		*
		* @memberof enyo.JsonpRequest.prototype
		* @type {Boolean}
		* @default true
		* @public
		*/
		cacheBust: true,
		
		/**
		* In cases where a backend is inflexible with regard to
		* [callback]{@link enyo.JsonpRequest#callback} names, this property may be used to
		* specify a global [function]{@glossary Function} instead. Note that when using
		* this, it will replace any existing function with the given
		* name and only one [JsonpRequest]{@link enyo.JsonpRequest} using this property may
		* be active at a time.
		*
		* @memberof enyo.JsonpRequest.prototype
		* @type {String}
		* @default null
		* @public
		*/
		overrideCallback: null
	},
	
	/**
	* @private
	*/
	protectedStatics: {
		// Counter to allow creation of unique name for each JSONP request
		nextCallbackID: 0
	},
	
	/**
	* @private
	*/
	addScriptElement: function () {
		var script = document.createElement('script');
		script.src = this.src;
		script.async = 'async';
		if (this.charset) {
			script.charset = this.charset;
		}
		// most modern browsers also have an onerror handler
		script.onerror = this.bindSafely(function() {
			// we don't get an error code, so we'll just use the generic 400 error status
			this.fail(400);
		});
		// add script before existing script to make sure it's in a valid part of document
		// http://www.jspatterns.com/the-ridiculous-case-of-adding-a-script-element/
		var first = document.getElementsByTagName('script')[0];
		first.parentNode.insertBefore(script, first);
		this.scriptTag = script;
	},
	
	/**
	* @private
	*/
	removeScriptElement: function () {
		var script = this.scriptTag;
		this.scriptTag = null;
		script.onerror = null;
		if (script.parentNode) {
			script.parentNode.removeChild(script);
		}
	},
	
	/**
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function (params) {
			utils.mixin(this, params);
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* Initiates the asynchronous routine and will supply the given value if it completes
	* successfully. Overloaded from [enyo.Async.go()]{@link enyo.Async#go}.
	*
	* @param {*} value - The value to pass to responders.
	* @returns {this} The callee for chaining.
	* @public
	*/
	go: function (value) {
		this.startTimer();
		this.jsonp(value);
		return this;
	},
	
	/**
	* @private
	*/
	jsonp: function (params) {
		var callbackFunctionName = this.overrideCallback ||
			'enyo_jsonp_callback_' + (JsonpRequest.nextCallbackID++);
		//
		this.src = this.buildUrl(params, callbackFunctionName);
		this.addScriptElement();
		//
		global[callbackFunctionName] = this.bindSafely(this.respond);
		//
		// setup cleanup handlers for JSONP completion and failure
		var cleanup = this.bindSafely(function() {
			this.removeScriptElement();
			global[callbackFunctionName] = null;
		});
		this.response(cleanup);
		this.error(cleanup);
	},
	
	/**
	* @private
	*/
	buildUrl: function(params, fn) {
		var parts = this.url.split('?');
		var uri = parts.shift() || '';
		var args = parts.length? parts.join('?').split('&'): [];
		//
		var bodyArgs = this.bodyArgsFromParams(params, fn);
		args.push(bodyArgs);
		if (this.cacheBust) {
			args.push(Math.random());
		}
		//
		return [uri, args.join('&')].join('?');
	},
	
	/**
	* If `params` is a string, we follow the convention of replacing the string
	* `'=?'` with the callback name. If `params` is an object (the more common
	* case), we add an argument using the `callbackName` published property.
	*
	* @private
	*/
	bodyArgsFromParams: function(params, fn) {
		if (utils.isString(params)) {
			return params.replace('=?', '=' + fn);
		} else {
			params = params ? utils.clone(params, true) : {};
			if (this.callbackName) {
				params[this.callbackName] = fn;
			}
			return Ajax.objectToQuery(params);
		}
	}
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./Ajax":2,"./Async":7,"./kind":66,"./utils":75}],5:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	animation = require('./animation');

var
	Component = require('./Component'),
	Jobs = require('./jobs');

/**
* Fires when an animation step occurs.
*
* @event enyo.Animator#onStep
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires when the animation finishes normally.
*
* @event enyo.Animator#onEnd
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires when the animation is prematurely stopped.
*
* @event enyo.Animator#onStop
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Animator} is a basic animation [component]{@link enyo.Component}.  Call
* [play()]{@link enyo.Animator#play} to start the animation. The animation will run for
* the period (in milliseconds) specified by its [duration]{@link enyo.Animator#duration}
* property. [onStep]{@link enyo.Animator#onStep} [events]{@glossary event} will
* fire in quick succession and should be handled to do something based on the
* [value]{@link enyo.Animator#value} property.
*
* The `value` property will progress from [startValue]{@link enyo.Animator#startValue}
* to [endValue]{@link enyo.Animator#endValue} during the animation, based on the
* [function]{@glossary Function} referenced by the
* [easingFunction]{@link enyo.Animator#easingFunction} property.
* 
* Event handlers may be specified as functions. If specified, the handler function will
* be used to handle the event directly, without sending the event to its
* [owner]{@link enyo.Component#owner} or [bubbling]{@link enyo.Component#bubble} it.
* The [context]{@link enyo.Animator#context} property may be used to call the supplied
* event functions in a particular `this` context.
* 
* During animation, an {@link enyo.jobs} priority of 5 is registered to defer low priority 
* tasks.
*
* @class enyo.Animator
* @extends enyo.Component
* @public
*/
module.exports = kind(
	/** @lends enyo.Animator.prototype */ {

	/**
	* A context in which to run the specified {@glossary event} handlers. If this is
	* not specified or is falsy, then the [global object]{@glossary global} is used.
	* 
	* @name context
	* @type {Object}
	* @default undefined
	* @memberOf enyo.Animator.prototype
	* @public
	*/
		
	name: 'enyo.Animator',

	/**
	* @private
	*/
	kind: Component,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Animator.prototype */ {
		
		/** 
		* Animation duration in milliseconds
		*
		* @type {Number}
		* @default 350
		* @public
		*/
		duration: 350,

		/** 
		* Value of [value]{@link enyo.Animator#value} property at the beginning of an animation.
		*
		* @type {Number}
		* @default 0
		* @public
		*/
		startValue: 0,

		/** 
		* Value of [value]{@link enyo.Animator#value} property at the end of an animation.
		*
		* @type {Number}
		* @default 1
		* @public
		*/
		endValue: 1,

		/** 
		* Node that must be visible in order for the animation to continue. This reference is 
		* destroyed when the animation ceases.
		*
		* @type {Object}
		* @default null
		* @public
		*/
		node: null,

		/** 
		* [Function]{@glossary Function} that determines how the animation progresses from 
		* [startValue]{@link enyo.Animator#startValue} to [endValue]{@link enyo.Animator#endValue}.
		* 
		* @type {Function}
		* @default enyo.easing.cubicOut
		* @public
		*/
		easingFunction: animation.easing.cubicOut
	},
	
	/*
	* @private
	*/
	events: {
		onStep: '',
		onEnd: '',
		onStop: ''
	},

	/**
	* @method
	* @private
	*/
	constructed: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this._next = this.bindSafely('next');
		};
	}),

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			this.stop();
			sup.apply(this, arguments);
		};
	}),

	/** 
	* Plays the animation.
	*
	* @param {Object} props - As a convenience, this [hash]{@glossary Object} will be mixed
	*	directly into this [object]{@glossary Object}.
	* @public
	*/
	play: function (props) {
		this.stop();
		this.reversed = false;
		if (props) {
			utils.mixin(this, props);
		}
		this.t0 = this.t1 = utils.perfNow();
		this.value = this.startValue;

		// register this jobPriority to block less urgent tasks from executing
		Jobs.registerPriority(5, this.id);

		this.job = true;
		this.next();
		return this;
	},

	/** 
	* Stops the animation and fires the associated {@glossary event}.
	*
	* @fires enyo.Animator#onStop
	* @returns {this} The callee for chaining.
	* @public
	*/
	stop: function () {
		if (this.isAnimating()) {
			this.cancel();
			this.fire('onStop');
			return this;
		}
	},

	/**
	* Stops the animation after a final step
	*
	* @returns {this} The callee for chaining
	* @public
	*/
	complete: function () {
		if (this.isAnimating()) {
			// set the start time such that the delta will always be greater than the duration
			// causing the animation to complete immediately
			this.t0 = -this.duration - 1;
			this.next();
		}

		return this;
	},

	/** 
	* Reverses the direction of a running animation.
	* 
	* @return {this} The callee for chaining.
	* @public
	*/
	reverse: function () {
		if (this.isAnimating()) {
			this.reversed = !this.reversed;
			var now = this.t1 = utils.perfNow();
			// adjust start time (t0) to allow for animation done so far to replay
			var elapsed = now - this.t0;
			this.t0 = now + elapsed - this.duration;
			// swap start and end values
			var startValue = this.startValue;
			this.startValue = this.endValue;
			this.endValue = startValue;
			return this;
		}
	},

	/**
	* Determines whether an animation is in progress.
	*
	* @returns {Boolean} `true` if there is an animation currently running; otherwise, `false`.
	* @private
	*/
	isAnimating: function () {
		return Boolean(this.job);
	},

	/**
	* @private
	*/
	requestNext: function () {
		this.job = animation.requestAnimationFrame(this._next, this.node);
	},

	/**
	* @private
	*/
	cancel: function () {
		animation.cancelRequestAnimationFrame(this.job);
		this.node = null;
		this.job = null;

		// unblock job queue
		Jobs.unregisterPriority(this.id);
	},

	/**
	* @private
	*/
	shouldEnd: function () {
		return (this.dt >= this.duration);
	},

	/**
	* Runs the next step of the animation.
	*
	* @fires enyo.Animator#onStep
	* @fires enyo.Animator#onEnd
	* @private
	*/
	next: function () {
		this.t1 = utils.perfNow();
		this.dt = this.t1 - this.t0;
		var args = this.easingFunction.length;
		var f;

		if (args === 1) {
			// time independent
			f = this.fraction = animation.easedLerp(this.t0, this.duration, this.easingFunction, this.reversed);
			this.value = this.startValue + f * (this.endValue - this.startValue);
		} else {
			this.value = animation.easedComplexLerp(this.t0, this.duration, this.easingFunction, this.reversed,
				this.dt, this.startValue, (this.endValue - this.startValue));
		}
		if (((f >= 1) && (args === 1)) || this.shouldEnd()) {
			this.value = this.endValue;
			this.fraction = 1;
			this.fire('onStep');
			this.cancel();
			utils.asyncMethod(this.bindSafely(function() {
				this.fire('onEnd');
			}));
		} else {
			this.fire('onStep');
			this.requestNext();
		}
	},

	/**
	* @private
	*/
	fire: function (nom) {
		var fn = this[nom];
		if (utils.isString(fn)) {
			this.bubble(nom);
		} else if (fn) {
			fn.call(this.context || global, this);
		}
	}
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./Component":13,"./animation":56,"./jobs":64,"./kind":66,"./utils":75}],12:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	Component = require('./Component'),
	EventEmitter = require('./EventEmitter'),
	Model = require('./Model'),
	ModelList = require('./ModelList'),
	StateSupport = require('./StateSupport'),
	Source = require('./Source'),
	Store = require('./Store'),
	States = require('./States');

/**
* This is only necessary because of the order in which mixins are applied.
*
* @class
* @private
*/
var BaseCollection = kind({
	kind: Component,
	mixins: [EventEmitter, StateSupport]
});

/**
* Fires when [models]{@link enyo.Model} have been [added]{@link enyo.Collection#add}
* to the [collection]{@link enyo.Collection}.
*
* @event enyo.Collection#add
* @type {Object}
* @property {enyo.Model[]} models - An [array]{@glossary Array} of
*	[models]{@link enyo.Model} that were [added]{@link enyo.Collection#add} to the
*	[collection]{@link enyo.Collection}.
* @property {enyo.Collection} collection - A reference to the
*	collection that [emitted]{@link enyo.EventEmitter.emit} the event.
* @property {Number} index - The index in the given collection where the models were inserted.
* @public
*/

/**
* Fires when [models]{@link enyo.Model} have been [removed]{@link enyo.Collection#remove}
* from the [collection]{@link enyo.Collection}.
*
* @event enyo.Collection#remove
* @type {Object}
* @property {enyo.Model[]} models - An [array]{@glossary Array} of
*	[models]{@link enyo.Model} that were [removed]{@link enyo.Collection#remove} from the
*	[collection]{@link enyo.Collection}.
* @property {enyo.Collection} collection - A reference to the
*	collection that [emitted]{@link enyo.EventEmitter.emit} the event.
* @public
*/

/**
* Fires when the [collection]{@link enyo.Collection} has been
* [sorted]{@link enyo.Collection#sort}.
*
* @event enyo.Collection#sort
* @type {Object}
* @property {enyo.Model[]} models - An [array]{@glossary Array} of all
*	[models]{@link enyo.Model} in the correct, [sorted]{@link enyo.Collection#sort} order.
* @property {enyo.Collection} collection - A reference to the
*	[collection]{@link enyo.Collection} that [emitted]{@link enyo.EventEmitter.emit} the event.
* @property {Function} comparator - A reference to the
*	[comparator]{@link enyo.Collection#comparator} that was used when
*	sorting the collection.
* @public
*/

/**
* Fires when the [collection]{@link enyo.Collection} has been reset and its
* contents have been updated arbitrarily.
*
* @event enyo.Collection#reset
* @type {Object}
* @property {enyo.Model[]} models - An [array]{@glossary Array} of all
*	[models]{@link enyo.Model} as they are currently.
* @property {enyo.Collection} collection - A reference to the
*	[collection]{@link enyo.Collection} that [emitted]{@link enyo.EventEmitter.emit} the event.
* @public
*/

/**
* The default configurable [options]{@link enyo.Collection#options} used by certain API
* methods of {@link enyo.Collection}.
*
* @typedef {Object} enyo.Collection~Options
* @property {Boolean} merge=true - If `true`, when data is being added to the
*	[collection]{@link enyo.Collection} that already exists (i.e., is matched by
*	[primaryKey]{@link enyo.Model#primaryKey}), the new data values will be set
* with the current [model]{@link enyo.Model} instance. This means that the
* existing values will be updated with the new ones by calling
* [set()]{@link enyo.Model#set} on the model.
* @property {Boolean} silent=false - Many accessor methods of the collection
*	will emit events and/or notifications. This value indicates whether or not
*	those events or notifications will be suppressed at times when that behavior
*	is necessary. Typically, you will not want to modify this value.
* @property {Boolean} purge=false - When [adding]{@link enyo.Collection#add}
*	models, this flag indicates whether or not to [remove]{@link enyo.Collection#remove}
* (purge) the existing models that are not included in the new dataset.
* @property {Boolean} parse=false - The collection's [parse()]{@link enyo.Collection#parse}
*	method can be executed automatically when incoming data is added via the
*	[constructor()]{@link enyo.Collection#constructor} method, or, later, via a
*	[fetch]{@link enyo.Collection#fetch}. You may need to examine the runtime
* configuration options of the method(s) to determine whether parsing is needed.
* In cases where parsing will always be necessary, this may be set to `true`.
* @property {Boolean} create=true - This value determines whether a new
*	model will be created when data being added to the collection cannot be found
* (or the [find]{@link enyo.Collection#options#find} flag is `false`). Models
* that are created by a collection have their [owner]{@link enyo.Model#owner}
* property set to the collection that instanced them.
* @property {Boolean} find=true - When data being added to the collection is not
* already a model instance, the collection will attempt to find an existing model
* by its `primaryKey`, if it exists. In most cases, this is the preferred behavior,
* but if the model [kind]{@glossary kind} being  instanced does not have a
* `primaryKey`, it is unnecessary and this value may be set to `false`.
* @property {Boolean} sort=false - When adding models to the collection, the
* collection can also be sorted. If the [comparator]{@link enyo.Collection#comparator}
* is a [function]{@glossary Function} and this value is `true`, the comparator
*	will be used to sort the entire collection. It may also be a function that
* will be used to sort the collection, instead of (or in the place of) a defined
*	comparator.
* @property {Boolean} commit=false - When modifications are made to the
*	collection, this flag ensures that those changes are
*	[committed]{@link enyo.Collection#commit} according to the configuration and
*	availability of a [source]{@link enyo.Collection#source}. This may also be
* configured per-call to methods that use it.
* @property {Boolean} destroy=false - When models are removed from the collection,
*	this flag indicates whether or not they will be [destroyed]{@link enyo.Model#destroy}
* as well. Note that this could have a significant impact if the same models are
* used in other collections.
* @property {Boolean} complete=false - When models are removed from the
* collection, this flag indicates whether or not they will also be removed from
* the [store]{@link enyo.Collection#store}. This is rarely necessary and can
* cause problems if the models are used in other collections. In addition, this
* value will be ignored if the [destroy]{@link enyo.Collection#options#destroy}
* flag is `true`.
* @property {Boolean} fetch=false - If `true`, when the collection is initialized,
* it will automatically attempt to fetch data if the
* [source]{@link enyo.Collection#source} and [url]{@link enyo.Collection#url}
*	or [getUrl]{@link enyo.Collection#getUrl} properties are properly configured.
* @property {Boolean} modelEvents=true - If `false`, this will keep the collection from
*	registering with each model for individual model events.
*/

/**
* The configuration options for [add()]{@link enyo.Collection#add}. For complete
* descriptions of the options and their default values, see
* {@link enyo.Collection#options}. Note that some properties have different
* meanings in different contexts. Please review the descriptions below to see
* how each property is used in this context.
* 
* @typedef {enyo.Collection~Options} enyo.Collection~AddOptions
* @property {Boolean} merge - Update existing [models]{@link enyo.Model} when found.
* @property {Boolean} purge - Remove existing models not in the new dataset.
* @property {Boolean} silent - Emit [events]{@glossary event} and notifications.
* @property {Boolean} parse - Parse the incoming dataset before evaluating.
* @property {Boolean} find - Look for an existing model.
* @property {(Boolean|Function)} sort - Sort the finalized dataset.
* @property {Boolean} commit - [Commit]{@link enyo.Collection#commit} changes to the
*	{@link enyo.Collection} after completing the [add]{@link enyo.Collection#add}
* operation.
* @property {Boolean} create - When an existing {@link enyo.Model} instance cannot be
*	resolved, a new instance should be created.
* @property {number} index - The index at which to add the new dataset. Defaults to the
*	end of the current dataset if not explicitly set or invalid.
* @property {Boolean} destroy - If `purge` is `true`, this will
* [destroy]{@link enyo.Model#destroy} any models that are
* [removed]{@link enyo.Collection#remove}.
* @property {Object} modelOptions - When instancing a model, this
*	[object]{@glossary Object} will be passed to the constructor as its `options`
*	parameter.
*/

/**
* The configuration options for [remove()]{@link enyo.Collection#remove}. For
* complete descriptions of the options and their defaults, see
* {@link enyo.Collection~Options}. Note that some properties have different
* meanings in different contexts. Please review the descriptions below to see
* how each property is used in this context.
* 
* @typedef {enyo.Collection~Options} enyo.Collection~RemoveOptions
* @property {Boolean} silent - Emit [events]{@glossary event} and notifications.
* @property {Boolean} commit - [Commit]{@link enyo.Collection#commit} changes to the
*	[collection]{@link enyo.Collection} after completing the
*	[remove]{@link enyo.Collection#remove} operation.
* @property {Boolean} complete - Remove the [model]{@link enyo.Model} from the
*	[store]{@link enyo.Collection#store} as well as the collection.
* @property {Boolean} destroy - [Destroy]{@link enyo.Model#destroy} models
*	that are removed from the collection.
*/

/**
* The configurable options for [fetch()]{@link enyo.Collection#fetch},
* [commit()]{@link enyo.Collection#commit}, and [destroy()]{@link enyo.Collection#destroy}.
*
* @typedef {enyo.Collection~Options} enyo.Collection~ActionOptions
* @property {enyo.Collection~Success} success - The callback executed upon successful
*	completion.
* @property {enyo.Collection~Error} error - The callback executed upon a failed attempt.
*/

/**
* @callback enyo.Collection~Success
* @param {enyo.Collection} collection - The [collection]{@link enyo.Collection}
* that is returning successfully.
* @param {enyo.Collection~ActionOptions} - opts The original options passed to the action method
*	that is returning successfully.
* @param {*} - res The result, if any, returned by the [source]{@link enyo.Source} that
*	executed it.
* @param {String} source - The name of the [source]{@link enyo.Collection#source} that has
*	returned successfully.
*/

/**
* @callback enyo.Collection~Error
* @param {enyo.Collection} collection - The [collection]{@link enyo.Collection}
* that is returning an error.
* @param {String} action - The name of the action that failed, one of `'FETCHING'`,
*	`'COMMITTING'`, or `'DESTROYING'`.
* @param {enyo.Collection~ActionOptions} opts - The original options passed to the
*	action method that is returning an error.
* @param {*} res - The result, if any, returned by the [source]{@link enyo.Source}
*	that executed it.
* @param {String} source - The name of the [source]{@link enyo.Collection#source}
*	that has returned an error.
*/

/**
* A method used to compare two elements in an {@link enyo.Collection}. Should be
* implemented like callbacks used with [Array.sort()]{@glossary Array.sort}.
*
* @see {@glossary Array.sort}
* @see enyo.Collection.sort
* @see enyo.Collection.comparator
* @callback enyo.Collection~Comparator
* @param {enyo.Model} a - The first [model]{@link enyo.Model} to compare.
* @param {enyo.Model} b - The second model to compare.
* @returns {Number} `-1` if `a` should have the lower index, `0` if they are the same,
* or `1` if `b` should have the lower index.
*/

/**
* An array-like structure designed to store instances of {@link enyo.Model}.
* 
* @class enyo.Collection
* @extends enyo.Component
* @mixes enyo.StateSupport
* @mixes enyo.EventEmitter
* @public
*/
var Collection = module.exports = kind(
	/** @lends enyo.Collection.prototype */ {
	
	name: 'enyo.Collection',
	
	/**
	* @private
	*/
	kind: BaseCollection,
	
	/**
	* @private
	*/

	
	/**
	* Used by various [sources]{@link enyo.Collection#source} as part of the
	* [URI]{@glossary URI} from which they may be [fetched]{@link enyo.Collection#fetch},
	* [committed]{@link enyo.Collection#commit}, or [destroyed]{@link enyo.Collection#destroy}.
	* Some sources may use this property in other ways.
	*
	* @see enyo.Collection.getUrl
	* @see enyo.Source
	* @see enyo.AjaxSource
	* @see enyo.JsonpSource
	* @type {String}
	* @default ''
	* @public
	*/
	url: '',
	
	/**
	* Implement this method to be used by [sources]{@link enyo.Model#source} to
	* dynamically derive the [URI]{@glossary URI} from which they may be
	* [fetched]{@link enyo.Collection#fetch}, [committed]{@link enyo.Collection#commit},
	* or [destroyed]{@link enyo.Collection#destroy}. Some
	* [sources]{@link enyo.Collection#source} may use this property in other ways.
	* Note that if this method is implemented, the [url]{@link enyo.Collection#url}
	* property will not be used.
	*
	* @see enyo.Collection.url
	* @see enyo.Source
	* @see enyo.AjaxSource
	* @see enyo.JsonpSource
	* @type {Function}
	* @default null
	* @virtual
	* @public
	*/
	getUrl: null,
	
	/**
	* The [kind]{@glossary kind) of {@link enyo.Model} that this
	* [collection]{@link enyo.Collection} will contain. This is important to set properly so
	* that when [fetching]{@link enyo.Collection#fetch}, the returned data will be instanced
	* as the correct model [subkind]{@glossary subkind}.
	* 
	* @type {(enyo.Model|String)}
	* @default enyo.Model
	* @public
	*/
	model: Model,
	
	/**
	* A special type of [array]{@glossary Array} used internally by
	* {@link enyo.Collection}. The array should not be modified directly, nor
	* should the property be set directly. It is used as a container by the
	* collection. If [set]{@link enyo.Collection#set} directly, it will
	* [emit]{@link enyo.EventEmitter.emit} a [reset]{@link enyo.Collection#reset}
	* event.
	*
	* @see enyo.Collection.modelsChanged
	* @type enyo.ModelList
	* @default null
	* @readonly
	* @protected
	*/
	models: null,
	
	/**
	* The current [state]{@link enyo.States} of the [collection]{@link enyo.Collection}.
	* This value changes automatically and may be observed for more complex state
	* monitoring. The default value is [READY]{@link enyo~States.READY}.
	* (And let's try {@link enyo~States#READY} while we're at it.)
	* @see enyo.States
	* @see enyo.StateSupport
	* @type enyo.States
	* @default enyo.States.READY
	* @readonly
	* @public
	*/
	status: States.READY,
	
	/**
	* The configurable default [options]{@link enyo.Collection~Options}. These values will be
	* used to modify the behavior of the [collection]{@link enyo.Collection} unless additional
	* options are passed into the methods that use them. When modifying these values in a
	* [subkind]{@glossary subkind} of {@link enyo.Collection}, they will be merged with
	* existing values.
	* 
	* @type {enyo.Collection~Options}
	* @public
	*/
	options: {
		merge: true,
		silent: false,
		purge: false,
		parse: false,
		create: true,
		find: true,
		sort: false,
		commit: false,
		destroy: false,
		complete: false,
		fetch: false,
		modelEvents: true
	},
	
	/**
	* Modifies the structure of data so that it can be used by the
	* [add()]{@link enyo.Collection#add} method. This method will only be used
	* during initialization or after a successful [fetch]{@link enyo.Collection#fetch}
	* if the [parse]{@link enyo.Collection~Options.parse} flag is set to `true`.
	* It may be used for simple remapping, renaming, or complex restructuring of
	* data coming from a [source]{@link enyo.Collection#source} that requires
	* modification before it can be added to the [collection]{@link enyo.Collection}.
	* This is a virtual method and must be implemented.
	* 
	* @param {*} data - The incoming data passed to the
	*	[constructor]{@link enyo.Collection#constructor} or returned by a successful
	*	[fetch]{@link enyo.Collection#fetch}.
	* @returns {Array} The properly formatted data to be accepted by the
	*	[add()]{@link enyo.Collection#add} method.
	* @virtual
	* @public
	*/
	parse: function (data) {
		return data;
	},
	
	/**
	* Adds data to the [collection]{@link enyo.Collection}. This method can add an
	* individual [model]{@link enyo.Model} or an [array]{@glossary Array} of models.
	* It can splice them into the dataset at a designated index or remove models
	* from the existing dataset that are not included in the new one.
	* See {@link enyo.Collection~AddOptions} for detailed information on the
	* configuration options available for this method. This method is heavily
	* optimized for batch operations on arrays of models. For better performance,
	* ensure that loops do not consecutively call this method but instead
	* build an array to pass as the first parameter.
	* 
	* @fires enyo.Collection#add
	* @param {(Object|Object[]|enyo.Model|enyo.Model[])} models The data to add to the
	*	{@link enyo.Collection} that can be a [hash]{@glossary Object}, an array of
	*	hashes, an {@link enyo.Model} instance, or and array of `enyo.Model` instances.
	* Note that if the [parse]{@link enyo.Collection#options#parse} configuration
	* option is `true`, it will use the returned value as this parameter.
	* @param {enyo.Collection~AddOptions} [opts] - The configuration options that modify
	*	the behavior of this method. The default values will be merged with these options
	* before evaluating.
	* @returns {enyo.Model[]} The models that were added, if any.
	* @public
	*/
	add: function (models, opts) {
		var loc = this.models
			, len = this.length
			, ctor = this.model
			, options = this.options
			, pkey = ctor.prototype.primaryKey
			, idx = len
			, removedBeforeIdx = 0
			, added, keep, removed, model, attrs, found, id;
			
		// for backwards compatibility with earlier api standards we allow the
		// second paramter to be the index and third param options when
		// necessary
		!isNaN(opts) && (idx = opts);
		arguments.length > 2 && (opts = arguments[2]);
		
		// normalize options so we have values
		opts = opts? utils.mixin({}, [options, opts]): options;
		
		// our flags
		var merge = opts.merge
			, purge = opts.purge
			, silent = opts.silent
			, parse = opts.parse
			, find = opts.find
			, sort = opts.sort
			, commit = opts.commit
			, create = opts.create !== false
			, modelOpts = opts.modelOptions
			, index = opts.index;
			
		idx = !isNaN(index) ? Math.max(0, Math.min(len, index)) : idx;

		/*jshint -W018 */
		sort && !(typeof sort == 'function') && (sort = this.comparator);
		/*jshint +W018 */
		
		// for a special case purge to remove records that aren't in the current
		// set being added
		
		if (parse) models = this.parse(models);
			
		// we treat all additions as an array of additions
		!(models instanceof Array) && (models = [models]);
		
		for (var i=0, end=models.length; i<end; ++i) {
			model = models[i];
			attrs = null;
			
			if (!model && isNaN(model)) continue;
			
			// first determine if the model is an instance of model since
			// everything else hinges on this
			if (!(model instanceof Model)) {
				// we need to determine how to handle this
				attrs = model;
			}
			
			if (typeof attrs == 'string' || typeof attrs == 'number') {
				id = attrs;
				attrs = {};
				attrs[pkey] = id;
			} else id = attrs? attrs[pkey]: model;
				
			
			// see if we have an existing entry for this model/hash
			if (find) found = loc.has(id);
			
			// if it already existed...
			if (found) {
				
				// we need to ensure we've resolved the model (if necessary)
				found = loc.resolve(id);
				
				if (merge) {
					attrs || (attrs = model.attributes);
					found.set(attrs, opts);
				}
				// with the purge flag we endeavor on the expensive track of removing
				// those models currently in the collection that aren't in the incoming
				// dataset and aren't being created
				if (purge) {
					keep || (keep = {length: 0});
					keep[found.euid] = model;
					keep.length++;
				}
			} else if (attrs && find && (found = this.store.resolve(ctor, id))) {
				// in this case we were asked to search our store for an existing record
				// and we found one but we didn't previously have it so we are technically
				// adding it
				// @NOTE: Setting the _find_ option always assumes _merge_
				attrs || (attrs = model.attributes);
				parse && (attrs = found.parse(attrs));
				added || (added = []);
				added.push(found);
				this.prepareModel(found, opts);
				merge && found.set(attrs, opts);
			} else if (!attrs) {
				added || (added = []);
				added.push(model);
				this.prepareModel(model);
			} else if (create) {
				model = this.prepareModel(attrs || model, modelOpts);
				added || (added = []);
				added.push(model);
				
				// with the purge flag we endeavor on the expensive track of removing
				// those models currently in the collection that aren't in the incoming
				// dataset and aren't being created
				if (purge) {
					keep || (keep = {length: 0});
					keep[model.euid] = model;
					keep.length++;
				}
			}
		}
		
		// here we process those models to be removed if purge was true
		// the other guard is just in case we actually get to keep everything
		// so we don't do this unnecessary pass
		if (purge && (keep && keep.length)) {
			removed || (removed = []);
			keep || (keep = {});
			for (i=0; i<len; ++i) {
				if (!keep[(model = loc[i]).euid]) {
					removed.push(model);
					if (i < idx) removedBeforeIdx++;
				}
			} 
			// if we removed any we process that now
			removed.length && this.remove(removed, opts);
			idx = idx - removedBeforeIdx;
		}
		
		// added && loc.stopNotifications().add(added, idx).startNotifications();
		if (added) {
			loc.add(added, idx);
			sort && this.sort(sort, {silent: true});
			
			// we batch this operation to make use of its ~efficient array operations
			this.store.add(added); 
		}
		this.length = loc.length;
		
		
		if (!silent) {
			// notify observers of the length change
			len != this.length && this.notify('length', len, this.length);
			// notify listeners of the addition of records
			if (added) {
				this.emit('add', {models: added, collection: this, index: idx});
			}
		}
		
		// note that if commit is set but this was called from a successful fetch this will be
		// a nop (as intended)
		commit && added && this.commit(opts);
		
		return added || [];
	},
	
	/**
	* Removes data from the [collection]{@link enyo.Collection}. It can take a
	* [model]{@link enyo.Model} or an [array]{@glossary Array} of models.
	* If any of the instances are present in the collection, they will be
	* removed in the order in which they are encountered. Emits the
	* [remove]{@link enyo.Collection#remove} event if any models were found and
	* removed from the collection (and the `silent` option is not `true`).
	* 
	* @fires enyo.Collection#remove
	* @param {(enyo.Model|enyo.Model[])} models The [models]{@link enyo.Model} to remove		
	*	if they exist in the [collection]{@link enyo.Collection}.
	* @param {enyo.Collection~RemoveOptions} [opts] - The configuration options that modify
	*	the behavior of this method.
	* @returns {enyo.Model[]} The models that were removed, if any.
	* @public
	*/
	remove: function (models, opts) {
		var loc = this.models
			, len = loc.length
			, options = this.options
			, removed, model;
		
		// normalize options so we have values
		opts = opts? utils.mixin({}, [options, opts]): options;
		
		// our flags
		var silent = opts.silent
			, destroy = opts.destroy
			, complete = opts.complete
			, commit = opts.commit;
		
		// we treat all additions as an array of additions
		!(models instanceof Array) && (models = [models]);
		
		removed = loc.remove(models);
		
		if (removed.length) {
			
			// ensure that we can batch remove from the store
			opts.batching = true;
			
			for (var i=0, end=removed.length; i<end; ++i) {
				model = removed[i];
				
				// it is possible but highly, highly unlikely that this would have been set
				// to false by default and true at runtime...so we take our chances for the
				// small performance gain in those situations where it was defaulted to false
				if (options.modelEvents) model.off('*', this._modelEvent, this);
				if (destroy) model.destroy(opts);
			}
			
			// if complete or destroy was set we remove them from the store (batched op)
			if (complete || destroy) this.store.remove(removed);
		}
		
		this.length = loc.length;
		
		if (!silent) {
			len != this.length && this.notify('length', len, this.length);
			if (removed.length) {
				this.emit('remove', {models: removed, collection: this});
			}
		}
		
		// if this is called from an overloaded method (such as fetch or commit) or some 
		// success callback this will be a nop (as intended)
		commit && removed.length && this.commit();
		
		return removed;
	},
	
	/**
	* Retrieves a [model]{@link enyo.Model} for the provided index.
	* 
	* @param {Number} idx - The index to return from the [collection]{@link enyo.Collection}.
	* @returns {(enyo.Model|undefined)} The [model]{@link enyo.Model} at the given index or
	*	`undefined` if it cannot be found.
	* @public
	*/
	at: function (idx) {
		return this.models[idx];
	},
	
	/**
	* Returns the JSON serializable [array]{@glossary Array} of [models]{@link enyo.Model}
	* according to their own [raw()]{@link enyo.Model#raw} output.
	*
	* @returns {enyo.Model[]} The [models]{@link enyo.Model} according to their
	*	[raw()]{@link enyo.Model#raw} output.
	* @public
	*/
	raw: function () {
		return this.models.map(function (model) {
			return model.raw();
		});
	},
	
	/**
	* Determines if the specified [model]{@link enyo.Model} is contained by this
	* [collection]{@link enyo.Collection}.
	*
	* @param {enyo.Model} model - The [model]{@link enyo.Model} to check.
	* @returns {Boolean} Whether or not the model belongs to the
	*	[collection]{@link enyo.Collection}.
	* @public
	*/
	has: function (model) {
		return this.models.has(model);
	},
	
	/**
	* @see {@glossary Array.forEach}
	* @public
	*/
	forEach: function (fn, ctx) {
		
		// ensure that this is an immutable reference to the models such that changes will
		// not affect the entire loop - e.g. calling destroy on models won't keep this from
		// completing
		return this.models.slice().forEach(fn, ctx || this);
	},
	
	/**
	* @see {@glossary Array.filter}
	* @public
	*/
	filter: function (fn, ctx) {
		
		// ensure that this is an immutable reference to the models such that changes will
		// not affect the entire loop - e.g. calling destroy on models won't keep this from
		// completing
		return this.models.slice().filter(fn, ctx || this);
	},
	
	/**
	* @see {@glossary Array.find}
	* @public
	*/
	find: function (fn, ctx) {
		
		// ensure that this is an immutable reference to the models such that changes will
		// not affect the entire loop - e.g. calling destroy on models won't keep this from
		// completing
		return this.models.slice().find(fn, ctx || this);
	},
	
	/**
	* @see {@glossary Array.map}
	* @public
	*/
	map: function (fn, ctx) {
		
		// ensure that this is an immutable reference to the models such that changes will
		// not affect the entire loop - e.g. calling destroy on models won't keep this from
		// completing
		return this.models.slice().map(fn, ctx || this);
	},
	
	/**
	* @see {@glossary Array.indexOf}
	* @public
	*/
	indexOf: function (model, offset) {
		return this.models.indexOf(model, offset);
	},
	
	/**
	* Removes all [models]{@link enyo.Model} from the [collection]{@link enyo.Collection}.
	* Optionally, a model (or models) may be provided to replace the removed models.
	* If this operation is not `silent`, it will emit a `reset` event. Returns the
	* removed models, but be aware that, if the `destroy` configuration option is set,
	* the returned models will have limited usefulness.
	* 
	* @param {(enyo.Model|enyo.Model[])} [models] The [model or models]{@link enyo.Model}
	*	to use as a replacement for the current set of models in the
	*	{@link enyo.Collection}.
	* @param {enyo.Collection~Options} [opts] - The options that will modify the behavior
	*	of this method.
	* @returns {enyo.Model[]} The models that were removed from the collection.
	* @public
	*/
	empty: function (models, opts) {
		var silent,
			removed,
			len = this.length;
		
		if (models && !(models instanceof Array || models instanceof Model)) {
			// there were no models but instead some options only
			opts = models;
			models = null;
		}
		
		opts = opts || {};
		
		// just in case the entire thing was supposed to be silent
		silent = opts.silent;
		opts.silent = true;
		
		removed = this.remove(this.models, opts);
		
		// if there are models we are going to propagate the remove quietly and instead issue
		// a single reset with the new content
		if (models) this.add(models, opts);
		
		// now if the entire thing wasn't supposed to have been done silently we issue
		// a reset
		if (!silent) {
			if (len != this.length) this.notify('length', len, this.length);
			this.emit('reset', {models: this.models.copy(), collection: this});
		}
		
		return removed;
	},
	
	/**
	* Returns the [JSON]{@glossary JSON} serializable [raw()]{@link enyo.Collection#raw}
	* output of the [collection]{@link enyo.Collection}. Will automatically be executed by
	* [JSON.parse()]{@glossary JSON.parse}.
	*
	* @see enyo.Collection.raw
	* @returns {Object} The return value of [raw()]{@link enyo.Collection#raw}.
	* @public
	*/
	toJSON: function () {
		return this.raw();
	},
	
	/**
	* The default behavior of this method is the same as {@glossary Array.sort}. If the
	* [function]{@glossary Function} parameter is omitted, it will attempt to use the
	* [comparator]{@link enyo.Collection#comparator} (if any) from the
	* [collection]{@link enyo.Collection}. Note that the collection is sorted in-place
	* and returns a reference to itself. The collection
	* [emits]{@link enyo.EventEmitter.emit} the [sort]{@link enyo.Collection#sort}
	* event.
	*
	* @fires enyo.Collection#sort
	* @see {@glossary Array.sort}
	* @param {enyo.Collection~Comparator} [fn] - The [comparator]{@link enyo.Collection#comparator}
	* method.
	* @param {enyo.Collection~Options} [opts] - The configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	sort: function (fn, opts) {
		if (fn || this.comparator) {
			var options = {silent: false}, silent;
		
			opts = opts? utils.mixin({}, [options, opts]): options;
			silent = opts.silent;
			this.models.sort(fn || this.comparator);
			!silent && this.emit('sort', {
				comparator: fn || this.comparator,
				models: this.models.copy(),
				collection: this
			});
		}
		return this;
	},
	
	/**
	* Commits the [collection]{@link enyo.Collection} to a
	* [source]{@link enyo.Collection#source} or sources. An {@link enyo.Collection}
	* cannot be committed if it is in an [error]{@link enyo.States.ERROR}
	* ({@link enyo.StateSupport.isError}) or [busy]{@link enyo.States.BUSY}
	* ({@link enyo.StateSupport.isBusy}) [state]{@link enyo.Model#status}. While
	* executing, it will add the [COMMITTING]{@link enyo.States.COMMITTING} flag
	* to the collection's [status]{@link enyo.Collection#status}. Once it has
	* completed execution, it will remove this flag (even if it fails).
	*
	* @see enyo.Collection.committed
	* @see enyo.Collection.status
	* @param {enyo.Collection~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	commit: function (opts) {
		var options,
			source,
			it = this;
		
		// if the current status is not one of the error states we can continue
		if (!(this.status & (States.ERROR | States.BUSY))) {
			
			// if there were options passed in we copy them quickly so that we can hijack
			// the success and error methods while preserving the originals to use later
			options = opts ? utils.clone(opts, true) : {};
			
			// make sure we keep track of how many sources we're requesting
			source = options.source || this.source;
			if (source && ((source instanceof Array) || source === true)) {
				this._waiting = source.length ? source.slice() : Object.keys(enyo.sources);
			}
				
			options.success = function (source, res) {
				it.committed(opts, res, source);
			};
			
			options.error = function (source, res) {
				it.errored('COMMITTING', opts, res, source);
			};
			
			// set the state
			this.set('status', (this.status | States.COMMITTING) & ~States.READY);
			
			// now pass this on to the source to execute as it sees fit
			Source.execute('commit', this, options);
		} else if (this.status & States.ERROR) this.errored(this.status, opts);
		
		return this;
	},
	
	/**
	* Fetches the [collection]{@link enyo.Collection} from a
	* [source]{@link enyo.Collection#source} or sources. An {@link enyo.Collection}
	* cannot be fetched if it is in an [error]{@link enyo.States.ERROR}
	* ({@link enyo.StateSupport.isError}) or [busy]{@link enyo.States.BUSY}
	* ({@link enyo.StateSupport.isBusy}) [state]{@link enyo.Model#status}. While
	* executing, it will add the [FETCHING]{@link enyo.States.FETCHING} flag to
	* the collection's [status]{@link enyo.Collection#status}. Once it has
	* completed execution, it will remove this flag (even if it fails).
	*
	* @see enyo.Collection.fetched
	* @see enyo.Collection.status
	* @param {enyo.Collection~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @public
	*/
	fetch: function (opts) {
		var options,
			source,
			it = this;
			
		// if the current status is not one of the error states we can continue
		if (!(this.status & (States.ERROR | States.BUSY))) {
			
			// if there were options passed in we copy them quickly so that we can hijack
			// the success and error methods while preserving the originals to use later
			options = opts ? utils.clone(opts, true) : {};
			
			// make sure we keep track of how many sources we're requesting
			source = options.source || this.source;
			if (source && ((source instanceof Array) || source === true)) {
				this._waiting = source.length ? source.slice() : Object.keys(enyo.sources);
			}
			
			options.success = function (source, res) {
				it.fetched(opts, res, source);
			};
			
			options.error = function (source, res) {
				it.errored('FETCHING', opts, res, source);
			};
			
			// set the state
			this.set('status', (this.status | States.FETCHING) & ~States.READY);
			
			// now pass this on to the source to execute as it sees fit
			Source.execute('fetch', this, options);
		} else if (this.status & States.ERROR) this.errored(this.status, opts);
		
		return this;
	},
	
	/**
	* Destroys the [collection]{@link enyo.Collection}. By default, the
	* collection will only be [destroyed]{@glossary destroy} in the client. To
	* execute with a [source]{@link enyo.Collection#source} or sources, the
	* [commit default option]{@link enyo.Collection#options} must be `true` or a
	* `source` property must be explicitly provided in the `opts` parameter. A
	* collection cannot be destroyed (using a source) if it is in an
	* [error]{@link enyo.States.ERROR} ({@link enyo.StateSupport.isError}) or
	* [busy]{@link enyo.States.BUSY} ({@link enyo.StateSupport.isBusy})
	* [state]{@link enyo.Collection#status}. While executing, it will add the
	* [DESTROYING]{@link enyo.States.DESTROYING} flag to the collection's
	* [status]{@link enyo.Collection#status}. Once it has completed execution,
	* it will remove this flag (even if it fails).
	*
	* @see enyo.Collection.status
	* @param {enyo.Collection~ActionOptions} [opts] - Optional configuration options.
	* @returns {this} The callee for chaining.
	* @method
	* @public
	*/
	destroy: kind.inherit(function (sup) {
		return function (opts) {
			var options = opts ? utils.mixin({}, [this.options, opts]) : this.options,
				it = this,
				idx;
						
			// this becomes an (potentially) async operation if we are committing this destroy
			// to a source and its kind of tricky to figure out because there are several ways
			// it could be flagged to do this
						
			if (options.commit || options.source) {
				
				// if the current status is not one of the error states we can continue
				if (!(this.status & (States.ERROR | States.BUSY))) {
				
					// remap to the originals
					options = opts ? utils.clone(opts, true) : {};
				
					options.success = function (source, res) {
				
						if (it._waiting) {
							idx = it._waiting.findIndex(function (ln) {
								return (ln instanceof Source ? ln.name : ln) == source;
							});
							if (idx > -1) it._waiting.splice(idx, 1);
							if (!it._waiting.length) it._waiting = null;
						}
				
						// continue the operation this time with commit false explicitly
						if (!it._waiting) {
							options.commit = options.source = null;
							it.destroy(options);
						}
						if (opts && opts.success) opts.success(this, opts, res, source);
					};
			
					options.error = function (source, res) {
				
						if (it._waiting) {
							idx = it._waiting.findIndex(function (ln) {
								return (ln instanceof Source ? ln.name : ln) == source;
							});
							if (idx > -1) it._waiting.splice(idx, 1);
							if (!it._waiting.length) it._waiting = null;
						}
				
						// continue the operation this time with commit false explicitly
						if (!it._waiting) {
							options.commit = options.source = null;
							it.destroy(options);
						}
				
						// we don't bother setting the error state if we aren't waiting because 
						// it will be cleared to DESTROYED and it would be pointless
						else this.errored('DESTROYING', opts, res, source);
					};
				
					this.set('status', (this.status | States.DESTROYING) & ~States.READY);
			
					Source.execute('destroy', this, options);
				} else if (this.status & States.ERROR) this.errored(this.status, opts);
				
				// we don't allow the destroy to take place and we don't forcibly break-down
				// the collection errantly so there is an opportuniy to resolve the issue
				// before we lose access to the collection's content!
				return this;
			}
			
			if (this.length && options.destroy) this.empty(options);
			
			// set the final resting state of this collection
			this.set('status', States.DESTROYED);
			
			sup.apply(this, arguments);
		};
	}),
	
	/**
	* This is a virtual method that, when provided, will be used for sorting during
	* [add()]{@link enyo.Collection#add} when the `sort` flag is `true` or when the
	* [sort()]{@link enyo.Collection#sort} method is called without a passed-in
	* [function]{@glossary Function} parameter.
	*
	* @see enyo.Collection~Comparator
	* @type {enyo.Collection~Comparator}
	* @default null
	* @virtual
	* @method
	* @public
	*/
	comparator: null,
	
	/**
	* Used during [add()]{@link enyo.Collection#add} when `create` is `true` and
	* the data is a [hash]{@glossary Object}.
	*
	* @private
	*/
	prepareModel: function (attrs, opts) {
		var Ctor = this.model
			, options = this.options
			, model;
		
		attrs instanceof Ctor && (model = attrs);
		if (!model) {
			opts = opts || {};
			opts.noAdd = true;
			model = new Ctor(attrs, null, opts);
		}
		
		if (options.modelEvents) model.on('*', this._modelEvent, this);
		
		return model;
	},
	
	/**
	* When a [commit]{@link enyo.Collection#commit} has completed successfully, it is returned
	* to this method. This method handles special and important behavior; it should not be
	* called directly and, when overloading, care must be taken to ensure that the
	* super-method is called. This correctly sets the [status]{@link enyo.Collection#status}
	* and, in cases where multiple [sources]{@link enyo.Collection#source} were used, it waits
	* until all have responded before clearing the [COMMITTING]{@link enyo.States.COMMITTING}
	* flag. If a [success]{@link enyo.Collection~Success} callback was provided, it will be
	* called once for each source.
	*
	* @param {enyo.Collection~ActionOptions} opts - The original options passed to
	*	[commit()]{@link enyo.Collection#commit}, merged with the defaults.
	* @param {*} [res] - The result provided from the given
	* [source]{@link enyo.Collection#source}, if any. This will vary depending
	* on the source.
	* @param {String} source - The name of the source that has completed successfully.
	* @public
	*/
	committed: function (opts, res, source) {
		var idx;
		
		if (this._waiting) {
			idx = this._waiting.findIndex(function (ln) {
				return (ln instanceof Source ? ln.name : ln) == source;
			});
			if (idx > -1) this._waiting.splice(idx, 1);
			if (!this._waiting.length) this._waiting = null;
		}
		
		if (opts && opts.success) opts.success(this, opts, res, source);
		
		// clear the state
		if (!this._waiting) {
			this.set('status', (this.status | States.READY) & ~States.COMMITTING);
		}
	},
	
	/**
	* When a [fetch]{@link enyo.Collection#fetch} has completed successfully, it is returned
	* to this method. This method handles special and important behavior; it should not be
	* called directly and, when overloading, care must be taken to ensure that you call the
	* super-method. This correctly sets the [status]{@link enyo.Collection#status} and, in
	* cases where multiple [sources]{@link enyo.Collection#source} were used, it waits until
	* all have responded before clearing the [FETCHING]{@link enyo.States.FETCHING} flag. If
	* a [success]{@link enyo.Collection~Success} callback was provided, it will be called
	* once for each source.
	*
	* @param {enyo.Collection~ActionOptions} opts - The original options passed to
	*	[fetch()]{@link enyo.Collection#fetch}, merged with the defaults.
	* @param {*} [res] - The result provided from the given
	* [source]{@link enyo.Collection#source}, if any. This will vary depending
	*	on the source.
	* @param {String} source - The name of the source that has completed successfully.
	* @public
	*/
	fetched: function (opts, res, source) {
		var idx;
		
		if (this._waiting) {
			idx = this._waiting.findIndex(function (ln) {
				return (ln instanceof Source ? ln.name : ln) == source;
			});
			if (idx > -1) this._waiting.splice(idx, 1);
			if (!this._waiting.length) this._waiting = null;
		}
		
		// if there is a result we add it to the collection passing it any per-fetch options
		// that will override the defaults (e.g. parse) we don't do that here as it will
		// be done in the add method -- also note we reassign the result to whatever was
		// actually added and pass that to any other success callback if there is one
		if (res) res = this.add(res, opts);
		
		// now look for an additional success callback
		if (opts && opts.success) opts.success(this, opts, res, source);
		
		// clear the state
		if (!this._waiting) {
			this.set('status', (this.status | States.READY) & ~States.FETCHING);
		}
	},
	
	/**
	* If an error is encountered while [fetching]{@link enyo.Collection#fetch},
	* [committing]{@link enyo.Collection#commit}, or [destroying]{@link enyo.Collection#destroy}
	* the [collection]{@link enyo.Collection}, this method will be called. By
	* default, it updates the collection's [status]{@link enyo.Collection#status}
	* property and then checks to see if there is a provided
	* [error handler]{@link enyo.Collection~ErrorCallback}. If the error handler
	* exists, it will be called.
	* 
	* @param {String} action - The name of the action that failed,
	* one of `'FETCHING'` or `'COMMITTING'`.
	* @param {enyo.Collection~ActionOptions} opts - The options hash originally
	* passed along with the original action.
	* @param {*} [res] - The result of the requested `action`; varies depending on the
	*	requested [source]{@link enyo.Collection#source}.
	* @param {String} source - The name of the source that has returned an error.
	* @public
	*/
	errored: function (action, opts, res, source) {
		var stat;
		
		// if the error action is a status number then we don't need to update it otherwise
		// we set it to the known state value
		if (typeof action == 'string') {
			
			// all built-in errors will pass this as their values are > 0 but we go ahead and
			// ensure that no developer used the 0x00 for an error code
			stat = STATES['ERROR_' + action];
		} else stat = action;
		
		if (isNaN(stat) || !(stat & States.ERROR)) stat = States.ERROR_UNKNOWN;
		
		// if it has changed give observers the opportunity to respond
		this.set('status', (this.status | stat) & ~States.READY);
		
		// we need to check to see if there is an options handler for this error
		if (opts && opts.error) opts.error(this, action, opts, res, source);
	},
	
	/**
	* Overloaded version of the method to call [set()]{@link enyo.Collection#set}
	* instead of simply assigning the value. This allows it to
	* [notify observers]{@link enyo.ObserverSupport.notify} and thus update
	* [bindings]{@link enyo.BindingSupport.bindings} as well.
	*
	* @see enyo.StateSupport.clearError
	* @public
	*/
	clearError: function () {
		return this.set('status', States.READY);
	},
	
	/**
	* @private
	*/
	_modelEvent: function (model, e) {
		switch (e) {
		case 'change':
			this.emit('change', {model: model});
			break;
		case 'destroy':
			this.remove(model);
			break;
		}
	},
	
	/**
	* Responds to changes to the [models]{@link enyo.Collection#models} property.
	*
	* @see enyo.Collection.models
	* @fires enyo.Collection#reset
	* @type {enyo.ObserverSupport~Observer}
	* @public
	*/
	modelsChanged: function (was, is, prop) {
		var models = this.models.copy(),
			len = models.length;
		
		if (len != this.length) this.set('length', len);
		
		this.emit('reset', {models: models, collection: this});
	},
	
	/**
	* Initializes the [collection]{@link enyo.Collection}.
	*
	* @param {(Object|Object[]|enyo.Model[])} [recs] May be an [array]{@glossary Array}
	*	of either [models]{@link enyo.Model} or [hashes]{@glossary Object} used to
	* initialize the [collection]{@link enyo.Collection}, or an [object]{@glossary Object}
	*	equivalent to the `props` parameter.
	* @param {Object} [props] - A hash of properties to apply directly to the
	* collection.
	* @param {Object} [opts] - A hash.
	* @method
	* @public
	*/
	constructor: kind.inherit(function (sup) {
		return function (recs, props, opts) {
			// opts = opts? (this.options = enyo.mixin({}, [this.options, opts])): this.options;
			
			// if properties were passed in but not a records array
			props = recs && !(recs instanceof Array)? recs: props;
			if (props === recs) recs = null;
			// initialize our core records
			// this.models = this.models || new ModelList();
			!this.models && (this.set('models', new ModelList()));
			
			// this is backwards compatibility
			if (props && props.records) {
				recs = recs? recs.concat(props.records): props.records.slice();
				delete props.records;
			}
			
			if (props && props.models) {
				recs = recs? recs.concat(props.models): props.models.slice();
				delete props.models;
			}
			
			if (props && props.options) {
				this.options = utils.mixin({}, [this.options, props.options]);
				delete props.options;
			}
			
			opts = opts? utils.mixin({}, [this.options, opts]): this.options;
			
			// @TODO: For now, while there is only one property we manually check for it
			// if more options arrise that should be configurable this way it may need to
			// be modified
			opts.fetch && (this.options.fetch = opts.fetch);
			
			this.length = this.models.length;
			this.euid = utils.uid('c');
			
			sup.call(this, props);
			
			typeof this.model == 'string' && (this.model = kind.constructorForKind(this.model));
			this.store = this.store || Store;
			recs && recs.length && this.add(recs, opts);
		};
	}),
	
	/**
	* @method
	* @private
	*/
	constructed: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			
			// automatically attempt a fetch after initialization is complete
			if (this.options.fetch) this.fetch();
		};
	})
	
});

/**
* @name enyo.Collection.concat
* @static
* @private
*/
Collection.concat = function (ctor, props) {
	var proto = ctor.prototype || ctor;
	
	if (props.options) {
		proto.options = utils.mixin({}, [proto.options, props.options]);
		delete props.options;
	}
};
},{"../../enyo":1,"./Component":13,"./EventEmitter":19,"./Model":30,"./ModelList":31,"./Source":48,"./StateSupport":49,"./States":50,"./Store":51,"./kind":66,"./utils":75}],41:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	platform = require('./platform'),
	animation = require('./animation');

var
	Component = require('./Component');

/**
* Fires when a scrolling action starts.
*
* @event enyo.ScrollMath#onScrollStart
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {enyo.Scroller~ScrollEvent} event - An [object]{@glossary Object} containing 
*	event information.
* @private
*/

/**
* Fires while a scrolling action is in progress.
*
* @event enyo.ScrollMath#onScroll
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {enyo.Scroller~ScrollEvent} event - An [object]{@glossary Object} containing 
*	event information.
* @private
*/

/**
* Fires when a scrolling action stops.
*
* @event enyo.ScrollMath#onScrollStop
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {enyo.Scroller~ScrollEvent} event - An [object]{@glossary Object} containing 
*	event information.
* @private
*/

/**
* {@link enyo.ScrollMath} implements a scrolling dynamics simulation. It is a
* helper [kind]{@glossary kind} used by other [scroller]{@link enyo.Scroller}
* kinds, such as {@link enyo.TouchScrollStrategy}.
* 
* `enyo.ScrollMath` is not typically created in application code.
*
* @class enyo.ScrollMath
* @protected
*/
module.exports = kind(
	/** @lends enyo.ScrollMath.prototype */ {

	name: 'enyo.ScrollMath',

	/**
	* @private
	*/
	kind: Component,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.ScrollMath.prototype */ {

		/** 
		* Set to `true` to enable vertical scrolling.
		*
		* @type {Boolean}
		* @default true
		* @private
		*/
		vertical: true,

		/** 
		* Set to `true` to enable horizontal scrolling.
		*
		* @type {Boolean}
		* @default true
		* @private
		*/
		horizontal: true
	},

	/**
	* @private
	*/
	events: {
		onScrollStart: '',
		onScroll: '',
		onScrollStop: '',
		onStabilize: ''
	},

	/**
	* "Spring" damping returns the scroll position to a value inside the boundaries. Lower 
	* values provide faster snapback.
	*
	* @private
	*/
	kSpringDamping: 0.93,

	/** 
	* "Drag" damping resists dragging the scroll position beyond the boundaries. Lower values 
	* provide more resistance.
	*
	* @private
	*/
	kDragDamping: 0.5,
	
	/** 
	* "Friction" damping reduces momentum over time. Lower values provide more friction.
	*
	* @private
	*/
	kFrictionDamping: 0.97,

	/** 
	* Additional "friction" damping applied when momentum carries the viewport into overscroll. 
	* Lower values provide more friction.
	*
	* @private
	*/
	kSnapFriction: 0.9,
	
	/** 
	* Scalar applied to `flick` event velocity.
	*
	* @private
	*/
	kFlickScalar: 15,

	/** 
	* Limits the maximum allowable flick. On Android > 2, we limit this to prevent compositing 
	* artifacts.
	*
	* @private
	*/
	kMaxFlick: platform.android > 2 ? 2 : 1e9,
	
	/** 
	* The value used in [friction()]{@link enyo.ScrollMath#friction} to determine if the delta 
	* (e.g., y - y0) is close enough to zero to consider as zero.
	*
	* @private
	*/
	kFrictionEpsilon: platform.webos >= 4 ? 1e-1 : 1e-2,
	
	/** 
	* Top snap boundary, generally `0`.
	*
	* @private
	*/
	topBoundary: 0,
	
	/** 
	* Right snap boundary, generally `(viewport width - content width)`.
	*
	* @private
	*/
	rightBoundary: 0,
	
	/** 
	* Bottom snap boundary, generally `(viewport height - content height)`.
	*
	* @private
	*/
	bottomBoundary: 0,
	
	/** 
	* Left snap boundary, generally `0`.
	*
	* @private
	*/
	leftBoundary: 0,
	
	/** 
	* Animation time step.
	*
	* @private
	*/
	interval: 20,
	
	/** 
	* Flag to enable frame-based animation; if `false`, time-based animation is used.
	*
	* @private
	*/
	fixedTime: true,

	/**
	* Simulation state.
	*
	* @private
	*/
	x0: 0,

	/**
	* Simulation state.
	*
	* @private
	*/
	x: 0,

	/**
	* Simulation state.
	*
	* @private
	*/
	y0: 0,

	/**
	* Simulation state.
	*
	* @private
	*/
	y: 0,

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			this.stop();
			sup.apply(this, arguments);
		};
	}),

	/**
	* Simple Verlet integrator for simulating Newtonian motion.
	*
	* @private
	*/
	verlet: function () {
		var x = this.x;
		this.x += x - this.x0;
		this.x0 = x;
		//
		var y = this.y;
		this.y += y - this.y0;
		this.y0 = y;
	},

	/**
	* Boundary damping function. Returns damped `value` based on `coeff` on one side of 
	* `origin`.
	*
	* @private
	*/
	damping: function (val, origin, coeff, sign) {
		var kEpsilon = 0.5;
		//
		// this is basically just value *= coeff (generally, coeff < 1)
		//
		// 'sign' and the conditional is to force the damping to only occur
		// on one side of the origin.
		//
		var dv = val - origin;
		// Force close-to-zero to zero
		if (Math.abs(dv) < kEpsilon) {
			return origin;
		}
		return val*sign > origin*sign ? coeff * dv + origin : val;
	},

	/**
	* Dual-boundary damping function. Returns damped `value` based on `coeff` when exceeding 
	* either boundary.
	*
	* @private
	*/
	boundaryDamping: function (val, aBoundary, bBoundary, coeff) {
		return this.damping(this.damping(val, aBoundary, coeff, 1), bBoundary, coeff, -1);
	},

	/**
	* Simulation constraints (spring damping occurs here).
	*
	* @private
	*/
	constrain: function () {
		var y = this.boundaryDamping(this.y, this.topBoundary, this.bottomBoundary, this.kSpringDamping);
		if (y != this.y) {
			// ensure snapping introduces no velocity, add additional friction
			this.y0 = y - (this.y - this.y0) * this.kSnapFriction;
			this.y = y;
		}
		var x = this.boundaryDamping(this.x, this.leftBoundary, this.rightBoundary, this.kSpringDamping);
		if (x != this.x) {
			this.x0 = x - (this.x - this.x0) * this.kSnapFriction;
			this.x = x;
		}
	},

	/**
	* The friction function.
	*
	* @private
	*/
	friction: function (ex, ex0, coeff) {
		// implicit velocity
		var dp = this[ex] - this[ex0];
		// let close-to-zero collapse to zero (i.e. smaller than epsilon is considered zero)
		var c = Math.abs(dp) > this.kFrictionEpsilon ? coeff : 0;
		// reposition using damped velocity
		this[ex] = this[ex0] + c * dp;
	},

	/** 
	* One unit of time for simulation.
	*
	* @private
	*/
	frame: 10,
	// piece-wise constraint simulation
	simulate: function (t) {
		while (t >= this.frame) {
			t -= this.frame;
			if (!this.dragging) {
				this.constrain();
			}
			this.verlet();
			this.friction('y', 'y0', this.kFrictionDamping);
			this.friction('x', 'x0', this.kFrictionDamping);
		}
		return t;
	},

	/**
	* @fires enyo.ScrollMath#onScrollStop
	* @private
	*/
	animate: function () {
		this.stop();
		// time tracking
		var t0 = utils.perfNow(), t = 0;
		// delta tracking
		var x0, y0;
		// animation handler
		var fn = this.bindSafely(function() {
			// wall-clock time
			var t1 = utils.perfNow();
			// schedule next frame
			this.job = animation.requestAnimationFrame(fn);
			// delta from last wall clock time
			var dt = t1 - t0;
			// record the time for next delta
			t0 = t1;
			// user drags override animation
			if (this.dragging) {
				this.y0 = this.y = this.uy;
				this.x0 = this.x = this.ux;
				this.endX = this.endY = null;
			}
			// frame-time accumulator
			// min acceptable time is 16ms (60fps)
			t += Math.max(16, dt);
			// prevent snapping to originally desired scroll position if we are in overscroll
			if (this.isInOverScroll()) {
				this.endX = null;
				this.endY = null;
			}
			// alternate fixed-time step strategy:
			else if (this.fixedTime) {
				t = this.interval;
			}
			// consume some t in simulation
			t = this.simulate(t);
			// scroll if we have moved, otherwise the animation is stalled and we can stop
			if (y0 != this.y || x0 != this.x) {
				this.scroll();
			} else if (!this.dragging) {
				// set final values
				if (this.endX != null) {
					this.x = this.x0 = this.endX;
				}
				if (this.endY != null) {
					this.y = this.y0 = this.endY;
				}

				this.stop();
				this.scroll();
				this.doScrollStop();

				this.endX = null;
				this.endY = null;
			}
			y0 = this.y;
			x0 = this.x;
		});
		this.job = animation.requestAnimationFrame(fn);
	},
	
	/**
	* @private
	*/
	start: function () {
		if (!this.job) {
			this.doScrollStart();
			this.animate();
		}
	},

	/**
	* @private
	*/
	stop: function (fire) {
		var job = this.job;
		if (job) {
			this.job = animation.cancelRequestAnimationFrame(job);
		}
		if (fire) {
			this.doScrollStop();

			this.endX = undefined;
			this.endY = undefined;
		}
	},

	/**
	* Adjusts the scroll position to be valid, if necessary (e.g., after the scroll contents
	* have changed).
	*
	* @private
	*/
	stabilize: function () {
		var y = Math.min(this.topBoundary, Math.max(this.bottomBoundary, this.y));
		var x = Math.min(this.leftBoundary, Math.max(this.rightBoundary, this.x));
		if (y != this.y || x != this.x) {
			this.y = this.y0 = y;
			this.x = this.x0 = x;
			this.doStabilize();
		}
	},

	/**
	* @private
	*/
	startDrag: function (e) {
		this.dragging = true;
		//
		this.my = e.pageY;
		this.py = this.uy = this.y;
		//
		this.mx = e.pageX;
		this.px = this.ux = this.x;
	},

	/**
	* @private
	*/
	drag: function (e) {
		if (this.dragging) {
			var dy = this.vertical ? e.pageY - this.my : 0;
			this.uy = dy + this.py;
			// provides resistance against dragging into overscroll
			this.uy = this.boundaryDamping(this.uy, this.topBoundary, this.bottomBoundary, this.kDragDamping);
			//
			var dx = this.horizontal ? e.pageX - this.mx : 0;
			this.ux = dx + this.px;
			// provides resistance against dragging into overscroll
			this.ux = this.boundaryDamping(this.ux, this.leftBoundary, this.rightBoundary, this.kDragDamping);
			//
			this.start();
			return true;
		}
	},

	/**
	* @private
	*/
	dragDrop: function () {
		if (this.dragging && !window.PalmSystem) {
			var kSimulatedFlickScalar = 0.5;
			this.y = this.uy;
			this.y0 = this.y - (this.y - this.y0) * kSimulatedFlickScalar;
			this.x = this.ux;
			this.x0 = this.x - (this.x - this.x0) * kSimulatedFlickScalar;
		}
		this.dragFinish();
	},

	/**
	* @private
	*/
	dragFinish: function () {
		this.dragging = false;
	},

	/**
	* @private
	*/
	flick: function (e) {
		var v;
		if (this.vertical) {
			v = e.yVelocity > 0 ? Math.min(this.kMaxFlick, e.yVelocity) : Math.max(-this.kMaxFlick, e.yVelocity);
			this.y = this.y0 + v * this.kFlickScalar;
		}
		if (this.horizontal) {
			v = e.xVelocity > 0 ? Math.min(this.kMaxFlick, e.xVelocity) : Math.max(-this.kMaxFlick, e.xVelocity);
			this.x = this.x0 + v * this.kFlickScalar;
		}
		this.start();
	},

	/**
	* @private
	*/
	mousewheel: function (e) {
		var dy = this.vertical ? e.wheelDeltaY || (!e.wheelDeltaX ? e.wheelDelta : 0) : 0,
			dx = this.horizontal ? e.wheelDeltaX : 0,
			shouldScroll = false;
		if ((dy > 0 && this.y < this.topBoundary) || (dy < 0 && this.y > this.bottomBoundary)) {
			this.y = this.y0 = this.y0 + dy;
			shouldScroll = true;
		}
		if ((dx > 0 && this.x < this.leftBoundary) || (dx < 0 && this.x > this.rightBoundary)) {
			this.x = this.x0 = this.x0 + dx;
			shouldScroll = true;
		}
		this.stop(!shouldScroll);
		if (shouldScroll) {
			this.start();
			return true;
		}
	},

	/**
	* @fires enyo.ScrollMath#onScroll
	* @private
	*/
	scroll: function () {
		this.doScroll();
	},

	// NOTE: Yip/Orvell method for determining scroller instantaneous velocity
	// FIXME: incorrect if called when scroller is in overscroll region
	// because does not account for additional overscroll damping.
	
	/**
	* Animates a scroll to the specified position.
	*
	* @param {Number} x - The `x` position in pixels.
	* @param {Number} y - The `y` position in pixels.
	* @private
	*/
	scrollTo: function (x, y) {
		if (x == this.x && y == this.y) return;
		if (y !== null) {
			this.endY = -y;
			this.y = this.y0 - (y + this.y0) * (1 - this.kFrictionDamping);
		}
		if (x !== null) {
			this.endX = -x;
			this.x = this.x0 - (x + this.x0) * (1 - this.kFrictionDamping);
		}
		this.start();
	},

	/**
	* Sets the scroll position along the x-axis.
	*
	* @param {Number} x - The x-axis scroll position in pixels.
	* @method
	* @private
	*/
	setScrollX: function (x) {
		this.x = this.x0 = x;
	},

	/**
	* Sets the scroll position along the y-axis.
	*
	* @param {Number} y - The y-axis scroll position in pixels.
	* @method
	* @private
	*/
	setScrollY: function (y) {
		this.y = this.y0 = y;
	},

	/**
	* Sets the scroll position; defaults to setting this position along the y-axis.
	*
	* @param {Number} pos - The scroll position in pixels.
	* @method
	* @private
	*/
	setScrollPosition: function (pos) {
		this.setScrollY(pos);
	},

	/** 
	* Determines whether or not the [scroller]{@link enyo.Scroller} is actively moving.
	* 
	* @return {Boolean} `true` if actively moving; otherwise, `false`.
	* @private
	*/
	isScrolling: function () {
		return Boolean(this.job);
	},

	/** 
	* Determines whether or not the [scroller]{@link enyo.Scroller} is in overscroll.
	* 
	* @return {Boolean} `true` if in overscroll; otherwise, `false`.
	* @private
	*/
	isInOverScroll: function () {
		return this.job && (this.x > this.leftBoundary || this.x < this.rightBoundary ||
			this.y > this.topBoundary || this.y < this.bottomBoundary);
	}
});
},{"../../enyo":1,"./Component":13,"./animation":56,"./kind":66,"./platform":71,"./utils":75}],46:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');
var
	Component = require('./Component');

/**
* The extended {@glossary event} [object]{@glossary Object} that is provided
* when the [onSelect]{@link enyo.Selection#onSelect} and
* [onDeselect]{@link enyo.Selection#onDeselect} events are fired.
*
* @typedef {Object} enyo.Selection~SelectionEvent
* @property {Number|String} key The key that was used to register the
*	[selection]{@link enyo.Selection} (usually a row index).
* @property {Object} data - References data registered with the key by the code
* that made the original selection.
*/

/**
* Fires when an item is selected.
* 
* ```javascript
* {kind: "Selection", onSelect: "selectRow"...
* ...
* selectRow: function(inSender, inEvent) {
* ...
* ```
*
* @event enyo.Selection#onSelect
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {enyo.Selection~SelectionEvent} event - An [object]{@glossary Object}
*	containing event information.
* @public
*/

/**
* Fires when an item is deselected.
* 
* ```javascript
* {kind: "Selection", onSelect: "deselectRow"...
* ...
* deselectRow: function(inSender, inEvent)
* ...
* ```
*
* @event enyo.Selection#onDeselect
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {enyo.Selection~SelectionEvent} event - An [object]{@glossary Object}
*	containing event information.
* @public
*/

/**
* Fires when selection changes (but not when selection is cleared).
*
* @event enyo.Selection#onChange
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Selection} is used to manage row selection state for lists. It provides
* selection state management for both single-select and multi-select lists.
*
* ```javascript
* // The following is an excerpt from enyo.FlyweightRepeater.
* enyo.kind({
*	name: "enyo.FlyweightRepeater",
*	...
*	components: [
*		{kind: "Selection", onSelect: "selectDeselect", onDeselect: "selectDeselect"},
*		...
*	],
*	tap: function(inSender, inEvent) {
*		...
*		// mark the tapped row as selected
*		this.$.selection.select(inEvent.index);
*		...
*	},
*	selectDeselect: function(inSender, inEvent) {
*		// this is where a row selection highlight might be applied
*		this.renderRow(inEvent.key);
*	}
*	...
* });
* ```
*
* @class enyo.Selection
* @extends enyo.Component
* @public
*/
module.exports = kind(
	/** @lends enyo.Selection.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Selection',

	/**
	* @private
	*/
	kind: Component,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Selection.prototype */ {

		/**
		* If `true`, multiple selections are allowed.
		* 
		* @type {Boolean}
		* @default false
		* @public
		*/
		multi: false
	},

	/**
	* @private
	*/
	events: {
		onSelect: '',
		onDeselect: '',
		onChange: ''
	},
	
	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			this.clear();
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	multiChanged: function () {
		if (!this.multi) {
			this.clear();
		}
		this.doChange();
	},

	/**
	* @private
	*/
	highlander: function () {
		if (!this.multi) {
			this.deselect(this.lastSelected);
		}
	},

	/**
	* Removes all selections.
	* 
	* @public
	*/
	clear: function () {
		this.selected = {};
	},

	/**
	* Determines whether a particular row is selected.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @returns {Boolean} `true` if the specified row is selected; otherwise, `false`.
	* @public
	*/
	isSelected: function (key) {
		return this.selected[key];
	},

	/**
	* Manually sets a row's state to selected or unselected.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @param {Boolean} sel - `true` if the row should be selected; `false` if the row
	* should be unselected.
	* @param {Object} [data] - An optional data [object]{@glossary Object} to store
	*	in the selection for the key that will be sent with the
	*	[onSelect]{@link enyo.Selection#onSelect} or
	*	[onDeselect]{@link enyo.Selection#onDeselect} {@glossary event}. If
	*	not used, the `data` will be set to `true`.
	* @fires enyo.Selection#onChange
	* @public
	*/
	setByKey: function (key, sel, data) {
		if (sel) {
			this.selected[key] = (data || true);
			this.lastSelected = key;
			this.doSelect({key: key, data: this.selected[key]});
		} else {
			var was = this.isSelected(key);
			delete this.selected[key];
			this.doDeselect({key: key, data: was});
		}
		this.doChange();
	},

	/**
	* Deselects a row.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @public
	*/
	deselect: function (key) {
		if (this.isSelected(key)) {
			this.setByKey(key, false);
		}
	},

	/**
	* Selects a row. If the [multi]{@link enyo.Selection#multi} property is set to `false`,
	* this will also deselect the previous [selection]{@link enyo.Selection}.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @param {Object} [data] - An optional data [object]{@glossary Object} to store
	* in the selection for the key that will be sent with the
	*	[onSelect]{@link enyo.Selection#onSelect} or
	*	[onDeselect]{@link enyo.Selection#onDeselect} {@glossary event}. If
	*	not used, the `data` will be set to `true`.
	* @public
	*/
	select: function (key, data) {
		if (this.multi) {
			this.setByKey(key, !this.isSelected(key), data);
		} else if (!this.isSelected(key)) {
			this.highlander();
			this.setByKey(key, true, data);
		}
	},

	/**
	* Toggles [selection]{@link enyo.Selection} state for a row. If the
	* [multi]{@link enyo.Selection#multi} property is set to `false`, toggling a
	* selection "on" will deselect the previous selection.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @param {Object} [data] - An optional data [object]{@glossary Object} to store
	* in the selection for the key that will be sent with the
	*	[onSelect]{@link enyo.Selection#onSelect} or
	*	[onDeselect]{@link enyo.Selection#onDeselect} {@glossary event}. If
	*	not used, the `data` will be set to `true`.
	* @public
	*/
	toggle: function (key, data) {
		if (!this.multi && this.lastSelected != key) {
			this.deselect(this.lastSelected);
		}
		this.setByKey(key, !this.isSelected(key), data);
	},

	/**
	* Retrieves the current [selection]{@link enyo.Selection}.
	*
	* @returns {Object} The selection as a [hash]{@glossary Object} in which each
	* selected item has a value; unselected items are [undefined]{@glossary undefined}.
	* @public
	*/
	getSelected: function () {
		return this.selected;
	},

	/**
	* Removes a row that's included in the [selection]{@link enyo.Selection} set.
	* If this row is selected, it will be unselected.  Any rows above this row
	* will have their keys value reduced by one.
	*
	* @param {Number|String} key - The unique identifier of the row.
	* @public
	*/
	remove: function (key) {
		var newSelected = {};
		for (var row in this.selected) {
			if (row < key) {
				newSelected[row] = this.selected[row];
			} else if (row > key) {
				newSelected[row - 1] = this.selected[row];
			}
		}
		this.selected = newSelected;
	}
});
},{"../../enyo":1,"./Component":13,"./kind":66}],47:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');

var
	Component = require('./Component');

/**
* {@link enyo.Signals} is a [component]{@link enyo.Component} used to listen
* to global messages.
* 
* An object with a Signals component can listen to messages sent from anywhere
* by declaring handlers for them.
* 
* DOM [events]{@glossary event} that have no node targets are broadcast as
* signals. These events include Window events, such as `onload` and
* `onbeforeunload`, as well as events that occur directly on `document`, such
* as `onkeypress` if `document` has the focus.
* 
* For more information, see the documentation on [Event
* Handling]{@linkplain $dev-guide/key-concepts/event-handling.html} in the
* Enyo Developer Guide.
*
* @class enyo.Signals
* @extends enyo.Component
* @public
*/
var Signals = module.exports = kind(
	/** @lends enyo.Signals.prototype */ {

	name: 'enyo.Signals',

	/**
	* @private
	*/
	kind: Component,

	/**
	* Needed because of early calls to bind DOM {@glossary event} listeners
	* to the [enyo.Signals.send()]{@link enyo.Signals#send} call.
	* 
	* @private
	*/


	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			Signals.addListener(this);
		};
	}),

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			Signals.removeListener(this);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	notify: function (msg, load) {
		this.dispatchEvent(msg, load);
	},

	/**
	* @private
	*/
	protectedStatics: {
		listeners: [],
		addListener: function(listener) {
			this.listeners.push(listener);
		},
		removeListener: function(listener) {
			utils.remove(listener, this.listeners);
		}
	},

	/**
	* @private
	*/
	statics: 
		/** @lends enyo.Signals.prototype */ {

		/**
		* Broadcasts a global message to be consumed by subscribers.
		* 
		* @param {String} msg - The message to send; usually the name of the
		*	{@glossary event}.
		* @param {Object} load - An [object]{@glossary Object} containing any
		*	associated event properties to be accessed by subscribers.
		* @public
		*/
		send: function (msg, load) {
			utils.forEach(this.listeners, function(l) {
				l.notify(msg, load);
			});
		}
	}
});
},{"../../enyo":1,"./Component":13,"./kind":66,"./utils":75}],68:[function(require,module,exports){
require('../../enyo');

var
	utils = require('./utils');
var
	Component = require('./Component'),
	Signals = require('./Signals');

/**
* Default owner assigned to ownerless [UiComponents]{@link enyo.UiComponent},
* to allow such UiComponents to be notified of important system events like window resize.
*
* NOTE: Ownerless [UiComponents]{@link enyo.UiComponent} will not be garbage collected unless 
* explicitly destroyed, as they will be referenced by `enyo.master`.
*
* @private
*/
var master = module.exports = new Component({
	name: 'master',
	notInstanceOwner: true,
	eventFlags: {showingOnly: true}, // don't waterfall these events into hidden controls
	getId: function () {
		return '';
	},
	isDescendantOf: utils.nop,
	bubble: function (nom, event) {
		//enyo.log('master event: ' + nom);
		if (nom == 'onresize') {
			// Resize is special; waterfall this message.
			// This works because master is a Component, so it waterfalls
			// to its owned Components (i.e., master has no children).
			master.waterfallDown('onresize', this.eventFlags);
			master.waterfallDown('onpostresize', this.eventFlags);
		} else {
			// All other top-level events are sent only to interested Signal
			// receivers.
			Signals.send(nom, event);
		}
	}
});
},{"../../enyo":1,"./Component":13,"./Signals":47,"./utils":75}],55:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	master = require('./master');

var
	Component = require('./Component');

/**
* {@link enyo.UiComponent} implements a container strategy suitable for presentation layers.
* 
* `UiComponent` itself is abstract. Concrete [subkinds]{@glossary subkind} include
* {@link enyo.Control} (for HTML/DOM) and
* {@link enyo.canvas.Control} (for Canvas contexts).
*
* @class enyo.UiComponent
* @extends enyo.Component
* @public
*/
var UiComponent = exports = module.exports = kind(
	/** @lends enyo.UiComponent.prototype */ {

	name: 'enyo.UiComponent',

	/**
	* @private
	*/
	kind: Component,

	/**
	* @private
	*/
	published: 
		/** @lends  enyo.UiComponent.prototype */ {

		/** 
		* The [UiComponent]{@link enyo.UiComponent} that physically contains this 
		* [component]{@link enyo.Component} in the DOM.
		*
		* @type {enyo.UiComponent}
		* @default null
		* @public
		*/
		container: null,

		/**
		* The [UiComponent]{@link enyo.UiComponent} that owns this
		* [component]{@link enyo.Component} for purposes of {@glossary event}
		* propagation.
		*
		* @type {enyo.UiComponent}
		* @default null
		* @public
		*/
		parent: null,

		/**
		* The [UiComponent]{@link enyo.UiComponent} that will physically contain new items added
		* by calls to [createComponent()]{@link enyo.UiComponent#createComponent}.
		*
		* @type {String}
		* @default 'client'
		* @public
		*/
		controlParentName: 'client',
		
		/** 
		* A [kind]{@glossary kind} used to manage the size and placement of child 
		* [components]{@link enyo.Component}.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		layoutKind: ''
	},

	/**
	* @private
	*/
	handlers: {
		onresize: 'handleResize'
	},

	/**
	* When set, provides a [control]{@link enyo.Control} reference used to indicate where a
	* newly-created [component]{@link enyo.Component} should be added in the
	* [UiComponent's]{@link enyo.UiComponent} [array]{@glossary Array} of children. This is
	* typically used when creating children dynamically (rather than at design time). If set
	* to `null`, the new control will be added at the beginning of the array; if set to a
	* specific existing control, the new control will be added before the specified
	* control. If left as `undefined`, the default behavior is to add the new control
	* at the end of the array.
	*
	* @type {enyo.Control}
	* @default undefined
	* @public
	*/
	addBefore: undefined,
	
	/**
	* @private
	*/
	protectedStatics: {
		_resizeFlags: {showingOnly: true} // don't waterfall these events into hidden controls
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			this.controls = this.controls || [];
			this.children = this.children || [];
			this.containerChanged();
			sup.apply(this, arguments);
			this.layoutKindChanged();
		};
	}),

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			// Destroys all non-chrome controls (regardless of owner).
			this.destroyClientControls();
			// Removes us from our container.
			this.setContainer(null);
			// Destroys chrome controls owned by this.
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	importProps: kind.inherit(function (sup) {
		return function(inProps) {
			sup.apply(this, arguments);
			if (!this.owner) {
				this.owner = master;
			}
		};
	}),

	/**
	* Creates [components]{@link enyo.Component} as defined by the [arrays]{@glossary Array}
	* of base and additional property [hashes]{@glossary Object}. The standard and 
	* additional property hashes are combined as described in
	* {@link enyo.Component#createComponent}.
	* 
	* ```
	* // ask foo to create components 'bar' and 'zot', but set the owner of
	* // both components to 'this'.
	* this.$.foo.createComponents([
	*	{name: 'bar'},
	*	{name: 'zot'}
	* ], {owner: this});
	* ```
	*
	* As implemented, [controlParentName]{@link enyo.UiComponent#controlParentName} only works
	* to identify an owned control created via `createComponents()`
	* (i.e., usually in our `components` block). To attach a `controlParent` via other means, 
	* one must call [discoverControlParent()]{@link enyo.UiComponent#discoverControlParent} or 
	* set `controlParent` directly.
	* 
	* We could call `discoverControlParent()` in
	* [addComponent()]{@link enyo.Component#addComponent}, but that would
	* cause a lot of useless checking.
	* 
	* @param {Object[]} props The array of {@link enyo.Component} definitions to be created.
	* @param {Object} ext - Additional properties to be supplied as defaults for each.
	* @returns {enyo.Component[]} The array of components that were created.
	* @method
	* @public
	*/
	// 
	createComponents: kind.inherit(function (sup) {
		return function() {
			var results = sup.apply(this, arguments);
			this.discoverControlParent();
			return results;
		};
	}),

	/**
	* Determines and sets the current [control's]{@link enyo.Control} parent.
	*
	* @protected
	*/
	discoverControlParent: function () {
		this.controlParent = this.$[this.controlParentName] || this.controlParent;
	},

	/**
	* @method
	* @private
	*/
	adjustComponentProps: kind.inherit(function (sup) {
		return function(inProps) {
			// Components we create have us as a container by default.
			inProps.container = inProps.container || this;
			sup.apply(this, arguments);
		};
	}),

	/**
	* Containment
	* 
	* @method
	* @private
	*/
	containerChanged: function (container) {
		if (container) {
			container.removeControl(this);
		}
		if (this.container) {
			this.container.addControl(this, this.addBefore);
		}
	},

	/**
	* Parentage
	* 
	* @method
	* @private
	*/
	parentChanged: function (oldParent) {
		if (oldParent && oldParent != this.parent) {
			oldParent.removeChild(this);
		}
	},

	/**
	* Determines whether the [control]{@link enyo.Control} is a descendant of
	* another control.
	* 
	* Note: Oddly, a control is considered to be a descendant of itself.
	*
	* @param {enyo.Control} ancestor - The [control]{@link enyo.Control} whose lineage
	*	will be checked to determine whether the current control is a descendant.
	* @public
	*/
	isDescendantOf: function (ancestor) {
		var p = this;
		while (p && p!=ancestor) {
			p = p.parent;
		}
		return ancestor && (p === ancestor);
	},

	/**
	* Returns all controls.
	*
	* @returns {enyo.Control[]} An [array]{@glossary Array} of [controls]{@link enyo.Control}.
	* @public
	*/
	getControls: function () {
		return this.controls;
	},

	/**
	* Returns all non-chrome controls.
	*
	* @returns {enyo.Control[]} An [array]{@glossary Array} of [controls]{@link enyo.Control}.
	* @public
	*/
	getClientControls: function () {
		var results = [];
		for (var i=0, cs=this.controls, c; (c=cs[i]); i++) {
			if (!c.isChrome) {
				results.push(c);
			}
		}
		return results;
	},

	/**
	* Destroys "client controls", the same set of [controls]{@link enyo.Control} returned by 
	* [getClientControls()]{@link enyo.UiComponent#getClientControls}.
	*
	* @public
	*/
	destroyClientControls: function () {
		var c$ = this.getClientControls();
		for (var i=0, c; (c=c$[i]); i++) {
			c.destroy();
		}
	},
	
	/**
	* @private
	*/
	addControl: function (ctl, before) {
		// Called to add an already created control to the object's control list. It is
		// not used to create controls and should likely not be called directly.
		// It can be overridden to detect when controls are added.
		if (before !== undefined) {
			var idx = (before === null) ? 0 : this.indexOfControl(before);
			this.controls.splice(idx, 0, ctl);
		} else {
			this.controls.push(ctl);
		}
		// When we add a Control, we also establish a parent.
		this.addChild(ctl, before);
	},

	/**
	* @private
	*/
	removeControl: function (ctl) {
		// Called to remove a control from the object's control list. As with addControl it
		// can be overridden to detect when controls are removed.
		// When we remove a Control, we also remove it from its parent.
		ctl.setParent(null);
		return utils.remove(ctl, this.controls);
	},

	/**
	* @private
	*/
	indexOfControl: function (ctl) {
		return utils.indexOf(ctl, this.controls);
	},

	/**
	* @private
	*/
	indexOfClientControl: function (ctl) {
		return utils.indexOf(ctl, this.getClientControls());
	},

	/**
	* @private
	*/
	indexInContainer: function () {
		return this.container.indexOfControl(this);
	},

	/**
	* @private
	*/
	clientIndexInContainer: function () {
		return this.container.indexOfClientControl(this);
	},

	/**
	* @private
	*/
	controlAtIndex: function (idx) {
		return this.controls[idx];
	},
	
	/**
	* Children
	* 
	* @private
	*/
	addChild: function (child, before) {
		// if before is undefined, add to the end of the child list.
		// If it's null, add to front of list, otherwise add before the
		// specified control.
		//
		// allow delegating the child to a different container
		if (this.controlParent /*&& !child.isChrome*/) {
			// this.controlParent might have a controlParent, and so on; seek the ultimate parent
			this.controlParent.addChild(child, before);
		} else {
			// NOTE: addChild drives setParent.
			// It's the opposite for setContainer, where containerChanged (in Containable)
			// drives addControl.
			// Because of the way 'parent' is derived from 'container', this difference is
			// helpful for implementing controlParent.
			// By the same token, since 'parent' is derived from 'container', setParent is
			// not intended to be called by client code. Therefore, the lack of parallelism
			// should be private to this implementation.
			// Set the child's parent property to this
			child.setParent(this);
			// track in children array
			if (before !== undefined) {
				var idx = (before === null) ? 0 : this.indexOfChild(before);
				this.children.splice(idx, 0, child);
			} else {
				this.children.push(child);
			}
		}
	},

	/**
	* @private
	*/
	removeChild: function (child) {
		return utils.remove(child, this.children);
	},

	/**
	* @private
	*/
	indexOfChild: function (child) {
		return utils.indexOf(child, this.children);
	},

	/**
	* @private
	*/
	layoutKindChanged: function () {
		if (this.layout) {
			this.layout.destroy();
		}
		this.layout = kind.createFromKind(this.layoutKind, this);
		if (this.generated) {
			this.render();
		}
	},

	/**
	* @private
	*/
	flow: function () {
		if (this.layout) {
			this.layout.flow();
		}
	},

	/**
	* CAVEAT: currently we use the entry point for both post-render layout work *and* 
	* post-resize layout work.
	* @private
	*/
	reflow: function () {
		if (this.layout) {
			this.layout.reflow();
		}
	},

	/**
	* Call after this [control]{@link enyo.Control} has been resized to allow it to process the 
	* size change. To respond to a resize, override `handleResize()` instead. Acts as syntactic 
	* sugar for `waterfall('onresize')`.
	* 
	* @public
	*/
	resize: function () {
		this.waterfall('onresize', UiComponent._resizeFlags);
		this.waterfall('onpostresize', UiComponent._resizeFlags);
	},
	
	/**
	* @private
	*/
	handleResize: function () {
		// FIXME: once we are in the business of reflowing layouts on resize, then we have an
		// inside/outside problem: some scenarios will need to reflow before child
		// controls reflow, and some will need to reflow after. Even more complex scenarios
		// have circular dependencies, and can require multiple passes or other resolution.
		// When we can rely on CSS to manage reflows we do not have these problems.
		this.reflow();
	},

	/**
	* Sends a message to all of my descendants, but not myself. You can stop a
	* [waterfall]{@link enyo.Component#waterfall} into [components]{@link enyo.Component}
	* owned by a receiving [object]{@glossary Object} by returning a truthy value from the
	* {@glossary event} [handler]{@link enyo.Component~EventHandler}.
	* 
	* @param {String} nom - The name of the {@glossary event}.
	* @param {Object} [event] - The event object to pass along.
	* @param {enyo.Component} [sender=this] - The event's originator.
	* @returns {this} The callee for chaining.
	* @public
	*/
	waterfallDown: function (nom, event, sender) {
		event = event || {};
		// Note: Controls will generally be both in a $ hash and a child list somewhere.
		// Attempt to avoid duplicated messages by sending only to components that are not
		// UiComponent, as those components are guaranteed not to be in a child list.
		// May cause a problem if there is a scenario where a UiComponent owns a pure
		// Component that in turn owns Controls.
		//
		// waterfall to all pure components
		for (var n in this.$) {
			if (!(this.$[n] instanceof UiComponent)) {
				this.$[n].waterfall(nom, event, sender);
			}
		}
		// waterfall to my children
		for (var i=0, cs=this.children, c; (c=cs[i]); i++) {
			// Do not send {showingOnly: true} events to hidden controls. This flag is set for resize events
			// which are broadcast from within the framework. This saves a *lot* of unnecessary layout.
			// TODO: Maybe remember that we did this, and re-send those messages on setShowing(true)?
			// No obvious problems with it as-is, though
			if (c.showing || !(event && event.showingOnly)) {
				c.waterfall(nom, event, sender);
			}
		}
	},

	/**
	* @private
	*/
	getBubbleTarget: function (nom, event) {
		if (event.delegate) return this.owner;
		else {
			return (
				this.bubbleTarget
				|| (this.cachedBubble && this.cachedBubbleTarget[nom])
				|| this.parent
				|| this.owner
			);
		}
	}
});
},{"../../enyo":1,"./Component":13,"./kind":66,"./master":68,"./utils":75}],57:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	logger = require('./logger'),
	master = require('./master'),
	utils = require('./utils'),
	platform = require('./platform');

var
	Dom = require('./dom');

/**
 * An [object]{@glossary Object} describing the the last known coordinates of the cursor or
 * user-interaction point in touch environments.
 *
 * @typedef {Object} enyo.dispatcher~CursorCoordinates
 * @property {Number} clientX - The horizontal coordinate within the application's client area.
 * @property {Number} clientY - The vertical coordinate within the application's client area.
 * @property {Number} pageX - The X coordinate of the cursor relative to the viewport, including any
 *   scroll offset.
 * @property {Number} pageY - The Y coordinate of the cursor relative to the viewport, including any
 *   scroll offset.
 * @property {Number} screenX - The X coordinate of the cursor relative to the screen, not including
 *   any scroll offset.
 * @property {Number} screenY - The Y coordinate of the cursor relative to the screen, not including
 *   any scroll offset.
 */

/**
* @private
*/

/**
* @private
*/
var dispatcher = module.exports = dispatcher =
	/** @lends enyo.dispatcher.prototype */ {

	$: {},

	/**
	* These events come from document
	*
	* @private
	*/
	events: ["mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mousewheel",
		"click", "dblclick", "change", "keydown", "keyup", "keypress", "input",
		"paste", "copy", "cut", "webkitTransitionEnd", "transitionend", "webkitAnimationEnd", "animationend",
		"webkitAnimationStart", "animationstart", "webkitAnimationIteration", "animationiteration"],

	/**
	* These events come from window
	*
	* @private
	*/
	windowEvents: ["resize", "load", "unload", "message", "hashchange", "popstate", "focus", "blur"],

	/**
	* Feature plugins (aka filters)
	*
	* @private
	*/
	features: [],

	/**
	* @private
	*/
	connect: function() {
		var d = dispatcher, i, n;
		for (i=0; (n=d.events[i]); i++) {
			d.listen(document, n);
		}
		for (i=0; (n=d.windowEvents[i]); i++) {
			// Chrome Packaged Apps don't like "unload"
			if(n === "unload" &&
				(typeof global.chrome === "object") &&
				global.chrome.app) {
				continue;
			}

			d.listen(window, n);
		}
	},

	/**
	* @private
	*/
	listen: function(inListener, inEventName, inHandler) {
		if (inListener.addEventListener) {
			this.listen = function(inListener, inEventName, inHandler) {
				inListener.addEventListener(inEventName, inHandler || dispatch, false);
			};
		} else {
			//enyo.log("IE8 COMPAT: using 'attachEvent'");
			this.listen = function(inListener, inEvent, inHandler) {
				inListener.attachEvent("on" + inEvent, function(e) {
					e.target = e.srcElement;
					if (!e.preventDefault) {
						e.preventDefault = this.iePreventDefault;
					}
					return (inHandler || dispatch)(e);
				});
			};
		}
		this.listen(inListener, inEventName, inHandler);
	},

	/**
	* @private
	*/
	stopListening: function(inListener, inEventName, inHandler) {
		if (inListener.addEventListener) {
			this.stopListening = function(inListener, inEventName, inHandler) {
				inListener.removeEventListener(inEventName, inHandler || dispatch, false);
			};
		} else {
			//enyo.log("IE8 COMPAT: using 'detachEvent'");
			this.stopListening = function(inListener, inEvent, inHandler) {
				inListener.detachEvent("on" + inEvent, inHandler || dispatch);
			};
		}
		this.stopListening(inListener, inEventName, inHandler);
	},

	/**
	* Fires an event for Enyo to listen for.
	*
	* @private
	*/
	dispatch: function(e) {
		// Find the control who maps to e.target, or the first control that maps to an ancestor of e.target.
		var c = this.findDispatchTarget(e.target) || this.findDefaultTarget();
		// Cache the original target
		e.dispatchTarget = c;
		// support pluggable features return true to abort immediately or set e.preventDispatch to avoid processing.
		for (var i=0, fn; (fn=this.features[i]); i++) {
			if (fn.call(this, e) === true) {
				return;
			}
		}
		if (c && !e.preventDispatch) {
			return this.dispatchBubble(e, c);
		}
	},

	/**
	* Takes an event target and finds the corresponding Enyo control.
	*
	* @private
	*/
	findDispatchTarget: function(inNode) {
		var t, n = inNode;
		// FIXME: Mozilla: try/catch is here to squelch "Permission denied to access property xxx from a non-chrome context"
		// which appears to happen for scrollbar nodes in particular. It's unclear why those nodes are valid targets if
		// it is illegal to interrogate them. Would like to trap the bad nodes explicitly rather than using an exception block.
		try {
			while (n) {
				if ((t = this.$[n.id])) {
					// there could be multiple nodes with this id, the relevant node for this event is n
					// we don't push this directly to t.node because sometimes we are just asking what
					// the target 'would be' (aka, calling findDispatchTarget from handleMouseOverOut)
					t.eventNode = n;
					break;
				}
				n = n.parentNode;
			}
		} catch(x) {
			logger.log(x, n);
		}
		return t;
	},

	/**
	* Returns the default Enyo control for events.
	*
	* @private
	*/
	findDefaultTarget: function() {
		return master;
	},

	/**
	* @private
	*/
	dispatchBubble: function(e, c) {
		var type = e.type;
		type = e.customEvent ? type : "on" + type;
		return c.bubble(type, e, c);
	}
};

/**
* Called in the context of an event.
*
* @private
*/
dispatcher.iePreventDefault = function() {
	try {
		this.returnValue = false;
	}
	catch(e) {
		// do nothing
	}
};

/**
* @private
*/
function dispatch (inEvent) {
	return dispatcher.dispatch(inEvent);
};

/**
* @private
*/
dispatcher.bubble = function(inEvent) {
	// '|| window.event' clause needed for IE8
	var e = inEvent || global.event;
	if (e) {
		// We depend on e.target existing for event tracking and dispatching.
		if (!e.target) {
			e.target = e.srcElement;
		}
		dispatcher.dispatch(e);
	}
};

// This string is set on event handlers attributes for DOM elements that
// don't normally bubble (like onscroll) so that they can participate in the
// Enyo event system.
dispatcher.bubbler = "enyo.bubble(arguments[0])";

// The code below helps make Enyo compatible with Google Packaged Apps
// Content Security Policy(http://developer.chrome.com/extensions/contentSecurityPolicy.html),
// which, among other things, forbids the use of inline scripts.
// We replace online scripting with equivalent means, leaving enyo.bubbler
// for backward compatibility.
(function() {
	var bubbleUp = function() {
		dispatcher.bubble(arguments[0]);
	};

	/**
	* Makes given events bubble on a specified Enyo control.
	*
	* @private
	*/
	dispatcher.makeBubble = function() {
		var args = Array.prototype.slice.call(arguments, 0),
			control = args.shift();

		if((typeof control === "object") && (typeof control.hasNode === "function")) {
			utils.forEach(args, function(event) {
				if(this.hasNode()) {
					dispatcher.listen(this.node, event, bubbleUp);
				}
			}, control);
		}
	};

	/**
	* Removes the event listening and bubbling initiated by
	* [enyo.makeBubble()]{@link enyo.makeBubble} on a specific control.
	*
	* @private
	*/
	dispatcher.unmakeBubble = function() {
		var args = Array.prototype.slice.call(arguments, 0),
			control = args.shift();

		if((typeof control === "object") && (typeof control.hasNode === "function")) {
			utils.forEach(args, function(event) {
				if(this.hasNode()) {
					dispatcher.stopListening(this.node, event, bubbleUp);
				}
			}, control);
		}
	};
})();

/**
* @private
*/
// FIXME: we need to create and initialize dispatcher someplace else to allow overrides
Dom.requiresWindow(dispatcher.connect);

/**
* Generates a tapped event for a raw-click event.
*
* @private
*/
dispatcher.features.push(
	function (e) {
		if ("click" === e.type) {
			if (e.clientX === 0 && e.clientY === 0) {
				// this allows the click to dispatch as well
				// but note the tap event will fire first
				var cp = utils.clone(e);
				cp.type = "tap";
				cp.preventDefault = utils.nop;
				dispatcher.dispatch(cp);
			}
		}
	}
);

/**
* Instead of having multiple `features` pushed and handled in separate methods
* for these events, we handle them uniformly here to expose the last known
* interaction coordinates as accurately as possible.
*
* @private
*/
var _xy = {};
dispatcher.features.push(
	function (e) {
		if (
			(e.type == "mousemove")  ||
			(e.type == "tap")        ||
			(e.type == "click")      ||
			(e.type == "touchmove")
		) {
			_xy.clientX = e.clientX;
			_xy.clientY = e.clientY;
			// note only ie8 does not support pageX/pageY
			_xy.pageX   = e.pageX;
			_xy.pageY   = e.pageY;
			// note ie8 and opera report these values incorrectly
			_xy.screenX = e.screenX;
			_xy.screenY = e.screenY;
		}
	}
);

/**
* Retrieves the last known coordinates of the cursor or user-interaction point
* in touch environments. Returns an immutable object with the `clientX`,
* `clientY`, `pageX`, `pageY`, `screenX`, and `screenY` properties. It is
* important to note that IE8 and Opera have improper reporting for the
* `screenX` and `screenY` properties (they both use CSS pixels as opposed to
* device pixels) and IE8 has no support for the `pageX` and `pageY` properties,
* so they are facaded.
*
* @returns {enyo.dispatcher~CursorCoordinates} An [object]{@glossary Object} describing the
*	the last known coordinates of the cursor or user-interaction point in touch environments.
* @public
*/
dispatcher.getPosition = function () {
	var p = utils.clone(_xy);
	// if we are in ie8 we facade the _pageX, pageY_ properties
	if (platform.ie < 9) {
		var d = (document.documentElement || document.body.parentNode || document.body);
		p.pageX = (p.clientX + d.scrollLeft);
		p.pageY = (p.clientY + d.scrollTop);
	}
	return p;
};


/**
* Key mapping feature: Adds a `keySymbol` property to key [events]{@glossary event},
* based on a global key mapping. Use
* [enyo.dispatcher.registerKeyMap()]{@link enyo.dispatcher.registerKeyMap} to add
* keyCode-to-keySymbol mappings via a simple hash. This method may be called
* multiple times from different libraries to mix different maps into the global
* mapping table; if conflicts arise, the last-in wins.
*
* ```
* enyo.dispatcher.registerKeyMap({
* 	415 : 'play',
* 	413 : 'stop',
* 	19  : 'pause',
* 	412 : 'rewind',
* 	417 : 'fastforward'
* });
* ```
* 
* @private
*/
dispatcher.features.push(function(e) {
	if ((e.type === 'keydown') || (e.type === 'keyup') || (e.type === 'keypress')) {
		e.keySymbol = this.keyMap[e.keyCode];
		// Dispatch key events to be sent via Signals
		var c = this.findDefaultTarget();
		if (e.dispatchTarget !== c) {
			this.dispatchBubble(e, c);
		}
	}
});

utils.mixin(dispatcher, {
	keyMap: {},
	registerKeyMap: function(map) {
		utils.mixin(this.keyMap, map);
	}
});


/**
* Event modal capture feature. Capture events to a specific control via
* [enyo.dispatcher.capture(inControl, inShouldForward)]{@linkcode enyo.dispatcher.capture};
* release events via [enyo.dispatcher.release()]{@link enyo.dispatcher.release}.
*
* @private
*/
dispatcher.features.push(function(e) {
	if (this.captureTarget) {
		var c = e.dispatchTarget;
		var eventName = (e.customEvent ? '' : 'on') + e.type;
		var handlerName = this.captureEvents[eventName];
		var handlerScope = this.captureHandlerScope || this.captureTarget;
		var handler = handlerName && handlerScope[handlerName];
		var shouldCapture = handler && !(c && c.isDescendantOf && c.isDescendantOf(this.captureTarget));
		if (shouldCapture) {
			var c1 = e.captureTarget = this.captureTarget;
			// NOTE: We do not want releasing capture while an event is being processed to alter
			// the way the event propagates. Therefore decide if the event should forward
			// before the capture target receives the event (since it may release capture).
			e.preventDispatch = handler && handler.apply(handlerScope, [c1, e]) && !this.autoForwardEvents[e.type];
		}
	}
});

//
//        NOTE: This object is a plug-in; these methods should
//        be called on `enyo.dispatcher`, and not on the plug-in itself.
//
utils.mixin(dispatcher, {

	/**
	* @private
	*/
	autoForwardEvents: {leave: 1, resize: 1},

	/**
	* @private
	*/
	captures: [],

	/** 
	* Captures [events]{@glossary event} for `inTarget`, where `inEvents` is specified as a
	* hash of event names mapped to callback handler names to be called on `inTarget` (or,
	* optionally, `inScope`). The callback is called when any of the captured events are
	* dispatched outside of the capturing control. Returning `true` from the callback stops
	* dispatch of the event to the original `dispatchTarget`.
	*
	* @private
	*/
	capture: function(inTarget, inEvents, inScope) {
		var info = {target: inTarget, events: inEvents, scope: inScope};
		this.captures.push(info);
		this.setCaptureInfo(info);
	},

	/**
	* Removes the specified target from the capture list.
	* 
	* @private
	*/
	release: function(inTarget) {
		for (var i = this.captures.length - 1; i >= 0; i--) {
			if (this.captures[i].target === inTarget) {
				this.captures.splice(i,1);
				this.setCaptureInfo(this.captures[this.captures.length-1]);
				break;
			}
		}
	},

	/**
	* Sets the information for a captured {@glossary event}.
	* 
	* @private
	*/
	setCaptureInfo: function(inInfo) {
		this.captureTarget = inInfo && inInfo.target;
		this.captureEvents = inInfo && inInfo.events;
		this.captureHandlerScope = inInfo && inInfo.scope;
	}
});


(function () {
	/**
	* Dispatcher preview feature
	* 
	* Allows {@link enyo.Control} ancestors of the {@glossary event} target
	* a chance (eldest first) to react by implementing `previewDomEvent`.
	*
	* @private
	*/
	var fn = 'previewDomEvent';
	var preview = 
		/** @lends enyo.dispatcher.features */ {

		/**
		* @private
		*/
		feature: function(e) {
			preview.dispatch(e, e.dispatchTarget);
		},

		/**
		* @returns {(Boolean|undefined)} Handlers return `true` to abort preview and prevent default
		*	event processing.
		*
		* @private
		*/
		dispatch: function(evt, control) {
			var i, l,
			lineage = this.buildLineage(control);
			for (i=0; (l=lineage[i]); i++) {
				if (l[fn] && l[fn](evt) === true) {
					evt.preventDispatch = true;
					return;
				}
			}
		},

		/**
		* We ascend, making a list of Enyo [controls]{@link enyo.Control}.
		*
		* Note that a control is considered to be its own ancestor.
		*
		* @private
		*/
		buildLineage: function(control) {
			var lineage = [],
				c = control;
			while (c) {
				lineage.unshift(c);
				c = c.parent;
			}
			return lineage;
		}
	};

	dispatcher.features.push(preview.feature);
})();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./dom":58,"./logger":67,"./master":68,"./platform":71,"./utils":75}],61:[function(require,module,exports){
require('../../../enyo');



var
	dispatcher = require('../dispatcher'),
	utils = require('../utils');
var
	Signals = require('../Signals'),
	Ready = require('../ready');

/**
* Normalizes and provides fullscreen support for [controls]{@link enyo.Control},
* based on the [fullscreen]{@glossary fullscreen} API.
*
* @name enyo.fullscreen
* @type Object
* @public
*/
var fullscreen = module.exports = {
	
	/**
	* Reference to the current fullscreen [control]{@link enyo.Control}.
	*
	* @private
	*/
	fullscreenControl: null,

	/**
	* Reference to the current fullscreen element (fallback for platforms
	* without native support).
	*
	* @private
	*/
	fullscreenElement: null,

	/** 
	* Reference to that [control]{@link enyo.Control} that requested fullscreen.
	* 
	* @private
	*/
	requestor: null,

	/** 
	* Native accessor used to get reference to the current fullscreen element.
	*
	* @private
	*/
	elementAccessor:
		('fullscreenElement' in document) ? 'fullscreenElement' :
		('mozFullScreenElement' in document) ? 'mozFullScreenElement' :
		('webkitFullscreenElement' in document) ? 'webkitFullscreenElement' :
		null,

	/** 
	* Native accessor used to request fullscreen.
	*
	* @private
	*/
	requestAccessor:
		('requestFullscreen' in document.documentElement) ? 'requestFullscreen' :
		('mozRequestFullScreen' in document.documentElement) ? 'mozRequestFullScreen' :
		('webkitRequestFullscreen' in document.documentElement) ? 'webkitRequestFullscreen' :
		null,

	/** 
	* Native accessor used to cancel fullscreen.
	*
	* @private
	*/
	cancelAccessor:
		('cancelFullScreen' in document) ? 'cancelFullScreen' :
		('mozCancelFullScreen' in document) ? 'mozCancelFullScreen' :
		('webkitCancelFullScreen' in document) ? 'webkitCancelFullScreen' :
		null,

	/**
	* Determines whether the platform supports the [fullscreen]{@glossary fullscreen} API.
	* 
	* @returns {Boolean} Returns `true` if platform supports all of the 
	*	[fullscreen]{@glossary fullscreen} API, `false` otherwise.
	* @public
	*/
	nativeSupport: function() {
		return (this.elementAccessor !== null && this.requestAccessor !== null && this.cancelAccessor !== null);
	},

	/** 
	* Normalizes `getFullscreenElement()`.
	*
	* @public
	*/
	getFullscreenElement: function() {
		return (this.nativeSupport()) ? document[this.elementAccessor] : this.fullscreenElement;
	},

	/** 
	* Returns current fullscreen [control]{@link enyo.Control}.
	*
	* @public
	*/
	getFullscreenControl: function() {
		return this.fullscreenControl;
	},

	/**
	* Normalizes `requestFullscreen()`.
	*
	* @public
	*/
	requestFullscreen: function(ctl) {
		if (this.getFullscreenControl() || !(ctl.hasNode())) {
			return false;
		}

		this.requestor = ctl;

		// Only use native request if platform supports all of the API
		if (this.nativeSupport()) {
			ctl.hasNode()[this.requestAccessor]();
		} else {
			this.fallbackRequestFullscreen();
		}

		return true;
	},

	/** 
	* Normalizes `cancelFullscreen()`.
	*
	* @public
	*/
	cancelFullscreen: function() {
		if (this.nativeSupport()) {
			document[this.cancelAccessor]();
		} else {
			this.fallbackCancelFullscreen();
		}
	},

	/** 
	* Fallback support for setting fullscreen element (done by browser on platforms with
	* native support).
	*
	* @private
	*/
	setFullscreenElement: function(node) {
		this.fullscreenElement = node;
	},

	/** 
	* Sets current fullscreen [control]{@link enyo.Control}.
	*
	* @private
	*/
	setFullscreenControl: function(ctl) {
		this.fullscreenControl = ctl;
	},

	/** 
	* Fallback fullscreen request for platforms without fullscreen support.
	*
	* @private
	*/
	fallbackRequestFullscreen: function() {
		var control = this.requestor;

		if (!control) {
			return;
		}

		// Get before node to allow us to exit floating layer to the proper position
		control.prevAddBefore = control.parent.controlAtIndex(control.indexInContainer() + 1);
		
		var floatingLayer = Control.floatingLayer;
		
		// Render floating layer if we need to
		if (!floatingLayer.hasNode()) {
			floatingLayer.render();
		}

		control.addClass('enyo-fullscreen');
		control.appendNodeToParent(floatingLayer.hasNode());
		control.resize();

		this.setFullscreenControl(control);
		this.setFullscreenElement(control.hasNode());
	},

	/** 
	* Fallback cancel fullscreen for platforms without fullscreen support.
	*
	* @private
	*/
	fallbackCancelFullscreen: function() {
		var control = this.fullscreenControl,
			beforeNode,
			parentNode
		;

		if (!control) {
			return;
		}

		// Find beforeNode based on _this.addBefore_ and _this.prevAddBefore_
		beforeNode = (control.prevAddBefore) ? control.prevAddBefore.hasNode() : null;
		parentNode = control.parent.hasNode();
		control.prevAddBefore = null;

		control.removeClass('enyo-fullscreen');

		if (!beforeNode) {
			control.appendNodeToParent(parentNode);
		} else {
			control.insertNodeInParent(parentNode, beforeNode);
		}

		control.resize();

		this.setFullscreenControl(null);
		this.setFullscreenElement(null);
	},

	/** 
	* Listens for fullscreen change {@glossary event} and broadcasts it as a
	* normalized event.
	*
	* @private
	*/
	detectFullscreenChangeEvent: function() {
		this.setFullscreenControl(this.requestor);
		this.requestor = null;

		// Broadcast change
		Signals.send('onFullscreenChange');
	}
};

/**
* Normalizes platform-specific fullscreen change [events]{@glossary event}.
*
* @private
*/
Ready(function() {
	// no need for IE8 fallback, since it won't ever send this event
	if (document.addEventListener) {
		document.addEventListener('webkitfullscreenchange', utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);
		document.addEventListener('mozfullscreenchange',    utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);
		document.addEventListener('fullscreenchange',       utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);
	}
});

/**
* If this platform doesn't have native support for fullscreen, add an escape handler to mimic 
* native behavior.
*/
if(!fullscreen.nativeSupport()) {
	dispatcher.features.push(
		function(e) {
			if (e.type === 'keydown' && e.keyCode === 27) {
				fullscreen.cancelFullscreen();
			}
		}
	);
}
},{"../../../enyo":1,"../Signals":47,"../dispatcher":57,"../ready":72,"../utils":75}],62:[function(require,module,exports){
(function (global){
require('../../enyo');

var
	utils = require('./utils'),
	platform = require('./platform'),
	dispatcher = require('./dispatcher');

var
	Dom = require('./dom');


/**
* Enyo supports a set of normalized events that work similarly across all supported platforms.
* These events are provided so that users can write a single set of event handlers for
* applications that run on both mobile and desktop platforms. They are needed because desktop
* and mobile platforms handle basic input differently.
*
* For more information on normalized input events and their associated properties, see the
* documentation on [Event Handling]{@linkplain $dev-guide/key-concepts/event-handling.html}
* in the Enyo Developer Guide.
*
* @namespace gesture
* @public
*/
var gesture = module.exports =
	/** @lends gesture */ {

	/**
	* @private
	*/
	eventProps: ['target', 'relatedTarget', 'clientX', 'clientY', 'pageX', 'pageY',
		'screenX', 'screenY', 'altKey', 'ctrlKey', 'metaKey', 'shiftKey',
		'detail', 'identifier', 'dispatchTarget', 'which', 'srcEvent'],

	/**
	* Creates an {@glossary event} of type `type` and returns it.
	* `evt` should be an event [object]{@glossary Object}.
	*
	* @param {String} type - The type of {@glossary event} to make.
	* @param {(Event|Object)} evt - The event you'd like to clone or an object that looks like it.
	* @returns {Object} The new event [object]{@glossary Object}.
	* @public
	*/
	makeEvent: function(type, evt) {
		var e = {};
		e.type = type;
		for (var i=0, p; (p=this.eventProps[i]); i++) {
			e[p] = evt[p];
		}
		e.srcEvent = e.srcEvent || evt;
		e.preventDefault = this.preventDefault;
		e.disablePrevention = this.disablePrevention;

		if (Dom._bodyScaleFactorX !== 1 || Dom._bodyScaleFactorY !== 1) {
			// Intercept only these events, not all events, like: hold, release, tap, etc,
			// to avoid doing the operation again.
			if (e.type == 'move' || e.type == 'up' || e.type == 'down' || e.type == 'enter' || e.type == 'leave') {
				e.clientX *= Dom._bodyScaleFactorX;
				e.clientY *= Dom._bodyScaleFactorY;
			}
		}
		//
		// normalize event.which and event.pageX/event.pageY
		// Note that while 'which' works in IE9, it is broken for mousemove. Therefore,
		// in IE, use global.event.button
		if (platform.ie < 10) {
			//Fix for IE8, which doesn't include pageX and pageY properties
			if(platform.ie==8 && e.target) {
				e.pageX = e.clientX + e.target.scrollLeft;
				e.pageY = e.clientY + e.target.scrollTop;
			}
			var b = global.event && global.event.button;
			if (b) {
				// multi-button not supported, priority: left, right, middle
				// (note: IE bitmask is 1=left, 2=right, 4=center);
				e.which = b & 1 ? 1 : (b & 2 ? 2 : (b & 4 ? 3 : 0));
			}
		} else if (platform.webos || global.PalmSystem) {
			// Temporary fix for owos: it does not currently supply 'which' on move events
			// and the user agent string doesn't identify itself so we test for PalmSystem
			if (e.which === 0) {
				e.which = 1;
			}
		}
		return e;
	},

	/**
	* Handles "down" [events]{@glossary event}, including `mousedown` and `keydown`. This is
	* responsible for the press-and-hold key repeater.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	down: function(evt) {
		var e = this.makeEvent('down', evt);

		// prepare for hold
		this.drag.prepareHold(e);

		// enable prevention of tap event
		e.preventTap = function() {
			e._tapPrevented = true;
		};

		dispatcher.dispatch(e);
		this.downEvent = e;

		// start hold, now that control has had a chance
		// to override the holdPulse configuration
		this.drag.beginHold(e);
	},

	/**
	* Handles `mousemove` [events]{@glossary event}.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	move: function(evt) {
		var e = this.makeEvent('move', evt);
		// include delta and direction v. down info in move event
		e.dx = e.dy = e.horizontal = e.vertical = 0;
		if (e.which && this.downEvent) {
			e.dx = evt.clientX - this.downEvent.clientX;
			e.dy = evt.clientY - this.downEvent.clientY;
			e.horizontal = Math.abs(e.dx) > Math.abs(e.dy);
			e.vertical = !e.horizontal;
		}
		dispatcher.dispatch(e);
	},

	/**
	* Handles "up" [events]{@glossary event}, including `mouseup` and `keyup`.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	up: function(evt) {
		var e = this.makeEvent('up', evt);

		// We have added some logic to synchronize up and down events in certain scenarios (i.e.
		// clicking multiple buttons with a mouse) and to generally guard against any potential
		// asymmetry, but a full solution would be to maintain a map of up/down events as an 
		// ideal solution, for future work.
		e._tapPrevented = this.downEvent && this.downEvent._tapPrevented && this.downEvent.which == e.which;
		e.preventTap = function() {
			e._tapPrevented = true;
		};

		dispatcher.dispatch(e);
		if (!e._tapPrevented && this.downEvent && this.downEvent.which == 1) {
			var target = this.findCommonAncestor(this.downEvent.target, evt.target);

			// the common ancestor of the down/up events is the target of the tap
			if(target) {
				if(this.supportsDoubleTap(target)) {
					this.doubleTap(e, target);
				} else {
					this.sendTap(e, target);
				}
			}
		}
		if (this.downEvent && this.downEvent.which == e.which) {
			this.downEvent = null;
		}
	},

	/**
	* Handles `mouseover` [events]{@glossary event}.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	over: function(evt) {
		var e = this.makeEvent('enter', evt);
		dispatcher.dispatch(e);
	},

	/**
	* Handles `mouseout` [events]{@glossary event}.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	out: function(evt) {
		var e = this.makeEvent('leave', evt);
		dispatcher.dispatch(e);
	},

	/**
	* Generates `tap` [events]{@glossary event}.
	*
	* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.
	* @public
	*/
	sendTap: function(evt, target) {
		var e = this.makeEvent('tap', evt);
		e.target = target;
		dispatcher.dispatch(e);
	},

	/**
	* @private
	*/
	tapData: {
		id: null,
		timer: null,
		start: 0
	},

	/**
	* Global configuration for double tap support. If this is true, all tap events for Controls
	* that do not have {@link enyo.Control#doubleTapEnabled} explicitly set to false will be
	* delayed by the {@link enyo.Control#doubleTapInterval}.
	*
	* @type {Boolean}
	* @default  false
	* @public
	*/
	doubleTapEnabled: false,

	/**
	* Determines if the provided target node supports double tap events
	*
	* @param {Node} target
	* @return {Boolean}
	* @private
	*/
	supportsDoubleTap: function(target) {
		var obj = dispatcher.findDispatchTarget(target);

		if(obj) {
			// Control.doubleTapEnabled is a tri-value property. The default is 'inherit'
			// which takes its cue from gesture's doubleTapEnabled. Values of true or false
			// override the default. So, if the global is true, any truthy value on Control
			// results in true. If the global is false, only an explicit true on Control
			// results in true.
			return this.doubleTapEnabled? !!obj.doubleTapEnabled : obj.doubleTapEnabled === true;
		} else {
			return false;
		}
	},

	/**
	* private
	*/
	doubleTap: function(evt, t) {
		var obj = dispatcher.findDispatchTarget(t);

		if(this.tapData.id !== obj.id) {	// this is the first tap
			this.resetTapData(true);

			this.tapData.id = obj.id;
			this.tapData.event = evt;
			this.tapData.target = t;
			this.tapData.timer = setTimeout(utils.bind(this, "resetTapData", true), obj.doubleTapInterval);
			this.tapData.start = utils.perfNow();
		} else {							// this is the double tap
			var e2 = this.makeEvent('doubletap', evt);
			e2.target = t;
			e2.tapInterval = utils.perfNow() - this.tapData.start;
			this.resetTapData(false);
			dispatcher.dispatch(e2);
		}
	},

	resetTapData: function(sendTap) {
		var data = this.tapData;

		if(sendTap && data.id) {
			this.sendTap(data.event, data.target);
		}

		clearTimeout(data.timer);
		data.id = data.start = data.event = data.target = data.timer = null;
	},

	/**
	* Given two [DOM nodes]{@glossary Node}, searches for a shared ancestor (looks up
	* the hierarchic [DOM]{@glossary DOM} tree of [nodes]{@glossary Node}). The shared
	* ancestor node is returned.
	*
	* @param {Node} controlA - Control one.
	* @param {Node} controlB - Control two.
	* @returns {(Node|undefined)} The shared ancestor.
	* @public
	*/
	findCommonAncestor: function(controlA, controlB) {
		var p = controlB;
		while (p) {
			if (this.isTargetDescendantOf(controlA, p)) {
				return p;
			}
			p = p.parentNode;
		}
	},

	/**
	* Given two controls, returns `true` if the `child` is inside the `parent`.
	*
	* @param {Node} child - The child to search for.
	* @param {Node} parent - The expected parent.
	* @returns {(Boolean|undefined)} `true` if the `child` is actually a child of `parent`.
	*/
	isTargetDescendantOf: function(child, parent) {
		var c = child;
		while(c) {
			if (c == parent) {
				return true;
			}
			c = c.parentNode;
		}
	}
};

/**
* Installed on [events]{@glossary event} and called in event context.
*
* @private
*/
gesture.preventDefault = function() {
	if (this.srcEvent) {
		this.srcEvent.preventDefault();
	}
};

/**
* @private
*/
gesture.disablePrevention = function() {
	this.preventDefault = utils.nop;
	if (this.srcEvent) {
		this.srcEvent.preventDefault = utils.nop;
	}
};

dispatcher.features.push(
	function(e) {
		// NOTE: beware of properties in gesture inadvertently mapped to event types
		if (gesture.events[e.type]) {
			return gesture.events[e.type](e);
		}
	}
);

/**
* @namespace gesture.events
* @public
*/
gesture.events =
	/** @lends gesture.events */ {

	/**
	* Shortcut to [gesture.down()]{@link gesture.down}.
	*
	* @public
	*/
	mousedown: function(e) {
		gesture.down(e);
	},

	/**
	* Shortcut to [gesture.up()]{@link gesture.up}.
	*
	* @public
	*/
	mouseup: function(e) {
		gesture.up(e);
	},

	/**
	* Shortcut to [gesture.move()]{@link gesture.move}.
	*
	* @public
	*/
	mousemove:  function(e) {
		gesture.move(e);
	},

	/**
	* Shortcut to [gesture.over()]{@link gesture.over}.
	*
	* @public
	*/
	mouseover:  function(e) {
		gesture.over(e);
	},

	/**
	* Shortcut to [gesture.out()]{@link gesture.out}.
	*
	* @public
	*/
	mouseout:  function(e) {
		gesture.out(e);
	}
};

// Firefox mousewheel handling
Dom.requiresWindow(function() {
	if (document.addEventListener) {
		document.addEventListener('DOMMouseScroll', function(inEvent) {
			var e = utils.clone(inEvent);
			e.preventDefault = function() {
				inEvent.preventDefault();
			};
			e.type = 'mousewheel';
			var p = e.VERTICAL_AXIS == e.axis ? 'wheelDeltaY' : 'wheelDeltaX';
			e[p] =  e.detail * -40;
			dispatcher.dispatch(e);
		}, false);
	}
});



/**
* The extended {@glossary event} [object]{@glossary Object} that is provided when we
* emulate iOS gesture events on non-iOS devices.
*
* @typedef {Object} enyo.gesture~EmulatedGestureEvent
* @property {Number} pageX - The x-coordinate of the center point between fingers.
* @property {Number} pageY - The y-coordinate of the center point between fingers.
* @property {Number} rotation - The degrees of rotation from the beginning of the gesture.
* @property {Number} scale - The percent change of distance between fingers.
*/

/**
* @private
*/
if (!platform.gesture && platform.touch) {
	dispatcher.features.push(function(e) {
		if (handlers[e.type]) {
			touchGestures[e.type](e);
		}
	});
}

/**
* @private
*/
var handlers = {
	touchstart: true,
	touchmove: true,
	touchend: true
};

/**
* @private
*/
var touchGestures = {

	/**
	* @private
	*/
	orderedTouches: [],

	/**
	* @private
	*/
	gesture: null,

	/**
	* @private
	*/
	touchstart: function (e) {
		// some devices can send multiple changed touches on start and end
		var i,
			changedTouches = e.changedTouches,
			length = changedTouches.length;

		for (i = 0; i < length; i++) {
			var id = changedTouches[i].identifier;

			// some devices can send multiple touchstarts
			if (utils.indexOf(id, this.orderedTouches) < 0) {
				this.orderedTouches.push(id);
			}
		}

		if (e.touches.length >= 2 && !this.gesture) {
			var p = this.gesturePositions(e);

			this.gesture = this.gestureVector(p);
			this.gesture.angle = this.gestureAngle(p);
			this.gesture.scale = 1;
			this.gesture.rotation = 0;
			var g = this.makeGesture('gesturestart', e, {vector: this.gesture, scale: 1, rotation: 0});
			dispatcher.dispatch(g);
		}
	},

	/**
	* @private
	*/
	touchend: function (e) {
		// some devices can send multiple changed touches on start and end
		var i,
			changedTouches = e.changedTouches,
			length = changedTouches.length;

		for (i = 0; i < length; i++) {
			utils.remove(changedTouches[i].identifier, this.orderedTouches);
		}

		if (e.touches.length <= 1 && this.gesture) {
			var t = e.touches[0] || e.changedTouches[e.changedTouches.length - 1];

			// gesture end sends last rotation and scale, with the x/y of the last finger
			dispatcher.dispatch(this.makeGesture('gestureend', e, {vector: {xcenter: t.pageX, ycenter: t.pageY}, scale: this.gesture.scale, rotation: this.gesture.rotation}));
			this.gesture = null;
		}
	},

	/**
	* @private
	*/
	touchmove: function (e) {
		if (this.gesture) {
			var g = this.makeGesture('gesturechange', e);
			this.gesture.scale = g.scale;
			this.gesture.rotation = g.rotation;
			enyo.dispatch(g);
		}
	},

	/**
	* @private
	*/
	findIdentifiedTouch: function (touches, id) {
		for (var i = 0, t; (t = touches[i]); i++) {
			if (t.identifier === id) {
				return t;
			}
		}
	},

	/**
	* @private
	*/
	gesturePositions: function (e) {
		var first = this.findIdentifiedTouch(e.touches, this.orderedTouches[0]);
		var last = this.findIdentifiedTouch(e.touches, this.orderedTouches[this.orderedTouches.length - 1]);
		var fx = first.pageX, lx = last.pageX, fy = first.pageY, ly = last.pageY;
		// center the first touch as 0,0
		var x = lx - fx, y = ly - fy;
		var h = Math.sqrt(x*x + y*y);
		return {x: x, y: y, h: h, fx: fx, lx: lx, fy: fy, ly: ly};
	},

	/**
	* Finds rotation angle.
	* 
	* @private
	*/
	gestureAngle: function (positions) {
		var p = positions;
		// yay math!, rad -> deg
		var a = Math.asin(p.y / p.h) * (180 / Math.PI);
		// fix for range limits of asin (-90 to 90)
		// Quadrants II and III
		if (p.x < 0) {
			a = 180 - a;
		}
		// Quadrant IV
		if (p.x > 0 && p.y < 0) {
			a += 360;
		}
		return a;
	},

	/**
	* Finds bounding box.
	* 
	* @private
	*/
	gestureVector: function (positions) {
		// the least recent touch and the most recent touch determine the bounding box of the gesture event
		var p = positions;
		// center the first touch as 0,0
		return {
			magnitude: p.h,
			xcenter: Math.abs(Math.round(p.fx + (p.x / 2))),
			ycenter: Math.abs(Math.round(p.fy + (p.y / 2)))
		};
	},

	/**
	* @private
	*/
	makeGesture: function (type, e, cache) {
		var vector, scale, rotation;
		if (cache) {
			vector = cache.vector;
			scale = cache.scale;
			rotation = cache.rotation;
		} else {
			var p = this.gesturePositions(e);
			vector = this.gestureVector(p);
			scale = vector.magnitude / this.gesture.magnitude;
			// gestureEvent.rotation is difference from the starting angle, clockwise
			rotation = (360 + this.gestureAngle(p) - this.gesture.angle) % 360;
		}
		var event = utils.clone(e);
		return utils.mixin(event, {
			type: type,
			scale: scale,
			pageX: vector.xcenter,
			pageY: vector.ycenter,
			rotation: rotation
		});
	}
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../enyo":1,"./dispatcher":57,"./dom":58,"./platform":71,"./utils":75}],99:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	dispatcher = require('../../../enyo/lib/dispatcher'),
	dom = require('../../../enyo/lib/dom'),
	platform = require('../../../enyo/lib/platform'),
	utils = require('../../../enyo/lib/utils'),
	Animator = require('../../../enyo/lib/Animator');

var
	CardArranger = require('../CardArranger');

/**
* Fires at the start of a panel transition, when [setIndex()]{@link enyo.Panels#setIndex}
* is called, and also during dragging.
*
* @event enyo.Panels#onTransitionStart
* @type {Object}
* @property {Number} fromIndex - The index of the old panel.
* @property {Number} toIndex   - The index of the new panel.
* @public
*/

/**
* Fires at the end of a panel transition, when [setIndex()]{@link enyo.Panels#setIndex}
* is called, and also during dragging.
*
* @event enyo.Panels#onTransitionFinish
* @type {Object}
* @property {Number} fromIndex - The index of the old panel.
* @property {Number} toIndex   - The index of the new panel.
* @public
*/

/**
* The {@link enyo.Panels} kind is designed to satisfy a variety of common use cases
* for application layout. Using `enyo.Panels`, controls may be arranged as (among
* other things) a carousel, a set of collapsing panels, a card stack that fades
* between panels, or a grid.
*
* Any Enyo control may be placed inside an `enyo.Panels`, but by convention we
* refer to each of these controls as a "panel". From the set of panels in an
* `enyo.Panels`, one is considered to be active. The active panel is set by index
* using the [setIndex()]{@link enyo.Panels#setIndex} method. The actual layout of
* the panels typically changes each time the active panel is set, such that the new
* active panel has the most prominent position.
*
* For more information, see the documentation on
* [Panels]{@linkplain $dev-guide/building-apps/layout/panels.html} in the
* Enyo Developer Guide.
*
* @ui
* @class enyo.Panels
* @extends enyo.Control
* @public
*/
var Panels = module.exports = kind(
	/** @lends  enyo.Panels.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Panels',

	/**
	* @private
	*/
	classes: 'enyo-panels',

	/**
	* @lends enyo.Panels.prototype
	* @private
	*/
	published: {
		/**
		* The index of the active panel. The layout of panels is controlled by the
		* [layoutKind]{@link enyo.Panels#layoutKind}, but as a rule, the active panel
		* is displayed in the most prominent position. For example, in the (default)
		* {@link enyo.CardArranger} layout, the active panel is shown and the other
		* panels are hidden.
		*
		* @type {Number}
		* @default  0
		* @public
		*/
		index: 0,

		/**
		* Indicates whether the user may drag between panels.
		*
		* @type {Boolean}
		* @default  true
		* @public
		*/
		draggable: true,

		/**
		* Indicates whether the panels animate when transitioning, e.g., when
		* [setIndex()]{@link enyo.Panels#setIndex} is called.
		*
		* @type {Boolean}
		* @default  true
		* @public
		*/
		animate: true,

		/**
		* Indicates whether panels "wrap around" when moving past the end.
		* The actual effect depends upon the arranger in use.
		*
		* @type {Boolean}
		* @default  false
		* @public
		*/
		wrap: false,

		/**
		* The arranger kind to be used for dynamic layout.
		*
		* @type {String}
		* @default  'CardArranger'
		* @public
		*/
		arrangerKind: CardArranger,

		/**
		* By default, each panel will be sized to fit the Panels' width when the
		* screen size is sufficiently narrow (less than 800px). Set to `false` to
		* avoid this behavior.
		*
		* @type {Boolean}
		* @default  true
		* @public
		*/
		narrowFit: true
	},

	/**
	* @private
	*/
	events: {
		onTransitionStart: '',
		onTransitionFinish: ''
	},

	/**
	* @private
	*/
	handlers: {
		ondragstart: 'dragstart',
		ondrag: 'drag',
		ondragfinish: 'dragfinish',
		onscroll: 'domScroll'
	},

	/**
	* @private
	*/
	tools: [
		{kind: Animator, onStep: 'step', onEnd: 'animationEnded'}
	],

	/**
	* Tracks completion percentage for a transition between two panels.
	*
	* @private
	*/
	fraction: 0,

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			this.transitionPoints = [];
			sup.apply(this, arguments);
			this.arrangerKindChanged();
			this.narrowFitChanged();
			this.indexChanged();
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			dispatcher.makeBubble(this, 'scroll');
		};
	}),

	/**
	* @private
	*/
	domScroll: function (sender, event) {
		if (this.hasNode()) {
			if (this.node.scrollLeft > 0) {
				// Reset scrollLeft position
				this.node.scrollLeft = 0;
			}
		}
	},

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function () {
			this.createChrome(this.tools);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	arrangerKindChanged: function () {
		this.setLayoutKind(this.arrangerKind);
	},

	/**
	* @private
	*/
	narrowFitChanged: function () {
		this.addRemoveClass(Panels.getNarrowClass(), this.narrowFit);
	},

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			// When the entire panels is going away, take note so we don't try and do single-panel
			// remove logic such as changing the index and reflowing when each panel is destroyed
			this.destroying = true;
			sup.apply(this, arguments);
		};
	}),

	/**
	* Adjusts the index if the removed control is the active panel and reflows the layout.
	*
	* @method
	* @private
	*/
	removeControl: kind.inherit(function (sup) {
		return function (control) {
			// Skip extra work during panel destruction.
			if (this.destroying) {
				return sup.apply(this, arguments);
			}
			// adjust index if the current panel is being removed
			// so it's either the previous panel or the first one.
			var newIndex = -1;
			var controlIndex = utils.indexOf(control, this.controls);
			if (controlIndex === this.index) {
				newIndex = Math.max(controlIndex - 1, 0);
			}
			sup.apply(this, arguments);
			if (newIndex !== -1 && this.controls.length > 0) {
				this.setIndex(newIndex);
				this.flow();
				this.reflow();
			}
		};
	}),

	/**
	* Designed to be overridden in kinds derived from Panels that have
	* non-panel client controls.
	*
	* @return {Boolean} [description]
	* @protected
	* @todo  Assume that this should take a control as a parameter.
	*/
	isPanel: function () {
		return true;
	},

	/**
	* @method
	* @private
	*/
	flow: kind.inherit(function (sup) {
		return function () {
			this.arrangements = [];
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	reflow: kind.inherit(function (sup) {
		return function () {
			this.arrangements = [];
			sup.apply(this, arguments);
			this.refresh();
		};
	}),

	/**
	* Returns the array of contained panels. Subclasses may override this if they
	* don't want the arranger to lay out all of their children.
	*
	* @return {enyo.Control[]} - The array of contained panels.
	*/
	getPanels: function () {
		var p = this.controlParent || this;
		return p.children;
	},

	/**
	* Returns a reference to the active panel--i.e., the panel at the specified index.
	*
	* @return {enyo.Control} - The active panel.
	*/
	getActive: function () {
		var p$ = this.getPanels();
		//Constrain the index within the array of panels, needed if wrapping is enabled
		var index = this.index % p$.length;
		if (index < 0) {
			index += p$.length;
		}
		return p$[index];
	},

	/**
	* Returns a reference to the {@link enyo.Animator} instance used to
	* animate panel transitions. The Panels' animator may be used to set the
	* duration of panel transitions, e.g.:
	*
	* ```
	* this.getAnimator().setDuration(1000);
	* ```
	*
	* @return {enyo.Animator} - The {@link enyo.Animator} instance used to animate
	* panel transitions.
	* @public
	*/
	getAnimator: function () {
		return this.$.animator;
	},

	/**
	* Sets the active panel to the panel specified by the given index.
	* Note that if the [animate]{@link enyo.Panels#animate} property is set to
	* `true`, the active panel will animate into view.
	*
	* @param {Number} index - The index of the panel to activate.
	* @public
	*/
	setIndex: function (index) {
		// override setIndex so that indexChanged is called
		// whether this.index has actually changed or not. Also, do
		// index clamping here.
		var prevIndex = this.get('index'),
			newIndex = this.clamp(index);
		this.index = newIndex;
		this.notifyObservers('index', prevIndex, newIndex);
	},

	/**
	* Sets the active panel to the panel specified by the given index.
	* The transition to the next panel will be immediate and will not be animated,
	* regardless of the value of the [animate]{@link enyo.Panels#animate} property.
	*
	* @param {Number} index - The index of the panel to activate.
	* @public
	*/
	setIndexDirect: function (index) {
		if (this.animate) {
			this.animate = false;
			this.setIndex(index);
			this.animate = true;
		} else {
			this.setIndex(index);
		}
	},

	/**
	* Selects the named component owned by the Panels and returns its index.
	*
	* @param  {String} name - The name of the panel to activate.
	* @return {Number} The index of the newly activated panel.
	* @public
	*/
	selectPanelByName: function (name) {
		if (!name) {
			return;
		}
		var idx = 0;
		var panels = this.getPanels();
		var len = panels.length;
		for (; idx < len; ++idx) {
			if (name === panels[idx].name) {
				this.setIndex(idx);
				return idx;
			}
		}
	},

	/**
	* Transitions to the previous panel--i.e., the panel whose index value is one
	* less than that of the current active panel.
	*
	* @public
	*/
	previous: function () {
		var prevIndex = this.index - 1;
		if (this.wrap && prevIndex < 0) {
			prevIndex = this.getPanels().length - 1;
		}
		this.setIndex(prevIndex);
	},

	/**
	* Transitions to the next panel--i.e., the panel whose index value is one
	* greater than that of the current active panel.
	*
	* @public
	*/
	next: function () {
		var nextIndex = this.index+1;
		if (this.wrap && nextIndex >= this.getPanels().length) {
			nextIndex = 0;
		}
		this.setIndex(nextIndex);
	},

	/**
	* Ensures that `value` references a valid panel, accounting for
	* [wrapping]{@link enyo.Panels#wrap}.
	*
	* @param  {Number} value - The index of a panel.
	* @return {Number}       - The valid index of a panel.
	* @private
	*/
	clamp: function (value) {
		var l = this.getPanels().length;
		if (this.wrap) {
			// FIXME: dragging makes assumptions about direction and from->start indexes.
			//return value < 0 ? l : (value > l ? 0 : value);
			value %= l;
			return (value < 0) ? value + l : value;
		} else {
			return Math.max(0, Math.min(value, l - 1));
		}
	},

	/**
	* @private
	*/
	indexChanged: function (old) {
		this.lastIndex = old;
		if (!this.dragging && this.$.animator && this.hasNode()) {
			if (this.shouldAnimate()) {
				// If we're mid-transition, complete it and indicate we need to transition
				if (this.$.animator.isAnimating()) {
					this.transitionOnComplete = true;
					this.$.animator.complete();
				} else {
					this.animateTransition();
				}
			} else {
				this.directTransition();
			}
		}
	},

	/**
	* Returns `true` if the panels should animate in the transition from `fromIndex` to
	* `toIndex`. This can be overridden in a {@glossary subkind} for greater customization.
	*
	* @protected
	*/
	shouldAnimate: function () {
		return this.animate;
	},

	/**
	* @private
	*/
	step: function (sender) {
		this.fraction = sender.value;
		this.stepTransition();
		return true;
	},

	/**
	* @private
	*/
	animationEnded: function (sender, event) {
		this.completed();
	},

	/**
	* @private
	*/
	completed: function () {
		this.finishTransition();

		// Animator.onEnd fires asynchronously so we need an internal flag to indicate we need
		// to start the next transition when the previous completes
		if (this.transitionOnComplete) {
			this.transitionOnComplete = false;
			this.animateTransition();
		}

		return true;
	},

	/**
	* @private
	*/
	dragstart: function (sender, event) {
		if (this.draggable && this.layout && this.layout.canDragEvent(event)) {
			event.preventDefault();
			this.dragstartTransition(event);
			this.dragging = true;
			this.$.animator.stop();
			return true;
		}
	},

	/**
	* @private
	*/
	drag: function (sender, event) {
		if (this.dragging) {
			event.preventDefault();
			this.dragTransition(event);
		}
	},

	/**
	* @private
	*/
	dragfinish: function (sender, event) {
		if (this.dragging) {
			this.dragging = false;
			event.preventTap();
			this.dragfinishTransition(event);
		}
	},

	/**
	* @private
	*/
	dragstartTransition: function (event) {
		if (!this.$.animator.isAnimating()) {
			var f = this.fromIndex = this.index;
			this.toIndex = f - (this.layout ? this.layout.calcDragDirection(event) : 0);
		} else {
			this.verifyDragTransition(event);
		}
		this.fromIndex = this.clamp(this.fromIndex);
		this.toIndex = this.clamp(this.toIndex);
		//this.log(this.fromIndex, this.toIndex);
		this.fireTransitionStart();
		if (this.layout) {
			this.layout.start();
		}
	},

	/**
	* @private
	*/
	dragTransition: function (event) {
		// note: for simplicity we choose to calculate the distance directly between
		// the first and last transition point.
		var d = this.layout ? this.layout.calcDrag(event) : 0;
		var t$ = this.transitionPoints, s = t$[0], f = t$[t$.length-1];
		var as = this.fetchArrangement(s);
		var af = this.fetchArrangement(f);
		var dx = this.layout ? this.layout.drag(d, s, as, f, af) : 0;
		var dragFail = d && !dx;
		if (dragFail) {
			//this.log(dx, s, as, f, af);
		}
		this.fraction += dx;
		var fr = this.fraction;
		if (fr > 1 || fr < 0 || dragFail) {
			if (fr > 0 || dragFail) {
				this.dragfinishTransition(event);
			}
			this.dragstartTransition(event);
			this.fraction = 0;
			// FIXME: account for lost fraction
			//this.dragTransition(event);
		}
		this.stepTransition();
	},

	/**
	* @private
	*/
	dragfinishTransition: function (event) {
		this.verifyDragTransition(event);
		this.setIndex(this.toIndex);
		// note: if we're still dragging, then we're at a transition boundary
		// and should fire the finish event
		if (this.dragging) {
			this.fireTransitionFinish();
		}
	},

	/**
	* @private
	*/
	verifyDragTransition: function (event) {
		var d = this.layout ? this.layout.calcDragDirection(event) : 0;
		var f = Math.min(this.fromIndex, this.toIndex);
		var t = Math.max(this.fromIndex, this.toIndex);
		if (d > 0) {
			var s = f;
			f = t;
			t = s;
		}
		if (f != this.fromIndex) {
			this.fraction = 1 - this.fraction;
		}
		//this.log('old', this.fromIndex, this.toIndex, 'new', f, t);
		this.fromIndex = f;
		this.toIndex = t;
	},

	/**
	* Resets the panels without sending any events.
	*
	* @private
	*/
	refresh: function () {
		if (this.$.animator && this.$.animator.isAnimating()) {
			this.$.animator.stop();
		}
		this.setupTransition();
		this.fraction = 1;
		this.stepTransition();
		this.transitioning = false;
		this.completeTransition();
	},

	/**
	* Transitions to the new index without animation
	*
	* @private
	*/
	directTransition: function () {
		this.startTransition();
		this.fraction = 1;
		this.stepTransition();
		this.finishTransition();
	},

	/**
	* Animates the transition to the new index
	*
	* @private
	*/
	animateTransition: function () {
		this.startTransition();
		this.$.animator.play({
			startValue: this.fraction
		});
	},

	/**
	* Starts the transition between two panels. if a transition is already in progress, this is
	* a no-op.
	*
	* @private
	*/
	startTransition: function () {
		if (!this.transitioning) {
			this.transitioning = true;
			this.setupTransition();
			this.fireTransitionStart();
		}
	},

	/**
	* Sets up transition state
	*
	* @private
	*/
	setupTransition: function () {
		this.fromIndex = this.fromIndex != null ? this.fromIndex : this.lastIndex || 0;
		this.toIndex = this.toIndex != null ? this.toIndex : this.index;
		if (this.layout) {
			this.layout.start();
		}
	},

	/**
	* Completes the transition between two panels.
	*
	* @private
	*/
	finishTransition: function () {
		this.transitioning = false;
		this.completeTransition(true);
	},

	/**
	* Completes the transition by performing any tasks to be run when the transition ends,
	* including firing events and clean-up.
	*
	* @param {Boolean} [fire] - If `true`, will fire the {@link enyo.Panels#onTransitionFinish}
	*	event if deemed necessary.
	* @private
	*/
	completeTransition: function (fire) {
		if (this.layout) {
			this.layout.finish();
		}

		if (fire) {
			this.fireTransitionFinish(true);
		} else {
			this.clearTransitionData();
		}
	},

	/**
	* Clears transition-related data.
	*
	* @private
	*/
	clearTransitionData: function() {
		this.transitionPoints = [];
		this.fraction = 0;
		this.fromIndex = this.toIndex = null;
	},

	/**
	* @fires enyo.Panels#onTransitionStart
	* @private
	*/
	fireTransitionStart: function () {
		var t = this.startTransitionInfo;
		if (this.hasNode() && (!t || (t.fromIndex != this.fromIndex || t.toIndex != this.toIndex))) {
			this.startTransitionInfo = {fromIndex: this.fromIndex, toIndex: this.toIndex};
			this.doTransitionStart(utils.clone(this.startTransitionInfo));
		}
	},

	/**
	* @fires enyo.Panels#onTransitionFinish
	* @param {Boolean} [clearData] - If `true`, {@link enyo.Panels#clearTransitionData} will be
	*	called after recording the values needed for the callback.
	* @private
	*/
	fireTransitionFinish: function (clearData) {
		var t = this.finishTransitionInfo,
			fromIndex = t ? t.fromIndex : null,
			toIndex = t ? t.toIndex : null;
		if (this.hasNode() && (!t || (fromIndex != this.fromIndex || toIndex != this.toIndex))) {
				if (this.transitionOnComplete) {
				this.finishTransitionInfo = {fromIndex: toIndex, toIndex: this.lastIndex};
				} else {
					this.finishTransitionInfo = {fromIndex: this.lastIndex, toIndex: this.index};
				}
			if (clearData) {
				this.clearTransitionData();
			}
				this.doTransitionFinish(enyo.clone(this.finishTransitionInfo));
		} else if (clearData) {
			this.clearTransitionData();
		}
	},

	/**
	* Interpolates between arrangements as needed.
	*
	* @private
	*/
	stepTransition: function () {
		if (this.hasNode()) {
			// select correct transition points and normalize fraction.
			var t$ = this.transitionPoints;
			var r = (this.fraction || 0) * (t$.length-1);
			var i = Math.floor(r);
			r = r - i;
			var s = t$[i], f = t$[i+1];
			// get arrangements and lerp between them
			var s0 = this.fetchArrangement(s);
			var s1 = this.fetchArrangement(f);
			this.arrangement = s0 && s1 ? Panels.lerp(s0, s1, r) : (s0 || s1);
			if (this.arrangement && this.layout) {
				this.layout.flowArrangement();
			}
		}
	},

	/**
	* Fetches the arrangement at a specified index, initializing it if necessary.
	*
	* @param  {Number} index - The index of the desired arrangement from `transitionPoints`.
	* @return {Object} The desired arrangement object.
	* @private
	*/
	fetchArrangement: function (index) {
		if ((index != null) && !this.arrangements[index] && this.layout) {
			this.layout._arrange(index);
			this.arrangements[index] = this.readArrangement(this.getPanels());
		}
		return this.arrangements[index];
	},

	/**
	* Iterates over `panels` and retrieves a copy of each panel's `_arranger`.
	*
	* @param  {enyo.Control[]} panels - The array of panels.
	* @return {Object[]}              - The array of arrangement objects.
	*/
	readArrangement: function (panels) {
		var r = [];
		for (var i=0, c$=panels, c; (c=c$[i]); i++) {
			r.push(utils.clone(c._arranger));
		}
		return r;
	},

	/**
	* @lends  enyo.Panels
	* @private
	*/
	statics: {
		/**
		* Returns `true` for iOS and Android phone form factors, or when window width
		* is 800px or less. Approximates work done using media queries in `Panels.css`.
		*
		* @return {Boolean} `true` for narrow devices or viewports; otherwise, `false`.
		* @public
		*/
		isScreenNarrow: function () {
			if(Panels.isNarrowDevice()) {
				return true;
			} else {
				return dom.getWindowWidth() <= 800;
			}
		},

		/**
		* Returns the class name to apply for narrow fitting. See media queries
		* in `Panels.css`.
		*
		* @return {String} The CSS class name to apply.
		*/
		getNarrowClass: function () {
			if(Panels.isNarrowDevice()) {
				return 'enyo-panels-force-narrow';
			} else {
				return 'enyo-panels-fit-narrow';
			}
		},

		/**
		* Lerps between arrangements.
		*
		* @param  {Object[]} a0     - Array of current arrangement objects.
		* @param  {Object[]} a1     - Array of target arrangement object.
		* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.
		* @return {Object[]}        - Array of arrangements that is `fraction` between
		* 	`a0` and `a1`.
		* @private
		*/
		lerp: function (a0, a1, fraction) {
			var r = [];
			for (var i=0, k$=utils.keys(a0), k; (k=k$[i]); i++) {
				r.push(this.lerpObject(a0[k], a1[k], fraction));
			}
			return r;
		},

		/**
		* Lerps between the values of arrangement objects.
		*
		* @param  {Object} a0       - The source arragement.
		* @param  {Object} a1       - The destination arragement.
		* @param  {Number} fraction - The fraction (between 0 and 1) with which to lerp.
		*
		* @return {Object}          - The lerped arrangement.
		* @private
		*/
		lerpObject: function (a0, a1, fraction) {
			var b = utils.clone(a0), n, o;
			// a1 might be undefined when deleting panels
			if (a1) {
				for (var i in a0) {
					n = a0[i];
					o = a1[i];
					if (n != o) {
						b[i] = n - (n - o) * fraction;
					}
				}
			}
			return b;
		},

		/**
		* Tests User Agent strings to identify narrow devices.
		*
		* @return {Boolean} `true` if the current device is a narrow device;
		* otherwise, `false`.
		*/
		isNarrowDevice: function () {
			var ua = navigator.userAgent;
			switch (platform.platformName) {
				case 'ios':
					return (/iP(?:hone|od;(?: U;)? CPU) OS (\d+)/).test(ua);
				case 'android':
					return (/Mobile/).test(ua) && (platform.android > 2);
				case 'androidChrome':
					return (/Mobile/).test(ua);
			}
			return false;
		}
	}
});
},{"../../../enyo/lib/Animator":5,"../../../enyo/lib/dispatcher":57,"../../../enyo/lib/dom":58,"../../../enyo/lib/kind":66,"../../../enyo/lib/platform":71,"../../../enyo/lib/utils":75,"../CardArranger":79}],16:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind'),
	utils = require('../utils'),
	platform = require('../platform'),
	dispatcher = require('../dispatcher'),
	fullscreen = require('../fullscreen'),
	roots = require('../roots');

var
	UiComponent = require('../UiComponent'),
	HTMLStringDelegate = require('../HTMLStringDelegate'),
	Dom = require('../dom'),
	FloatingLayer = require('../floatingLayer');

var nodePurgatory;

/**
* Called by `Control.teardownRender()`. In certain circumstances,
* we need to temporarily keep a DOM node around after tearing down
* because we're still acting on a stream of touch events emanating
* from the node. See `Control.retainNode()` for more information.
*
* @private
*/
function storeRetainedNode (control) {
	var p = getNodePurgatory(),
		n = control._retainedNode;
	if (n) {
		p.appendChild(n);
	}
	control._retainedNode = null;
}

/**
* Called (via a callback) when it's time to release a DOM node
* that we've retained.
*
* @private
*/
function releaseRetainedNode (retainedNode) {
	var p = getNodePurgatory();
	if (retainedNode) {
		p.removeChild(retainedNode);
	}
}

/**
* Lazily add a hidden `<div>` to `document.body` to serve as a
* container for retained DOM nodes.
*
* @private
*/
function getNodePurgatory () {
	var p = nodePurgatory;
	if (!p) {
		p = nodePurgatory = document.createElement("div");
		p.id = "node_purgatory";
		p.style.display = "none";
		document.body.appendChild(p);
	}
	return p;
}

/**
* {@link enyo.Control} is a [component]{@link enyo.UiComponent} that controls
* a [DOM]{@glossary DOM} [node]{@glossary Node} (i.e., an element in the user
* interface). Controls are generally visible and the user often interacts with
* them directly. While things like buttons and input boxes are obviously
* controls, in Enyo, a control may be as simple as a text item or as complex
* as an entire application. Both inherit the same basic core capabilities from
* this kind.
*
* For more information, see the documentation on
* [Controls]{@linkplain $dev-guide/key-concepts/controls.html} in the
* Enyo Developer Guide.
*
* **If you make changes to `enyo.Control`, be sure to add or update the
* appropriate unit tests.**
*
* @class enyo.Control
* @extends enyo.UiComponent
* @ui
* @public
*/
var Control = module.exports = kind(
	/** @lends enyo.Control.prototype */ {

	name: 'enyo.Control',

	/**
	* @private
	*/
	kind: UiComponent,

	/**
	* @private
	*/


	/**
	* @type {String}
	* @default 'enyo.Control'
	* @public
	*/
	defaultKind: null, // set after the fact

	/**
	* The [DOM node]{@glossary DOM} tag name that should be created.
	*
	* @type {String}
	* @default 'div'
	* @public
	*/
	tag: 'div',

	/**
	* A [hash]{@glossary Object} of attributes to be applied to the created
	* [DOM]{@glossary DOM} node.
	*
	* @type {Object}
	* @default null
	* @public
	*/
	attributes: null,

	/**
	* [Boolean]{@glossary Boolean} flag indicating whether this element should
	* "fit", or fill its container's size.
	*
	* @type {Boolean}
	* @default null
	* @public
	*/
	fit: null,

	/**
	* [Boolean]{@glossary Boolean} flag indicating whether HTML is allowed in
	* this control's [content]{@link enyo.Control#content} property. If `false`
	* (the default), HTML will be encoded into [HTML entities]{@glossary entity}
	* (e.g., `&lt;` and `&gt;`) for literal visual representation.
	*
	* @type {Boolean}
	* @default null
	* @public
	*/
	allowHtml: false,

	/**
	* Mimics the HTML `style` attribute.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	style: '',

	/**
	* @private
	*/
	kindStyle: '',

	/**
	* Mimics the HTML `class` attribute.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	classes: '',

	/**
	* @private
	*/
	kindClasses: '',

	/**
	* [Classes]{@link enyo.Control#classes} that are applied to all controls.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	controlClasses: '',

	/**
	* The text-based content of the Control. If the [allowHtml]{@link enyo.Control#allowHtml}
	* flag is set to `true`, you may set this property to an HTML string.
	* @public
	*/
	content: '',

	/**
	* If true or 'inherit' and enyo.gesture.doubleTabEnabled == true, will fire a doubletap
	* event, and will temporarily suppress a single tap while waiting for a double tap.
	*
	* @type {String|Boolean}
	* @default 'inherit'
	* @public
	*/
	doubleTapEnabled: 'inherit',

	/**
	* Time in milliseconds to wait to detect a double tap
	*
	* @type {Number}
	* @default 300
	* @public
	*/
	doubleTapInterval: 300,

	/**
	* @todo Find out how to document "handlers".
	* @public
	*/
	handlers: {
		ontap: 'tap',
		onShowingChanged: 'showingChangedHandler'
	},

	/**
	* @private
	*/
	strictlyInternalEvents: {onenter: 1, onleave: 1},

	/**
	* @private
	*/
	isInternalEvent: function (event) {
		var rdt = dispatcher.findDispatchTarget(event.relatedTarget);
		return rdt && rdt.isDescendantOf(this);
	},

	// .................................
	// DOM NODE MANIPULATION API

	/**
	* Gets the bounds for this control. The `top` and `left` properties returned
	* by this method represent the control's positional distance in pixels from
	* either A) the first parent of this control that is absolutely or relatively
	* positioned, or B) the `document.body`.
	*
	* This is a shortcut convenience method for {@link enyo.dom.getBounds}.
	*
	* @returns {Object} An [object]{@glossary Object} containing `top`, `left`,
	* `width`, and `height` properties.
	* @public
	*/
	getBounds: function () {
		var node = this.hasNode(),
			bounds = node && Dom.getBounds(node);

		return bounds || {left: undefined, top: undefined, width: undefined, height: undefined};
	},

	/**
	* Sets the absolute/relative position and/or size for this control. Values
	* of `null` or `undefined` for the `bounds` properties will be ignored. You
	* may optionally specify a `unit` (i.e., a valid CSS measurement unit) as a
	* [string]{@glossary String} to be applied to each of the position/size
	* assignments.
	*
	* @param {Object} bounds - An [object]{@glossary Object}, optionally
	* containing one or more of the following properties: `width`, `height`,
	* `top`, `right`, `bottom`, and `left`.
	* @param {String} [unit='px']
	* @public
	*/
	setBounds: function (bounds, unit) {
		var newStyle = '',
			extents = ['width', 'height', 'left', 'top', 'right', 'bottom'],
			i = 0,
			val,
			ext;

		// if no unit is supplied, we default to pixels
		unit = unit || 'px';

		for (; (ext = extents[i]); ++i) {
			val = bounds[ext];
			if (val || val === 0) {
				newStyle += (ext + ':' + val + (typeof val == 'string' ? '' : unit) + ';');
			}
		}

		this.set('style', this.style + newStyle);
	},

	/**
	* Gets the bounds for this control. The `top` and `left` properties returned
	* by this method represent the control's positional distance in pixels from
	* `document.body`. To get the bounds relative to this control's parent(s),
	* use [getBounds()]{@link enyo.Control#getBounds}.
	*
	* This is a shortcut convenience method for {@link enyo.dom.getAbsoluteBounds}.
	*
	* @returns {Object} An [object]{@glossary Object} containing `top`, `left`,
	* `width`, and `height` properties.
	* @public
	*/
	getAbsoluteBounds: function () {
		var node = this.hasNode(),
			bounds = node && Dom.getAbsoluteBounds(node);

		return bounds || {
			left: undefined,
			top: undefined,
			width: undefined,
			height: undefined,
			bottom: undefined,
			right: undefined
		};
	},

	/**
	* Shortcut method to set [showing]{@link enyo.Control#showing} to `true`.
	*
	* @public
	*/
	show: function () {
		this.set('showing', true);
	},

	/**
	* Shortcut method to set [showing]{@link enyo.Control#showing} to `false`.
	*
	* @public
	*/
	hide: function () {
		this.set('showing', false);
	},

	/**
	* Sets this control to be [focused]{@glossary focus}.
	*
	* @public
	*/
	focus: function () {
		if (this.hasNode()) this.node.focus();
	},

	/**
	* [Blurs]{@glossary blur} this control. (The opposite of
	* [focus()]{@link enyo.Control#focus}.)
	*
	* @public
	*/
	blur: function () {
		if (this.hasNode()) this.node.blur();
	},

	/**
	* Determines whether this control currently has the [focus]{@glossary focus}.
	*
	* @returns {Boolean} Whether this control has focus. `true` if the control
	* has focus; otherwise, `false`.
	* @public
	*/
	hasFocus: function () {
		if (this.hasNode()) return document.activeElement === this.node;
	},

	/**
	* Determines whether this control's [DOM node]{@glossary Node} has been created.
	*
	* @returns {Boolean} Whether this control's [DOM node]{@glossary Node} has
	* been created. `true` if it has been created; otherwise, `false`.
	* @public
	*/
	hasNode: function () {
		return this.generated && (this.node || this.findNodeById());
	},

	/**
	* Gets the requested property (`name`) from the control's attributes
	* [hash]{@glossary Object}, from its cache of node attributes, or, if it has
	* yet to be cached, from the [node]{@glossary Node} itself.
	*
	* @param {String} name - The attribute name to get.
	* @returns {(String|Null)} The value of the requested attribute, or `null`
	* if there isn't a [DOM node]{@glossary Node} yet.
	* @public
	*/
	getAttribute: function (name) {
		var node;

		// TODO: This is a fixed API assuming that no changes will happen to the DOM that
		// do not use it...original implementation of this method used the node's own
		// getAttribute method every time it could but we really only need to do that if we
		// weren't the ones that set the value to begin with -- in slow DOM situations this
		// could still be faster but it needs to be verified
		if (this.attributes.hasOwnProperty(name)) return this.attributes[name];
		else {
			node = this.hasNode();

			// we store the value so that next time we'll know what it is
			/*jshint -W093 */
			return (this.attributes[name] = (node ? node.getAttribute(name) : null));
			/*jshint +W093 */
		}
	},

	/**
	* Assigns an attribute to a control's [node]{@glossary Node}. Assigning
	* `name` a value of `null`, `false`, or the empty string `("")` will remove
	* the attribute from the node altogether.
	*
	* @param {String} name - Attribute name to assign/remove.
	* @param {(String|Number|null)} value - The value to assign to `name`
	* @returns {this} Callee for chaining.
	* @public
	*/
	setAttribute: function (name, value) {
		var attrs = this.attributes,
			node = this.hasNode(),
			delegate = this.renderDelegate || Control.renderDelegate;

		if (name) {
			attrs[name] = value;

			if (node) {
				if (value == null || value === false || value === '') {
					node.removeAttribute(name);
				} else node.setAttribute(name, value);
			} else delegate.invalidate(this, 'attributes');
		}

		return this;
	},

	/**
	* Reads the `name` property directly from the [node]{@glossary Node}. You
	* may provide a default (`def`) to use if there is no node yet.
	*
	* @param {String} name - The [node]{@glossary Node} property name to get.
	* @param {*} def - The default value to apply if there is no node.
	* @returns {String} The value of the `name` property, or `def` if the node
	* was not available.
	* @public
	*/
	getNodeProperty: function (name, def) {
		return this.hasNode() ? this.node[name] : def;
	},

	/**
	* Sets the value of a property (`name`) directly on the [node]{@glossary Node}.
	*
	* @param {String} name - The [node]{@glossary Node} property name to set.
	* @param {*} value - The value to assign to the property.
	* @returns {this} The callee for chaining.
	* @public
	*/
	setNodeProperty: function (name, value) {
		if (this.hasNode()) this.node[name] = value;
		return this;
	},

	/**
	* Appends additional content to this control.
	*
	* @param {String} content - The new string to add to the end of the `content`
	* property.
	* @returns {this} The callee for chaining.
	* @public
	*/
	addContent: function (content) {
		return this.set('content', this.get('content') + content);
	},

	// .................................

	// .................................
	// STYLE/CLASS API

	/**
	* Determines whether this control has the class `name`.
	*
	* @param {String} name - The name of the class (or classes) to check for.
	* @returns {Boolean} Whether the control has the class `name`.
	* @public
	*/
	hasClass: function (name) {
		return name && (' ' + this.classes + ' ').indexOf(' ' + name + ' ') > -1;
	},

	/**
	* Adds the specified class to this control's list of classes.
	*
	* @param {String} name - The name of the class to add.
	* @returns {this} The callee for chaining.
	* @public
	*/
	addClass: function (name) {
		var classes = this.classes || '';

		// NOTE: Because this method accepts a string and for efficiency does not wish to
		// parse it to determine if it is actually multiple classes we later pull a trick
		// to keep it normalized and synchronized with our attributes hash and the node's
		if (!this.hasClass(name)) {

			// this is hooked
			this.set('classes', classes + (classes ? (' ' + name) : name));
		}

		return this;
	},

	/**
	* Removes the specified class from this control's list of classes.
	*
	* **Note: It is not advisable to pass a string of multiple, space-delimited
	* class names into this method. Instead, call the method once for each class
	* name that you want to remove.**
	*
	* @param {String} name - The name of the class to remove.
	* @returns {this} The callee for chaining.
	* @public
	*/
	removeClass: function (name) {
		var classes = this.classes;

		if (name) {
			this.set('classes', (' ' + classes + ' ').replace(' ' + name + ' ', ' ').trim());
		}

		return this;
	},

	/**
	* Adds or removes the specified class conditionally, based on the state
	* of the `add` argument.
	*
	* @param {String} name - The name of the class to add or remove.
	* @param {Boolean} add - If `true`, `name` will be added as a class; if
	* `false`, it will be removed.
	* @returns {this} The callee for chaining.
	* @public
	*/
	addRemoveClass: function (name, add) {
		return name ? this[add ? 'addClass' : 'removeClass'](name) : this;
	},

	/**
	* @private
	*/
	classesChanged: function () {
		var classes = this.classes,
			node = this.hasNode(),
			attrs = this.attributes,
			delegate = this.renderDelegate || Control.renderDelegate;

		if (node) {
			if (classes || this.kindClasses) {
				node.setAttribute('class', classes || this.kindClasses);
			} else node.removeAttribute('class');

			this.classes = classes = node.getAttribute('class');
		}

		// we need to update our attributes.class value and flag ourselves to be
		// updated
		attrs['class'] = classes;

		// we want to notify the delegate that the attributes have changed in case it wants
		// to handle this is some special way
		delegate.invalidate(this, 'attributes');
	},

	/**
	* Applies a CSS style directly to the control. Use the `prop` argument to
	* specify the CSS property name you'd like to set, and `value` to specify
	* the desired value. Setting `value` to `null` will remove the CSS property
	* `prop` altogether.
	*
	* @param {String} prop - The CSS property to assign.
	* @param {(String|Number|null|undefined)} value - The value to assign to
	* `prop`. Setting a value of `null`, `undefined`, or the empty string `("")`
	* will remove the property `prop` from the control.
	* @returns {this} Callee for chaining.
	* @public
	*/
	applyStyle: function (prop, value) {

		// NOTE: This method deliberately avoids calling set('style', ...) for performance
		// as it will have already been parsed by the browser so we pass it on via the
		// notification system which is the same

		// TODO: Wish we could delay this potentially...
		// if we have a node we render the value immediately and update our style string
		// in the process to keep them synchronized
		var node = this.hasNode(),
			style = this.style,
			delegate = this.renderDelegate || Control.renderDelegate;

		// FIXME: This is put in place for a Firefox bug where setting a style value of a node 
		// via its CSSStyleDeclaration object (by accessing its node.style property) does
		// not work when using a CSS property name that contains one or more dash, and requires 
		// setting the property via the JavaScript-style property name. This fix should be 
		// removed once this issue has been resolved in the Firefox mainline and its variants
		// (it is currently resolved in the 36.0a1 nightly):
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1083457
		if (node && (platform.firefox < 35 || platform.firefoxOS || platform.androidFirefox)) {
			prop = prop.replace(/-([a-z])/gi, function(match, submatch) {
				return submatch.toUpperCase();
			});
		}

		if (value !== null && value !== '' && value !== undefined) {
			// update our current cached value
			if (node) {
				node.style[prop] = value;

				// cssText is an internal property used to help know when to sync and not
				// sync with the node in styleChanged
				this.style = this.cssText = node.style.cssText;

				// we need to invalidate the style for the delegate
				delegate.invalidate(this, 'style');

				// otherwise we have to try and prepare it for the next time it is rendered we
				// will need to update it because it will not be synchronized
			} else this.set('style', style + (' ' + prop + ':' + value + ';'));
		} else {

			// in this case we are trying to clear the style property so if we have the node
			// we let the browser handle whatever the value should be now and otherwise
			// we have to parse it out of the style string and wait to be rendered

			if (node) {
				node.style[prop] = '';
				this.style = this.cssText = node.style.cssText;

				// we need to invalidate the style for the delegate
				delegate.invalidate(this, 'style');
			} else {

				// this is a rare case to nullify the style of a control that is not
				// rendered or does not have a node
				style = style.replace(new RegExp(
					// This looks a lot worse than it is. The complexity stems from needing to
					// match a url container that can have other characters including semi-
					// colon and also that the last property may/may-not end with one
					'\\s*' + prop + '\\s*:\\s*[a-zA-Z0-9\\ ()_\\-\'"%,]*(?:url\\(.*\\)\\s*[a-zA-Z0-9\\ ()_\\-\'"%,]*)?\\s*(?:;|;?$)',
					'gi'
				),'');
				this.set('style', style);
			}
		}

		return this;
	},

	/**
	* Allows the addition of several CSS properties and values at once, via a
	* single string, similar to how the HTML `style` attribute works.
	*
	* @param {String} css - A string containing one or more valid CSS styles.
	* @returns {this} The callee for chaining.
	* @public
	*/
	addStyles: function (css) {
		var key,
			newStyle = '';

		if (typeof css == 'object') {
			for (key in css) newStyle += (key + ':' + css[key] + ';');
		} else newStyle = css || '';

		this.set('style', this.style + newStyle);
	},

	/**
	* @private
	*/
	styleChanged: function () {
		var delegate = this.renderDelegate || Control.renderDelegate;

		// if the cssText internal string doesn't match then we know style was set directly
		if (this.cssText !== this.style) {

			// we need to render the changes and synchronize - this means that the style
			// property was set directly so we will reset it prepending it with the original
			// style (if any) for the kind and keeping whatever the browser is keeping
			if (this.hasNode()) {
				this.node.style.cssText = this.kindStyle + (this.style || '');
				// now we store the parsed version
				this.cssText = this.style = this.node.style.cssText;
			}

			// we need to ensure that the delegate has an opportunity to handle this change
			// separately if it needs to
			delegate.invalidate(this, 'style');
		}
	},

	/**
	* Retrieves a control's CSS property value. This doesn't just pull the
	* assigned value of `prop`; it returns the browser's understanding of `prop`,
	* the "computed" value. If the control isn't been rendered yet, and you need
	* a default value (such as `0`), include it in the arguments as `def`.
	*
	* @param {String} prop - The property name to get.
	* @param {*} [def] - An optional default value, in case the control isn't
	* rendered yet.
	* @returns {(String|Number)} The computed value of `prop`, as the browser
	* sees it.
	* @public
	*/
	getComputedStyleValue: function (prop, def) {
		return this.hasNode() ? Dom.getComputedStyleValue(this.node, prop) : def;
	},

	/**
	* @private
	*/
	findNodeById: function () {
		return this.id && (this.node = Dom.byId(this.id));
	},

	/**
	* @private
	*/
	idChanged: function (was) {
		if (was) Control.unregisterDomEvents(was);
		if (this.id) {
			Control.registerDomEvents(this.id, this);
			this.setAttribute('id', this.id);
		}
	},

	/**
	* @private
	*/
	contentChanged: function () {
		var delegate = this.renderDelegate || Control.renderDelegate;
		delegate.invalidate(this, 'content');
	},

	/**
	* If the control has been generated, re-flows the control.
	*
	* @public
	*/
	beforeChildRender: function () {
		// if we are generated, we should flow before rendering a child;
		// if not, the render context isn't ready anyway
		if (this.generated) this.flow();
	},

	/**
	* @private
	*/
	showingChanged: function (was) {
		// if we are changing from not showing to showing we attempt to find whatever
		// our last known value for display was or use the default
		if (!was && this.showing) {
			this.applyStyle('display', this._display || '');
			this.sendShowingChangedEvent(was);
		}

		// if we are supposed to be hiding the control then we need to cache our current
		// display state
		else if (was && !this.showing) {
			this.sendShowingChangedEvent(was);
			// we can't truly cache this because it _could_ potentially be set to multiple
			// values throughout its lifecycle although that seems highly unlikely...
			this._display = this.hasNode() ? this.node.style.display : '';
			this.applyStyle('display', 'none');
		}

	},

	/**
	* @private
	*/
	sendShowingChangedEvent: function (was) {
		var waterfall = (was === true || was === false),
			parent = this.parent;

		// make sure that we don't trigger the waterfall when this method
		// is arbitrarily called during _create_ and it should only matter
		// that it changed if our parent's are all showing as well
		if (waterfall && (parent ? parent.getAbsoluteShowing(true) : true)) {
			this.waterfall('onShowingChanged', {originator: this, showing: this.showing});
		}
	},

	/**
	* Returns `true` if this control and all parents are showing.
	*
	* @param {Boolean} ignoreBounds - If `true`, it will not force a layout by retrieving
	*	computed bounds and rely on the return from [showing]{@link enyo.Control#showing}
	* exclusively.
	* @returns {Boolean} Whether the control is showing (visible).
	* @public
	*/
	getAbsoluteShowing: function (ignoreBounds) {
		var bounds = !ignoreBounds ? this.getBounds() : null,
			parent = this.parent;

		if (!this.generated || this.destroyed || !this.showing || (bounds &&
			bounds.height === 0 && bounds.width === 0)) {
			return false;
		}

		if (parent && parent.getAbsoluteShowing) {

			// we actually don't care what the parent says if it is the floating layer
			if (!this.parentNode || (this.parentNode !== Control.floatingLayer.hasNode())) {
				return parent.getAbsoluteShowing(ignoreBounds);
			}
		}

		return true;
	},

	/**
	* Handles the `onShowingChanged` event that is waterfalled by controls when
	* their `showing` value is modified. If the control is not showing itself
	* already, it will not continue the waterfall. Overload this method to
	* provide additional handling for this event.
	*
	* @private
	*/
	showingChangedHandler: function (sender, event) {
		return sender === this ? false : !this.showing;
	},

	/**
	* @private
	*/
	fitChanged: function () {
		this.parent.reflow();
	},

	/**
	* Determines whether we are in fullscreen mode or not.
	*
	* @returns {Boolean} Whether we are currently in fullscreen mode.
	* @public
	*/
	isFullscreen: function () {
		return (this.hasNode() && this.node === fullscreen.getFullscreenElement());
	},

	/**
	* Requests that this control be displayed fullscreen (like a video
	* container). If the request is granted, the control fills the screen and
	* `true` is returned; if the request is denied, the control is not resized
	* and `false` is returned.
	*
	* @returns {Boolean} `true` on success; otherwise, `false`.
	* @public
	*/
	requestFullscreen: function () {
		if (!this.hasNode()) return false;

		if (fullscreen.requestFullscreen(this)) {
			return true;
		}

		return false;
	},

	/**
	* Ends fullscreen mode for this control.
	*
	* @returns {Boolean} If the control was in fullscreen mode before this
	* method was called, it is taken out of that mode and `true` is returned;
	* otherwise, `false` is returned.
	* @public
	*/
	cancelFullscreen: function() {
		if (this.isFullscreen()) {
			fullscreen.cancelFullscreen();
			return true;
		}

		return false;
	},

	// .................................

	// .................................
	// RENDER-SCHEME API

	/**
	* Indicates whether the control is allowed to be generated, i.e., rendered
	* into the [DOM]{@glossary DOM} tree.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	canGenerate: true,

	/**
	* Indicates whether the control is visible.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	showing: true,

	/**
	* The [node]{@glossary Node} that this control will be rendered into.
	*
	* @type {enyo.Control}
	* @default null
	* @public
	*/
	renderDelegate: null,

	/**
	* Indicates whether the control has been generated yet.
	*
	* @type {Boolean}
	* @default false
	* @private
	*/
	generated: false,

	/**
	* Forces the control to be rendered. You should use this sparingly, as it
	* can be costly, but it may be necessary in cases where a control or its
	* contents have been updated surreptitiously.
	*
	* @returns {this} The callee for chaining.
	* @public
	*/
	render: function () {

		// prioritize the delegate set for this control otherwise use the default
		var delegate = this.renderDelegate || Control.renderDelegate;

		// the render delegate acts on the control
		delegate.render(this);

		return this;
	},

	/**
	* Takes this control and drops it into a (new/different)
	* [DOM node]{@glossary Node}. This will replace any existing nodes in the
	* target `parentNode`.
	*
	* @param {Node} parentNode - The new parent of this control.
	* @param {Boolean} preventRooting - If `true`, this control will not be treated as a root 
	*	view and will not be added to the set of roots.
	* @returns {this} The callee for chaining.
	* @public
	*/
	renderInto: function (parentNode, preventRooting) {
		var delegate = this.renderDelegate || Control.renderDelegate,
			noFit = this.fit === false;

		// attempt to retrieve the parentNode
		parentNode = Dom.byId(parentNode);

		// teardown in case of previous render
		delegate.teardownRender(this);

		if (parentNode == document.body && !noFit) this.setupBodyFitting();
		else if (this.fit) this.addClass('enyo-fit enyo-clip');

		// for IE10 support, we want full support over touch actions in enyo-rendered areas
		this.addClass('enyo-no-touch-action');

		// add css to enable hw-accelerated scrolling on non-android platforms
		// ENYO-900, ENYO-901
		this.setupOverflowScrolling();

		// if there are unflushed body classes we flush them now...
		Dom.flushBodyClasses();

		// we inject this as a root view because, well, apparently that is just an assumption
		// we've been making...
		if (!preventRooting) {
			roots.addToRoots(this);
		}

		// now let the delegate render it the way it needs to
		delegate.renderInto(this, parentNode);

		Dom.updateScaleFactor();

		return this;
	},

	/**
	* A function that fires after the control has rendered. This performs a
	* reflow.
	*
	* @public
	*/
	rendered: function () {
		var child,
			i = 0;

		// CAVEAT: Currently we use one entry point ('reflow') for
		// post-render layout work *and* post-resize layout work.
		this.reflow();

		for (; (child = this.children[i]); ++i) {
			if (child.generated) child.rendered();
		}
	},

	/**
	* You should generally not need to call this method in your app code.
	* It is used internally by some Enyo UI libraries to handle a rare
	* issue that sometimes arises when using a virtualized list or repeater
	* on a touch device.
	*
	* This issue occurs when a gesture (e.g. a drag) originates with a DOM
	* node that ends up being destroyed in mid-gesture as the list updates.
	* When the node is destroyed, the stream of DOM events representing the
	* gesture stops, causing the associated action to stop or otherwise
	* fail.
	*
	* You can prevent this problem from occurring by calling `retainNode`
	* on the {@link enyo.Control} from which the gesture originates. Doing
	* so will cause Enyo to keep the DOM node around (hidden from view)
	* until you explicitly release it. You should call `retainNode` in the
	* event handler for the event that starts the gesture.
	*
	* `retainNode` returns a function that you must call when the gesture
	* ends to release the node. Make sure you call this function to avoid
	* "leaking" the DOM node (failing to remove it from the DOM).
	*
	* @param {Node} node - Optional. Defaults to the node associated with
	* the Control (`Control.node`). You can generally omit this parameter
	* when working with {@link enyo.DataList} or {@link enyo.DataGridList},
	* but should generally pass in the event's target node (`event.target`)
	* when working with {@link enyo.List}. (Because {@link enyo.List} is
	* based on the Flyweight pattern, the event's target node is often not
	* the node currently associated with the Control at the time the event
	* occurs.)
	* @returns {Function} Keep a reference to this function and call it
	* to release the node when the gesture has ended.
	* @public
	*/
	retainNode: function(node) {
		var control = this,
			retainedNode = this._retainedNode = (node || this.hasNode());
		return function() {
			if (control && (control._retainedNode == retainedNode)) {
				control._retainedNode = null;
			} else {
				releaseRetainedNode(retainedNode);
			}
		};
	},

	/**
	* @private
	*/
	teardownRender: function () {
		var delegate = this.renderDelegate || Control.renderDelegate;

		if (this._retainedNode) {
			storeRetainedNode(this);
		}

		delegate.teardownRender(this);
	},

	/**
	* @private
	*/
	teardownChildren: function () {
		var delegate = this.renderDelegate || Control.renderDelegate;

		delegate.teardownChildren(this);
	},

	/**
	* @private
	*/
	addNodeToParent: function () {
		var pn;

		if (this.node) {
			pn = this.getParentNode();
			if (pn) {
				if (this.addBefore !== undefined) {
					this.insertNodeInParent(pn, this.addBefore && this.addBefore.hasNode());
				} else this.appendNodeToParent(pn);
			}
		}
	},

	/**
	* @private
	*/
	appendNodeToParent: function(parentNode) {
		parentNode.appendChild(this.node);
	},

	/**
	* @private
	*/
	insertNodeInParent: function(parentNode, beforeNode) {
		parentNode.insertBefore(this.node, beforeNode || parentNode.firstChild);
	},

	/**
	* @private
	*/
	removeNodeFromDom: function() {
		if (this.hasNode() && this.node.parentNode) {
			this.node.parentNode.removeChild(this.node);
		}
	},

	/**
	* @private
	*/
	getParentNode: function () {
		return this.parentNode || (this.parent && (
			this.parent.hasNode() || this.parent.getParentNode())
		);
	},

	// .................................

	/**
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function (props) {
			var attrs = props && props.attributes;

			// ensure that we both keep an instance copy of defined attributes but also
			// update the hash with any additional instance definitions at runtime
			this.attributes = this.attributes ? utils.clone(this.attributes) : {};
			if (attrs) {
				utils.mixin(this.attributes, attrs);
				delete  props.attributes;
			}

			return sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function (props) {
			var classes;

			// initialize the styles for this instance
			this.style = this.kindStyle + this.style;

			// ensure that the default value assigned to showing is actually a boolean
			this.showing = !! this.showing;

			// super initialization
			sup.apply(this, arguments);

			// ensure that if we aren't showing -> true then the correct style
			// is applied - note that there might be issues with this because we are
			// trying not to have to parse out any other explicit display value during
			// initialization and we can't check because we haven't rendered yet
			if (!this.showing) this.style += ' display: none;';

			// try and make it so we only need to call the method once during
			// initialization and only then when we have something to add
			classes = this.kindClasses;
			if (classes && this.classes) classes += (' ' + this.classes);
			else if (this.classes) classes = this.classes;

			// if there are known classes needed to be applied from the kind
			// definition and the instance definition (such as a component block)
			this.classes = this.attributes['class'] = classes ? classes.trim() : classes;

			// setup the id for this control if we have one
			this.idChanged();
			this.contentChanged();
		};
	}),

	/**
	* Destroys the control and removes it from the [DOM]{@glossary DOM}. Also
	* removes the control's ability to receive bubbled events.
	*
	* @public
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			// if the control has been rendered we ensure it is removed from the DOM
			this.removeNodeFromDom();

			// ensure no other bubbled events can be dispatched to this control
			dispatcher.$[this.id] = null;
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	dispatchEvent: kind.inherit(function (sup) {
		return function (name, event, sender) {
			// prevent dispatch and bubble of events that are strictly internal (e.g.
			// enter/leave)
			if (this.strictlyInternalEvents[name] && this.isInternalEvent(event)) {
				return true;
			}
			return sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	addChild: kind.inherit(function (sup) {
		return function (control) {
			control.addClass(this.controlClasses);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	removeChild: kind.inherit(function (sup) {
		return function (control) {
			sup.apply(this, arguments);
			control.removeClass(this.controlClasses);
		};
	}),

	/**
	* @private
	*/
	set: kind.inherit(function (sup) {
		return function (path, value, opts) {
			// this should be updated if a better api for hooking becomes available but for
			// now we just do this directly to ensure that the showing value is actually
			// a boolean
			if (path == 'showing') {
				return sup.call(this, path, !! value, opts);
			} else return sup.apply(this, arguments);
		};
	}),

	// .................................
	// BACKWARDS COMPATIBLE API, LEGACY METHODS AND PUBLIC PROPERTY
	// METHODS OR PROPERTIES THAT PROBABLY SHOULD NOT BE HERE BUT ARE ANYWAY

	/**
	* Apparently used by Ares 2 still but we have the property embedded in the kind...
	*
	* @deprecated
	* @private
	*/
	isContainer: false,

	/**
	* @private
	*/
	rtl: false,

	/**
	* @private
	*/
	setupBodyFitting: function () {
		Dom.applyBodyFit();
		this.addClass('enyo-fit enyo-clip');
	},

	/*
	* If the platform is Android or Android-Chrome, don't include the css rule
	* `-webkit-overflow-scrolling: touch`, as it is not supported in Android and leads to
	* overflow issues (ENYO-900 and ENYO-901). Similarly, BB10 has issues repainting
	* out-of-viewport content when `-webkit-overflow-scrolling` is used (ENYO-1396).
	*
	* @private
	*/
	setupOverflowScrolling: function () {
		if(platform.android || platform.androidChrome || platform.blackberry) {
			return;
		}
		Dom.addBodyClass('webkitOverflowScrolling');
	},

	/**
	* Sets the control's directionality based on its content, or an optional `stringInstead`.
	*
	* @param {String} [stringInstead] An alternate string for consideration may be sent instead,
	*	in-case the string to test the directionality of the control is stored in `this.value`,
	*	or some other property, for example.
	* @private
	*/
	detectTextDirectionality: function (stringInstead) {
		// If an argument was supplied at all, use it, even if it's undefined.
		// Values that are null or undefined, or are numbers, arrays, and some objects are safe
		// to be tested.
		var str = (arguments.length) ? stringInstead : this.content;
		if (str || str === 0) {
			this.rtl = utils.isRtl(str);
			this.applyStyle('direction', this.rtl ? 'rtl' : 'ltr');
		} else {
			this.applyStyle('direction', null);
		}

	},

	// .................................

	// .................................
	// DEPRECATED

	/**
	* @deprecated
	* @public
	*/
	getTag: function () {
		return this.tag;
	},

	/**
	* @deprecated
	* @public
	*/
	setTag: function (tag) {
		var was = this.tag;

		if (tag && typeof tag == 'string') {
			this.tag = tag;
			if (was !== tag) this.notify('tag', was, tag);
		}
		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getAttributes: function () {
		return this.attributes;
	},

	/**
	* @deprecated
	* @public
	*/
	setAttributes: function (attrs) {
		var was = this.attributes;

		if (typeof attrs == 'object') {
			this.attributes = attrs;
			if (attrs !== was) this.notify('attributes', was, attrs);
		}

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getClasses: function () {
		return this.classes;
	},

	/**
	* @deprecated
	* @public
	*/
	setClasses: function (classes) {
		var was = this.classes;

		this.classes = classes;
		if (was != classes) this.notify('classes', was, classes);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getStyle: function () {
		return this.style;
	},

	/**
	* @deprecated
	* @public
	*/
	setStyle: function (style) {
		var was = this.style;

		this.style = style;
		if (was != style) this.notify('style', was, style);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getContent: function () {
		return this.content;
	},

	/**
	* @deprecated
	* @public
	*/
	setContent: function (content) {
		var was = this.content;
		this.content = content;

		if (was != content) this.notify('content', was, content);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getShowing: function () {
		return this.showing;
	},

	/**
	* @deprecated
	* @public
	*/
	setShowing: function (showing) {
		var was = this.showing;

		// force the showing property to always be a boolean value
		this.showing = !! showing;

		if (was != showing) this.notify('showing', was, showing);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getAllowHtml: function () {
		return this.allowHtml;
	},

	/**
	* @deprecated
	* @public
	*/
	setAllowHtml: function (allow) {
		var was = this.allowHtml;
		this.allowHtml = !! allow;

		if (was !== allow) this.notify('allowHtml', was, allow);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getCanGenerate: function () {
		return this.canGenerate;
	},

	/**
	* @deprecated
	* @public
	*/
	setCanGenerate: function (can) {
		var was = this.canGenerate;
		this.canGenerate = !! can;

		if (was !== can) this.notify('canGenerate', was, can);

		return this;
	},

	/**
	* @deprecated
	* @public
	*/
	getFit: function () {
		return this.fit;
	},

	/**
	* @deprecated
	* @public
	*/
	setFit: function (fit) {
		var was = this.fit;
		this.fit = !! fit;

		if (was !== fit) this.notify('fit', was, fit);

		return this;
	},

	/**
	* @ares
	* @deprecated
	* @public
	*/
	getIsContainer: function () {
		return this.isContainer;
	},

	/**
	* @ares
	* @deprecated
	* @public
	*/
	setIsContainer: function (isContainer) {
		var was = this.isContainer;
		this.isContainer = !! isContainer;

		if (was !== isContainer) this.notify('isContainer', was, isContainer);

		return this;
	}

	// .................................

});

/**
* @static
* @public
*/
kind.setDefaultCtor(Control);

/**
* @static
* @public
*/
Control.renderDelegate = HTMLStringDelegate;

/**
* @private
*/
Control.registerDomEvents = function (id, control) {
	dispatcher.$[id] = control;
};

/**
* @private
*/
Control.unregisterDomEvents = function (id) {
	dispatcher.$[id] = null;
};

/**
* @private
*/
Control.normalizeCssStyleString = function (style) {
	return style ? (
		(";" + style)
		// add a semi-colon if it's not the last character (also trim possible unnecessary whitespace)
		.replace(/([^;])\s*$/, "$1;")
		// ensure we have one space after each colon or semi-colon
		.replace(/\s*;\s*([\w-]+)\s*:\s*/g, "; $1: ")
		// remove first semi-colon and space
		.substr(2).trim()
	) : "";
};

/**
* @private
*/
Control.concat = function (ctor, props, instance) {
	var proto = ctor.prototype || ctor,
		attrs,
		str;

	if (props.classes) {
		if (instance) {
			str = (proto.classes ? (proto.classes + ' ') : '') + props.classes;
			proto.classes = str;
		} else {
			str = (proto.kindClasses || '') + (proto.classes ? (' ' + proto.classes) : '');
			proto.kindClasses = str;
			proto.classes = props.classes;
		}
		delete props.classes;
	}

	if (props.style) {
		if (instance) {
			str = (proto.style ? (proto.style + ';') : '') + (props.style + ';');
			proto.style = Control.normalizeCssStyleString(str);
		} else {
			str = proto.kindStyle ? proto.kindStyle : '';
			str += proto.style ? (';' + proto.style) : '';
			str += props.style;

			// moved it all to kindStyle so that it will be available whenever instanced
			proto.kindStyle = Control.normalizeCssStyleString(str);
		}
		delete props.style;
	}

	if (props.attributes) {
		attrs = proto.attributes;
		proto.attributes = attrs ? utils.mixin({}, [attrs, props.attributes]) : props.attributes;
		delete props.attributes;
	}
};

Control.prototype.defaultKind = Control;

// Control has to be *completely* set up before creating the floating layer otherwise things will
// error out during construction.

/**
* @static
* @public
*/
Control.FloatingLayer = FloatingLayer(Control);

/**
* @static
* @public
*/
Control.floatingLayer = new Control.FloatingLayer({id: 'floatingLayer'});
},{"../../../enyo":1,"../HTMLStringDelegate":22,"../UiComponent":55,"../dispatcher":57,"../dom":58,"../floatingLayer":60,"../fullscreen":61,"../kind":66,"../platform":71,"../roots":74,"../utils":75}],59:[function(require,module,exports){
require('../../enyo');

var
	dispatcher = require('./dispatcher'),
	gesture = require('./gesture'),
	platform = require('./platform'),
	utils = require('./utils');

/**
* @private
*/
dispatcher.features.push(
	function(e) {
		// NOTE: beware of properties in gesture inadvertently mapped to event types
		if (gesture.drag[e.type]) {
			return gesture.drag[e.type](e);
		}
	}
);

/**
* Enyo supports a cross-platform set of drag [events]{@glossary event}. These
* events allow users to write a single set of event handlers for applications
* that run on both mobile and desktop platforms.
*
* The following events are provided:
*
* * 'dragstart'
* * 'dragfinish'
* * 'drag'
* * 'drop'
* * 'dragover'
* * 'dragout'
* * 'hold'
* * 'release'
* * 'holdpulse'
* * 'flick'
*
* For more information on these events, see the documentation on
* [Event Handling]{@linkplain $dev-guide/key-concepts/event-handling.html} in
* the Enyo Developer Guide.
*
* @namespace gesture.drag
* @public
*/
module.exports = gesture.drag =
	/** @lends gesture.drag */ {

	/**
	* @private
	*/
	holdPulseDefaultConfig: {
		frequency: 200,
		events: [{name: 'hold', time: 200}],
		resume: false,
		moveTolerance: 16,
		endHold: 'onMove'
	},

	/**
	* Call this method to specify the framework's 'holdPulse' behavior, which
	* determines the nature of the events generated when a user presses and holds
	* on a user interface element.
	*
	* By default, an `onhold` event fires after 200 ms. After that, an `onholdpulse`
	* event fires every 200 ms until the user stops holding, at which point a
	* `onrelease` event fires.
	*
	* To change the default behavior, call this method and pass it a holdPulse
	* configuration object. The holdPulse configuration object has a number of
	* properties.
	*
	* You can specify a set of custom hold events by setting the `events` property
	* to an array containing one or more objects. Each object specifies a custom
	* hold event, in the form of a `name` / `time` pair. Notes:
	*
	*  * Your custom event names should not include the 'on' prefix; that will be
	*    added automatically by the framework.
	*
	*  * Times should be specified in milliseconds.
	*
	*  * Your `events` array overrides the framework defaults entirely, so if you
	*    want the standard `hold` event to fire at 200 ms (in addition to whatever
	*    custom events you define), you'll need to redefine it yourself as part of
	*    your `events` array.
	*
	* Regardless of how many custom hold events you define, `onholdpulse` events
	* will start firing after the first custom hold event fires, and continue until
	* the user stops holding. Likewise, only one `onrelease` event will fire,
	* regardless of how many custom hold events you define.
	*
	* The`frequency` parameter determines not only how often `holdpulse` events are
	* sent, but the frequency with which the hold duration is measured. This means
	* that the value you set for `frequency` should always be a common factor of the
	* times you set for your custom hold events, to ensure accurate event timing.
	*
	* You can use the `endHold` property to specify the circumstances under which a
	* hold is considered to end. Set `endHold` to `onMove` (the default) if you want
	* the hold to end as soon as the user's finger or pointer moves. Set `endHold`
	* to `onLeave` if you want the hold to end only when the finger or pointer
	* leaves the element altogether. When specifying `onMove`, you can also provide
	* a `moveTolerance` value (default: `16`) that determines how tolerant you want
	* to be of small movements when deciding whether a hold has ended. The higher
	* the value, the further a user's finger or pointer may move without causing
	* the hold to end.
	*
	* Finally, the `resume` parameter (default: `false`) specifies whether a hold
	* that has ended due to finger / pointer movement should be resumed if the
	* user's finger or pointer moves back inside the tolerance threshold (in the
	* case of `endHold: onMove`) or back over the element (in the case of
	* `endHold: onLeave`).
	*
	* Here is an example:
	*
	* ```
	* gesture.drag.configureHoldPulse({
	*     frequency: 100,
	*     events: [
	*         {name: 'hold', time: 200},
	*         {name: 'longpress', time: 500}
	*     ],
	*     endHold: 'onLeave',
	*     resume: true
	* });
	* ```
	* For comparison, here are the out-of-the-box defaults:
	*
	* ```
	* gesture.drag.configureHoldPulse({
	*     frequency: 200,
	*     events: [
	*         {name: 'hold', time: 200}
	*     ],
	*     endHold: 'onMove',
	*     moveTolerance: 16,
	*     resume: false
	* });
	* ```
	*
	* The settings you provide via this method will be applied globally, affecting
	* every Control. Note that you can also override the defaults on a case-by-case
	* basis by handling the `down` event for any Control and calling the
	* `configureHoldPulse` method exposed by the event itself. That method works
	* exactly like this one, except that the settings you provide will apply only to
	* holds on that particular Control.
	*
	* @public
	*/
	configureHoldPulse: function(config) {
		// TODO: Might be nice to do some validation, error handling
		this.holdPulseDefaultConfig = config;
	},

	/**
	* @private
	*/
	holdPulseConfig: {},

	/**
	* @private
	*/
	trackCount: 5,

	/**
	* @private
	*/
	minFlick: 0.1,

	/**
	* @private
	*/
	minTrack: 8,

	/**
	* @private
	*/
	down: function(e) {
		// tracking if the mouse is down
		//enyo.log('tracking ON');
		// Note: 'tracking' flag indicates interest in mousemove, it's turned off
		// on mouseup
		// make sure to stop dragging in case the up event was not received.
		this.stopDragging(e);
		this.target = e.target;
		this.startTracking(e);
	},

	/**
	* @private
	*/
	move: function(e) {
		if (this.tracking) {
			this.track(e);
			// If the mouse is not down and we're tracking a drag, abort.
			// this error condition can occur on IE/Webkit after interaction with a scrollbar.
			if (!e.which) {
				this.stopDragging(e);
				this.endHold();
				this.tracking = false;
				//enyo.log('gesture.drag: mouse must be down to drag.');
				return;
			}
			if (this.dragEvent) {
				this.sendDrag(e);
			} else if (this.holdPulseConfig.endHold === 'onMove') {
				if (this.dy*this.dy + this.dx*this.dx >= this.holdPulseConfig.moveTolerance) { // outside of target
					if (this.holdJob) { // only stop/cancel hold job if it currently exists
						if (this.holdPulseConfig.resume) { // pause hold to potentially resume later
							this.suspendHold();
						} else { // completely cancel hold
							this.endHold();
							this.sendDragStart(e);
						}
					}
				} else if (this.holdPulseConfig.resume && !this.holdJob) { // when moving inside target, only resume hold job if it was previously paused
					this.resumeHold();
				}
			}
		}
	},

	/**
	* @private
	*/
	up: function(e) {
		this.endTracking(e);
		this.stopDragging(e);
		this.endHold();
		this.target = null;
	},

	/**
	* @private
	*/
	enter: function(e) {
		// resume hold when re-entering original target when using 'onLeave' endHold value
		if (this.holdPulseConfig.resume && this.holdPulseConfig.endHold === 'onLeave' && this.target && e.target === this.target) {
			this.resumeHold();
		}
	},

	/**
	* @private
	*/
	leave: function(e) {
		if (this.dragEvent) {
			this.sendDragOut(e);
		} else if (this.holdPulseConfig.endHold === 'onLeave') {
			if (this.holdPulseConfig.resume) { // pause hold to potentially resume later
				this.suspendHold();
			} else { // completely cancel hold
				this.endHold();
				this.sendDragStart(e);
			}
		}
	},

	/**
	* @private
	*/
	stopDragging: function(e) {
		if (this.dragEvent) {
			this.sendDrop(e);
			var handled = this.sendDragFinish(e);
			this.dragEvent = null;
			return handled;
		}
	},

	/**
	* @private
	*/
	makeDragEvent: function(inType, inTarget, inEvent, inInfo) {
		var adx = Math.abs(this.dx), ady = Math.abs(this.dy);
		var h = adx > ady;
		// suggest locking if off-axis < 22.5 degrees
		var l = (h ? ady/adx : adx/ady) < 0.414;
		var e = {};
		// var e = {
		e.type = inType;
		e.dx = this.dx;
		e.dy = this.dy;
		e.ddx = this.dx - this.lastDx;
		e.ddy = this.dy - this.lastDy;
		e.xDirection = this.xDirection;
		e.yDirection = this.yDirection;
		e.pageX = inEvent.pageX;
		e.pageY = inEvent.pageY;
		e.clientX = inEvent.clientX;
		e.clientY = inEvent.clientY;
		e.horizontal = h;
		e.vertical = !h;
		e.lockable = l;
		e.target = inTarget;
		e.dragInfo = inInfo;
		e.ctrlKey = inEvent.ctrlKey;
		e.altKey = inEvent.altKey;
		e.metaKey = inEvent.metaKey;
		e.shiftKey = inEvent.shiftKey;
		e.srcEvent = inEvent.srcEvent;
		// };
		//Fix for IE8, which doesn't include pageX and pageY properties
		if(platform.ie==8 && e.target) {
			e.pageX = e.clientX + e.target.scrollLeft;
			e.pageY = e.clientY + e.target.scrollTop;
		}
		e.preventDefault = gesture.preventDefault;
		e.disablePrevention = gesture.disablePrevention;
		return e;
	},

	/**
	* @private
	*/
	sendDragStart: function(e) {
		//enyo.log('dragstart');
		this.dragEvent = this.makeDragEvent('dragstart', this.target, e);
		dispatcher.dispatch(this.dragEvent);
	},

	/**
	* @private
	*/
	sendDrag: function(e) {
		//enyo.log('sendDrag to ' + this.dragEvent.target.id + ', over to ' + e.target.id);
		// send dragOver event to the standard event target
		var synth = this.makeDragEvent('dragover', e.target, e, this.dragEvent.dragInfo);
		dispatcher.dispatch(synth);
		// send drag event to the drag source
		synth.type = 'drag';
		synth.target = this.dragEvent.target;
		dispatcher.dispatch(synth);
	},

	/**
	* @private
	*/
	sendDragFinish: function(e) {
		//enyo.log('dragfinish');
		var synth = this.makeDragEvent('dragfinish', this.dragEvent.target, e, this.dragEvent.dragInfo);
		synth.preventTap = function() {
			if (e.preventTap) {
				e.preventTap();
			}
		};
		dispatcher.dispatch(synth);
	},

	/**
	* @private
	*/
	sendDragOut: function(e) {
		var synth = this.makeDragEvent('dragout', e.target, e, this.dragEvent.dragInfo);
		dispatcher.dispatch(synth);
	},

	/**
	* @private
	*/
	sendDrop: function(e) {
		var synth = this.makeDragEvent('drop', e.target, e, this.dragEvent.dragInfo);
		synth.preventTap = function() {
			if (e.preventTap) {
				e.preventTap();
			}
		};
		dispatcher.dispatch(synth);
	},

	/**
	* @private
	*/
	startTracking: function(e) {
		this.tracking = true;
		// note: use clientX/Y to be compatible with ie8
		this.px0 = e.clientX;
		this.py0 = e.clientY;
		// this.flickInfo = {startEvent: e, moves: []};
		this.flickInfo = {};
		this.flickInfo.startEvent = e;
		// FIXME: so we're trying to reuse objects where possible, should
		// do the same in scenarios like this for arrays
		this.flickInfo.moves = [];
		this.track(e);
	},

	/**
	* @private
	*/
	track: function(e) {
		this.lastDx = this.dx;
		this.lastDy = this.dy;
		this.dx = e.clientX - this.px0;
		this.dy = e.clientY - this.py0;
		this.xDirection = this.calcDirection(this.dx - this.lastDx, 0);
		this.yDirection = this.calcDirection(this.dy - this.lastDy, 0);
		//
		var ti = this.flickInfo;
		ti.moves.push({
			x: e.clientX,
			y: e.clientY,
			t: utils.perfNow()
		});
		// track specified # of points
		if (ti.moves.length > this.trackCount) {
			ti.moves.shift();
		}
	},

	/**
	* @private
	*/
	endTracking: function() {
		this.tracking = false;
		var ti = this.flickInfo;
		var moves = ti && ti.moves;
		if (moves && moves.length > 1) {
			// note: important to use up time to reduce flick
			// velocity based on time between move and up.
			var l = moves[moves.length-1];
			var n = utils.perfNow();
			// take the greatest of flick between each tracked move and last move
			for (var i=moves.length-2, dt=0, x1=0, y1=0, x=0, y=0, sx=0, sy=0, m; (m=moves[i]); i--) {
				// this flick (this move - last move) / (this time - last time)
				dt = n - m.t;
				x1 = (l.x - m.x) / dt;
				y1 = (l.y - m.y) / dt;
				// establish flick direction
				sx = sx || (x1 < 0 ? -1 : (x1 > 0 ? 1 : 0));
				sy = sy || (y1 < 0 ? -1 : (y1 > 0 ? 1 : 0));
				// if either axis is a greater flick than previously recorded use this one
				if ((x1 * sx > x * sx) || (y1 * sy > y * sy)) {
					x = x1;
					y = y1;
				}
			}
			var v = Math.sqrt(x*x + y*y);
			if (v > this.minFlick) {
				// generate the flick using the start event so it has those coordinates
				this.sendFlick(ti.startEvent, x, y, v);
			}
		}
		this.flickInfo = null;
	},

	/**
	* @private
	*/
	calcDirection: function(inNum, inDefault) {
		return inNum > 0 ? 1 : (inNum < 0 ? -1 : inDefault);
	},

	/**
	* Translate the old format for holdPulseConfig to the new one, to
	* preserve backward compatibility.
	*
	* @private
	*/
	normalizeHoldPulseConfig: function (oldOpts) {
		var nOpts = utils.clone(oldOpts);
		nOpts.frequency = nOpts.delay;
		nOpts.events = [{name: 'hold', time: nOpts.delay}];
		return nOpts;
	},

	/**
	* Method to override holdPulseConfig for a given gesture. This method isn't
	* accessed directly from gesture.drag, but exposed by the `down` event.
	* See `prepareHold()`.
	*
	* @private
	*/
	_configureHoldPulse: function(opts) {
		var nOpts = (opts.delay === undefined) ?
			opts :
			this.normalizeHoldPulseConfig(opts);
		utils.mixin(this.holdPulseConfig, nOpts);
	},

	/**
	* @private
	*/
	prepareHold: function(e) {
		// quick copy as the prototype of the new overridable config
		this.holdPulseConfig = utils.clone(this.holdPulseDefaultConfig, true);

		// expose method for configuring holdpulse options
		e.configureHoldPulse = this._configureHoldPulse.bind(this);
	},

	/**
	* @private
	*/
	beginHold: function(e) {
		var ce;
		// cancel any existing hold since it's possible in corner cases to get a down without an up
		this.endHold();
		this.holdStart = utils.perfNow();
		this._holdJobFunction = utils.bind(this, 'handleHoldPulse');
		// clone the event to ensure it stays alive on IE upon returning to event loop
		ce = this._holdJobEvent = utils.clone(e);
		ce.srcEvent = utils.clone(e.srcEvent);
		this._pulsing = false;
		this._unsent = utils.clone(this.holdPulseConfig.events);
		this._unsent.sort(this.sortEvents);
		this._next = this._unsent.shift();
		if (this._next) {
			this.holdJob = setInterval(this._holdJobFunction, this.holdPulseConfig.frequency);
		}
	},

	/**
	* @private
	*/
	resumeHold: function() {
		this.handleHoldPulse();
		this.holdJob = setInterval(this._holdJobFunction, this.holdPulseConfig.frequency);
	},

	/**
	* @private
	*/
	sortEvents: function(a, b) {
			if (a.time < b.time) return -1;
			if (a.time > b.time) return 1;
			return 0;
	},

	/**
	* @private
	*/
	endHold: function() {
		var e = this._holdJobEvent;
		this.suspendHold();
		if (e && this._pulsing) {
			this.sendRelease(e);
		}
		this._pulsing = false;
		this._unsent = null;
		this._holdJobFunction = null;
		this._holdJobEvent = null;
		this._next = null;
	},

	/**
	* @private
	*/
	suspendHold: function() {
		clearInterval(this.holdJob);
		this.holdJob = null;
	},

	/**
	* @private
	*/
	handleHoldPulse: function() {
		var holdTime = utils.perfNow() - this.holdStart,
			hje = this._holdJobEvent,
			e;
		this.maybeSendHold(hje, holdTime);
		if (this._pulsing) {
			e = gesture.makeEvent('holdpulse', hje);
			e.holdTime = holdTime;
			dispatcher.dispatch(e);
		}
	},

	/**
	* @private
	*/
	maybeSendHold: function(inEvent, inHoldTime) {
		var n = this._next;
		while (n && n.time <= inHoldTime) {
			var e = gesture.makeEvent(n.name, inEvent);
			this._pulsing = true;
			dispatcher.dispatch(e);
			n = this._next = this._unsent.shift();
		}
	},

	/**
	* @private
	*/
	sendRelease: function(inEvent) {
		var e = gesture.makeEvent('release', inEvent);
		dispatcher.dispatch(e);
	},

	/**
	* @private
	*/
	sendFlick: function(inEvent, inX, inY, inV) {
		var e = gesture.makeEvent('flick', inEvent);
		e.xVelocity = inX;
		e.yVelocity = inY;
		e.velocity = inV;
		dispatcher.dispatch(e);
	}
};
},{"../../enyo":1,"./dispatcher":57,"./gesture":62,"./platform":71,"./utils":75}],4:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');
var
	Control = require('./Control');

/**
* {@link enyo.Anchor} implements an HTML [anchor]{@glossary Anchor} (&lt;a&gt;) tag.
* Published properties allow you to [bind]{@link enyo.BindingSupport} the anchor's
* [href]{@link enyo.Anchor#href} and [title]{@link enyo.Anchor#title}
* [attributes]{@glossary Attribute} to appropriate fields on data
* [objects]{@glossary Object}.
* 
* @class enyo.Anchor
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Anchor.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Anchor',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	tag: 'a',

	/** 
	* @private
	*/
	published: 
		/** @lends enyo.Anchor.prototype */ {
		
		/** 
		* Maps to the `href` [attribute]{@glossary Attribute} of the &lt;a&gt; tag.
		* 
		* @type {String}
		* @default ''
		* @public
		*/
		href: '',

		/**
		* Maps to the `title` [attribute]{@glossary Attribute} of the &lt;a&gt; tag.
		* 
		* @type {String}
		* @default  ''
		* @public
		*/
		title: ''
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.hrefChanged();
			this.titleChanged();
		};
	}),

	/**
	* @private
	*/
	hrefChanged: function () {
		this.setAttribute('href', this.href);
	},

	/**
	* @private
	*/
	titleChanged: function () {
		this.setAttribute('title', this.title);
	}
});
},{"../../enyo":1,"./Control":16,"./kind":66}],18:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');
var
	Control = require('./Control'),
	RepeaterChildSupport = require('./RepeaterChildSupport');

/**
* {@link enyo.DataRepeater} iterates over the items in an {@link enyo.Collection} to
* repeatedly render and synchronize records (instances of {@link enyo.Model}) to its
* own children. For any record in the collection, a new child will be rendered in
* the repeater. If the record is destroyed, the child will be destroyed. These
* [controls]{@link enyo.Control} will automatically update when properties on the
* underlying records are modified if they have been bound using
* [bindings]{@link enyo.Binding}.
*
* @class enyo.DataRepeater
* @extends enyo.Control
* @ui
* @public
*/
var DataRepeater = module.exports = kind(
	/** @lends enyo.DataRepeater.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.DataRepeater',

	/**
	* @private
	*/
	kind: Control,

	/**
	* Set this to `true` to enable selection support. Note that selection stores a
	* reference to the [model]{@link enyo.Model} that is selected, via the
	* [selected]{@link enyo.DataRepeater#selected} method.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	selection: true,

	/**
	* Specifies the type of selection (if enabled), that we want to enable. The possible values
	* are 'single', 'multi', and 'group'. The default is 'single' selection mode, which enables
	* selection and deselection of a single item at a time. The 'multi' selection mode allows
	* multiple children to be selected simultaneously, while the 'group' selection mode allows
	* group-selection behavior such that only one child may be selected at a time and, once a
	* child is selected, it cannot be deselected via user input. The child may still be 
	* deselected via the selection API methods.
	* 
	* @type {String}
	* @default 'single'
	* @public
	*/
	selectionType: 'single',

	/**
	* Set this to `true` to allow multiple children to be selected simultaneously.
	*
	* @deprecated since version 2.6
	* @type {Boolean}
	* @default false
	* @public
	*/
	multipleSelection: false,

	/**
	* Set this to `true` to allow group-selection behavior such that only one child
	* may be selected at a time and, once a child is selected, it cannot be
	* deselected via user input. The child may still be deselected via the selection
	* API methods. Note that setting this property to `true` will set the
	* [multipleSelection]{@link enyo.DataRepeater#multipleSelection} property to
	* `false`.
	*
	* @deprecated since version 2.6
	* @type {Boolean}
	* @default false
	* @public
	*/
	groupSelection: false,

	/**
	* This class will be applied to the [repeater]{@link enyo.DataRepeater} when
	* [selection]{@link enyo.DataRepeater#selection} is enabled. It will also be
	* applied if [multipleSelection]{@link enyo.DataRepeater#multipleSelection}
	* is `true`.
	*
	* @type {String}
	* @default 'selection-enabled'
	* @public
	*/
	selectionClass: 'selection-enabled',

	/**
	* This class will be applied to the [repeater]{@link enyo.DataRepeater} when
	* [selectionType]{@link enyo.DataRepeater#selectionType} is `multi`.
	* When that is the case, the [selectionClass]{@link enyo.DataRepeater#selectionClass}
	* will also be applied.
	*
	* @type {String}
	* @default 'multiple-selection-enabled'
	* @public
	*/
	multipleSelectionClass: 'multiple-selection-enabled',

	/**
	* In cases where selection should be detected from the state of the
	* [model]{@link enyo.Model}, this property should be set to the property on
	* the model that the [repeater]{@link enyo.DataRepeater} should observe for
	* changes. If the model changes, the repeater will reflect the change without
	* having to interact directly with the model. Note that this property must be
	* part of the model's schema, or else its changes will not be detected
	* properly.
	*
	* @type {String}
	* @default ''
	* @public
	*/
	selectionProperty: '',

	/**
	* Set this to a space-delimited string of [events]{@glossary event} or an
	* [array]{@glossary Array} that can trigger the selection of a particular
	* child. To prevent selection entirely, set
	* [selection]{@link enyo.DataRepeater#selection} to `false`.
	*
	* @type {String}
	* @default 'ontap'
	* @public
	*/
	selectionEvents: 'ontap',

	/**
	* Use this [hash]{@glossary Object} to define default [binding]{@link enyo.Binding}
	* properties for **all** children (even children of children) of this
	* [repeater]{@link enyo.DataRepeater}. This can eliminate the need to write the
	* same paths over and over. You may also use any binding macros. Any property
	* defined here will be superseded by the same property if defined for an individual
	* binding.
	*
	* @type {Object}
	* @default null
	* @public
	*/
	childBindingDefaults: null,

	/**
	* @private
	*/
	initComponents: function () {
		this.initContainer();
		var components = this.kindComponents || this.components || [],
			owner = this.getInstanceOwner(),
			props = this.defaultProps? utils.clone(this.defaultProps, true): (this.defaultProps = {});
		// ensure that children know who their binding owner is
		props.bindingTransformOwner = this;
		props.bindingDefaults = this.childBindingDefaults;
		if (components) {
			// if there are multiple components in the components block they will become nested
			// children of the default kind set for the repeater
			if (components.length > 1) {
				props.components = components;
			}
			// if there is only one child, the properties will be the default kind of the repeater
			else {
				utils.mixin(props, components[0]);
			}
			props.repeater = this;
			props.owner = owner;
			props.mixins = props.mixins? props.mixins.concat(this.childMixins): this.childMixins;
		}

		this.defaultProps = props;
	},

	/**
	* @method
	* @private
	*/
	constructor: kind.inherit(function (sup) {
		return function () {
			this._selection = [];
			// we need to initialize our selectionEvents array
			var se = this.selectionEvents;
			this.selectionEvents = (typeof se == 'string'? se.split(' '): se);
			// we need to pre-bind these methods so they can easily be added
			// and removed as listeners later
			var h = this._handlers = utils.clone(this._handlers);
			for (var e in h) {
				h[e] = this.bindSafely(h[e]);
			}
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.collectionChanged();
			// Converting deprecated selection properties to our current selection API
			this.selectionType = this.multipleSelection ? (this.groupSelection ? 'group' : 'multi') : this.selectionType;
			this.selectionTypeChanged();
		};
	}),

	/**
	* @private
	*/
	groupSelectionChanged: function () {
		this.set('selectionType', this.groupSelection ? 'group' : 'single');
	},

	/**
	* @private
	*/
	multipleSelectionChanged: function () {
		this.set('selectionType', this.multipleSelection ? 'multi' : 'single');
	},

	/**
	* @private
	*/
	selectionTypeChanged: function (was) {
		// Synchronizing our deprecated properties
		this.groupSelection = this.selectionType == 'group';
		this.multipleSelection = this.selectionType == 'multi';

		if (was == 'multi') {
			if (this._selection.length > 1) {
				this.deselectAll();
			}
		}
		this.selectionChanged();
	},

	/**
	* @private
	*/
	selectionChanged: function () {
		this.addRemoveClass(this.selectionClass, this.selection);
		this.addRemoveClass(this.multipleSelectionClass, this.selectionType == 'multi' && this.selection);
	},

	/**
	* Destroys any existing children in the [repeater]{@link enyo.DataRepeater} and creates all
	* new children based on the current [data]{@link enyo.Repeater#data}.
	*
	* @public
	*/
	reset: function () {
		// use the facaded dataset because this could be any
		// collection of records
		var dd = this.get('data');
		// destroy the client controls we might already have
		this.destroyClientControls();
		// and now we create new ones for each new record we have
		for (var i=0, r; (r=dd.at(i)); ++i) {
			this.add(r, i);
		}
		this.hasReset = true;
	},
	/**
	* Refreshes each [control]{@link enyo.Control} in the dataset.
	*
	* @param {Boolean} immediate - If `true`, refresh will occur immediately; otherwise,
	* it will be queued up as a job.
	* @public
	*/
	refresh: function (immediate) {
		if (!this.hasReset) { return this.reset(); }
		var refresh = this.bindSafely(function () {
			var dd = this.get('data'),
				cc = this.getClientControls();
			for (var i=0, c, d; (d=dd.at(i)); ++i) {
				c = cc[i];
				if (c) {
					c.set('model', d);
				} else {
					this.add(d, i);
				}
			}
			this.prune();
		});

		// refresh is used as the event handler for
		// collection resets so checking for truthy isn't
		// enough. it must be true.
		if(immediate === true) {
			refresh();
		} else {
			this.startJob('refreshing', refresh, 16);
		}
	},

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			if (this.collection && this.collection.length) {
				this.reset();
			}
			this.hasRendered = true;
		};
	}),

	/**
	* Adds a [record]{@link enyo.Model} at a particular index.
	*
	* @param {enyo.Model} rec - The [record]{@link enyo.Model} to add.
	* @param {Number} idx - The index at which the record should be added.
	* @public
	*/
	add: function (rec, idx) {
		var c = this.createComponent({model: rec, index: idx});
		if (this.generated && !this.batching) {
			c.render();
		}
	},

	/**
	* Removes the [record]{@link enyo.Model} at a particular index.
	*
	* @param {Number} idx - The index of the [record]{@link enyo.Model} to be removed.
	* @public
	*/
	remove: function (idx) {
		var controls = this.getClientControls()
			, control;

		control = controls[idx];

		if (control) control.destroy();
	},

	/**
	* Removes any [controls]{@link enyo.Control} that are outside the boundaries of the
	* [data]{@link enyo.DataRepeater#data} [collection]{@link enyo.Collection} for the
	* [repeater]{@link enyo.DataRepeater}.
	*
	* @public
	*/
	prune: function () {
		var g = this.getClientControls()
			, len = (this.collection? this.collection.length: 0)
			, x;
		if (g.length > len) {
			x = g.slice(len);
			for (var i=0, c; (c=x[i]); ++i) {
				c.destroy();
			}
		}
	},

	/**
	* @private
	*/
	initContainer: function () {
		var ops = this.get('containerOptions'),
			nom = ops.name || (ops.name = this.containerName);
		this.createChrome([ops]);
		this.discoverControlParent();
		if (nom != this.containerName) {
			this.$[this.containerName] = this.$[nom];
		}
	},

	/**
	* @private
	*/
	handlers: {
		onSelected: 'childSelected',
		onDeselected: 'childDeselected'
	},

	/**
	* @private
	*/
	_handlers: {
		add: 'modelsAdded',
		remove: 'modelsRemoved',
		reset: 'refresh',
		sort: 'refresh',
		filter: 'refresh'
	},

	/**
	* @private
	*/
	collectionChanged: function (p) {
		var c = this.collection;
		if (typeof c == 'string') {
			c = this.collection = enyo.getPath(c);
		}
		if (c) {
			this.initCollection(c, p);
		}
	},

	/**
	* @private
	*/
	initCollection: function (c, p) {
		var e;
		if (c && c.addListener) {
			for (e in this._handlers) {
				c.addListener(e, this._handlers[e]);
			}
		}
		if (p && p.removeListener) {
			for (e in this._handlers) {
				p.removeListener(e, this._handlers[e]);
			}
		}
	},

	/**
	* @private
	*/
	modelsAdded: function (sender, e, props) {
		if (sender === this.collection) this.refresh();
	},

	/**
	* @private
	*/
	modelsRemoved: function (sender, e, props) {
		if (sender === this.collection) {
			this.deselectRemovedModels(props.models);
			this.refresh();
		}
	},

	/**
	* Deselect removed models from _selected array.
	* After calling it, we can ensure that the removed models aren't currently selected.
	* @param {array} models - The array of models that are removed from collection.
	* @private
	*/
	deselectRemovedModels: function(models) {
		var selected = this._selection,
			orig,
			model,
			idx,
			len = selected && selected.length,
			i = models.length - 1;

		// We have selected models
		if (len) {
			// unfortunately we need to make a copy to preserve what the original was
			// so we can pass it with the notification if any of these are deselected
			orig = selected.slice();

			// we have _selected array to track currently selected models
			// if some removed models are in _selected, we should remove them from _selected
			// clearly we won't need to continue checking if selected does not have any models
			for (; (model = models[i]) && selected.length; --i) {
				idx = selected.indexOf(model);
				if (idx > -1) selected.splice(idx, 1);
			}

			// Some selected models are discovered, so we need to notify
			if (len != selected.length) {
				if (this.selection) {
					if (this.selectionType == 'multi') this.notify('selected', orig, selected);
					else this.notify('selected', orig[0], selected[0] || null);
				}
			}
		}
	},

	/**
	* @private
	*/
	batchingChanged: function (prev, val) {
		if (this.generated && false === val) {
			this.$[this.containerName].render();
			this.refresh(true);
		}
	},

	/**
	* Calls [childForIndex()]{@link enyo.DataRepeater#getChildForIndex}. Leaving for posterity.
	*
	* @param {Number} idx - The index of the child to retrieve.
	* @returns {enyo.Control|undefined} The [control]{@link enyo.Control} at the specified
	* index, or `undefined` if it could not be found or the index is out of bounds.
	* @public
	*/
	getChildForIndex: function (idx) {
		return this.childForIndex(idx);
	},

	/**
	* Attempts to return the [control]{@link enyo.Control} representation at a particular index.
	*
	* @param {Number} idx - The index of the child to retrieve.
	* @returns {enyo.Control|undefined} The [control]{@link enyo.Control} at the specified
	* index, or `undefined` if it could not be found or the index is out of bounds.
	* @public
	*/
	childForIndex: function (idx) {
		return this.$.container.children[idx];
	},

	/**
	* Retrieves the data associated with the [repeater]{@link enyo.DataRepeater}.
	*
	* @returns {enyo.Collection} The {@link enyo.Collection} that comprises the data.
	* @public
	*/
	data: function () {
		return this.collection;
	},

	/**
	* Consolidates selection logic and allows for deselection of a [model]{@link enyo.Model}
	* that has already been removed from the [collection]{@link enyo.Collection}.
	*
	* @private
	*/
	_select: function (idx, model, select) {
		if (!this.selection) {
			return;
		}

		var c = this.getChildForIndex(idx),
			s = this._selection,
			i = utils.indexOf(model, s);

		if (select) {
			if(i == -1) {
				if(this.selectionType != 'multi') {
					while (s.length) {
						i = this.collection.indexOf(s.pop());
						this.deselect(i);
					}
				}

				s.push(model);
			}
		} else {
			if(i >= 0) {
				s.splice(i, 1);
			}
		}

		if (c) {
			c.set('selected', select);
		}
		if (this.selectionProperty && model) {
			(s=this.selectionProperty) && model.set(s, select);
		}
		this.notifyObservers('selected');
	},

	/**
	* Selects the item at the given index.
	*
	* @param {Number} idx - The index of the item to select.
	* @public
	*/
	select: function (idx) {
		this._select(idx, this.collection.at(idx), true);
	},

	/**
	* Deselects the item at the given index.
	*
	* @param {Number} idx - The index of the item to deselect.
	* @public
	*/
	deselect: function (idx) {
		this._select(idx, this.collection.at(idx), false);
	},

	/**
	* Determines whether a [model]{@link enyo.Model} is currently selected.
	*
	* @param {enyo.Model} model - The [model]{@link enyo.Model} whose selection status
	* is to be determined.
	* @returns {Boolean} `true` if the given model is selected; otherwise, `false`.
	* @public
	*/
	isSelected: function (model) {
		return !!~utils.indexOf(model, this._selection);
	},

	/**
	* Selects all items (if [selectionType]{@link enyo.DataRepeater#selectionType} is `multi`).
	*
	* @public
	*/
	selectAll: function () {
		if (this.selectionType == 'multi') {
			this.stopNotifications();
			var s = this._selection
				, len = this.collection? this.collection.length: 0;
			s.length = 0;
			for (var i=0; i<len; ++i) {
				this.select(i);
			}
			this.startNotifications();
		}
	},

	/**
	* Deselects all items.
	*
	* @public
	*/
	deselectAll: function () {
		if (this.selection) {
			this.stopNotifications();
			var s = this._selection, m, i;
			while (s.length) {
				m = s.pop();
				i = this.collection.indexOf(m);
				this.deselect(i);
			}
			this.startNotifications();
		}
	},

	/**
	* A computed property that returns the currently selected [model]{@link enyo.Model}
	* (if [selectionType]{@link enyo.DataRepeater#selectionType} is not `multi'`),
	* or an immutable [array]{@glossary Array} of all currently selected models (if
	* `selectionType` is `multi'`).
	*
	* @public
	*/
	selected: function() {
		// to ensure that bindings will clear properly according to their api
		return (this.selectionType == 'multi' ? this._selection : this._selection[0]) || null;
	},

	/**
	* @private
	*/
	dataChanged: function () {
		if (this.collection && this.hasRendered) {
			this.reset();
		}
	},

	/**
	* @private
	*/
	computed: [
		{method: 'selected'},
		{method: 'data', path: ['controller', 'collection']}
	],

	/**
	* @private
	*/


	/**
	* @private
	*/
	childMixins: [RepeaterChildSupport],

	/**
	* @private
	*/
	controlParentName: 'container',

	/**
	* @private
	*/
	containerName: 'container',

	/**
	* @private
	*/
	containerOptions: {name: 'container', classes: 'enyo-fill enyo-data-repeater-container'},

	/**
	* @private
	*/
	batching: false,

	/**
	* @private
	*/
	_selection: null
});

/**
* @static
* @private
*/
DataRepeater.concat = function (ctor, props) {
	var p = ctor.prototype || ctor;
	if (props.childMixins) {
		p.childMixins = (p.childMixins? utils.merge(p.childMixins, props.childMixins): props.childMixins.slice());
		delete props.childMixins;
	}
};
},{"../../enyo":1,"./Control":16,"./RepeaterChildSupport":39,"./kind":66,"./utils":75}],21:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');
var
	Control = require('./Control');

/**
* Fires when the [active state]{@link enyo.GroupItem#active} has changed.
*
* @event enyo.GroupItem#onActivate
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.GroupItem} is the base [kind]{@glossary kind} for the
* [Grouping]{@link enyo.Group} API. It manages the
* [active state]{@link enyo.GroupItem#active} of the [component]{@link enyo.Component}
* (or the [inheriting]{@glossary subkind} component). A subkind may call `setActive()` 
* to set the [active]{@link enyo.GroupItem#active} property to the desired state; this
* will additionally [bubble]{@link enyo.Component#bubble} an 
* [onActivate]{@link enyo.GroupItem#onActivate} {@glossary event}, which may
* be handled as needed by the containing components. This is useful for creating
* groups of items whose state should be managed collectively.
*
* For an example of how this works, see the {@link enyo.Group} kind, which enables the
* creation of radio groups from arbitrary components that	support the Grouping API.
*
* @class enyo.GroupItem
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Groupitem.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.GroupItem',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Groupitem.prototype */ {

		/**
		* Will be `true` if the item is currently selected.
		* 
		* @type {Boolean}
		* @default false
		* @public
		*/
		active: false
	},
	
	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.activeChanged();
		};
	}),

	/**
	* @fires enyo.GroupItem#onActivate
	* @private
	*/
	activeChanged: function () {
		this.bubble('onActivate');
	}
});
},{"../../enyo":1,"./Control":16,"./kind":66}],23:[function(require,module,exports){
require('../../../enyo');

var
	kind = require('../kind'),
	ri = require('../resolution'),
	dispatcher = require('../dispatcher'),
	path = require('../pathResolver');
var
	Control = require('../Control');

/**
* Fires when the [image]{@link enyo.Image} has loaded.
*
* @event enyo.Image#onload
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires when there has been an error while loading the [image]{@link enyo.Image}.
*
* @event enyo.Image#onerror
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Image} implements an HTML [&lt;img&gt;]{@glossary img} element and, optionally,
* [bubbles]{@link enyo.Component#bubble} the [onload]{@link enyo.Image#onload} and
* [onerror]{@link enyo.Image#onerror} [events]{@glossary event}. Image dragging is suppressed by
* default, so as not to interfere with touch interfaces.
*
* {@link enyo.Image} also has support for multi-resolution images. If you are developing assets
* for specific screen sizes, HD (720p), FHD (1080p), UHD (4k), for example, you may provide
* specific image assets in a hash/object format to the `src` property, instead of the usual
* string. The image sources will be used automatically when the screen resolution is less than
* or equal to those screen types. For more informaton on our resolution support, and how to
* enable this feature, see our [resolution independence docs]{@link enyo.ri}.
*
* ```
* // Take advantage of the multi-rez mode
* {kind: 'enyo.Image', src: {
* 	'hd': 'http://lorempixel.com/64/64/city/1/',
* 	'fhd': 'http://lorempixel.com/128/128/city/1/',
* 	'uhd': 'http://lorempixel.com/256/256/city/1/'
* }, alt: 'Multi-rez'},
* // Standard string `src`
* {kind: 'enyo.Image', src: http://lorempixel.com/128/128/city/1/', alt: 'Large'},
* ```
*
* @class enyo.Image
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Image.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Image',

	/**
	* @private
	*/
	kind: Control,

	/**
	* When `true`, no [onload]{@link enyo.Image#onload} or
	* [onerror]{@link enyo.Image#onerror} {@glossary event} handlers will be
	* created.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	noEvents: false,

	/**
	* @private
	*/
	published:
		/** @lends enyo.Image.prototype */ {

		/**
		* Maps to the `src` attribute of an [&lt;img&gt; tag]{@glossary img}. This also supports
		* a multi-resolution hash object. See
		* [the above description of enyo.Image]{@link enyo.Image} for more details and examples
		* or our [resolution independence docs]{@link enyo.ri}.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		src: '',

		/**
		* Maps to the `alt` attribute of an [&lt;img&gt; tag]{@glossary img}.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		alt: '',

		/**
		* By default, the [image]{@link enyo.Image} is rendered using an `<img>` tag.
		* When this property is set to `'cover'` or `'constrain'`, the image will be
		* rendered using a `<div>`, utilizing `background-image` and `background-size`.
		*
		* Set this property to `'constrain'` to letterbox the image in the available
		* space, or `'cover'` to cover the available space with the image (cropping the
		* larger dimension).  Note that when `sizing` is set, the control must be
		* explicitly sized.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		sizing: '',

		/**
		* When [sizing]{@link enyo.Image#sizing} is used, this property sets the positioning of
		* the [image]{@link enyo.Image} within the bounds, corresponding to the
		* [`background-position`]{@glossary backgroundPosition} CSS property.
		*
		* @type {String}
		* @default 'center'
		* @public
		*/
		position: 'center'
	},

	/**
	* @private
	*/
	tag: 'img',

	/**
	* @private
	*/
	classes: 'enyo-image',

	/**
	* @type {Object}
	* @property {Boolean} draggable - This attribute will take one of the following
	*	[String]{@glossary String} values: 'true', 'false' (the default), or 'auto'.
	* Setting Boolean `false` will remove the attribute.
	* @public
	*/
	attributes: {
		draggable: 'false'
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			if (this.noEvents) {
				delete this.attributes.onload;
				delete this.attributes.onerror;
			}
			sup.apply(this, arguments);
			this.altChanged();
			this.sizingChanged();
			this.srcChanged();
			this.positionChanged();
		};
	}),

	/**
	* @private
	*/
	srcChanged: function () {
		var src = ri.selectSrc(this.src);
		if (this.sizing) {
			this.applyStyle('background-image', src ? 'url(' + path.rewrite(src) + ')' : 'none');
		} else {
			if (!src) {
				// allow us to clear the src property
				this.setAttribute('src', '');
			} else {
				this.setAttribute('src', path.rewrite(src));
			}
		}
	},

	/**
	* @private
	*/
	altChanged: function () {
		this.setAttribute('alt', this.alt);
	},

	/**
	* @private
	*/
	sizingChanged: function (was) {
		this.tag = this.sizing ? 'div' : 'img';
		this.addRemoveClass('sized', !!this.sizing);
		if (was) {
			this.removeClass(was);
		}
		if (this.sizing) {
			this.addClass(this.sizing);
		}
		if (this.generated) {
			this.srcChanged();
			this.render();
		}
	},

	/**
	* @private
	*/
	positionChanged: function () {
		if (this.sizing) {
			this.applyStyle('background-position', this.position);
		}
	},

	/**
	* @fires enyo.Image#onload
	* @fires enyo.Image#onerror
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			dispatcher.makeBubble(this, 'load', 'error');
		};
	}),

	/**
	* @private
	*/
	statics: {
		/**
			A globally accessible data URL that describes a simple
			placeholder image that may be used in samples and applications
			until final graphics are provided. As an SVG image, it will
			expand to fill the desired width and height set in the style.
		*/
		placeholder:
			'data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC' +
			'9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48cmVjdCB3aWR0aD0iMTAw' +
			'JSIgaGVpZ2h0PSIxMDAlIiBzdHlsZT0ic3Ryb2tlOiAjNDQ0OyBzdHJva2Utd2lkdGg6IDE7IGZpbGw6ICNhYW' +
			'E7IiAvPjxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjEwMCUiIHkyPSIxMDAlIiBzdHlsZT0ic3Ryb2tlOiAjNDQ0' +
			'OyBzdHJva2Utd2lkdGg6IDE7IiAvPjxsaW5lIHgxPSIxMDAlIiB5MT0iMCIgeDI9IjAiIHkyPSIxMDAlIiBzdH' +
			'lsZT0ic3Ryb2tlOiAjNDQ0OyBzdHJva2Utd2lkdGg6IDE7IiAvPjwvc3ZnPg=='
	}
});
},{"../../../enyo":1,"../Control":16,"../dispatcher":57,"../kind":66,"../pathResolver":70,"../resolution":73}],24:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	dispatcher = require('./dispatcher'),
	platform = require('./platform');
var
	Control = require('./Control');

/**
* Fires immediately when the text changes.
*
* @event enyo.Input#oninput
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires when the text has changed and the [input]{@link enyo.Input} subsequently loses
* focus.
*
* @event enyo.Input#onchange
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires when the [input]{@link enyo.Input} is disabled or enabled.
*
* @event enyo.Input#onDisabledChange
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Input} implements an HTML [&lt;input&gt;]{@glossary input} element
* with cross-platform support for change [events]{@glossary event}.
*
* You may listen for [oninput]{@link enyo.Input#oninput} and
* [onchange]{@link enyo.Input#onchange} [DOM events]{@glossary DOMEvent} from
* this [control]{@link enyo.Control} to know when the text inside has been modified.
*
* For more information, see the documentation on
* [Text Fields]{@linkplain $dev-guide/building-apps/controls/text-fields.html}
* in the Enyo Developer Guide.
*
* @class enyo.Input
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Input.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Input',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	published:
		/** @lends enyo.Input.prototype */ {

		/**
		* Value of the [input]{@link enyo.Input}. Use this property only to initialize the
		* value. Call `getValue()` and `setValue()` to manipulate the value at runtime.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		value: '',

		/**
		* Text to display when the [input]{@link enyo.Input} is empty
		*
		* @type {String}
		* @default ''
		* @public
		*/
		placeholder: '',

		/**
		* Type of [input]{@link enyo.Input}; if not specified, it's treated as `'text'`.
		* This may be anything specified for the `type` attribute in the HTML
		* specification, including `'url'`, `'email'`, `'search'`, or `'number'`.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		type: '',

		/**
		* When `true`, prevents input into the [control]{@link enyo.Control}. This maps
		* to the `disabled` DOM attribute.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		disabled: false,

		/**
		* When `true`, the contents of the [input]{@link enyo.Input} will be selected
		* when the input gains focus.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		selectOnFocus: false
	},

	/**
	* @private
	*/
	events: {
		onDisabledChange: ''
	},

	/**
	* Set to `true` to focus this [control]{@link enyo.Control} when it is rendered.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	defaultFocus: false,

	/**
	* @private
	*/
	tag: 'input',

	/**
	* @private
	*/
	classes: 'enyo-input',

	/**
	* @private
	*/
	handlers: {
		onfocus: 'focused',
		oninput: 'input',
		onclear: 'clear',
		ondragstart: 'dragstart'
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			if (platform.ie) {
				this.handlers.onkeyup = 'iekeyup';
			}
			if (platform.windowsPhone) {
				this.handlers.onkeydown = 'iekeydown';
			}
			sup.apply(this, arguments);
			this.placeholderChanged();
			// prevent overriding a custom attribute with null
			if (this.type) {
				this.typeChanged();
			}
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);

			dispatcher.makeBubble(this, 'focus', 'blur');

			//Force onchange event to be bubbled inside Enyo for IE8
			if(platform.ie == 8){
				this.setAttribute('onchange', enyo.bubbler);
			}

			this.disabledChanged();
			if (this.defaultFocus) {
				this.focus();
			}
		};
	}),

	/**
	* @private
	*/
	typeChanged: function () {
		this.setAttribute('type', this.type);
	},

	/**
	* @private
	*/
	placeholderChanged: function () {
		this.setAttribute('placeholder', this.placeholder);
		this.valueChanged();
	},

	/**
	* @fires enyo.Input#onDisabledChange
	* @private
	*/
	disabledChanged: function () {
		this.setAttribute('disabled', this.disabled);
		this.bubble('onDisabledChange');
	},

	/**
	* @private
	*/
	valueChanged: function () {
		var node = this.hasNode(),
			attrs = this.attributes;
		if (node) {
			if (node.value !== this.value) {
				node.value = this.value;
			}
			// we manually update the cached value so that the next time the
			// attribute is requested or the control is re-rendered it will
			// have the correct value - this is because calling setAttribute()
			// in some cases does not receive an appropriate response from the
			// browser
			attrs.value = this.value;
		} else {
			this.setAttribute('value', this.value);
		}
		this.detectTextDirectionality((this.value || this.value === 0) ? this.value : this.get('placeholder'));
	},

	/**
	* @private
	*/
	iekeyup: function (sender, e) {
		var ie = platform.ie, kc = e.keyCode;
		// input event missing on ie 8, fails to fire on backspace and delete keys in ie 9
		if (ie <= 8 || (ie == 9 && (kc == 8 || kc == 46))) {
			this.bubble('oninput', e);
		}
	},

	/**
	* @private
	*/
	iekeydown: function (sender, e) {
		var wp = platform.windowsPhone, kc = e.keyCode, dt = e.dispatchTarget;
		// onchange event fails to fire on enter key for Windows Phone 8, so we force blur
		if (wp <= 8 && kc == 13 && this.tag == 'input' && dt.hasNode()) {
			dt.node.blur();
		}
	},

	/**
	* @private
	*/
	clear: function () {
		this.setValue('');
	},

	// note: we disallow dragging of an input to allow text selection on all platforms
	/**
	* @private
	*/
	dragstart: function () {
		return this.hasFocus();
	},

	/**
	* @private
	*/
	focused: function () {
		if (this.selectOnFocus) {
			enyo.asyncMethod(this, 'selectContents');
		}
	},

	/**
	* @private
	*/
	selectContents: function () {
		var n = this.hasNode();

		if (n && n.setSelectionRange) {
			n.setSelectionRange(0, n.value.length);
		} else if (n && n.createTextRange) {
			var r = n.createTextRange();
			r.expand('textedit');
			r.select();
		}
	},

	/**
	* @private
	*/
	input: function () {
		var val = this.getNodeProperty('value');
		this.setValue(val);
	}
});
},{"../../enyo":1,"./Control":16,"./dispatcher":57,"./kind":66,"./platform":71}],35:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind');
var
	Control = require('./Control');

/**
* {@link enyo.Option} implements the [options]{@glossary option} in an
* {@link enyo.Select} [control]{@link enyo.Control}.
*
* @class enyo.Option
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Option.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Option',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	published: {
		/**
		* Value of the [option]{@link enyo.Option}.
		* 
		* @type {String}
		* @default ''
		* @memberof enyo.Option.prototype
		* @public
		*/
		value: '',

		/**
		* Set to `true` if this [option]{@link enyo.Option} is selected (default is `false`).
		* 
		* @type {Boolean}
		* @default false
		* @memberof enyo.Option.prototype
		* @public
		*/
		selected: false
	},
	
	/**
	* @private
	*/
	tag: 'option',

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.valueChanged();
			this.selectedChanged();
		};
	}),

	/**
	* @private
	*/
	valueChanged: function () {
		this.setAttribute('value', this.value);
	},

	/**
	* @private
	*/
	selectedChanged: function () {
		this.setAttribute('selected', this.selected);
	}
});
},{"../../enyo":1,"./Control":16,"./kind":66}],38:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils');
var
	Control = require('./Control');

/**
* The extended {@glossary event} [object]{@glossary Object} that is provided
* when the [onSetupItem]{@link enyo.Repeater#onSetupItem} event is fired.
*
* @typedef {Object} enyo.Repeater~SetupItemEvent
* @property {Number} index - The item's index.
* @property {Object} item - The item control, for decoration.
*/

/**
* Fires when each item is created.
*
* @event enyo.Repeater#onSetupItem
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {enyo.Repeater~SetupItemEvent} event - An [object]{@glossary Object} containing
*	event information.
* @public
*/
	
/**
* Sometimes client [controls]{@link enyo.Control} are intermediated with null-controls.
* These overrides reroute [events]{@glossary event} from such controls to the nominal
* [delegate]{@glossary delegate}, as would happen in the absence of intermediation.
* 
* @class enyo.OwnerProxy
* @extends enyo.Control
* @private
*/
var OwnerProxy = kind(
	/** @lends enyo.OwnerProxy.prototype */ {

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	tag: null,

	/**
	* @method
	* @private
	*/
	decorateEvent: kind.inherit(function (sup) {
		return function(inEventName, inEvent, inSender) {
			if (inEvent) {
				// preserve an existing index property.
				if (utils.exists(inEvent.index)) {
					// if there are nested indices, store all of them in an array
					// but leave the innermost one in the index property
					inEvent.indices = inEvent.indices || [inEvent.index];
					inEvent.indices.push(this.index);
				} else {
					// for a single level, just decorate the index property
					inEvent.index = this.index;
				}
				// update delegate during bubbling to account for proxy
				// by moving the delegate up to the repeater level
				if (inEvent.delegate && inEvent.delegate.owner === this) {
					inEvent.delegate = this.owner;
				}
			}
			sup.apply(this, arguments);
		};
	})
});

/**
* {@link enyo.Repeater} is a simple [control]{@link enyo.Control} for making lists of items.
*
* The [components]{@link enyo.Component} of a repeater are copied for each item created,
* and are wrapped in a control that keeps the state of the item index.
* 
* ```javascript
* {kind: 'Repeater', count: 2, onSetupItem: 'setImageSource', components: [
*	{kind: 'Image'}
* ]}
* 
* setImageSource: function(inSender, inEvent) {
*	var index = inEvent.index;
*	var item = inEvent.item;
*	item.$.image.setSrc(this.imageSources[index]);
*	return true;
* }
* ```
* 
* Be sure to return `true` from your `onSetupItem` handler to avoid having other 
* {@glossary event} handlers further up the tree try to modify your item control.
* 
* For more information, see the documentation on
* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the
* Enyo Developer Guide.
*
* @class enyo.Repeater
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Repeater.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Repeater',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Repeater.prototype */ {
		
		/**
		* The number of items to be repeated.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		count: 0
	},

	/**
	* @private
	*/
	events: {
		onSetupItem: ''
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.countChanged();
		};
	}),
	
	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function() {
			this.itemComponents = this.components || this.kindComponents;
			this.components = this.kindComponents = null;
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	countChanged: function () {
		this.build();
	},

	/**
	* @private
	*/
	itemAtIndex: function (idx) {
		return this.controlAtIndex(idx);
	},

	/** 
	* Renders the [collection]{@link enyo.Collection} of items. This will delete any
	* existing items and recreate the [repeater]{@link enyo.Repeater} if called after
	* the repeater has been rendered. This is called automatically when the
	* [count]{@link enyo.Repeater#count} property changes. To set the `count` property
	* and force a re-render, such as when a [data model]{@link enyo.Model} changes,
	* use `set('count', newCount, true)`, where the last parameter forces the change
	* handler to be called, even if the `count` remains the same.
	*
	* @fires enyo.Repeater#onSetupItem
	* @public
	*/
	build: function () {
		this.destroyClientControls();
		for (var i=0, c; i<this.count; i++) {
			c = this.createComponent({kind: OwnerProxy, index: i});
			// do this as a second step so 'c' is the owner of the created components
			c.createComponents(this.itemComponents);
			// invoke user's setup code
			this.doSetupItem({index: i, item: c});
		}
		this.render();
	},
	/**
	* Renders a specific item in the [collection]{@link enyo.Collection}. This does not
	* destroy the item, but just calls the `onSetupItem` {@glossary event} handler again
	* for it, so any state stored in the item is preserved.
	*
	* @param {Number} idx - The index of the item to render.
	* @fires enyo.Repeater#onSetupItem
	* @public
	*/
	renderRow: function (idx) {
		var c = this.itemAtIndex(idx);
		this.doSetupItem({index: idx, item: c});
	},

	/**
	* A legacy method that sets the number of items to be repeated and effectively forces a 
	* rebuild of the [repeater]{@link enyo.Repeater}, regardless of whether or not the count has
	* changed.
	*
	* @param {Number} count - The number of items to be repeated.
	* @public
	*/
	setCount: function (count) {
		this.set('count', count, {force: true});
	}
});
},{"../../enyo":1,"./Control":16,"./kind":66,"./utils":75}],40:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind'),
	utils = require('../utils'),
	floatingLayer = require('../floatingLayer');
var
	Control = require('../Control');

/**
* {@link enyo.Scrim} provides an overlay that will prevent taps from propagating
* to the controls that it covers.  A scrim may be "floating" or "non-floating".
* A floating scrim will fill the entire viewport, while a non-floating scrim will
* be constrained by the dimensions of its container.
*
* The scrim should have a CSS class of `enyo-scrim-transparent`,
* `enyo-scrim-translucent`, or any other class that has
* `pointer-events: auto` in its style properties.
*
* You may specify the `z-index` at which you want the scrim to appear by calling
* [showAtZIndex()]{@link enyo.Scrim#showAtZIndex}. If you do so, you must call
* [hideAtZIndex()]{@link enyo.Scrim#hideAtZIndex} with the same value to hide the
* scrim.
*
* @class  enyo.Scrim
* @extends enyo.Control
* @ui
* @public
*/
var Scrim = module.exports = kind(
	/** @lends enyo.Scrim.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Scrim',

	kind: Control,

	/**
	* Current visibility state
	*
	* @type {Boolean}
	* @private
	*/
	showing: false,

	/**
	* @private
	*/
	classes: 'enyo-scrim enyo-fit',

	/**
	* If `true`, the scrim is rendered in a floating layer outside of other
	* controls. This can be used to guarantee that the scrim will be shown
	* on top of other controls.
	*
	* @type {Boolean}
	* @default  false
	* @public
	*/
	floating: false,

	/**
	* @private
	*/
	create: function () {
		this.inherited(arguments);
		this.zStack = [];
		if (this.floating) {
			this.setParent(floatingLayer);
		}
	},

	/**
	* @private
	*/
	showingChanged: function () {
		// auto render when shown.
		if (this.floating && this.showing && !this.hasNode()) {
			this.render();
		}
		this.inherited(arguments);
		//this.addRemoveClass(this.showingClassName, this.showing);
	},

	/**
	* @private
	*/
	addZIndex: function (zIndex) {
		if (utils.indexOf(zIndex, this.zStack) < 0) {
			this.zStack.push(zIndex);
		}
	},

	/**
	* @private
	*/
	removeZIndex: function (control) {
		utils.remove(control, this.zStack);
	},

	/**
	* Shows scrim at the specified z-index. Note that if you call
	* `showAtZIndex()`, you must call [hideAtZIndex()]{@link enyo.Scrim#hideAtZIndex}
	* to properly unwind the z-index stack.
	*
	* @param  {Number} zIndex - z-index for the scrim
	* @public
	*/
	showAtZIndex: function (zIndex) {
		this.addZIndex(zIndex);
		if (zIndex !== undefined) {
			this.setZIndex(zIndex);
		}
		this.show();
	},

	/**
	* Hides scrim at the specified z-index.
	*
	* @param  {Number} zIndex - z-index of the scrim
	* @public
	*/
	hideAtZIndex: function (zIndex) {
		this.removeZIndex(zIndex);
		if (!this.zStack.length) {
			this.hide();
		} else {
			var z = this.zStack[this.zStack.length-1];
			this.setZIndex(z);
		}
	},

	/**
	* @private
	*/
	setZIndex: function (zIndex) {
		this.zIndex = zIndex;
		this.applyStyle('z-index', zIndex);
	},

	/**
	* @private
	*/
	make: function () {
		return this;
	}
});

/**
* Scrim singleton exposing a subset of the Scrim API;
* it is replaced with a proper {@link enyo.Scrim} instance.
*
* @class  enyo.scrimSingleton
* @private
*/
var ScrimSingleton = kind(
	/** @lends  enyo.scrimSingleton.prototype */ {

	/**
	* @private
	*/
	kind: null,

	/**
	* @private
	*/
	constructor: function (props) {
		this.instanceName = name;
		this.props = props || {};
	},

	/**
	* @private
	*/
	make: function () {
		var s = new Scrim(this.props);
		return s;
	},

	/**
	* @private
	*/
	showAtZIndex: function (zIndex) {
		var s = this.make();
		s.showAtZIndex(zIndex);
	},

	/**
	* In case somebody does this out of order
	*
	* @private
	*/
	hideAtZIndex: utils.nop,

	/**
	* @private
	*/
	show: function () {
		var s = this.make();
		s.show();
	}
});

Scrim.scrim = new ScrimSingleton({floating: true, classes: 'enyo-scrim-translucent'});
Scrim.scrimTransparent = new ScrimSingleton({floating: true, classes: 'enyo-scrim-transparent'});
Scrim.ScrimSingleton = ScrimSingleton;
},{"../../../enyo":1,"../Control":16,"../floatingLayer":60,"../kind":66,"../utils":75}],42:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	dispatcher = require('./dispatcher');

var
	Control = require('./Control');

/**
* {@link enyo.ScrollStrategy} is a helper [kind]{@glossary kind} that implements a default 
* scrolling strategy for an {@link enyo.Scroller}.
* 
* `enyo.ScrollStrategy` is not typically created in application code. Instead, it is specified 
* as the value of the [strategyKind]{@link enyo.Scroller#strategyKind} property of an
* `enyo.Scroller` or {@link enyo.List}, or is used by the framework implicitly.
*
* @class enyo.ScrollStrategy
* @protected
*/
module.exports = kind(
	/** @lends enyo.ScrollStrategy.prototype */ {

	name: 'enyo.ScrollStrategy',

	kind: Control,

	/**
	* @private
	*/
	tag: null,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.ScrollStrategy.prototype */ {
		
		/**
		* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		* 
		* @type {String}
		* @default 'default'
		* @public
		*/
		vertical: 'default',
		
		/**
		* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		* 
		* @type {String}
		* @default 'default'
		* @public
		*/
		horizontal: 'default',
		
		/**
		* The horizontal scroll position.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		scrollLeft: 0,
		
		/**
		* The vertical scroll position.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		scrollTop: 0,
		
		/**
		* Maximum height of the scroll content.
		* 
		* @type {Number}
		* @default null
		* @public
		*/
		maxHeight: null,
		
		/**
		* Indicates whether mouse wheel may be used to move the [scroller]{@link enyo.Scroller}.
		* 
		* @type {Boolean}
		* @default true
		* @public
		*/
		useMouseWheel: true
	},
	
	/**
	* @private
	*/
	events: {
		onScrollStart: '',
		onScrollStop: ''
	},

	/**
	* @private
	*/
	handlers: {
		ondragstart: 'dragstart',
		ondragfinish: 'dragfinish',
		ondown: 'down',
		onmove: 'move',
		onmousewheel: 'mousewheel',
		onscroll: 'domScroll'
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.horizontalChanged();
			this.verticalChanged();
			this.maxHeightChanged();
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			dispatcher.makeBubble(this.container, 'scroll');
			this.scrollNode = this.calcScrollNode();
		};
	}),

	/**
	* @method
	* @private
	*/
	teardownRender: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.scrollNode = null;
		};
	}),

	/**
	* @private
	*/
	calcScrollNode: function () {
		return this.container.hasNode();
	},

	/**
	* @private
	*/
	horizontalChanged: function () {
		this.container.applyStyle('overflow-x', this.horizontal == 'default' ? 'auto' : this.horizontal);
	},

	/**
	* @private
	*/
	verticalChanged: function () {
		this.container.applyStyle('overflow-y', this.vertical == 'default' ? 'auto' : this.vertical);
	},

	/**
	* @private
	*/
	maxHeightChanged: function () {
		this.container.applyStyle('max-height', this.maxHeight);
	},

	/** 
	* Scrolls to the specified position.
	*
	* @param {Number} x - The `x` position in pixels.
	* @param {Number} y - The `y` position in pixels.
	* @public
	*/
	scrollTo: function (x, y) {
		if (this.scrollNode) {
			this.setScrollLeft(x);
			this.setScrollTop(y);
		}
	},

	/** 
	* Ensures that the given node is visible in the [scroller's]{@link enyo.Scroller} viewport.
	*
	* @param {Node} node - The node to make visible in the [scroller's]{@link enyo.Scroller}
	*	viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the
	*	scroller.
	* @public
	*/
	scrollToNode: function (node, alignWithTop) {
		if (this.scrollNode) {
			var sb = this.getScrollBounds();
			var n = node;
			var b = {height: n.offsetHeight, width: n.offsetWidth, top: 0, left: 0};
			while (n && n.parentNode && n.id != this.scrollNode.id) {
				b.top += n.offsetTop;
				b.left += n.offsetLeft;
				n = n.parentNode;
			}
			// By default, the element is scrolled to align with the top of the scroll area.
			this.setScrollTop(Math.min(sb.maxTop, alignWithTop === false ? b.top - sb.clientHeight + b.height : b.top));
			this.setScrollLeft(Math.min(sb.maxLeft, alignWithTop === false ? b.left - sb.clientWidth + b.width : b.left));
		}
	},

	/**
	* Scrolls the given [control]{@link enyo.Control} into view.
	*
	* @param {enyo.Control} ctl - The [control]{@link enyo.Control} to make visible in the
	*	[scroller's]{@link enyo.Scroller} viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the
	*	scroller.
	* @public
	*/
	scrollIntoView: function (ctl, alignWithTop) {
		if (ctl.hasNode()) {
			ctl.node.scrollIntoView(alignWithTop);
		}
	},
	isInView: function(inNode) {
		var sb = this.getScrollBounds();
		var ot = inNode.offsetTop;
		var oh = inNode.offsetHeight;
		var ol = inNode.offsetLeft;
		var ow = inNode.offsetWidth;
		return (ot >= sb.top && ot + oh <= sb.top + sb.clientHeight) && (ol >= sb.left && ol + ow <= sb.left + sb.clientWidth);
	},

	/**
	* Sets the vertical scroll position.
	*
	* @param {Number} top - The vertical scroll position in pixels.
	* @public
	*/
	setScrollTop: function (top) {
		this.scrollTop = top;
		if (this.scrollNode) {
			this.scrollNode.scrollTop = this.scrollTop;
		}
	},

	/**
	* Sets the horizontal scroll position.
	*
	* @param {Number} left - The horizontal scroll position in pixels.
	* @public
	*/
	setScrollLeft: function (left) {
		this.scrollLeft = left;
		if (this.scrollNode) {
			this.scrollNode.scrollLeft = this.scrollLeft;
		}
	},

	/**
	* Retrieves the horizontal scroll position.
	*
	* @returns {Number} The horizontal scroll position in pixels.
	* @public
	*/
	getScrollLeft: function () {
		return this.scrollNode ? this.scrollNode.scrollLeft : this.scrollLeft;
	},

	/**
	* Retrieves the vertical scroll position.
	*
	* @returns {Number} The vertical scroll position in pixels.
	* @private
	*/
	getScrollTop: function () {
		return this.scrollNode ? this.scrollNode.scrollTop : this.scrollTop;
	},

	/**
	* @private
	*/
	_getScrollBounds: function () {
		var s = this.getScrollSize(), cn = this.container.hasNode();
		var b = {
			left: this.getScrollLeft(),
			top: this.getScrollTop(),
			clientHeight: cn ? cn.clientHeight : 0,
			clientWidth: cn ? cn.clientWidth : 0,
			height: s.height,
			width: s.width
		};
		b.maxLeft = Math.max(0, b.width - b.clientWidth);
		b.maxTop = Math.max(0, b.height - b.clientHeight);
		return b;
	},

	/**
	* @private
	*/
	getScrollSize: function () {
		var n = this.scrollNode;
		return {width: n ? n.scrollWidth : 0, height: n ? n.scrollHeight : 0};
	},

	/**
	* Retrieves the scroll boundaries of the [scroller]{@link enyo.Scroller}.
	* 
	* @returns {enyo.Scroller~BoundaryObject} An [object]{@glossary Object} describing the 
	*	scroll boundaries.
	* @public
	*/
	getScrollBounds: function () {
		return this._getScrollBounds();
	},

	/**
	* @private
	*/
	calcStartInfo: function () {
		var sb = this.getScrollBounds();
		var y = this.getScrollTop(), x = this.getScrollLeft();
		this.canVertical = sb.maxTop > 0 && this.vertical != 'hidden';
		this.canHorizontal = sb.maxLeft > 0 && this.horizontal != 'hidden';
		this.startEdges = {
			top: y === 0,
			bottom: y === sb.maxTop,
			left: x === 0,
			right: x === sb.maxLeft
		};
	},

	// NOTE: down, move, and drag handlers are needed only for native touch scrollers

	/**
	* @private
	*/
	shouldDrag: function (e) {
		var requestV = e.vertical;
		return (requestV && this.canVertical  || !requestV && this.canHorizontal) /*&& !this.isOobVerticalScroll(event)*/;
	},

	/**
	* @private
	*/
	dragstart: function (sender, e) {
		this.dragging = this.shouldDrag(e);
		if (this.dragging) {
			return this.preventDragPropagation;
		}
	},

	/**
	* @private
	*/
	dragfinish: function (sender, e) {
		if (this.dragging) {
			this.dragging = false;
			e.preventTap();
		}
	},

	/**
	* Avoid allowing scroll when starting at a vertical boundary to prevent iOS from window 
	* scrolling.
	* 
	* @private
	*/
	down: function (sender, e) {
		if (this.isScrolling()) {
			e.preventTap();
		}
		this.calcStartInfo();
	},

	/**
	* NOTE: Mobile native [scrollers]{@link enyo.Scroller} need `touchmove`. Indicate this by 
	* setting the `requireTouchmove` property to `true`.
	* 
	* @private
	*/
	move: function (sender, e) {
		if (e.which && (this.canVertical && e.vertical || this.canHorizontal && e.horizontal)) {
			e.disablePrevention();
		}
	},

	/**
	* @private
	*/
	mousewheel: function (sender, e) {
		//* We disable mouse wheel scrolling by preventing the default
		if (!this.useMouseWheel) {
			e.preventDefault();
		}
	},

	/**
	* @private
	*/
	domScroll: function(sender, e) {
		if (!this._scrolling) {
			this.doScrollStart();
		}
		this._scrolling = true;
		this.startJob('stopScrolling', function() {
			this._scrolling = false;
			this.doScrollStop();
		}, 100);
	},

	/**
	* @public
	*/
	isScrolling: function() {
		return this._scrolling;
	}
});
},{"../../enyo":1,"./Control":16,"./dispatcher":57,"./kind":66}],43:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind');

var
	Control = require('../Control'),
	Dom = require('../dom');

/**
* {@link enyo.ScrollThumb} is a helper [kind]{@glossary kind} used by 
* {@link enyo.TouchScrollStrategy} and {@link enyo.TranslateScrollStrategy} to
* display a small visual scroll indicator.
* 
* `enyo.ScrollThumb` is not typically created in application code.
*
* @class enyo.ScrollThumb
* @protected
*/
module.exports = kind(
	/** @lends enyo.ScrollThumb.prototype */ {
	
	name: 'enyo.ScrollThumb',
	
	kind: Control,

	/**
	* The orientation of the scroll indicator bar; 'v' for vertical or 'h' for horizontal.
	* 
	* @type {String}
	* @default 'v'
	* @public
	*/
	axis: 'v',

	/**
	* Minimum size of the indicator.
	* 
	* @private
	*/
	minSize: 4,

	/**
	* Size of the indicator's corners.
	* 
	* @private
	*/
	cornerSize: 6,

	/**
	* @private
	*/
	classes: 'enyo-thumb',

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			var v = this.axis == 'v';
			this.dimension = v ? 'height' : 'width';
			this.offset = v ? 'top' : 'left';
			this.translation = v ? 'translateY' : 'translateX';
			this.positionMethod = v ? 'getScrollTop' : 'getScrollLeft';
			this.sizeDimension = v ? 'clientHeight' : 'clientWidth';
			this.addClass('enyo-' + this.axis + 'thumb');
			this.transform = Dom.canTransform();
			if (Dom.canAccelerate()) {
				Dom.transformValue(this, 'translateZ', 0);
			}
		};
	}),

	/** 
	* Syncs the scroll indicator bar to the [scroller]{@link enyo.Scroller} size and position,
	* as determined by the passed-in scroll strategy.
	*
	* @param {enyo.ScrollStrategy} strategy - The scroll strategy to be synced with.
	* @public
	*/
	sync: function (strategy) {
		this.scrollBounds = strategy._getScrollBounds();
		this.update(strategy);
	},

	/**
	* Updates the scroll indicator bar based on the scroll bounds of the strategy, the available
	* scroll area, and whether there is overscrolling. If the scroll indicator bar is not
	* needed, it will be not be displayed.
	* 
	* @param {enyo.ScrollStrategy} strategy - The scroll strategy to update from.
	* @public
	*/
	update: function (strategy) {
		if (this.showing) {
			var d = this.dimension, o = this.offset;
			var bd = this.scrollBounds[this.sizeDimension], sbd = this.scrollBounds[d];
			var overs = 0, overp = 0, over = 0;
			if (bd >= sbd) {
				this.hide();
				return;
			}
			if (strategy.isOverscrolling()) {
				over = strategy.getOverScrollBounds()['over' + o];
				overs = Math.abs(over);
				overp = Math.max(over, 0);
			}
			var sbo = strategy[this.positionMethod]() - over;
			// calc size & position
			var bdc = bd - this.cornerSize;
			var s = Math.floor((bd * bd / sbd) - overs);
			s = Math.max(this.minSize, s);
			var p = Math.floor((bdc * sbo / sbd) + overp);
			p = Math.max(0, Math.min(bdc - this.minSize, p));
			// apply thumb styling
			this.needed = s < bd;
			if (this.needed && this.hasNode()) {
				if (this._pos !== p) {
					this._pos = p;
					if(!this.transform) {
						//adjust top/left for browsers that don't support translations
						if(this.axis=='v') {
							this.setBounds({top:p + 'px'});
						} else {
							this.setBounds({left:p + 'px'});
						}
					} else {
						Dom.transformValue(this, this.translation, p + 'px');
					}
				}
				if (this._size !== s) {
					this._size = s;
					this.applyStyle(d, s + 'px');
				}
			} else {
				this.hide();
			}
		}
	},

	/**
	* We implement `setShowing()` and cancel the [delayHide()]{@link enyo.ScrollThumb#delayHide} 
	* because [showing]{@link enyo.Control#showing} is not changed while we execute
	* `delayHide()`.
	*
	* @param {Boolean} showing - If `true`, displays the {@link enyo.ScrollThumb} if appropriate;
	*	otherwise, hides the ScrollThumb.
	* @public
	*/
	setShowing: function (showing) {
		if (showing && showing != this.showing) {
			if (this.scrollBounds[this.sizeDimension] >= this.scrollBounds[this.dimension]) {
				return;
			}
		}
		if (this.hasNode()) {
			this.cancelDelayHide();
		}
		if (showing != this.showing) {
			var last = this.showing;
			this.showing = showing;
			this.showingChanged(last);
		}
	},

	/**
	* Delays automatic hiding of the {@link enyo.ScrollThumb}.
	*
	* @param {Number} delay - The number of milliseconds to delay hiding of the
	*	{@link enyo.ScrollThumb}.
	* @public
	*/
	delayHide: function (delay) {
		if (this.showing) {
			this.startJob('hide', this.hide, delay || 0);
		}
	},

	/**
	* Cancels any pending [delayHide()]{@link enyo.ScrollThumb#delayHide} jobs.
	* 
	* @public
	*/
	cancelDelayHide: function () {
		this.stopJob('hide');
	}
});
},{"../../../enyo":1,"../Control":16,"../dom":58,"../kind":66}],87:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	dom = require('../../../enyo/lib/dom'),
	Control = require('../../../enyo/lib/Control')
	Layout = require('../../../enyo/lib/Layout');

var detector = document.createElement('div'),
	flexAvailable =
		(detector.style.flexBasis !== undefined) ||
		(detector.style.webkitFlexBasis !== undefined) ||
		(detector.style.mozFlexBasis !== undefined) ||
		(detector.style.msFlexBasis !== undefined);

/**
* {@link enyo.FittableLayout} provides the base positioning and boundary logic for
* the fittable layout strategy. The fittable layout strategy is based on
* laying out items in either a set of rows or a set of columns, with most of
* the items having natural size, but one item expanding to fill the remaining
* space. The item that expands is labeled with the attribute `fit: true`.
*
* The subkinds {@link enyo.FittableColumnsLayout} and {@link enyo.FittableRowsLayout}
* (or _their_ subkinds) are used for layout rather than `enyo.FittableLayout` because
* they specify properties that the framework expects to be available when laying items
* out.
*
* When available on the platform, you can opt-in to have `enyo.FittableLayout` use CSS
* flexible box (flexbox) to implement fitting behavior on the platform for better
* performance; Enyo will fall back to JavaScript-based layout on older platforms.
* Three subtle differences between the flexbox and JavaScript implementations
* should be noted:

* - When using flexbox, vertical margins (i.e., `margin-top`, `margin-bottom`) will
* not collapse; when using JavaScript layout, vertical margins will collapse according
* to static layout rules.
*
* - When using flexbox, non-fitting children of the Fittable must not be sized
* using percentages of the container (even if set to `position: relative`);
* this is explicitly not supported by the flexbox 2013 spec.
*
* - The flexbox-based Fittable implementation will respect multiple children
* with `fit: true` (the fitting space will be divided equally between them).
* This is NOT supported by the JavaScript implementation, and you should not rely
* upon this behavior if you are deploying to platforms without flexbox support.
*
* The flexbox implementation was added to Enyo 2.5.0 as an optional performance
* optimization; to use the optimization, set `useFlex: true` on the Fittable
* container.  This will cause flexbox to be used when possible.
*
* @class  enyo.FittableLayout
* @extends enyo.Layout
* @public
*/
var FittableLayout = module.exports = kind(/** @lends  enyo.FittableLayout.prototype */{
	name: 'enyo.FittableLayout',

	/**
	* @private
	*/
	kind: Layout,

	/**
	* @private
	*/
	noDefer: true,

	/**
	* @method
	* @private
	*/
	constructor: function () {
		Layout.prototype._constructor.apply(this, arguments);

		// Add the force-ltr class if we're in RTL mode, but this control is set explicitly to NOT be in RTL mode.
		this.container.addRemoveClass('force-left-to-right', (Control.prototype.rtl && !this.container.get('rtl')) );

		// Flexbox optimization is determined by global flexAvailable and per-instance opt-in useFlex flag
		this.useFlex = flexAvailable && (this.container.useFlex === true);
		if (this.useFlex) {
			this.container.addClass(this.flexLayoutClass);
		} else {
			this.container.addClass(this.fitLayoutClass);
		}
	},

	/**
	* @private
	*/
	calcFitIndex: function () {
		var aChildren = this.container.children,
			oChild,
			n;

		for (n=0; n<aChildren.length; n++) {
			oChild = aChildren[n];
			if (oChild.fit && oChild.showing) {
				return n;
			}
		}
	},

	/**
	* @private
	*/
	getFitControl: function () {
		var aChildren = this.container.children,
			oFitChild = aChildren[this.fitIndex];

		if (!(oFitChild && oFitChild.fit && oFitChild.showing)) {
			this.fitIndex = this.calcFitIndex();
			oFitChild = aChildren[this.fitIndex];
		}
		return oFitChild;
	},

	/**
	* @private
	*/
	shouldReverse: function () {
		return this.container.rtl && this.orient === 'h';
	},
	
	/**
	* @private
	*/
	destroy: function () {
		Layout.prototype.destroy.apply(this, arguments);
		
		if (this.container) {
			this.container.removeClass(this.useFlex ? this.flexLayoutClass : this.fitLayoutClass);
		}
	},

	/**
	* @private
	*/
	getFirstChild: function() {
		var aChildren = this.getShowingChildren();

		if (this.shouldReverse()) {
			return aChildren[aChildren.length - 1];
		} else {
			return aChildren[0];
		}
	},

	/**
	* @private
	*/
	getLastChild: function() {
		var aChildren = this.getShowingChildren();

		if (this.shouldReverse()) {
			return aChildren[0];
		} else {
			return aChildren[aChildren.length - 1];
		}
	},

	/**
	* @private
	*/
	getShowingChildren: function() {
		var a = [],
			n = 0,
			aChildren = this.container.children,
			nLength   = aChildren.length;

		for (;n<nLength; n++) {
			if (aChildren[n].showing) {
				a.push(aChildren[n]);
			}
		}

		return a;
	},

	/**
	* @private
	*/
	_reflow: function(sMeasureName, sClienMeasure, sAttrBefore, sAttrAfter) {
		this.container.addRemoveClass('enyo-stretch', !this.container.noStretch);

		var oFitChild       = this.getFitControl(),
			oContainerNode  = this.container.hasNode(),  // Container node
			nTotalSize     = 0,                          // Total container width or height without padding
			nBeforeOffset   = 0,                         // Offset before fit child
			nAfterOffset    = 0,                         // Offset after fit child
			oPadding,                                    // Object containing t,b,r,l paddings
			oBounds,                                     // Bounds object of fit control
			oLastChild,
			oFirstChild,
			nFitSize;

		if (!oFitChild || !oContainerNode) { return; }

		oPadding   = dom.calcPaddingExtents(oContainerNode);
		oBounds    = oFitChild.getBounds();
		nTotalSize = oContainerNode[sClienMeasure] - (oPadding[sAttrBefore] + oPadding[sAttrAfter]);

		if (this.shouldReverse()) {
			oFirstChild  = this.getFirstChild();
			nAfterOffset = nTotalSize - (oBounds[sAttrBefore] + oBounds[sMeasureName]);

			var nMarginBeforeFirstChild = dom.getComputedBoxValue(oFirstChild.hasNode(), 'margin', sAttrBefore) || 0;

			if (oFirstChild == oFitChild) {
				nBeforeOffset = nMarginBeforeFirstChild;
			} else {
				var oFirstChildBounds      = oFirstChild.getBounds(),
					nSpaceBeforeFirstChild = oFirstChildBounds[sAttrBefore];

				nBeforeOffset = oBounds[sAttrBefore] + nMarginBeforeFirstChild - nSpaceBeforeFirstChild;
			}
		} else {
			oLastChild    = this.getLastChild();
			nBeforeOffset = oBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);

			var nMarginAfterLastChild = dom.getComputedBoxValue(oLastChild.hasNode(), 'margin', sAttrAfter) || 0;

			if (oLastChild == oFitChild) {
				nAfterOffset = nMarginAfterLastChild;
			} else {
				var oLastChildBounds = oLastChild.getBounds(),
					nFitChildEnd     = oBounds[sAttrBefore] + oBounds[sMeasureName],
					nLastChildEnd    = oLastChildBounds[sAttrBefore] + oLastChildBounds[sMeasureName] +  nMarginAfterLastChild;

				nAfterOffset = nLastChildEnd - nFitChildEnd;
			}
		}

		nFitSize = nTotalSize - (nBeforeOffset + nAfterOffset);
		oFitChild.applyStyle(sMeasureName, nFitSize + 'px');
	},

	/**
	* Assigns any static layout properties not dependent on changes to the
	* rendered component or container sizes, etc.
	* 
	* @public
	*/
	flow: function() {
		if (this.useFlex) {
			var i,
				children = this.container.children,
				child;
			this.container.addClass(this.flexLayoutClass);
			this.container.addRemoveClass('nostretch', this.container.noStretch);
			for (i=0; i<children.length; i++) {
				child = children[i];
				child.addClass('enyo-flex-item');
				child.addRemoveClass('flex', child.fit);
			}
		}
	},

	/**
	* Updates the layout to reflect any changes made to the layout container or
	* the contained components.
	*
	* @public
	*/
	reflow: function() {
		if (!this.useFlex) {
			if (this.orient == 'h') {
				this._reflow('width', 'clientWidth', 'left', 'right');
			} else {
				this._reflow('height', 'clientHeight', 'top', 'bottom');
			}
		}
	},

	/**
	* @private
	* @lends  enyo.FittableLayout.prototype
	*/
	statics: {
		/**
		* Indicates whether flexbox optimization can be used.
		*
		* @type {Boolean}
		* @default  false
		* @private
		*/
		flexAvailable: flexAvailable
	}
});

/**
* {@link enyo.FittableColumnsLayout} provides a container in which items are laid
* out in a set of vertical columns, with most of the items having natural
* size, but one expanding to fill the remaining space. The one that expands is
* labeled with the attribute `fit: true`.
*
* `enyo.FittableColumnsLayout` is meant to be used as a value for the
* `layoutKind` property of other kinds. `layoutKind` provides a way to add
* layout behavior in a pluggable fashion while retaining the ability to use a
* specific base kind.
*
* For more information, see the documentation on
* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the
* Enyo Developer Guide.
*
* @class  enyo.FittableColumnsLayout
* @extends enyo.FittableLayout
* @public
*/
FittableLayout.Columns = kind(/** @lends  enyo.FittableColumnsLayout.prototype */{
	name        : 'enyo.FittableColumnsLayout',
	kind        : FittableLayout,
	orient      : 'h',
	fitLayoutClass : 'enyo-fittable-columns-layout',
	flexLayoutClass: 'enyo-flex-container columns'
});


/**
* {@link enyo.FittableRowsLayout} provides a container in which items are laid out
* in a set of horizontal rows, with most of the items having natural size, but
* one expanding to fill the remaining space. The one that expands is labeled
* with the attribute `fit: true`.
*
* `enyo.FittableRowsLayout` is meant to be used as a value for the
* `layoutKind` property of other kinds. `layoutKind` provides a way to add
* layout behavior in a pluggable fashion while retaining the ability to use a
* specific base kind.
*
* For more information, see the documentation on
* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the
* Enyo Developer Guide.
*
* @class  enyo.FittableRowsLayout
* @extends enyo.FittableLayout
* @public
*/
FittableLayout.Rows = kind(
	/** @lends enyo.FittableRowsLayout.prototype */ {

	/**
	* @private
	*/
	name        : 'enyo.FittableRowsLayout',

	/**
	* @private
	*/
	kind        : FittableLayout,

	/**
	* Layout CSS class used to fit rows.
	*
	* @type {String}
	* @default 'enyo-fittable-rows-layout'
	* @public
	*/
	fitLayoutClass : 'enyo-fittable-rows-layout',

	/**
	* The orientation of the layout.
	*
	* @type {String}
	* @default 'v'
	* @public
	*/
	orient      : 'v',

	/**
	* @private
	*/
	flexLayoutClass: 'enyo-flex-container rows'
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/Layout":26,"../../../enyo/lib/dom":58,"../../../enyo/lib/kind":66}],89:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom'),
	utils = require('../../enyo/lib/utils'),
	Control = require('../../enyo/lib/Control'),
	HTMLStringDelegate = require('../../enyo/lib/HTMLStringDelegate'),
	Selection = require('../../enyo/lib/Selection');

var FlyweightRepeaterDelegate = Object.create(HTMLStringDelegate);

FlyweightRepeaterDelegate.generateInnerHtml = function (control) {
	var h = '';
	control.index = null;
	// note: can supply a rowOffset
	// and indicate if rows should be rendered top down or bottomUp
	for (var i=0, r=0; i<control.count; i++) {
		r = control.rowOffset + (this.bottomUp ? control.count - i-1 : i);
		control.setupItem(r);
		control.$.client.setAttribute('data-enyo-index', r);
		if (control.orient == 'h') {
			control.$.client.setStyle('display:inline-block;');
		}
		h += HTMLStringDelegate.generateChildHtml(control);
		control.$.client.teardownRender();
	}
	return h;
};

/**
* Fires once per row at render time.
*
* @event enyo.FlyweightRepeater#onSetupItem
* @type {Object}
* @property {Number} index     - The index of the row being rendered.
* @property {Boolean} selected - `true` if the row is selected; otherwise, `false`.
* @public
*/

/**
* Fires after an individual row has been rendered.
*
* @event enyo.FlyweightRepeater#onRenderRow
* @type {Object}
* @property {Number} rowIndex - The index of the row that was rendered.
* @public
*/

/**
* {@link enyo.FlyweightRepeater} is a control that displays a repeating list of
* rows, suitable for displaying medium-sized lists (up to ~100 items). A
* flyweight strategy is employed to render one set of row controls, as needed,
* for as many rows as are contained in the repeater.
*
* The FlyweightRepeater's `components` block contains the controls to be used
* for a single row. This set of controls will be rendered for each row. You
* may customize row rendering by handling the
* [onSetupItem]{@link enyo.FlyweightRepeater#onSetupItem} event.
*
* The controls inside a FlyweightRepeater are non-interactive. This means that
* calling methods that would normally cause rendering to occur (e.g.,
* `set('content', <value>)`) will not do so. However, you may force a row to
* render by calling [renderRow()]{@link enyo.FlyweightRepeater#renderRow}.
*
* In addition, you may force a row to be temporarily interactive by calling
* [prepareRow()]{@link enyo.FlyweightRepeater#prepareRow}. Call
* [lockRow()]{@link enyo.FlyweightRepeater#lockRow} when the interaction
* is complete.
*
* For more information, see the documentation on
* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the
* Enyo Developer Guide.
*
* @ui
* @class enyo.FlyweightRepeater
* @extends enyo.Control
* @public
*/
var FlyweightRepeater = module.exports = kind(
	/** @lends enyo.FlyweightRepeater.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.FlyweightRepeater',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @lends enyo.FlyweightRepeater.prototype
	* @private
	*/
	published: {
		/**
		 * The number of rows to render.
		 *
		 * @type {Number}
		 * @default 0
		 * @public
		 */
		count: 0,

		/**
		* If `true`, the selection mechanism is disabled. Tap events are still
		* sent, but items won't be automatically re-rendered when tapped.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		noSelect: false,

		/**
		 * If `true`, multiple selection is allowed.
		 *
		 * @type {Boolean}
		 * @default false
		 * @public
		 */
		multiSelect: false,

		/**
		 * If `true`, the selected item will toggle.
		 *
		 * @type {Boolean}
		 * @default false
		 * @public
		 */
		toggleSelected: false,

		/**
		* Used to specify CSS classes for the repeater's wrapper component (client).
		* Input is identical to that of {@link enyo.Control#setClasses}.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		clientClasses: '',

		/**
		* Used to specify custom styling for the repeater's wrapper component
		* (client). Input is identical to that of {@link enyo.Control#setStyle}.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		clientStyle: '',

		/**
		* Numerical offset applied to row number during row generation. Allows items
		* to have natural indices instead of `0`-based ones. This value must be
		* positive, as row number `-1` is used to represent undefined rows in the
		* event system.
		*
		* @type {Number}
		* @default 0
		* @public
		*/
		rowOffset: 0,

		/**
		* Direction in which items will be laid out. Valid values are `'v'` for
		* vertical or `'h'` for horizontal.
		*
		* @type {String}
		* @default 'h'
		* @public
		*/
		orient: 'v'
	},

	/**
	* @private
	*/
	events: {
		onSetupItem: '',
		onRenderRow: ''
	},

	/**
	* Setting cachePoint: true ensures that events from the repeater's subtree will
	* always bubble up through the repeater, allowing the events to be decorated with repeater-
	* related metadata and references.
	*
	* @type {Boolean}
	* @default true
	* @private
	*/
	cachePoint: true,

	/**
	* Design-time attribute indicating whether row indices run
	* from `0` to [`count`]{@link enyo.FlyweightRepeater#count}`-1` `(false)` or
	* from [`count`]{@link enyo.FlyweightRepeater#count}`-1` to `0` `(true)`.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	bottomUp: false,

	/**
	* @private
	*/
	renderDelegate: FlyweightRepeaterDelegate,

	/**
	* @private
	*/
	components: [
		{kind: Selection, onSelect: 'selectDeselect', onDeselect: 'selectDeselect'},
		{name: 'client'}
	],

	/**
	* @method
	* @private
	*/
	create: function () {
		Control.prototype.create.apply(this, arguments);
		this.noSelectChanged();
		this.multiSelectChanged();
		this.clientClassesChanged();
		this.clientStyleChanged();
	},

	/**
	* @private
	*/
	noSelectChanged: function () {
		if (this.noSelect) {
			this.$.selection.clear();
		}
	},

	/**
	* @private
	*/
	multiSelectChanged: function () {
		this.$.selection.setMulti(this.multiSelect);
	},

	/**
	* @private
	*/
	clientClassesChanged: function () {
		this.$.client.setClasses(this.clientClasses);
	},

	/**
	* @private
	*/
	clientStyleChanged: function () {
		this.$.client.setStyle(this.clientStyle);
	},

	/**
	* @fires enyo.FlyweightRepeater#onSetupItem
	* @private
	*/
	setupItem: function (index) {
		this.doSetupItem({index: index, selected: this.isSelected(index)});
	},

	/**
	* Renders the list.
	*
	* @private
	*/
	generateChildHtml: function () {
		return this.renderDelegate.generateInnerHtml(this);
	},

	/**
	* @todo add link to preview.js
	* @private
	*/
	previewDomEvent: function (event) {
		var i = this.index = this.rowForEvent(event);
		event.rowIndex = event.index = i;
		event.flyweight = this;
	},

	/**
	* @method
	* @private
	*/
	decorateEvent: function (eventName, event, sender) {
		// decorate event with index found via dom iff event does not already contain an index.
		var i = (event && event.index != null) ? event.index : this.index;
		if (event && i != null) {
			event.index = i;
			event.flyweight = this;
		}
		Control.prototype.decorateEvent.apply(this, arguments);
	},

	/**
	* @private
	*/
	tap: function (sender, event) {
		// ignore taps if selecting is disabled or if they don't target a row
		if (this.noSelect || event.index === -1) {
			return;
		}
		if (this.toggleSelected) {
			this.$.selection.toggle(event.index);
		} else {
			this.$.selection.select(event.index);
		}
	},

	/**
	* Handler for selection and deselection.
	*
	* @private
	*/
	selectDeselect: function (sender, event) {
		this.renderRow(event.key);
	},

	/**
	* Returns the repeater's [selection]{@link enyo.Selection} component.
	*
	* @return {enyo.Selection} The repeater's selection component.
	* @public
	*/
	getSelection: function () {
		return this.$.selection;
	},

	/**
	* Gets the selection state for the given row index.
	*
	* @return {Boolean} `true` if the row is currently selected; otherwise, `false`.
	* @public
	*/
	isSelected: function (index) {
		return this.getSelection().isSelected(index);
	},

	/**
	* Renders the row with the specified index.
	*
	* @param {Number} index - The index of the row to render.
	* @fires enyo.FlyweightRepeater#onRenderRow
	* @public
	*/
	renderRow: function (index) {
		// do nothing if index is out-of-range
		if (index < this.rowOffset || index >= this.count + this.rowOffset) {
			return;
		}
		//this.index = null;
		// always call the setupItem callback, as we may rely on the post-render state
		this.setupItem(index);
		var node = this.fetchRowNode(index);
		if (node) {
			// hack to keep this working...
			var delegate = HTMLStringDelegate;

			dom.setInnerHtml(node, delegate.generateChildHtml(this.$.client));
			this.$.client.teardownChildren();
			this.doRenderRow({rowIndex: index});
		}
	},

	/**
	* Fetches the DOM node for the given row index.
	*
	* @param {Number} index - The index of the row whose DOM node is to be fetched.
	* @return {Node} The DOM node for the specified row.
	* @public
	*/
	fetchRowNode: function (index) {
		if (this.hasNode()) {
			return this.node.querySelector('[data-enyo-index="' + index + '"]');
		}
	},

	/**
	* Fetches the row number corresponding to the target of a given event.
	*
	* @param {Object} event - Event object.
	* @return {Number} The index of the row corresponding to the event's target.
	* @public
	*/
	rowForEvent: function (event) {
		if (!this.hasNode()) {
			return -1;
		}
		var n = event.target;
		while (n && n !== this.node) {
			var i = n.getAttribute && n.getAttribute('data-enyo-index');
			if (i !== null) {
				return Number(i);
			}
			n = n.parentNode;
		}
		return -1;
	},

	/**
	* Prepares the specified row such that changes made to the controls inside
	* the repeater will be rendered for the row.
	*
	* @param {Number} index - The index of the row to be prepared.
	* @public
	*/
	prepareRow: function (index) {
		// do nothing if index is out-of-range
		if (index < this.rowOffset || index >= this.count + this.rowOffset) {
			return;
		}
		// update row internals to match model
		this.setupItem(index);
		var n = this.fetchRowNode(index);
		FlyweightRepeater.claimNode(this.$.client, n);
	},

	/**
	* Prevents rendering of changes made to controls inside the repeater.
	*
	* @public
	*/
	lockRow: function () {
		this.$.client.teardownChildren();
	},

	/**
	* Prepares the specified row such that changes made to the controls in the
	* repeater will be rendered in the row; then performs the function `func`
	* and, finally, locks the row.
	*
	* @param {Number} index   - The index of the row to be acted upon.
	* @param {Function} func  - The function to perform.
	* @param {Object} context - The context to which `func` is bound.
	* @private
	*/
	performOnRow: function (index, func, context) {
		// do nothing if index is out-of-range
		if (index < this.rowOffset || index >= this.count + this.rowOffset) {
			return;
		}
		if (func) {
			this.prepareRow(index);
			utils.call(context || null, func);
			this.lockRow();
		}
	},

	/**
	* @lends enyo.FlyweightRepeater
	* @private
	*/
	statics: {
		/**
		* Associates a flyweight rendered control (`control`) with a
		* rendering context specified by `node`.
		*
		* @param {enyo.Control} control - A flyweight-rendered control.
		* @param {Node} node - The DOM node to be associated with `control`.
		* @public
		*/
		claimNode: function (control, node) {
			var n;
			if (node) {
				if (node.id !== control.id) {
					n = node.querySelector('#' + control.id);
				} else {
					// node is already the right node, so just use it
					n = node;
				}
			}
			// FIXME: consider controls generated if we found a node or tag: null, the later so can teardown render
			control.generated = Boolean(n || !control.tag);
			control.node = n;
			if (control.node) {
				control.rendered();
			} else {
				//enyo.log('Failed to find node for',  control.id, control.generated);
			}
			// update control's class cache based on the node contents
			for (var i=0, c$=control.children, c; (c=c$[i]); i++) {
				this.claimNode(c, node);
			}
		}
	}
});
},{"../../enyo/lib/Control":16,"../../enyo/lib/HTMLStringDelegate":22,"../../enyo/lib/Selection":46,"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"../../enyo/lib/utils":75}],93:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Control = require('../../../enyo/lib/Control');

/**
* {@link enyo.ImageViewPin} is a control that can be used to display
* non-zooming content inside of a zoomable {@link enyo.ImageView} control. The
* [anchor]{@link enyo.ImageViewPin#anchor} and
* [position]{@link enyo.ImageViewPin#position} properties may be used to
* position both the ImageViewPin and its content in a specific location within
* the ImageView.
*
* @ui
* @class enyo.ImageViewPin
* @extends enyo.Control
* @public
*/
module.exports = kind(
	/** @lends enyo.ImageViewPin.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.ImageViewPin',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @lends enyo.ImageViewPin.prototype
	* @private
	*/
	published: {
		/**
		* If `true`, the anchor point for this pin will be highlighted in yellow,
		* which can be useful for debugging. Defaults to `false`.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		highlightAnchorPoint: false,

		/**
		* The coordinates at which this control should be anchored inside
		* of the parent ImageView control. This position is relative to the
		* ImageView control's original size. Works like standard CSS positioning,
		* and accepts both px and percentage values.
		*
		* * `top`: Distance from the parent's top edge.
		* * `bottom`: Distance from the parent's bottom edge (overrides `top`).
		* * `left`: Distance from the parent's left edge.
		* * `right`: Distance from the parent's right edge (overrides `left`).
		*
		* @type {Object}
		* @default {top: 0px, left: 0px}
		* @public
		*/
		anchor: {
			top: 0,
			left: 0
		},

		/**
		* The coordinates at which the contents of this control should be
		* positioned relative to the ImageViewPin itself. Works like standard
		* CSS positioning. Only accepts px values. Defaults to
		* `{top: 0px, left: 0px}`.
		*
		* * `top`: Distance from the ImageViewPin's top edge.
		* * `bottom`: Distance from the ImageViewPin's bottom edge.
		* * `left`: Distance from the ImageViewPin's left edge.
		* * `right`: Distance from the ImageViewPin's right edge.
		*
		* @type {Object}
		* @default {top: 0px, left: 0px}
		* @public
		*/
		position: {
			top: 0,
			left: 0
		}
	},

	/**
	* @private
	*/
	style: 'position:absolute;z-index:1000;width:0px;height:0px;',

	/**
	* @private
	*/
	handlers: {
		onPositionPin: 'reAnchor'
	},

	/**
	* @method
	* @private
	*/
	create: function () {
		Control.prototype.create.apply(this, arguments);
		this.styleClientControls();
		this.positionClientControls();
		this.highlightAnchorPointChanged();
		this.anchorChanged();
	},

	/**
	* Absolutely positions client controls.
	*
	* @private
	*/
	styleClientControls: function () {
		var controls = this.getClientControls();
		for (var i = 0; i < controls.length; i++) {
			controls[i].applyStyle('position','absolute');
		}
	},

	/**
	* Applies specified positioning to client controls.
	*
	* @private
	*/
	positionClientControls: function () {
		var controls = this.getClientControls();
		for (var i = 0; i < controls.length; i++) {
			for (var p in this.position) {
				controls[i].applyStyle(p, this.position[p]+'px');
			}
		}
	},

	/**
	* Updates styling of anchor point.
	*
	* @private
	*/
	highlightAnchorPointChanged: function () {
		this.addRemoveClass('pinDebug', this.highlightAnchorPoint);
	},

	/**
	* Creates `coords` object for each anchor, containing value and units.
	*
	* @private
	*/
	anchorChanged: function () {
		var coords = null, a = null;
		for (a in this.anchor) {
			coords = this.anchor[a].toString().match(/^(\d+(?:\.\d+)?)(.*)$/);
			if (!coords) {
				continue;
			}
			this.anchor[a+'Coords'] = {
				value: coords[1],
				units: coords[2] || 'px'
			};
		}
	},

	/*
	* Applies positioning to ImageViewPin specified in `this.anchor`.
	* Called anytime the parent ImageView is rescaled. If `right/bottom`
	* are specified, they override `top/left`.
	*
	* @private
	*/
	reAnchor: function (sender, event) {
		var scale = event.scale;
		var bounds = event.bounds;
		var left = (this.anchor.right)
			// Right
			? (this.anchor.rightCoords.units == 'px')
				? (bounds.width + bounds.x - this.anchor.rightCoords.value*scale)
				: (bounds.width*(100-this.anchor.rightCoords.value)/100 + bounds.x)
			// Left
			: (this.anchor.leftCoords.units == 'px')
				? (this.anchor.leftCoords.value*scale + bounds.x)
				: (bounds.width*this.anchor.leftCoords.value/100 + bounds.x);
		var top = (this.anchor.bottom)
			// Bottom
			? (this.anchor.bottomCoords.units == 'px')
				? (bounds.height + bounds.y - this.anchor.bottomCoords.value*scale)
				: (bounds.height*(100-this.anchor.bottomCoords.value)/100 + bounds.y)
			// Top
			: (this.anchor.topCoords.units == 'px')
				? (this.anchor.topCoords.value*scale + bounds.y)
				: (bounds.height*this.anchor.topCoords.value/100 + bounds.y);
		this.applyStyle('left', left+'px');
		this.applyStyle('top', top+'px');
	}
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/kind":66}],101:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Control = require('../../../enyo/lib/Control');

/**
* Fires when the Puller is created.
*
* @event enyo.Puller#onCreate
* @type {Object}
* @public
*/

/**
* {@link enyo.Puller} is a control displayed within an {@link enyo.PulldownList}
* to indicate that the list is refreshing due to a pull-to-refresh.
*
* @ui
* @class enyo.Puller
* @extends enyo.Control
* @public
*/
module.exports = kind(
	/** @lends enyo.Puller.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Puller',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	classes: 'enyo-puller',

	/**
	* @lends enyo.Puller.prototype
	* @private
	*/
	published: {
		/**
		* Text to display below icon.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		text: '',

		/**
		* CSS classes to apply to the icon control.
		*
		* @type {String}
		* @default ''
		* @public
		*/
		iconClass: ''
	},

	/**
	* @private
	*/
	events: {
		onCreate: ''
	},

	/**
	* @private
	*/
	components: [
		{name: 'icon'},
		{name: 'text', tag: 'span', classes: 'enyo-puller-text'}
	],

	/**
	* @method
	* @private
	*/
	create: function () {
		Control.prototype.create.apply(this, arguments);
		this.doCreate();
		this.textChanged();
		this.iconClassChanged();
	},

	/**
	* @private
	*/
	textChanged: function () {
		this.$.text.setContent(this.text);
	},

	/**
	* @private
	*/
	iconClassChanged: function () {
		this.$.icon.setClasses(this.iconClass);
	}
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/kind":66}],102:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom'),
	platform = require('../../enyo/lib/platform'),
	Animator = require('../../enyo/lib/Animator'),
	Control = require('../../enyo/lib/Control');

/**
* Fires when the Slideable finishes animating.
*
* @event enyo.Slideable#onAnimateFinish
* @type {enyo.Animator}
* @public
*/

/**
* Fires when the position (i.e., [value]{@link enyo.Slideable#value}) of the
* Slideable changes.
*
* @event enyo.Slideable#onChange
* @type {Object}
* @public
*/

/**
* {@link enyo.Slideable} is a control that may be dragged either horizontally
* or vertically between a minimum and a maximum value. When released from
* dragging, a Slideable will animate to its minimum or maximum position,
* depending on the direction of the drag.
*
* The [min]{@link enyo.Slideable#min} value specifies a position to the left of,
* or above, the initial position, to which the Slideable may be dragged.
* The [max]{@link enyo.Slideable#max} value specifies a position to the right of,
* or below, the initial position, to which the Slideable may be dragged.
* The [value]{@link enyo.Slideable#value} property specifies the current position
* of the Slideable, between the minimum and maximum positions.
*
* `min`, `max`, and `value` may be specified in units of 'px' or '%'.
*
* The [axis]{@link enyo.Slideable#axis} property determines whether the Slideable
* slides left-to-right ('h') or up-and-down ('v').
*
* The following control is placed 90% off the screen to the right, and slides
* to its natural position:
*
* ```
* {kind: 'enyo.Slideable', value: -90, min: -90, unit: '%',
* 	classes: 'enyo-fit', style: 'width: 300px;',
* 	components: [
* 		{content: 'stuff'}
* 	]
* }
* ```
*
* @ui
* @class  enyo.Slideable
* @extends enyo.Control
* @public
*/
module.exports = kind(
	/** @lends  enyo.Slideable.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Slideable',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @lends enyo.Slideable.prototype
	* @private
	*/
	published: {
		/**
		* Direction of sliding; valid values are `'h'` for horizonal or `'v'` for vertical.
		*
		* @type {String}
		* @default 'h'
		* @public
		*/
		axis: 'h',

		/**
		* Current position of the Slideable (a value between
		* [min]{@link enyo.Slideable#min} and [max]{@link enyo.Slideable#max}).
		*
		* @type {Number}
		* @default  0
		* @public
		*/
		value: 0,

		/**
		* Unit for [min]{@link enyo.Slideable#min}, [max]{@link enyo.Slideable#max},
		* and [value]{@link enyo.Slideable#value}; valid values are `'px'` or `'%'`.
		*
		* @type {String}
		* @default  'px'
		* @public
		*/
		unit: 'px',

		/**
		* The minimum value to slide to.
		*
		* @type {Number}
		* @default 0
		* @public
		*/
		min: 0,

		/**
		* The maximum value to slide to.
		*
		* @type {Number}
		* @default  0
		* @public
		*/
		max: 0,

		/**
		* When truthy, applies CSS styles to allow GPU compositing of slideable
		* content, if allowed by the platform.
		*
		* @type {String}
		* @default  'auto'
		* @public
		*/
		accelerated: 'auto',

		/**
		* Set to `false` to prevent the Slideable from dragging with elasticity
		* past its [min]{@link enyo.Slideable#min} or [max]{@link enyo.Slideable#max}
		* value.
		*
		* @type {Boolean}
		* @default  true
		* @public
		*/
		overMoving: true,

		/**
		* Indicates whether dragging is allowed. Set to `false` to disable dragging.
		*
		* @type {Boolean}
		* @default  true
		* @public
		*/
		draggable: true
	},

	/**
	* @private
	*/
	events: {
		onAnimateFinish: '',
		onChange: ''
	},

	/**
	* Set to `true` to prevent drag events from bubbling beyond the Slideable.
	*
	* @private
	*/
	preventDragPropagation: false,

	/**
	* @private
	*/
	tools: [
		{kind: Animator, onStep: 'animatorStep', onEnd: 'animatorComplete'}
	],

	/**
	* @private
	*/
	handlers: {
		ondragstart: 'dragstart',
		ondrag: 'drag',
		ondragfinish: 'dragfinish'
	},

	/**
	* @private
	*/
	kDragScalar: 1,

	/**
	* @private
	*/
	dragEventProp: 'dx',

	/**
	* @private
	*/
	unitModifier: false,

	/**
	* @private
	*/
	canTransform: false,

	/**
	* Indicates which property of the drag event is used to position the control.
	*
	* @private
	*/
	dragMoveProp: 'dx',

	/**
	* Indicates which property of the drag event is used to allow dragging.
	*
	* @private
	*/
	shouldDragProp: 'horizontal',

	/**
	* The transform property to modify, provided that
	* [canTransform]{@link enyo.Slideable#canTransform} is `true`.
	*
	* @private
	*/
	transform: 'translateX',

	/**
	* The dimension attribute to modify; will be either `'height'` or `'width'`.
	*
	* @private
	*/
	dimension: 'width',

	/**
	* The position attribute to modify; will be either `'top'` or `'left'`.
	*
	* @private
	*/
	boundary: 'left',

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.acceleratedChanged();
			this.transformChanged();
			this.axisChanged();
			this.valueChanged();
			this.addClass('enyo-slideable');
		};
	}),

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function () {
			this.createComponents(this.tools);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.canModifyUnit();
			this.updateDragScalar();
		};
	}),

	/**
	* @method
	* @private
	*/
	handleResize: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.updateDragScalar();
		};
	}),

	/**
	* If transforms can't be used and inline style is using 'px' while
	* [unit]{@link enyo.Slideable#unit} is `'%'`, this sets the
	* [unitModifier]{@link enyo.Slideable#unitModifier} property to the current
	* value of [dimension]{@link enyo.Slideable#dimension}.
	*
	* @private
	*/
	canModifyUnit: function () {
		if (!this.canTransform) {
			var b = this.getInitialStyleValue(this.hasNode(), this.boundary);
			// If inline style of 'px' exists, while unit is '%'
			if (b.match(/px/i) && (this.unit === '%')) {
				// Set unitModifier - used to over-ride '%'
				this.unitModifier = this.getBounds()[this.dimension];
			}
		}
	},

	/**
	* @private
	*/
	getInitialStyleValue: function (node, boundary) {
		var s = dom.getComputedStyle(node);
		if (s) {
			return s.getPropertyValue(boundary);
		} else if (node && node.currentStyle) {
			return node.currentStyle[boundary];
		}
		return '0';
	},

	/**
	* @private
	*/
	updateBounds: function (inValue, inDimensions) {
		var inBounds = {};
		inBounds[this.boundary] = inValue;
		this.setBounds(inBounds, this.unit);

		this.setInlineStyles(inValue, inDimensions);
	},

	/**
	* @private
	*/
	updateDragScalar: function () {
		if (this.unit == '%') {
			var d = this.getBounds()[this.dimension];
			this.kDragScalar = d ? 100 / d : 1;

			if (!this.canTransform) {
				this.updateBounds(this.value, 100);
			}
		}
	},

	/**
	* @private
	*/
	transformChanged: function () {
		this.canTransform = dom.canTransform();
	},

	/**
	* @private
	*/
	acceleratedChanged: function () {
		if (!platform.android || platform.android <= 2) {
			dom.accelerate(this, this.accelerated);
		}
	},

	/**
	* @private
	*/
	axisChanged: function () {
		var h = this.axis == 'h';
		this.dragMoveProp = h ? 'dx' : 'dy';
		this.shouldDragProp = h ? 'horizontal' : 'vertical';
		this.transform = h ? 'translateX' : 'translateY';
		this.dimension = h ? 'width' : 'height';
		this.boundary = h ? 'left' : 'top';
	},

	/**
	* @private
	*/
	setInlineStyles: function (value, dimensions) {
		var inBounds = {};

		if (this.unitModifier) {
			inBounds[this.boundary] = this.percentToPixels(value, this.unitModifier);
			inBounds[this.dimension] = this.unitModifier;
			this.setBounds(inBounds);
		} else {
			if (dimensions) {
				inBounds[this.dimension] = dimensions;
			} else {
				inBounds[this.boundary] = value;
			}
			this.setBounds(inBounds, this.unit);
		}
	},

	/**
	* @fires enyo.Slideable#onChange
	* @private
	*/
	valueChanged: function (inLast) {
		var v = this.value;
		if (this.isOob(v) && !this.isAnimating()) {
			this.value = this.overMoving ? this.dampValue(v) : this.clampValue(v);
		}
		// FIXME: android cannot handle nested compositing well so apply acceleration only if needed
		// desktop chrome doesn't like this code path so avoid...
		if (platform.android > 2) {
			if (this.value) {
				if (inLast === 0 || inLast === undefined) {
					dom.accelerate(this, this.accelerated);
				}
			} else {
				dom.accelerate(this, false);
			}
		}

		// If platform supports transforms
		if (this.canTransform) {
			dom.transformValue(this, this.transform, this.value + this.unit);
		// else update inline styles
		} else {
			this.setInlineStyles(this.value, false);
		}
		this.doChange();
	},

	/**
	* @private
	*/
	getAnimator: function () {
		return this.$.animator;
	},

	/**
	* @private
	*/
	isAtMin: function () {
		return this.value <= this.calcMin();
	},

	/**
	* @private
	*/
	isAtMax: function () {
		return this.value >= this.calcMax();
	},

	/**
	* @private
	*/
	calcMin: function () {
		return this.min;
	},

	/**
	* @private
	*/
	calcMax: function () {
		return this.max;
	},

	/**
	* @private
	*/
	clampValue: function (inValue) {
		var min = this.calcMin();
		var max = this.calcMax();
		return Math.max(min, Math.min(inValue, max));
	},

	/**
	* @private
	*/
	dampValue: function (inValue) {
		return this.dampBound(this.dampBound(inValue, this.min, 1), this.max, -1);
	},

	/**
	* @private
	*/
	dampBound: function (inValue, inBoundary, inSign) {
		var v = inValue;
		if (v * inSign < inBoundary * inSign) {
			v = inBoundary + (v - inBoundary) / 4;
		}
		return v;
	},

	/**
	* Calculates the pixel value corresponding to the specified `percent` and
	* `dimension`.
	*
	* @param  {Number} percent
	* @param  {Number} dimension
	*
	* @return {Number}
	* @private
	*/
	percentToPixels: function (percent, dimension) {
		return Math.floor((dimension / 100) * percent);
	},

	/**
	* @private
	*/
	pixelsToPercent: function (value) {
		var boundary = this.unitModifier ? this.getBounds()[this.dimension] : this.container.getBounds()[this.dimension];
		return (value / boundary) * 100;
	},

	/**
	* @private
	*/
	shouldDrag: function (inEvent) {
		return this.draggable && inEvent[this.shouldDragProp];
	},

	/**
	* Determines whether the specified value is out of bounds (i.e., greater than
	* [max]{@link enyo.Slideable#max} or less than [min]{@link enyo.Slideable#min}).
	*
	* @param {Number} inValue - The value to check.
	* @return {Boolean} `true` if `inValue` is out of bounds; otherwise, `false`.
	* @private
	*/
	isOob: function (inValue) {
		return inValue > this.calcMax() || inValue < this.calcMin();
	},

	/**
	* @private
	*/
	dragstart: function (inSender, inEvent) {
		if (this.shouldDrag(inEvent)) {
			inEvent.preventDefault();
			this.$.animator.stop();
			inEvent.dragInfo = {};
			this.dragging = true;
			this.drag0 = this.value;
			this.dragd0 = 0;
			return this.preventDragPropagation;
		}
	},

	/**
	* Updates [value]{@link enyo.Slideable#value} during a drag and determines the
	* direction of the drag.
	*
	* @private
	*/
	drag: function (inSender, inEvent) {
		if (this.dragging) {
			inEvent.preventDefault();
			var d = this.canTransform ? inEvent[this.dragMoveProp] * this.kDragScalar : this.pixelsToPercent(inEvent[this.dragMoveProp]);
			var v = this.drag0 + d;
			var dd = d - this.dragd0;
			this.dragd0 = d;
			if (dd) {
				inEvent.dragInfo.minimizing = dd < 0;
			}
			this.setValue(v);
			return this.preventDragPropagation;
		}
	},

	/**
	* @private
	*/
	dragfinish: function (sender, event) {
		if (this.dragging) {
			this.dragging = false;
			this.completeDrag(event);
			event.preventTap();
			return this.preventDragPropagation;
		}
	},

	/**
	* Animates the control to either the [min]{@link enyo.Slideable#min} or
	* [max]{@link enyo.Slideable#max} value when dragging completes, based on the
	* direction of the drag (determined in [drag()]{@link enyo.Slideable#drag}).
	*
	* @private
	*/
	completeDrag: function (event) {
		if (this.value !== this.calcMax() && this.value != this.calcMin()) {
			this.animateToMinMax(event.dragInfo.minimizing);
		}
	},

	/**
	* @private
	*/
	isAnimating: function () {
		return this.$.animator.isAnimating();
	},

	/**
	* @private
	*/
	play: function (start, end) {
		this.$.animator.play({
			startValue: start,
			endValue: end,
			node: this.hasNode()
		});
	},

	/**
	* Animates to the given value.
	*
	* @param   {Number} value - The value to animate to.
	* @public
	*/
	animateTo: function (value) {
		this.play(this.value, value);
	},

	/**
	* Animates to the [minimum]{@link enyo.Slideable#min} value.
	*
	* @public
	*/
	animateToMin: function () {
		this.animateTo(this.calcMin());
	},

	/**
	* Animates to the [maximum]{@link enyo.Slideable#max} value.
	*
	* @public
	*/
	animateToMax: function () {
		this.animateTo(this.calcMax());
	},

	/**
	* Helper method to toggle animation to either the [min]{@link enyo.Slideable#min}
	* or [max]{@link enyo.Slideable#max} value.
	*
	* @param  {Boolean} min - Whether to animate to the minimum value.
	* @private
	*/
	animateToMinMax: function (min) {
		if (min) {
			this.animateToMin();
		} else {
			this.animateToMax();
		}
	},

	/**
	* Updates the [value]{@link enyo.Slideable#value} property during animation.
	*
	* @private
	*/
	animatorStep: function (sender) {
		this.setValue(sender.value);
		return true;
	},

	/**
	* @fires enyo.Slideable#onAnimateFinish
	* @private
	*/
	animatorComplete: function (sender) {
		this.doAnimateFinish(sender);
		return true;
	},

	/**
	* Toggles animation to either the [min]{@link enyo.Slideable#min} or
	* [max]{@link enyo.Slideable#max} value.
	*
	* @public
	*/
	toggleMinMax: function () {
		this.animateToMinMax(!this.isAtMin());
	}
});
},{"../../enyo/lib/Animator":5,"../../enyo/lib/Control":16,"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"../../enyo/lib/platform":71}],52:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind');
var
	GroupItem = require('../GroupItem');

/**
* {@link enyo.ToolDecorator} lines up [components]{@link enyo.Component} in a row,
* centered vertically.
*
* @class enyo.ToolDecorator
* @extends enyo.GroupItem
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.ToolDecorator.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.ToolDecorator',

	/**
	* @private
	*/
	kind: GroupItem,

	/**
	* @private
	*/
	classes: 'enyo-tool-decorator'
});
},{"../../../enyo":1,"../GroupItem":21,"../kind":66}],97:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Control = require('../../../enyo/lib/Control'),
	Image = require('../../../enyo/lib/Image');

/**
* Fires when the Node is tapped. No additional data is sent with this event.
*
* @event enyo.Node#onNodeTap
* @type {Object}
* @public
*/

/**
* Fires when the Node is double-clicked. No additional data is sent with this event.
*
* @event enyo.Node#onNodeDblClick
* @type {Object}
* @public
*/

/**
* Fires when the Node expands or contracts, as indicated by the
* `expanded` property in the event data.
*
* @event enyo.Node#onExpand
* @type {Object}
* @property {Boolean} expanded - `true` if the node is currently expanded;
* otherwise, `false`.
* @public
*/

/**
* Fires when the Node is destroyed. No additional data is sent with this event.
*
* @event enyo.Node#onDestroyed
* @type {Object}
* @public
*/

/**
* {@link enyo.Node} is a control that creates structured trees based on Enyo's child
* component hierarchy format, e.g.:
*
* ```
* {kind: 'Node', icon: 'images/folder-open.png', content: 'Tree',
* 	expandable: true, expanded: true, components: [
* 		{icon: 'images/file.png', content: 'Alpha'},
* 		{icon: 'images/folder-open.png', content: 'Bravo',
* 			expandable: true, expanded: false, components: [
* 				{icon: 'images/file.png', content: 'Bravo-Alpha'},
* 				{icon: 'images/file.png', content: 'Bravo-Bravo'},
* 				{icon: 'images/file.png', content: 'Bravo-Charlie'}
* 			]
* 		}
* 	]
* }
* ```
*
* The default kind of components within a node is itself {@link enyo.Node}, so only
* the top-level node of the tree needs to be explicitly defined as such.
*
* When an expandable tree node expands, an [onExpand]{@link enyo.Node#onExpand}
* event is sent; when it is tapped, an [onNodeTap]{@link enyo.Node#onNodeTap}
* event is sent.
*
* When the optional [onlyIconExpands]{@link enyo.Node#onlyIconExpands} property is
* set to `true`, expandable nodes may only be opened by tapping the icon; tapping the
* content label will fire the `onNodeTap` event, but will not expand the node.
*
* @ui
* @class  enyo.Node
* @extends enyo.Control
* @public
*/
var TreeNode = module.exports = kind(
	/** @lends  enyo.Node.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Node',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @lends enyo.Node.prototype
	* @private
	*/
	published: {
		/**
		* Indicates whether the Node is expandable and has child branches.
		*
		* @type {Boolean}
		* @default  false
		* @public
		*/
		expandable: false,

		/**
		* Indicates whether the Node is currently expanded (open).
		*
		* @type {Boolean}
		* @default  false
		* @public
		*/
		expanded: false,

		/**
		* Path to an image to be used as the icon for this Node.
		*
		* @type {String}
		* @default  ''
		* @public
		*/
		icon: '',

		/**
		* Optional flag that, when `true`, causes the Node to expand only when
		* the icon is tapped (not when the contents are tapped).
		*
		* @type {Boolean}
		*/
		onlyIconExpands: false,

		/**
		* If `true`, adds the `'enyo-selected'` CSS class; changing value from `true`
		* to `false` removes the class.
		*
		* @type {Boolean}
		* @default  false
		* @public
		*/
		selected: false
	},

	/**
	* @todo remove inline styles
	* @private
	*/
	style: 'padding: 0 0 0 16px;',

	/**
	* @private
	*/
	content: 'Node',

	/**
	* @private
	*/
	defaultKind: TreeNode,

	/**
	* @private
	*/
	classes: 'enyo-node',

	/**
	* @private
	*/
	components: [
		{name: 'icon', kind: Image, showing: false},
		{name: 'caption', kind: Control, Xtag: 'span', style: 'display: inline-block; padding: 4px;', allowHtml: true},
		{name: 'extra', kind: Control, tag: 'span', allowHtml: true}
	],

	/**
	* @private
	*/
	childClient: [
		{name: 'box', kind: Control, classes: 'enyo-node-box', Xstyle: 'border: 1px solid orange;', components: [
			{name: 'client', kind: Control, classes: 'enyo-node-client', Xstyle: 'border: 1px solid lightblue;'}
		]}
	],

	/**
	* @private
	*/
	handlers: {
		ondblclick: 'dblclick'
	},

	/**
	* @private
	*/
	events: {
		onNodeTap: 'nodeTap',
		onNodeDblClick: 'nodeDblClick',
		onExpand: 'nodeExpand',
		onDestroyed: 'nodeDestroyed'
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			//this.expandedChanged();
			//this.levelChanged();
			this.selectedChanged();
			this.iconChanged();
		};
	}),

	/**
	* @method
	* @fires enyo.Node#onDestroyed
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function () {
			this.doDestroyed();
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function () {
			// TODO: optimize to create the childClient on demand
			//this.hasChildren = this.components;
			if (this.expandable) {
				this.kindComponents = this.kindComponents.concat(this.childClient);
			}
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	contentChanged: function () {
		//this.$.caption.setContent((this.expandable ? (this.expanded ? '-' : '+') : '') + this.content);
		this.$.caption.setContent(this.content);
	},

	/**
	* @private
	*/
	iconChanged: function () {
		this.$.icon.setSrc(this.icon);
		this.$.icon.setShowing(Boolean(this.icon));
	},

	/**
	* @private
	*/
	selectedChanged: function () {
		this.addRemoveClass('enyo-selected', this.selected);
	},

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			if (this.expandable && !this.expanded) {
				this.quickCollapse();
			}
		};
	}),

	/**
	* Adds nodes as children of this control.
	*
	* @param {Object[]} nodes - An array of component configurations.
	* @public
	*/
	addNodes: function (nodes) {
		this.destroyClientControls();
		for (var i=0, n; (n=nodes[i]); i++) {
			this.createComponent(n);
		}
		this.$.client.render();
	},

	/**
	* Adds new Nodes as children of this Node; each value in the `nodes` array
	* becomes the content of a new child Node.
	*
	* @param {String[]} nodes - An array of strings.
	* @public
	*/
	addTextNodes: function (nodes) {
		this.destroyClientControls();
		for (var i=0, n; (n=nodes[i]); i++) {
			this.createComponent({content: n});
		}
		this.$.client.render();
	},

	/**
	* @fires enyo.Node#onNodeTap
	* @private
	*/
	tap: function (sender, event) {
		if(!this.onlyIconExpands) {
			this.toggleExpanded();
			this.doNodeTap();
		} else {
			if((event.target==this.$.icon.hasNode())) {
				this.toggleExpanded();
			} else {
				this.doNodeTap();
			}
		}
		return true;
	},

	/**
	* @fires enyo.Node#onNodeDblClick
	* @private
	*/
	dblclick: function (sender, event) {
		this.doNodeDblClick();
		return true;
	},

	/**
	* Toggles the value of [expanded]{@link enyo.Node#expanded}.
	*
	* @public
	*/
	toggleExpanded: function () {
		this.setExpanded(!this.expanded);
	},

	/**
	* Immediately collapses the control's children.
	*
	* @private
	*/
	quickCollapse: function () {
		this.removeClass('enyo-animate');
		this.$.box.applyStyle('height', '0');
		var h = this.$.client.getBounds().height;
		this.$.client.setBounds({top: -h});
	},

	/**
	* Animates the expansion (using CSS transitions).
	*
	* @private
	*/
	_expand: function () {
		this.addClass('enyo-animate');
		var h = this.$.client.getBounds().height;
		this.$.box.setBounds({height: h});
		this.$.client.setBounds({top: 0});
		setTimeout(this.bindSafely(function () {
			// things may have happened in the interim, make sure
			// we only fix height if we are still expanded
			if (this.expanded) {
				this.removeClass('enyo-animate');
				this.$.box.applyStyle('height', 'auto');
			}
		}), 225);
	},

	/**
	* Animates the collapsing (using CSS transitions).
	*
	* @private
	*/
	_collapse: function () {
		// disable transitions
		this.removeClass('enyo-animate');
		// fix the height of our box (rather than 'auto'), this
		// gives webkit something to lerp from
		var h = this.$.client.getBounds().height;
		this.$.box.setBounds({height: h});
		// yield the thead so DOM can make those changes (without transitions)
		setTimeout(this.bindSafely(function () {
			// enable transitions
			this.addClass('enyo-animate');
			// shrink our box to 0
			this.$.box.applyStyle('height', '0');
			// slide the contents up
			this.$.client.setBounds({top: -h});
		}), 25);
	},

	/**
	* @fires enyo.Node#onExpand
	* @private
	*/
	expandedChanged: function (old) {
		if (!this.expandable) {
			this.expanded = false;
		} else {
			var event = {expanded: this.expanded};
			this.doExpand(event);
			if (!event.wait) {
				this.effectExpanded();
			}
		}
	},

	/**
	* @private
	*/
	effectExpanded: function () {
		if (this.$.client) {
			if (!this.expanded) {
				this._collapse();
			} else {
				this._expand();
			}
		}
		//this.contentChanged();
	}
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/Image":23,"../../../enyo/lib/kind":66}],11:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('./utils'),
	platform = require('./platform');
var
	Input = require('./Input');

/**
* Fires when checkbox is tapped.
*
* @event enyo.Checkbox#onActivate
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Checkbox} implements an HTML checkbox [input]{@glossary input}, with
* support for grouping using {@link enyo.Group}.
*
* @class enyo.Checkbox
* @extends enyo.Input
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Checkbox.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Checkbox',

	/**
	* @private
	*/
	kind: Input,

	/**
	* @private
	*/
	classes: 'enyo-checkbox',

	/**
	* @private
	*/
	events: {
		onActivate: ''
	},

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Checkbox.prototype */ {
		
		/**
		* Value of the checkbox; will be `true` if checked.
		* 
		* @type {Boolean}
		* @default false
		* @public
		*/
		checked: false,
		
		/**
		* A [Group API]{@link enyo.Group} requirement for determining the selected item.
		* 
		* @type {Boolean}
		* @default false
		* @public
		*/
		active: false,
		
		/**
		* @private
		*/
		type: 'checkbox'
	},
	
	/**
	* Disable classes inherited from {@link enyo.Input}.
	* 
	* @private
	*/
	kindClasses: "",

	/**
	* @private
	*/
	handlers: {
		onchange: 'change',
		onclick: 'click'
	},

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			if (this.active) {
				this.activeChanged();
			}
			this.checkedChanged();
		};
	}),

	/**
	* @private
	*/
	checkedChanged: function () {
		this.setNodeProperty('checked', this.checked);
		this.setAttribute('checked', this.checked ? 'checked' : '');
		this.setActive(this.checked);
	},

	/**
	* The [active]{@link enyo.Checkbox#active} property and `onActivate`
	* {@glossary event} are part of the [GroupItem]{@link enyo.GroupItem}
	* interface supported by this [object]{@glossary Object}.
	* 
	* @private
	*/
	activeChanged: function () {
		this.active = utils.isTrue(this.active);
		this.setChecked(this.active);
		this.bubble('onActivate');
	},

	/**
	* All [input]{@link enyo.Input} type [controls]{@link enyo.Control} support the 
	* [value]{@link enyo.Input#value} property.
	*
	* @param {Boolean} val - Whether or not the [checkbox]{@link enyo.Checkbox} should
	* be checked. The value will be treated as `true` if it is truthy; otherwise,
	* `false`.
	* @public
	*/
	setValue: function (val) {
		this.setChecked(utils.isTrue(val));
	},

	/**
	* Retrieves the current [value]{@link enyo.Input#value} of the
	* [checkbox]{@link enyo.Checkbox}.
	*
	* @returns {Boolean} `true` if the [checkbox]{@link enyo.Checkbox} is checked;
	* otherwise, `false`.
	* @public
	*/
	getValue: function () {
		return this.getChecked();
	},

	/**
	* @private
	*/
	valueChanged: function () {

	/**
	* @private
	*/
	// inherited behavior is to set "value" attribute and node-property
	// which does not apply to checkbox (uses "checked") so
	// we squelch the inherited method
	},
	change: function () {
		var nodeChecked = utils.isTrue(this.getNodeProperty('checked'));
		this.setActive(nodeChecked);
	},

	/**
	* @private
	*/
	click: function (sender, e) {
		// Various versions of IE (notably IE8) do not fire 'onchange' for
		// checkboxes, so we discern change via 'click'.
		// Note: keyboard interaction (e.g. pressing space when focused) fires
		// a click event.
		if (platform.ie <= 8) {
			this.bubble('onchange', e);
		}
	}
});
},{"../../enyo":1,"./Input":24,"./kind":66,"./platform":71,"./utils":75}],45:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	platform = require('./platform'),
	dispatcher = require('./dispatcher');
var
	Control = require('./Control'),
	Option = require('./Option');

/**
* {@link enyo.Select} implements an HTML [selection]{@glossary select} widget, using
* {@link enyo.Option} instances by default.
*
* ```
* {kind: 'Select', onchange: 'selectChanged', components: [
*	{content: 'Descending', value: 'd'},
*	{content: 'Ascending', value: 'a'}
* ]}
* 
* selectChanged: function(inSender, inEvent) {
*	var s = inSender.getValue();
*	if (s == 'd') {
*		this.sortListDescending();
*	} else {
*		this.sortListAscending();
*	}
* }
* ```
* 
* Note: This uses the [&lt;select&gt;]{@glossary select} tag, which isn't implemented for
* native webOS applications, although it does work in the webOS Web browser.
*
* @class enyo.Select
* @extends enyo.Control
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Select.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Select',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/
	published: 
		/** @lends enyo.Select.prototype */ {
		
		/**
		* The index of the selected [option]{@link enyo.Option} in the list.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		selected: 0,

		/**
		* The value of the selected [option]{@link enyo.Option}.
		* 
		* @type {Object}
		* @default null
		* @public
		*/
		value: null
	},
	
	/**
	* @private
	*/
	handlers: {
		onchange: 'change'
	},

	/**
	* @private
	*/
	tag: 'select',

	/**
	* @private
	*/
	defaultKind: Option,

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			//Trick to force IE8 onchange event bubble
			if(platform.ie == 8){
				this.setAttribute('onchange', dispatcher.bubbler);
			}
			this.change();
			this.selectedChanged();
		};
	}),

	/**
	* @private
	*/
	getSelected: function () {
		return Number(this.getNodeProperty('selectedIndex', this.selected));
	},

	/**
	* @private
	*/
	selectedChanged: function () {
		this.setNodeProperty('selectedIndex', this.selected);
	},

	/**
	* @private
	*/
	change: function () {
		this.selected = this.getSelected();
		if (this.hasNode()) {
			this.set('value', this.node.value);
		}
	},

	/**
	* @method
	* @private
	*/
	render: kind.inherit(function (sup) {
		return function() {
			// work around IE bug with innerHTML setting of <select>, rerender parent instead
			// http://support.microsoft.com/default.aspx?scid=kb;en-us;276228
			if (platform.ie) {
				this.parent.render();
			} else {
				sup.apply(this, arguments);
			}
		};
	})
});
},{"../../enyo":1,"./Control":16,"./Option":35,"./dispatcher":57,"./kind":66,"./platform":71}],37:[function(require,module,exports){
(function (global){
require('../../../enyo');



var
	kind = require('../kind'),
	utils = require('../utils'),
	dispatcher = require('../dispatcher');
var
	Control = require('../Control'),
	Signals = require('../Signals'),
	Scrim = require('../Scrim'),
	Dom = require('../dom');

/**
* Fires after the [popup]{@link enyo.Popup} is shown.
*
* @event enyo.Popup#onShow
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* Fires after the [popup]{@link enyo.Popup} is hidden.
*
* @event enyo.Popup#onHide
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing event information.
* @public
*/

/**
* {@link enyo.Popup} is a [control]{@link enyo.Control} used to display certain content
* on top of other content.
*
* Popups are initially hidden on creation; they may be shown by calling the
* [show()]{@link enyo.Control#show} method and re-hidden by calling
* [hide()]{@link enyo.Control#hide}. Popups may be centered using the
* [centered]{@link enyo.Popup#centered} property; if not centered, they should
* be given a specific position.
*
* A popup may be optionally floated above all
* [application]{@link enyo.Application} content by setting its
* [floating]{@link enyo.Popup#floating} property to `true`. This has the
* advantage of guaranteeing that the popup will be displayed on top of other
* content. This usage is appropriate when the popup does not need to scroll
* along with other content.
*
* To avoid obscuring popup contents, scrims require the dialog to be floating;
* otherwise, they won't render. A modal popup will get a transparent scrim
* unless the popup isn't floating. To get a translucent scrim when modal,
* specify `[scrim]{@link enyo.Popup#scrim}: true` and
* `[scrimWhenModal]{@link enyo.Popup#scrimWhenModal}: false`.
*
* Finally, there is a WebKit bug affecting the behavior of popups that are
* displayed on top of text input controls.  For more information, including a
* workaround, see the documentation on
* [Popups]{@linkplain $dev-guide/building-apps/controls/popups.html}
* in the Enyo Developer Guide.
*
* @class enyo.Popup
* @extends enyo.Control
* @ui
* @public
*/
var Popup = module.exports = kind(
	/** @lends enyo.Popup.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Popup',

	/**
	* @private
	*/
	kind: Control,

	/**
	* @private
	*/


	/**
	* @private
	*/
	classes: 'enyo-popup enyo-no-touch-action',

	/**
	* @private
	*/
	published:
		/** @lends enyo.Popup.prototype */ {

		/**
		* Set to `true` to prevent [controls]{@link enyo.Control} outside the
		* [popup]{@link enyo.Popup} from receiving [events]{@glossary event} while the
		* popup is showing.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		modal: false,

		/**
		* By default, the [popup]{@link enyo.Popup} will hide when the user taps outside it or
		* presses `ESC`.  Set to `false` to prevent this behavior.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		autoDismiss: true,

		/**
		* Set to `true` to render the [popup]{@link enyo.Popup} in a
		* [floating layer]{@link enyo.FloatingLayer} outside of other
		* [controls]{@link enyo.Control}.  This may be used to guarantee that the
		* popup will be shown on top of other controls.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		floating: false,

		/**
		* Set to `true` to automatically center the [popup]{@link enyo.Popup} in
		* the middle of the viewport.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		centered: false,

		/**
		* Set to `true` to be able to show transition on the style modifications;
		* otherwise the transition is invisible `(visibility: hidden)`.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		showTransitions: false,

		/**
		* Set to `true` to stop `preventDefault()` from being called on captured
		* [events]{@glossary event}.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		allowDefault: false,

		/**
		* Boolean that controls whether a scrim will appear when the dialog is
		* modal. Note that modal scrims are transparent, so you won't see them.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		scrimWhenModal: true,

		/**
		* Boolean that controls whether or not a scrim will be displayed. Scrims are
		* only displayed when the dialog is floating.
		*
		* @type {Boolean}
		* @default  false
		* @public
		*/
		scrim: false,

		/**
		* Optional class name to apply to the scrim. Be aware that the scrim
		* is a singleton and you will be modifying the scrim instance used for
		* other popups.
		*
		* @type {String}
		* @default  ''
		* @public
		*/
		scrimClassName: '',

		/**
		* Lowest z-index that may be applied to a popup
		*
		* @type {Number}
		* @default  120
		* @public
		*/
		defaultZ: 120
	},

	/**
	* @lends  enyo.Popup
	* @private
	*/
	protectedStatics: {
		/**
		* Count of currently showing popups
		* @type {Number}
		* @static
		* @private
		*/
		count: 0,

		/**
		* Highest possible z-index for a popup
		* @type {Number}
		* @static
		* @private
		*/
		highestZ: 120
	},

	/**
	* @private
	*/
	showing: false,

	/**
	* @private
	*/
	handlers: {
		onkeydown: 'keydown',
		ondragstart: 'dragstart',
		onfocus: 'focus',
		onblur: 'blur',
		onRequestShow: 'requestShow',
		onRequestHide: 'requestHide'
	},

	/**
	* @private
	*/
	captureEvents: true,

	/**
	* @private
	*/
	eventsToCapture: {
		ondown: 'capturedDown',
		ontap: 'capturedTap'
	},

	/**
	* @private
	*/
	events: {
		onShow: '',
		onHide: ''
	},

	/**
	* @private
	*/
	tools: [
		{kind: Signals, onKeydown: 'keydown'}
	],

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			var showing = this.showing;
			this.showing = false;

			sup.apply(this, arguments);
			this.canGenerate = !this.floating;

			// if the showing flag was true we know the intent was to automatically show the
			// popup on render...but it can't be rendered in the normal flow...but the rendered
			// method won't be called because it wasn't generated...SO...we arbitrarily flag
			// it as generated even though it wasn't to ensure that its rendered method will
			// be called and we then check for this scenario in rendered
			this.generated = showing;
		};
	}),

	/**
	* @method
	* @private
	*/
	render: kind.inherit(function (sup) {
		return function() {
			if (this.floating) {
				if (!Control.floatingLayer.hasNode()) {
					Control.floatingLayer.render();
				}
				this.parentNode = Control.floatingLayer.hasNode();
			}
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	teardownRender: kind.inherit(function (sup) {
		return function () {
			// if this is a rendered floating popup, remove the node from the
			// floating layer because it won't be removed otherwise
			var node = this.hasNode();
			if(this.floating && node) {
				this.node.remove();
			}

			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			this.release();
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	reflow: kind.inherit(function (sup) {
		return function() {
			this.updatePosition();
			sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	calcViewportSize: function () {
		if (global.innerWidth) {
			return {
				width: global.innerWidth,
				height: global.innerHeight
			};
		} else {
			var e = document.documentElement;
			return {
				width: e.offsetWidth,
				height: e.offsetHeight
			};
		}
	},

	/**
	* @private
	*/
	updatePosition: function () {
		var d = this.calcViewportSize(),
			b = this.getBounds();

		if (this.targetPosition) {
			// For brevity's sake...
			var p = this.targetPosition;

			// Test and optionally adjust our target bounds (only first is commented, because logic is effectively identical for all scenarios)
			if (typeof p.left == 'number') {
				// If popup will be outside global bounds, switch anchor
				if (p.left + b.width > d.width) {
					if (p.left - b.width >= 0) {
						// Switching to right corner will fit in global
						p.right = d.width - p.left;
					} else {
						// Neither corner will work; stick at side of global
						p.right = 0;
					}
					p.left = null;
				} else {
					p.right = null;
				}
			} else if (typeof p.right == 'number') {
				if (p.right + b.width > d.width) {
					if (p.right - b.width >= 0) {
						p.left = d.width - p.right;
					} else {
						p.left = 0;
					}
					p.right = null;
				} else {
					p.left = null;
				}
			}

			if (typeof p.top == 'number') {
				if (p.top + b.height > d.height) {
					if (p.top - b.height >= 0) {
						p.bottom = d.height - p.top;
					} else {
						p.bottom = 0;
					}
					p.top = null;
				} else {
					p.bottom = null;
				}
			} else if (typeof p.bottom == 'number') {
				if (p.bottom + b.height > d.height) {
					if (p.bottom - b.height >= 0) {
						p.top = d.height - p.bottom;
					} else {
						p.top = 0;
					}
					p.bottom = null;
				} else {
					p.top = null;
				}
			}

			// 'initial' values are necessary to override positioning rules in the CSS
			this.addStyles('left: ' + (p.left !== null ? p.left + 'px' : 'initial') + '; right: ' + (p.right !== null ? p.right + 'px' : 'initial') + '; top: ' + (p.top !== null ? p.top + 'px' : 'initial') + '; bottom: ' + (p.bottom !== null ? p.bottom + 'px' : 'initial') + ';');
		} else if (this.centered) {
			var o = this.floating ? d : this.getInstanceOwner().getBounds();
			this.addStyles( 'top: ' + Math.max( ( ( o.height - b.height ) / 2 ), 0 ) + 'px; left: ' + Math.max( ( ( o.width - b.width ) / 2 ), 0 ) + 'px;' );
		}
	},

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function () {
			// generated won't be true when this method is called with showing false unless
			// we set it that way so we need to go ahead and do our actual render now that the container (parent)
			// has been rendered and the floating layer can be rendered and we should be able to carry on normally
			if (this.generated && !this.showing && !this.hasNode()) {
				this.generated = false;
				this.showing = true;
				this.showingChanged();
			} else sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @fires enyo.Popup#onShow
	* @fires enyo.Popup#onHide
	* @private
	*/
	showingChanged: kind.inherit(function (sup) {
		return function() {
			// auto render when shown.
			if (this.floating && this.showing && !this.hasNode()) {
				this.render();
			}
			// hide while sizing, and move to top corner for accurate sizing
			if (this.centered || this.targetPosition) {
				if (!this.showTransitions) {
					this.applyStyle('visibility', 'hidden');
				}
				this.addStyles('top: 0px; left: 0px; right: initial; bottom: initial;');
			}
			sup.apply(this, arguments);
			if (this.showing) {
				this.resize();
				Popup.count++;
				this.applyZIndex();
				if (this.captureEvents) {
					this.capture();
				}
			} else {
				if(Popup.count > 0) {
					Popup.count--;
				}
				if (this.captureEvents) {
					this.release();
				}
			}
			this.showHideScrim(this.showing);
			// show after sizing
			if (this.centered || this.targetPosition && !this.showTransitions) {
				this.applyStyle('visibility', null);
			}
			// events desired due to programmatic show/hide
			if (this.hasNode()) {
				this[this.showing ? 'doShow' : 'doHide']();
			}
		};
	}),

	/**
	* @private
	*/
	capture: function () {
		dispatcher.capture(this, this.eventsToCapture);
	},

	/**
	* @private
	*/
	release: function () {
		dispatcher.release(this);
	},

	/**
	* @private
	*/
	capturedDown: function (sender, e) {
		//record the down event to verify in tap
		this.downEvent = e;

		// prevent focus from shifting outside the popup when modal.
		if (this.modal && !this.allowDefault) {
			e.preventDefault();
		}
		return this.modal;
	},

	/**
	* @private
	*/
	capturedTap: function (sender, e) {
		// dismiss on tap if property is set and click started & ended outside the popup
		if (this.autoDismiss && (!e.dispatchTarget.isDescendantOf(this)) && this.downEvent &&
			(!this.downEvent.dispatchTarget.isDescendantOf(this))) {
			this.downEvent = null;
			this.hide();
		}
		return this.modal;
	},

	/**
	* If a drag event occurs outside a [popup]{@link enyo.Popup}, hide.
	*
	* @private
	*/
	dragstart: function (sender, e) {
		var inScope = (e.dispatchTarget === this || e.dispatchTarget.isDescendantOf(this));
		if (sender.autoDismiss && !inScope) {
			sender.setShowing(false);
		}
		return true;
	},

	/**
	* @private
	*/
	keydown: function (sender, e) {
		if (this.showing && this.autoDismiss && e.keyCode == 27 /* escape */) {
			this.hide();
		}
	},

	/**
	* If something inside the [popup]{@link enyo.Popup} blurred, keep track of it.
	*
	* @private
	*/
	blur: function (sender, e) {
		if (e.dispatchTarget.isDescendantOf(this)) {
			this.lastFocus = e.originator;
		}
	},

	/**
	* When something outside the [popup]{@link enyo.Popup} focuses (e.g., due to tab key), focus
	* our last focused [control]{@link enyo.Control}.
	*
	* @private
	*/
	focus: function (sender, e) {
		var dt = e.dispatchTarget;
		if (this.modal && !dt.isDescendantOf(this)) {
			if (dt.hasNode()) {
				dt.node.blur();
			}
			var n = (this.lastFocus && this.lastFocus.hasNode()) || this.hasNode();
			if (n) {
				n.focus();
			}
		}
	},

	/**
	* @private
	*/
	requestShow: function () {
		this.show();
		return true;
	},

	/**
	* @private
	*/
	requestHide: function () {
		this.hide();
		return true;
	},

	/**
	* Opens the [popup]{@link enyo.Popup} at the location of a mouse
	* {@glossary event}. The popup's position is automatically constrained so
	* that it does not display outside the viewport, and defaults to anchoring
	* the top left corner of the popup to the position of the mouse event.
	*
	* @param {Object} e - The mouse {@glossary event} that initiated this call.
	* @param {Object} [offset] - An optional [object]{@glossary Object} that may
	* contain `left` and `top` properties to specify an offset relative to the
	* location where the [popup]{@link enyo.Popup} would otherwise be positioned.
	* @public
	*/
	showAtEvent: function (e, offset) {
		// Calculate our ideal target based on the event position and offset
		var p = {
			left: e.centerX || e.clientX || e.pageX,
			top: e.centerY || e.clientY || e.pageY
		};
		if (offset) {
			p.left += offset.left || 0;
			p.top += offset.top || 0;
		}

		this.showAtPosition(p);
	},

	/**
	* Opens the [popup]{@link enyo.Popup} at a specific position. The final
	* location of the popup will be automatically constrained so that it does
	* not display outside the viewport.
	*
	* @param {Object} pos An [object]{@glossary Object} that may contain `left`,
	* `top`, `bottom`, and `right` properties to specify where the
	* [popup]{@link enyo.Popup} will be anchored. If both `left` and `right` are
	* included, the preference will be to anchor on the left; similarly, if both
	* `top` and `bottom` are specified, the preference will be to anchor at the
	* top.
	* @public
	*/
	showAtPosition: function (pos) {
		// Save our target position for later processing
		this.targetPosition = pos;

		// Show the dialog
		this.show();
	},

	/**
	* Toggles the display of the scrim
	*
	* @param  {Boolean} show - Show the scrim
	* @private
	*/
	showHideScrim: function (show) {
		if (this.floating && (this.scrim || (this.modal && this.scrimWhenModal))) {
			var scrim = this.getScrim();
			if (show) {
				// move scrim to just under the popup to obscure rest of screen
				var i = this.getScrimZIndex();
				this._scrimZ = i;
				scrim.showAtZIndex(i);
			} else {
				scrim.hideAtZIndex(this._scrimZ);
			}
			utils.call(scrim, 'addRemoveClass', [this.scrimClassName, scrim.showing]);
		}
	},

	/**
	* Calculates the z-index for the scrim so it's directly below the popup
	*
	* @private
	*/
	getScrimZIndex: function () {
		return Popup.highestZ >= this._zIndex ? this._zIndex - 1 : Popup.highestZ;
	},

	/**
	* Show a transparent scrim for modal popups if {@link enyo.Popup#scrimWhenModal} is `true`
	* if {@link enyo.Popup#scrim} is `true`, then show a regular scrim.
	*
	* @return {enyo.Scrim}
	* @private
	*/
	getScrim: function () {
		//
		if (this.modal && this.scrimWhenModal && !this.scrim) {
			return Scrim.scrimTransparent.make();
		}
		return Scrim.scrim.make();
	},

	/**
	* Adjust the zIndex so that popups will properly stack on each other.
	*
	* @private
	*/
	applyZIndex: function () {
		this._zIndex = (Popup.count * 2) + this.findZIndex() + 1;
		if (this._zIndex <= Popup.highestZ) {
			this._zIndex = Popup.highestZ + 1;
		}
		if (this._zIndex > Popup.highestZ) {
			Popup.highestZ = this._zIndex;
		}
		// leave room for scrim
		this.applyStyle('z-index', this._zIndex);
	},

	/**
	* Find the z-index for this popup, clamped by {@link enyo.Popup#defaultZ}
	*
	* @return {Number} z-index value
	* @private
	*/
	findZIndex: function () {
		// a default z value
		var z = this.defaultZ;
		if (this._zIndex) {
			z = this._zIndex;
		} else if (this.hasNode()) {
			// Re-use existing zIndex if it has one
			z = Number(Dom.getComputedStyleValue(this.node, 'z-index')) || z;
		}
		if (z < this.defaultZ) {
			z = this.defaultZ;
		}
		this._zIndex = z;
		return this._zIndex;
	}
});

/**
* By default, we capture `ondown` and `ontap` to implement the [popup's]{@link enyo.Popup}
* modal behavior, but in certain circumstances it may be necessary to capture other
* [events]{@glossary event} as well, so we provide this hook to extend. (We are currently
* using this in Moonstone to capture `onSpotlightFocus` [events]{@glossary event}).
*
* @private
*/
Popup.concat = function (ctor, props, instance) {
	var proto = ctor.prototype || ctor,
		evts = proto.eventsToCapture;
	proto.eventsToCapture = evts ? utils.mixin({}, [evts, props.eventsToCapture]) : props.eventsToCapture;
	delete props.eventsToCapture;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../enyo":1,"../Control":16,"../Scrim":40,"../Signals":47,"../dispatcher":57,"../dom":58,"../kind":66,"../utils":75}],53:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	utils = require('../../enyo/lib/utils'),
	dispatcher = require('./dispatcher'),
	platform = require('./platform');

var
	ScrollMath = require('./ScrollMath'),
	ScrollStrategy = require('./ScrollStrategy'),
	ScrollThumb = require('./ScrollThumb'),
	Dom = require('./dom');

/**
* Fires when dragging has started, allowing drags to propagate to parent
* [scrollers]{@link enyo.Scroller}.
*
* @event enyo.TouchScrollStrategy#onShouldDrag
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently
*	propagated the {@glossary event}.
* @property {enyo.Scroller~ScrollEvent} event - An [object]{@glossary Object} containing
*	event information.
* @private
*/

/**
* {@link enyo.TouchScrollStrategy} is a helper [kind]{@glossary kind} for implementing a
* touch-based [scroller]{@link enyo.Scroller}. It integrates the scrolling simulation provided
* by {@link enyo.ScrollMath} into an `enyo.Scroller`.
*
* `enyo.TouchScrollStrategy` is not typically created in application code. Instead, it is
* specified as the value of the [strategyKind]{@link enyo.Scroller#strategyKind} property
* of an `enyo.Scroller` or {@link enyo.List}, or is used by the framework implicitly.
*
* @class enyo.TouchScrollStrategy
* @extends enyo.ScrollStrategy
* @protected
*/
module.exports = kind(
	/** @lends enyo.TouchScrollStrategy.prototype */ {

	name: 'enyo.TouchScrollStrategy',

	/**
	* @private
	*/
	kind: ScrollStrategy,

	/**
		If `true` (the default), the scroller will overscroll and bounce back at the edges.
	*/
	overscroll: true,

	/**
		If `true` (the default), the scroller will not propagate `dragstart`
		events that cause it to start scrolling.
	*/
	preventDragPropagation: true,

	/**
	* @private
	*/
	published:
		/** @lends enyo.TouchScrollStrategy.prototype */ {

		/**
		* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		*
		* @type {String}
		* @default 'default'
		* @public
		*/
		vertical: 'default',

		/**
		* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		*
		* @type {String}
		* @default 'default'
		* @public
		*/
		horizontal: 'default',

		/**
		* Set to `true` to display a scroll thumb.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		thumb: true,

		/**
		* Set to `true` to display a transparent overlay while scrolling. This can help improve
		* performance of complex, large scroll regions on some platforms (e.g., Android).
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		scrim: false,

		/**
		* Indicates whether to allow drag [events]{@glossary event} to be sent while gesture
		* events are happening simultaneously.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		dragDuringGesture: true,

		/**
		* Facades animation time step from [ScrollMath]{@link enyo.ScrollMath}.
		*
		* @type {Number}
		* @default 20
		* @public
		*/
		interval: 20,

		/**
		* Facades animation interval type from [ScrollMath]{@link enyo.ScrollMath}.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		fixedTime: true,

		/**
		* Facades one unit of time for simulation from [ScrollMath]{@link enyo.ScrollMath}.
		*
		* @type {Number}
		* @default 10
		* @public
		*/
		frame: 10,

		/**
		* Indicates whether default [events]{@glossary event} (e.g., native scrolling
		* events) should be suppressed.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		preventDefault: true
	},

	/**
	* @private
	*/
	events: {
		onShouldDrag: ''
	},

	/**
	* @private
	*/
	handlers: {
		onflick: 'flick',
		onShouldDrag: 'shouldDrag',
		ondrag: 'drag'
	},

	/**
	* @private
	*/
	tools: [
		{kind: ScrollMath, onScrollStart: 'scrollMathStart', onScroll: 'scrollMathScroll', onScrollStop: 'scrollMathStop', onStabilize: 'scrollMathStabilize'},
		{name: 'vthumb', kind: ScrollThumb, axis: 'v', showing: false},
		{name: 'hthumb', kind: ScrollThumb, axis: 'h', showing: false}
	],

	/**
	* @private
	*/
	scrimTools: [{name: 'scrim', classes: 'enyo-fit', style: 'z-index: 1;', showing: false}],

	/**
	* @private
	*/
	components: [
		{name: 'client', classes: 'enyo-touch-scroller'}
	],

	/**
	* Flag indicating whether the list is currently reordering.
	*
	* @readonly
	* @public
	*/
	listReordering: false,

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.transform = Dom.canTransform();
			if(!this.transform) {
				if(this.overscroll) {
					//so we can adjust top/left if browser can't handle translations
					this.$.client.applyStyle('position', 'relative');
				}
			}
			this.accel = Dom.canAccelerate();
			var containerClasses = 'enyo-touch-strategy-container';
			// note: needed for ios to avoid incorrect clipping of thumb
			// and need to avoid on Android as it causes problems hiding the thumb
			if (platform.ios && this.accel) {
				containerClasses += ' enyo-composite';
			}
			this.scrimChanged();
			this.intervalChanged();
			this.fixedTimeChanged();
			this.frameChanged();
			this.container.addClass(containerClasses);
			this.translation = this.accel ? 'translate3d' : 'translate';
		};
	}),

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function() {
			this.createChrome(this.tools);
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	destroy: kind.inherit(function (sup) {
		return function() {
			this.container.removeClass('enyo-touch-strategy-container');
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			dispatcher.makeBubble(this.$.client, 'scroll');
			this.calcBoundaries();
			this.syncScrollMath();
			if (this.thumb) {
				this.alertThumbs();
			}
		};
	}),

	/**
	* @private
	*/
	scrimChanged: function () {
		if (this.scrim && !this.$.scrim) {
			this.makeScrim();
		}
		if (!this.scrim && this.$.scrim) {
			this.$.scrim.destroy();
		}
	},

	/**
	* @private
	*/
	makeScrim: function () {
		// reset control parent so scrim doesn't go into client.
		var cp = this.controlParent;
		this.controlParent = null;
		this.createChrome(this.scrimTools);
		this.controlParent = cp;
		var cn = this.container.hasNode();
		// render scrim in container, strategy has no dom.
		if (cn) {
			this.$.scrim.parentNode = cn;
			this.$.scrim.render();
		}
	},

	/**
	* Determines whether or not the scroller is actively moving.
	*
	* @return {Boolean} `true` if actively moving; otherwise, `false`.
	* @public
	*/
	isScrolling: function () {
		var m = this.$.scrollMath;
		return m ? m.isScrolling() : this.scrolling;
	},

	/**
	* Determines whether or not the scroller is in overscroll.
	*
	* @return {Boolean} `true` if in overscroll; otherwise, `false`.
	* @public
	*/
	isOverscrolling: function () {
		var m = this.$.scrollMath || this;
		return (this.overscroll) ? Boolean(m.isInOverScroll()) : false;
	},

	/**
	* @private
	*/
	domScroll: function () {
		if (!this.isScrolling()) {
			this.calcBoundaries();
			this.syncScrollMath();
			if (this.thumb) {
				this.alertThumbs();
			}
		}
	},

	/**
	* @private
	*/
	horizontalChanged: function () {
		this.$.scrollMath.horizontal = (this.horizontal != 'hidden');
	},

	/**
	* @private
	*/
	verticalChanged: function () {
		this.$.scrollMath.vertical = (this.vertical != 'hidden');
	},

	/**
	* @private
	*/
	maxHeightChanged: function () {
		this.$.client.applyStyle('max-height', this.maxHeight);
		// note: previously used enyo-fit here but IE would reset scroll position when the scroll thumb
		// was hidden; in general IE resets scrollTop when there are 2 abs position siblings, one has
		// scrollTop and the other is hidden.
		this.$.client.addRemoveClass('enyo-scrollee-fit', !this.maxHeight);
	},

	/**
	* @private
	*/
	thumbChanged: function () {
		this.hideThumbs();
	},

	/**
	* @private
	*/
	intervalChanged: function () {
		if (this.$.scrollMath) {
			this.$.scrollMath.interval = this.interval;
		}
	},

	/**
	* @private
	*/
	fixedTimeChanged: function () {
		if (this.$.scrollMath) {
			this.$.scrollMath.fixedTime = this.fixedTime;
		}
	},

	/**
	* @private
	*/
	frameChanged: function () {
		if (this.$.scrollMath) {
			this.$.scrollMath.frame = this.frame;
		}
	},

	/**
	* Stops any active scroll movement.
	*
	* @todo Doc update made while merging, need official documentation update!
	*
	* @param {Boolean} emit - Whether or not to fire the `onScrollStop` event.
	* @public
	*/
	stop: function (emit) {
		if (this.isScrolling()) {
			this.$.scrollMath.stop(emit);
		}
	},

	/**
	* Adjusts the scroll position to be valid, if necessary (e.g., after the scroll contents
	* have changed).
	*
	* @public
	*/
	stabilize: function () {
		if(this.$.scrollMath) {
			this.$.scrollMath.stabilize();
		}
	},

	/**
	* Scrolls to a specific position within the scroll area.
	*
	* @param {Number} x - The `x` position in pixels.
	* @param {Number} y - The `y` position in pixels.
	* @public
	*/
	scrollTo: function (x, y) {
		this.stop(true);
		this.$.scrollMath.scrollTo(x, y || y === 0 ? y : null);
	},

	/**
	* Scrolls the given [control]{@link enyo.Control} into view.
	*
	* @param {enyo.Control} ctl - The [control]{@link enyo.Control} to make visible in the
	*	[scroller's]{@link enyo.Scroller} viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the
	*	scroller.
	* @method
	* @public
	*/
	scrollIntoView: kind.inherit(function (sup) {
		return function() {
			this.stop(true);
			sup.apply(this, arguments);
		};
	}),

	/**
	* Sets the horizontal scroll position.
	*
	* @param {Number} left - The horizontal scroll position in pixels.
	* @method
	* @public
	*/
	setScrollLeft: kind.inherit(function (sup) {
		return function() {
			this.stop(true);
			sup.apply(this, arguments);
		};
	}),

	/**
	* Sets the vertical scroll position.
	*
	* @param {Number} top - The vertical scroll position in pixels.
	* @method
	* @public
	*/
	setScrollTop: kind.inherit(function (sup) {
		return function(top) {
			this.stop(true);
			sup.apply(this, arguments);
		};
	}),

	/**
	* Retrieves the horizontal scroll position.
	*
	* @returns {Number} The horizontal scroll position in pixels.
	* @method
	* @public
	*/
	getScrollLeft: kind.inherit(function (sup) {
		return function() {
			return this.isScrolling() ? this.scrollLeft : sup.apply(this, arguments);
		};
	}),

	/**
	* Retrieves the vertical scroll position.
	*
	* @returns {Number} The vertical scroll position in pixels.
	* @method
	* @private
	*/
	getScrollTop: kind.inherit(function (sup) {
		return function() {
			return this.isScrolling() ? this.scrollTop : sup.apply(this, arguments);
		};
	}),

	/**
	* @private
	*/
	calcScrollNode: function () {
		return this.$.client.hasNode();
	},

	/**
	* @private
	*/
	calcAutoScrolling: function () {
		var v = (this.vertical == 'auto');
		var h = (this.horizontal == 'auto') || (this.horizontal == 'default');
		if ((v || h) && this.scrollNode) {
			var b = this.getScrollBounds();
			if (v) {
				this.$.scrollMath.vertical = b.height > b.clientHeight;
			}
			if (h) {
				this.$.scrollMath.horizontal = b.width > b.clientWidth;
			}
		}
	},

	/**
	* @private
	*/
	shouldDrag: function (sender, e) {
		this.calcAutoScrolling();
		var requestV = e.vertical;
		var canH = this.$.scrollMath.horizontal && !requestV;
		var canV = this.$.scrollMath.vertical && requestV;
		var down = e.dy < 0, right = e.dx < 0;
		var oobV = (!down && this.startEdges.top || down && this.startEdges.bottom);
		var oobH = (!right && this.startEdges.left || right && this.startEdges.right);
		// we would scroll if not at a boundary
		if (!e.boundaryDragger && (canH || canV)) {
			e.boundaryDragger = this;
		}
		// include boundary exclusion
		if ((!oobV && canV) || (!oobH && canH)) {
			e.dragger = this;
			return true;
		}
	},

	/**
	* @private
	*/
	flick: function (sender, e) {
		var onAxis = Math.abs(e.xVelocity) > Math.abs(e.yVelocity) ? this.$.scrollMath.horizontal : this.$.scrollMath.vertical;
		if (onAxis && this.dragging) {
			this.$.scrollMath.flick(e);
			return this.preventDragPropagation;
		}
	},

	/**
	* @private
	*/
	down: kind.inherit(function (sup) {
		return function (sender, e) {
			if (!this.isOverscrolling()) {
				sup.apply(this, arguments);
			}
		};
	}),

	/**
	* @private
	*/
	move: function (sender, e) {
	},

	// Special synthetic DOM events served up by the Gesture system

	/**
	* @fires enyo.TouchScrollStrategy#onShouldDrag
	* @private
	*/
	dragstart: function (sender, e) {
		// Ignore drags sent from multi-touch events
		if(!this.dragDuringGesture && e.srcEvent.touches && e.srcEvent.touches.length > 1) {
			return true;
		}
		// note: allow drags to propagate to parent scrollers via data returned in the shouldDrag event.
		this.doShouldDrag(e);
		this.dragging = (e.dragger == this || (!e.dragger && e.boundaryDragger == this));
		if (this.dragging) {
			if(this.preventDefault){
				e.preventDefault();
			}
			// note: needed because show/hide changes
			// the position so sync'ing is required when
			// dragging begins (needed because show/hide does not trigger onscroll)
			this.syncScrollMath();
			this.$.scrollMath.startDrag(e);
			if (this.preventDragPropagation) {
				return true;
			}
		}
	},

	/**
	* @private
	*/
	drag: function (sender, e) {
		// if the list is doing a reorder, don't scroll
		if(this.listReordering) {
			return false;
		}
		if (this.dragging) {
			if(this.preventDefault){
				e.preventDefault();
			}
			this.$.scrollMath.drag(e);
			if (this.scrim) {
				this.$.scrim.show();
			}
		}
	},
	dragfinish: function (sender, e) {
		if (this.dragging) {
			e.preventTap();
			this.$.scrollMath.dragFinish();
			this.dragging = false;
			if (this.scrim) {
				this.$.scrim.hide();
			}
		}
	},

	/**
	* @private
	*/
	mousewheel: function (sender, e) {
		if (!this.dragging && this.useMouseWheel) {
			this.calcBoundaries();
			this.syncScrollMath();
			this.stabilize();
			if (this.$.scrollMath.mousewheel(e)) {
				e.preventDefault();
				return true;
			}
		}
	},

	/**
	* @private
	*/
	scrollMathStart: function () {
		if (this.scrollNode && !this.isScrolling()) {
			this.scrolling = true;
			if (!this.isOverscrolling()) {
				this.calcBoundaries();
			}
		}
	},

	/**
	* @private
	*/
	scrollMathScroll: function (sender) {
		if(!this.overscroll) {
			//don't overscroll past edges
			this.effectScroll(-Math.min(sender.leftBoundary, Math.max(sender.rightBoundary, sender.x)),
					-Math.min(sender.topBoundary, Math.max(sender.bottomBoundary, sender.y)));
		} else {
			this.effectScroll(-sender.x, -sender.y);
		}
		if (this.thumb) {
			this.showThumbs();
			this.delayHideThumbs(100);
		}
	},

	/**
	* @private
	*/
	scrollMathStop: function () {
		this.scrolling = false;
		this.effectScrollStop();
		if (this.thumb) {
			this.delayHideThumbs(100);
		}
	},

	/**
	* @private
	*/
	scrollMathStabilize: function (sender) {
		this.effectScroll(-sender.x, -sender.y);
		if (this.thumb) {
			this.showThumbs();
			this.delayHideThumbs(100);
		}
		return true;
	},

	/**
	* @private
	*/
	calcBoundaries: function () {
		var s = this.$.scrollMath || this, b = this._getScrollBounds();
		s.bottomBoundary = b.clientHeight - b.height;
		s.rightBoundary = b.clientWidth - b.width;
	},

	/**
	* @private
	*/
	syncScrollMath: function () {
		var m = this.$.scrollMath;
		if(m) {
			m.setScrollX(-this.getScrollLeft());
			m.setScrollY(-this.getScrollTop());
		}
	},

	/**
	* @private
	*/
	effectScroll: function (x, y) {
		if (this.scrollNode) {
			this.scrollLeft = this.scrollNode.scrollLeft = x;
			this.scrollTop = this.scrollNode.scrollTop = y;
			this.effectOverscroll(x !== null? Math.round(x): x, y !== null? Math.round(y): y);
		}
	},

	/**
	* @private
	*/
	effectScrollStop: function () {
		this.effectOverscroll(null, null);
	},

	/**
	* @private
	*/
	effectOverscroll: function (x, y) {
		var n = this.scrollNode;
		var xt = '0', yt = '0', zt = this.accel ? ',0' : '';
		if (y !== null && Math.abs(y - n.scrollTop) > 1) {
			yt = (n.scrollTop - y);
		}
		if (x !== null && Math.abs(x - n.scrollLeft) > 1) {
			xt = (n.scrollLeft - x);
		}
		if(!this.transform) {
			//adjust top/left if browser can't handle translations
			this.$.client.setBounds({left:xt + 'px', top:yt + 'px'});
		} else {
			Dom.transformValue(this.$.client, this.translation, xt + 'px, ' + yt + 'px' + zt);
		}
	},

	/**
	* Retrieves the overscroll boundaries of the [scroller]{@link enyo.Scroller}.
	*
	* @returns {enyo.Scroller~OverscrollBoundaryObject} An [object]{@glossary Object}
	*	describing the overscroll boundaries.
	* @public
	*/
	getOverScrollBounds: function () {
		var m = this.$.scrollMath || this;
		return {
			overleft: Math.min(m.leftBoundary - m.x, 0) || Math.max(m.rightBoundary - m.x, 0),
			overtop: Math.min(m.topBoundary - m.y, 0) || Math.max(m.bottomBoundary - m.y, 0)
		};
	},

	/**
	* @method
	* @private
	*/
	_getScrollBounds: kind.inherit(function (sup) {
		return function() {
			var r = sup.apply(this, arguments);
			utils.mixin(r, this.getOverScrollBounds());
			return r;
		};
	}),

	/**
	* Retrieves the scroll boundaries of the [scroller]{@link enyo.Scroller}.
	*
	* @returns {enyo.Scroller~BoundaryObject} An [object]{@glossary Object} describing the
	*	scroll boundaries.
	* @method
	* @public
	*/
	getScrollBounds: kind.inherit(function (sup) {
		return function() {
			this.stop(true);
			return sup.apply(this, arguments);
		};
	}),

	/**
	* This method exists primarily to support an internal use case for
	* [enyo.DataList]{@link enyo.DataList}. It is intended to be called by the
	* [scroller]{@link enyo.Scroller} that owns this strategy.
	*
	* Triggers a remeasurement of the scroller's metrics (specifically, the
	* size of its viewport, the size of its contents and the difference between
	* the two, which determines the extent to which the scroller may scroll).
	*
	* @public
	*/
	remeasure: function () {
		this.calcBoundaries();
		if (this.thumb) {
			this.syncThumbs();
		}
		this.stabilize();
	},

	/**
	* Displays the scroll indicators and sets the auto-hide timeout.
	*
	* @public
	*/
	alertThumbs: function () {
		this.showThumbs();
		this.delayHideThumbs(500);
	},

	/**
	* Syncs the vertical and horizontal scroll indicators.
	*
	* @public
	*/
	syncThumbs: function () {
		this.$.vthumb.sync(this);
		this.$.hthumb.sync(this);
	},
	updateThumbs: function () {
		this.$.vthumb.update(this);
		this.$.hthumb.update(this);
	},

	/**
	* Syncs and shows both the vertical and horizontal scroll indicators. We only sync after we
	* have checked if the vertical and/or horizontal scroll indicators are to be shown, so that
	* {@link enyo.ScrollThumb#update} accurately makes calculations when the indicators are
	* visible.
	*
	* @public
	*/
	showThumbs: function () {
		if (this.horizontal != 'hidden') {
			this.$.hthumb.show();
		}
		if (this.vertical != 'hidden') {
			this.$.vthumb.show();
		}
		this.syncThumbs();
	},

	/**
	* Hides the vertical and horizontal scroll indicators.
	*
	* @public
	*/
	hideThumbs: function () {
		this.$.vthumb.hide();
		this.$.hthumb.hide();
	},

	/**
	* Hides the vertical and horizontal scroll indicators asynchronously.
	*
	* @public
	*/
	delayHideThumbs: function (delay) {
		this.$.vthumb.delayHide(delay);
		this.$.hthumb.delayHide(delay);
	}
});
},{"../../enyo":1,"../../enyo/lib/utils":75,"./ScrollMath":41,"./ScrollStrategy":42,"./ScrollThumb":43,"./dispatcher":57,"./dom":58,"./kind":66,"./platform":71}],85:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	FittableLayout = require('./FittableLayout'),
	FittableColumnsLayout = FittableLayout.Columns;

/**
* {@link enyo.FittableColumns} provides a container in which items are laid out in a
* set of vertical columns, with most items having natural size, but one
* expanding to fill the remaining space. The one that expands is labeled with
* the attribute `fit: true`.
*
* For more information, see the documentation on
* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the
* Enyo Developer Guide.
*
* @ui
* @class  enyo.FittableColumns
* @extends enyo.Control
* @public
*/
module.exports = kind(/** @lends  enyo.FittableColumns.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.FittableColumns',

	/**
	* A {@glossary kind} used to manage the size and placement of child
	* [components]{@link enyo.Component}.
	*
	* @type {String}
	* @default ''
	* @private
	*/
	layoutKind: FittableColumnsLayout,

	/**
	* By default, items in columns stretch to fit vertically; set to `true` to
	* avoid this behavior.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	noStretch: false
});
},{"../../enyo/lib/kind":66,"./FittableLayout":87}],86:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	FittableLayout = require('./FittableLayout'),
	FittableColumnsLayout = FittableLayout.Columns;

/**
* {@link enyo.FittableHeaderLayout} extends {@link enyo.FittableColumnsLayout},
* providing a container in which items are laid out in a set of vertical columns,
* with most items having natural size, but one expanding to fill the remaining
* space. The one that expands is labeled with the attribute `fit: true`.
*
* For more information, see the documentation on
* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the
* Enyo Developer Guide.
*
* @class  enyo.FittableHeaderLayout
* @extends enyo.FittableColumnsLayout
* @public
*/
module.exports = kind(/** @lends  enyo.FittableHeaderLayout.prototype */{

	/**
	* @private
	*/
	name: 'enyo.FittableHeaderLayout',

	/**
	* @private
	*/
	kind: FittableColumnsLayout,

	/**
	* @private
	*/
	applyFitSize: function(measure, total, before, after) {
		var padding = before - after;
		var f = this.getFitControl();

		if (padding < 0) {
			f.applyStyle('padding-left', Math.abs(padding) + 'px');
			f.applyStyle('padding-right', null);
		} else if (padding > 0) {
			f.applyStyle('padding-left', null);
			f.applyStyle('padding-right', Math.abs(padding) + 'px');
		} else {
			f.applyStyle('padding-left', null);
			f.applyStyle('padding-right', null);
		}

		FittableColumnsLayout.prototype.applyFitSize.apply(this, arguments);
	}
});
},{"../../enyo/lib/kind":66,"./FittableLayout":87}],88:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind')	;

var
	FittableLayout = require('./FittableLayout'),
	FittableRowsLayout = FittableLayout.Rows;

/**
* {@link enyo.FittableRows} provides a container in which items are laid out in a
* set	of horizontal rows, with most of the items having natural size, but one
* expanding to fill the remaining space. The one that expands is labeled with
* the attribute `fit: true`.
*
* For more information, see the documentation on
* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the
* Enyo Developer Guide.
*
* @ui
* @class  enyo.FittableRows
* @extends enyo.Control
* @public
*/
module.exports = kind(/** @lends  enyo.FittableRows.prototype */{

	/**
	* @private
	*/
	name: 'enyo.FittableRows',

	/**
	* A {@glossary kind} used to manage the size and placement of child
	* [components]{@link enyo.Component}.
	*
	* @type {String}
	* @default ''
	* @private
	*/
	layoutKind: FittableRowsLayout,

	/**
	* By default, items in columns stretch to fit horizontally; set to `true` to
	* avoid this behavior.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	noStretch: false
});
},{"../../enyo/lib/kind":66,"./FittableLayout":87}],10:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind');
var
	ToolDecorator = require('../ToolDecorator');

/**
* {@link enyo.Button} implements an HTML [button]{@glossary button}, with support
* for grouping using {@link enyo.Group}.
*
* For more information, see the documentation on
* [Buttons]{@linkplain $dev-guide/building-apps/controls/buttons.html} in the
* Enyo Developer Guide.
*
* @class enyo.Button
* @extends enyo.ToolDecorator
* @ui
* @public
*/
module.exports = kind(
	/** @lends enyo.Button.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.Button',
	
	/**
	* @private
	*/
	kind: ToolDecorator,

	/**
	* @private
	*/
	tag: 'button',

	/**
	* @private
	*/
	attributes: {
		/**
		 * Set to `'button'`; otherwise, the default value would be `'submit'`, which
		 * can cause unexpected problems when [controls]{@link enyo.Control} are used
		 * inside of a [form]{@glossary form}.
		 * 
		 * @type {String}
		 * @private
		 */
		type: 'button'
	},
	
	/**
	* @private
	*/
	published: 
		/** @lends enyo.Button.prototype */ {
		
		/**
		 * When `true`, the [button]{@glossary button} is shown as disabled and does not 
		 * generate tap [events]{@glossary event}.
		 * 
		 * @type {Boolean}
		 * @default false
		 * @public
		 */
		disabled: false
	},
	
	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.disabledChanged();
		};
	}),

	/**
	* @private
	*/
	disabledChanged: function () {
		this.setAttribute('disabled', this.disabled);
	},

	/**
	* @private
	*/
	tap: function () {
		if (this.disabled) {
			// work around for platforms like Chrome on Android or Opera that send
			// mouseup to disabled form controls
			return true;
		} else {
			this.setActive(true);
		}
	}
});
},{"../../../enyo":1,"../ToolDecorator":52,"../kind":66}],54:[function(require,module,exports){
require('../../enyo');

var
	kind = require('./kind'),
	dispatcher = require('./dispatcher');

var
	TouchScrollStrategy = require('./TouchScrollStrategy'),
	Dom = require('./dom');

/**
* {@link enyo.TranslateScrollStrategy} is a helper [kind]{@glossary kind} that extends
* {@link enyo.TouchScrollStrategy}, optimizing it for scrolling environments in which effecting 
* scroll changes with transforms using CSS translations is fastest.
* 
* `enyo.TranslateScrollStrategy` is not typically created in application code. Instead, it is 
* specified as the value of the [strategyKind]{@link enyo.Scroller#strategyKind} property of 
* an {@link enyo.Scroller} or {@link enyo.List}, or is used by the framework implicitly.
*
* @class enyo.TranslateScrollStrategy
* @extends enyo.TouchScrollStrategy
* @protected
*/
module.exports = kind(
	/** @lends enyo.TranslateScrollStrategy.prototype */ {

	name: 'enyo.TranslateScrollStrategy',

	/**
	* @private
	*/
	kind: TouchScrollStrategy,

	/** 
	* Set to `true` to optimize the strategy to only use translation to scroll; this increases 
	* fluidity of scrolling animation. It should not be used when the 
	* [scroller]{@link enyo.Scroller} contains [controls]{@link enyo.Control} that require 
	* keyboard input. This is because when `translateOptimized` is `true`, it is possible to 
	* position inputs such that they will not become visible when focused.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	translateOptimized: false,
	
	/**
	* @private
	*/
	components: [
		{name: 'clientContainer', classes: 'enyo-touch-scroller', components: [
			{name: 'client'}
		]}
	],

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			dispatcher.makeBubble(this.$.clientContainer, 'scroll');
			if (this.translateOptimized) {
				this.setStartPosition();
			}
		};
	}),

	/**
	* @method
	* @private
	*/
	setStartPosition: function() {
		this.startX = this.getScrollLeft();
		this.startY = this.getScrollTop();
	},

	/**
	* @private
	*/
	getScrollSize: function () {
		var n = this.$.client.hasNode();
		return {width: n ? n.scrollWidth : 0, height: n ? n.scrollHeight : 0};
	},

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			// apply initial transform so we're always composited
			Dom.transformValue(this.$.client, this.translation, '0,0,0');
		};
	}),
	
	/**
	* @private
	*/
	calcScrollNode: function () {
		return this.$.clientContainer.hasNode();
	},

	/**
	* @private
	*/
	maxHeightChanged: function () {
		// content should cover scroller at a minimum if there's no max-height.
		this.$.client.applyStyle('min-height', this.maxHeight ? null : '100%');
		this.$.client.applyStyle('max-height', this.maxHeight);
		this.$.clientContainer.addRemoveClass('enyo-scrollee-fit', !this.maxHeight);
	},

	/**
	* @method
	* @private
	*/
	shouldDrag: kind.inherit(function (sup) {
		return function(inEvent) {
			// stop and update drag info before checking drag status
			this.stop();
			this.calcStartInfo();
			return sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	syncScrollMath: kind.inherit(function (sup) {
		return function() {
			if (!this._translated) {
				sup.apply(this, arguments);
			}
		};
	}),
	
	/**
	* Sets the horizontal scroll position.
	*
	* @param {Number} left - The horizontal scroll position in pixels.
	* @method
	* @public
	*/
	setScrollLeft: kind.inherit(function (sup) {
		return function(inLeft) {
			var m, p;
			if (this.translateOptimized) {
				p = this.scrollLeft;
				m = this.$.scrollMath;
				this.stop(true);
				m.setScrollX(-inLeft);
				m.stabilize();
				if (p != -m.x) {
					// We won't get a native scroll event,
					// so need to make one ourselves
					m.doScroll();
					this.delayHideThumbs(100);
				} 
			} else {
				sup.apply(this, arguments);
			}
		};
	}),
	
	/**
	* Sets the vertical scroll position.
	*
	* @param {Number} top - The vertical scroll position in pixels.
	* @method
	* @public
	*/
	setScrollTop: kind.inherit(function (sup) {
		return function(inTop) {
			var m, p;
			if (this.translateOptimized) {
				p = this.scrollTop;
				m = this.$.scrollMath;
				this.stop(true);
				m.setScrollY(-inTop);
				m.stabilize();
				if (p != -m.y) {
					// We won't get a native scroll event,
					// so need to make one ourselves
					m.doScroll();
					this.delayHideThumbs(100);
				}
			} else {
				sup.apply(this, arguments);
			}
		};
	}),
	
	/**
	* Retrieves the horizontal scroll position.
	*
	* @returns {Number} The horizontal scroll position in pixels.
	* @method
	* @public
	*/
	getScrollLeft: kind.inherit(function (sup) {
		return function() {
			return this._translated ? this.scrollLeft: sup.apply(this, arguments);
		};
	}),
	
	/**
	* Retrieves the vertical scroll position.
	*
	* @returns {Number} The vertical scroll position in pixels.
	* @method
	* @private
	*/
	getScrollTop: kind.inherit(function (sup) {
		return function() {
			return this._translated ? this.scrollTop : sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	calcBoundaries: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			if (this.translateOptimized && !this.isScrolling()) this.stabilize();
		};
	}),

	/**
	* @method
	* @private
	*/
	handleResize: function() {
		if (this.translateOptimized) {
			this.stabilize();
		}
	},
	
	/**
	* @method
	* @private
	*/
	scrollMathStart: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			if (!this._translated) {
				this.setStartPosition();
			}
		};
	}),

	/**
	* @private
	*/
	scrollMathScroll: function (sender) {
		if(!this.overscroll) { //don't overscroll past edges
			this.scrollLeft = -Math.min(sender.leftBoundary, Math.max(sender.rightBoundary, sender.x));
			this.scrollTop = -Math.min(sender.topBoundary, Math.max(sender.bottomBoundary, sender.y));
		} else {
			this.scrollLeft = -sender.x;
			this.scrollTop = -sender.y;
		}
		this.effectScroll(this.scrollLeft, this.scrollTop);
		if (this.thumb) {
			this.showThumbs();
		}
	},

	/**
	* @private
	*/
	scrollMathStabilize: kind.inherit(function (sup) {
		return function (sender) {
			if (this._translated) {
				this.scrollLeft = -sender.x;
				this.scrollTop = -sender.y;
				this.effectScroll(-sender.x, -sender.y);
				return true;
			} else {
				return sup.apply(this, arguments);
			}
		};
	}),

	/**
	* While moving, scroller uses translate.
	* 
	* @private
	*/
	effectScroll: kind.inherit(function (sup) {
		return function (x, y) {
			var o;
			if (this.translateOptimized || this.isScrolling()) {
				x = this.startX - x;
				y = this.startY - y;
				o = x + 'px, ' + y + 'px' + (this.accel ? ',0' : '');
				Dom.transformValue(this.$.client, this.translation, o);
				this._translated = true;
			} else {
				sup.apply(this, arguments);
			}
		};
	}),

	/**
	* When stopped, we use `scrollLeft/scrollTop` (makes cursor positioning automagic).
	* 
	* @private
	*/
	effectScrollStop: function () {
		if (!this.translateOptimized) {
			var t = '0,0' + (this.accel ? ',0' : '');
			// FIXME: normally translate3d changes not effect scrollHeight; however
			// there appear to be some dom changes (e.g. showing a node inside the scroller,
			// which do cause the scrollHeight to be changed from the translate3d.
			// In this case setting the translate3d back to 0 does not restore scrollHeight.
			// This causes a problem because setting scrollTop can produced an unexpected result if
			// scrollHeight is less than expected.
			// We detect this fault by validating scroll bounds and (1) un-apply the translate3d,
			// (2) update scrollTop/Left, and (3) re-apply a 0,0,0 translate3d to ensure compositing.
			// Luckily this corrects the problem (which appears to be a webkit bug). Note that
			// it's important to maintain a composited state (translate3d 0,0,0) or Android 4 is
			// slow to start scrolling.
			var m = this.$.scrollMath, sb = this._getScrollBounds();
			var needsBoundsFix = Boolean((sb.maxTop + m.bottomBoundary) || (sb.maxLeft + m.rightBoundary));
			Dom.transformValue(this.$.client, this.translation, needsBoundsFix ? null : t);
			// note: this asynchronously triggers dom scroll event
			this.setScrollLeft(this.scrollLeft);
			this.setScrollTop(this.scrollTop);
			if (needsBoundsFix) {
				Dom.transformValue(this.$.client, this.translation, t);
			}
			this._translated = false;
		}
	},

	/**
	* FIXME: we can fix scrolling artifacts BUGS on Android 4.04 with this heinous incantation.
	* 
	* @private
	*/
	twiddle: function () {
		if (this.translateOptimized && this.scrollNode) { // this.scrollNode is not always defined and makes Motorola XOOM crash
			this.scrollNode.scrollTop = 1;
			this.scrollNode.scrollTop = 0;
		}
	}
});
},{"../../enyo":1,"./TouchScrollStrategy":53,"./dispatcher":57,"./dom":58,"./kind":66}],133:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	utils = require('../../../enyo/lib/utils'),
	Control = require('../../../enyo/lib/Control');

var
	FittableLayout = require('../../../layout/lib/FittableLayout'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	Slideable = require('../../../layout/lib/Slideable'),
	FittableColumnsLayout = FittableLayout.Columns,
	FittableRowsLayout = FittableLayout.Rows;

var SlideableInfo = kind({
	kind: Control,
	published: {
		info: null
	},
	components: [
		{kind: FittableRows, classes: 'slideableinfo-sample', components: [
			{name: 'name'},
			{name: 'axis'},
			{name: 'unit'},
			{name: 'min'},
			{name: 'max'},
			{name: 'value'}
		]}
	],
	handlers: {
		onUpdateInfo: 'updateInfo'
	},
	create: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.infoChanged();
		};
	}),
	infoChanged: function() {
		for (var p in this.info) {
			if (this.$[p]) {
				this.$[p].setContent(utils.cap(p) + ': ' + this.info[p]);
			}
		}
	},
	updateInfo: function(inSender, inEvent) {
		this.setInfo(inEvent);
		return true;
	}
});

module.exports = kind({
	name: 'enyo.sample.SlideableSample',
	classes: 'enyo-unselectable enyo-fit',
	style: 'overflow: hidden; background-color: #000;',
	components: [
		{name: 'top', kind: Slideable, axis: 'v', unit: '%', min: -90, max: 0, classes: 'enyo-fit slideable-sample top', onChange: 'updateInfo'},
		{name: 'right', kind: Slideable, axis: 'h', unit: '%', min: 0, max: 90, classes: 'enyo-fit slideable-sample right', onChange: 'updateInfo'},
		{name: 'bottom', kind: Slideable, axis: 'v', unit: '%', min: 0, max: 90, classes: 'enyo-fit slideable-sample bottom', onChange: 'updateInfo'},
		{name: 'left', kind: Slideable, axis: 'h', unit: '%', min: -90, max: 0, classes: 'enyo-fit slideable-sample left', onChange: 'updateInfo'}
	],
	handlers: {
		ondragstart: 'suppressPanelDrag'
	},
	create: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			var slideables = [];

			for (var c in this.$) {
				if (this.$[c].kind === 'Slideable') {
					slideables.push(this.$[c]);
				}
			}
			this.populate(slideables);
		};
	}),
	populate: function(inSlideables) {
		var slideable;
		for (var i = 0; i < inSlideables.length; i++) {
			slideable = inSlideables[i];
			slideable.createComponents([
				{style: slideable.axis === 'h' ? 'height: 38%;' : ''}, // cheating here for the horizontal Slideables to make everything nice and (almost) centered vertically
				{
					kind: SlideableInfo,
					layoutKind: (slideable.axis === 'v') ? FittableColumnsLayout : FittableRowsLayout,
					classes: 'enyo-center', // cheating here for the vertical Slideables to make everything nice and centered horizontally (no effect on horizontal Slideables)
					info: {
						name: slideable.name,
						axis: slideable.axis,
						unit: slideable.unit,
						min: slideable.min,
						max: slideable.max,
						value: slideable.value
					}
				}
			]);
		}
	},
	updateInfo: function(inSender) {
		inSender.waterfallDown('onUpdateInfo', {
			name: inSender.name,
			axis: inSender.axis,
			unit: inSender.unit,
			min: inSender.min,
			max: inSender.max,
			value: Math.round(inSender.value)
		});
		return true;
	},
	// keeps the view panel from moving in Sampler app while dragging the Slideable
	suppressPanelDrag: function() {
		return true;
	}
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/FittableLayout":87,"../../../layout/lib/FittableRows":88,"../../../layout/lib/Slideable":102}],107:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	drag = require('../../../enyo/lib/drag'),
	Animator = require('../../../enyo/lib/Animator'),
	Button = require('../../../enyo/lib/Button'),
	Select = require('../../../enyo/lib/Select');

var
	easing = require('../../../layout/lib/easing');

module.exports = kind({
	name: 'moon.sample.EasingSample',
	classes: 'enyo-unselectable easing-sample',
	components: [
		{kind: Animator, name: 'animator', onStep: 'animatorStep', onEnd: 'animatorComplete', easingFunction: easing.linear},
		{name: 'container', classes: 'easing-sample-ball-container', components: [
			{name: 'box', classes: 'easing-sample-ball'}
		]},
		{classes: 'easing-sample-control-container', style: 'display:inline-block;', components: [
			{name: 'menu', kind: Select, onchange: 'itemSelected', components: [
				{content: 'Easing Type'}
			]},
			{name: 'btnAnimate', kind: Button, content: 'Animate', ontap: 'play'}
		]}
	],
	duration: 1000,
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.buildMenu();
		};
	}),
	itemSelected: function(sender, event) {
		var item = Object.keys(easing)[sender.selected - 1];
		this.$.animator.setEasingFunction(easing[item] || easing.linear);
		this.play();
	},
	play: function() {
		this.$.btnAnimate.set('disabled', true);
		this.$.animator.play({
			startValue: 0,
			endValue: 150,
			node: this.$.box.hasNode(),
			duration: this.duration
		});
	},
	animatorStep: function(sender) {
		this.$.box.applyStyle('top', sender.value + 'px');
		return true;
	},
	animatorComplete: function(sender) {
		this.$.btnAnimate.set('disabled', false);
		return true;
	},
	buildMenu: function() {
		for (var k in easing){
			this.$.menu.createComponent({content: k});
		}
	}
});

},{"../../../enyo/lib/Animator":5,"../../../enyo/lib/Button":10,"../../../enyo/lib/Select":45,"../../../enyo/lib/drag":59,"../../../enyo/lib/kind":66,"../../../layout/lib/easing":105}],108:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button'),
	Control = require('../../../enyo/lib/Control'),
	Input = require('../../../enyo/lib/Input');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableAppLayout1',
	kind: FittableRows,
	classes: 'enyo-fit',
	components: [
		{kind: Control, classes: 'layout-sample-toolbar', components: [
			{content: 'Header'},
			{kind: Button, content: 'Button'},
			{kind: 'enyo.ToolDecorator', tag: 'label', components: [
				{kind: Input}
			]}
		]},
		{kind: FittableColumns, fit: true, components: [
			{classes: 'fittable-sample-column'},
			{kind: FittableRows, fit: true, classes: 'fittable-sample-shadow', components: [
				{classes: 'fittable-sample-row fittable-sample-shadow2'},
				{fit: true, classes: 'fittable-sample-fitting-color'}
			]}
		]}
	]
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Control":16,"../../../enyo/lib/Input":24,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],109:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableAppLayout2',
	kind: FittableColumns,
	classes: 'enyo-fit',
	components: [
		{kind: FittableRows, classes: 'fittable-sample-column', components: [
			{fit: true},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '1'}
			]}
		]},
		{kind: FittableRows, classes: 'fittable-sample-column fittable-sample-shadow', components: [
			{fit: true, style: ''},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '2'}
			]}
		]},
		{kind: FittableRows, fit: true, classes: 'fittable-sample-shadow', components: [
			{fit: true, classes: 'fittable-sample-fitting-color'},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '3'}
			]}
		]}
	]
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],110:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableAppLayout3',
	kind: FittableColumns,
	classes: 'enyo-fit',
	components: [
		{kind: FittableRows, fit: true, components: [
			{fit: true, classes: 'fittable-sample-fitting-color'},
			{classes: 'fittable-sample-row fittable-sample-shadow3'},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '1'}
			]}
		]},
		{kind: FittableRows, classes: 'fittable-sample-column fittable-sample-shadow', components: [
			{fit: true},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '2'}
			]}
		]}
	]
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],111:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableAppLayout4',
	kind: FittableColumns,
	classes: 'enyo-fit',
	components: [
		{kind: FittableRows, classes: 'fittable-sample-column fittable-sample-shadow4', components: [
			{fit: true},
			{classes: 'layout-sample-toolbar', components: [
				{content: 'Toolbar'}
			]}
		]},
		{kind: FittableRows, fit: true, components: [
			{fit: true, classes: 'fittable-sample-fitting-color'},
			{classes: 'layout-sample-toolbar', components: [
				{kind: Button, content: '2'}
			]}
		]}
	]
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],113:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableHeaderLayout = require('../../../layout/lib/FittableHeaderLayout'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableSample',
	kind: FittableRows,
	classes: 'fittable-sample-box enyo-fit',
	components: [
		{layoutKind: FittableHeaderLayout, components:[
			{kind: Button, content: 'Back'},
			{content: 'Fittable Sample', fit: true, style: 'text-align:center'},
			{kind: Button, content: 'Action 1'},
			{kind: Button, content: 'Action 2'}
		]},
		{content: 'Foo<br>Foo', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mtb'},
		{content: 'Foo<br>Foo', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mtb'},
		{kind: FittableColumns, fit: true, classes: 'fittable-sample-box fittable-sample-mtb fittable-sample-o', components: [
			{content: 'Foo', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'Foo', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'Fits!', fit: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-o'},
			{content: 'Foo', classes: 'fittable-sample-box fittable-sample-mlr'}
		]},
		{kind: FittableColumns, content: 'Bat', classes: 'fittable-sample-box fittable-sample-mtb enyo-center', components: [
			{content: 'Centered', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: '1', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: '2', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: '3', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: '4', classes: 'fittable-sample-box fittable-sample-mlr'}
		]}
	]
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableHeaderLayout":86,"../../../layout/lib/FittableRows":88}],44:[function(require,module,exports){
require('../../../enyo');



var
	kind = require('../kind'),
	utils = require('../utils'),
	platform = require('../platform');

var
	Control = require('../Control'),
	ScrollStrategy = require('../ScrollStrategy'),
	TouchScrollStrategy = require('../TouchScrollStrategy'),
	TranslateScrollStrategy = require('../TranslateScrollStrategy');

/**
* An [object]{@glossary Object} representing the scroll boundaries.
*
* @typedef {Object} enyo.Scroller~BoundaryObject
* @property {Number} left - The left scroll position.
* @property {Number} top - The top scroll position.
* @property {Number} maxLeft - Maximum value for the left scroll position (minimum is always 0).
* @property {Number} maxTop - Maximum value for the top scroll position (minimum is always 0).
* @property {Number} clientHeight - The vertical size of the [scroller]{@link enyo.Scroller} on
*	screen.
* @property {Number} clientWidth - The horizontal size of the [scroller]{@link enyo.Scroller} on
*	screen.
* @property {Number} width - The horizontal size of the full area of the scrolled region.
* @property {Number} height - The vertical size of the full area of the scrolled region.
* @property {Number} xDir - Either `1`, `-1`, or `0`, indicating positive movement along the
*	x-axis, negative movement, or no movement, respectively.
* @property {Number} yDir - Either `1`, `-1`, or `0`, indicating positive movement along the
*	y-axis, negative movement, or no movement, respectively.
*/


/**
* An [object]{@glossary Object} representing the overscroll boundaries.
*
* @typedef {Object} enyo.Scroller~OverscrollBoundaryObject
* @property {Number} overleft - The left overscroll position.
* @property {Number} overtop - The top overscroll position.
*/

/**
* The extended {@glossary event} [object]{@glossary Object} that is provided 
* when a scroll event is fired.
*
* @typedef {Object} enyo.Scroller~ScrollEvent
* @property {enyo.Scroller~BoundaryObject} bounds Current values of scroller bounds.
*/

/**
* Fires when a scrolling action starts.
*
* @event enyo.Scroller#onScrollStart
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {enyo.Scroller~ScrollEvent} event - An [object]{@glossary Object} containing 
*	event information.
* @public
*/

/**
* Fires while a scrolling action is in progress.
*
* @event enyo.Scroller#onScroll
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing 
*	event information.
* @public
*/

/**
* Fires when a scrolling action stops.
*
* @event enyo.Scroller#onScrollStop
* @type {Object}
* @property {Object} sender - The [component]{@link enyo.Component} that most recently 
*	propagated the {@glossary event}.
* @property {Object} event - An [object]{@glossary Object} containing 
*	event information.
* @public
*/

/**
* {@link enyo.Scroller} is a scroller suitable for use in both desktop and mobile
* applications.
* 
* In some mobile environments, a default scrolling solution is not implemented for
* DOM elements. In such cases, `enyo.Scroller` implements a touch-based scrolling
* solution, which may be opted into either globally (by setting
* [touchScrolling]{@link enyo.Scroller#touchScrolling} to `true`) or on a
* per-instance basis (by specifying a [strategyKind]{@link enyo.Scroller#strategyKind}
* of `"TouchScrollStrategy"`).
* 
* For more information, see the documentation on
* [Scrollers]{@linkplain $dev-guide/building-apps/layout/scrollers.html} in the
* Enyo Developer Guide.
*
* @class enyo.Scroller
* @public
*/
var Scroller = module.exports = kind(
	/** @lends enyo.Scroller.prototype */ {
	
	name: 'enyo.Scroller',
	
	kind: Control,
	
	/**
	* @private
	*/
	published: 
		/** @lends enyo.Scroller.prototype */ {

		/**
		* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		* 
		* @type {String}
		* @default 'default'
		* @public
		*/
		horizontal: 'default',

		/**
		* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,
		* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the
		* scroll strategy.
		* 
		* @type {String}
		* @default 'default'
		* @public
		*/
		vertical: 'default',

		/**
		* The vertical scroll position.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		scrollTop: 0,

		/**
		* The horizontal scroll position.
		* 
		* @type {Number}
		* @default 0
		* @public
		*/
		scrollLeft: 0,

		/**
		* Maximum height of the scroll content.
		* 
		* @type {Number}
		* @default null
		* @memberof enyo.Scroller.prototype
		* @public
		*/
		maxHeight: null,

		/**
		* Set to `true` to make this [scroller]{@link enyo.Scroller} select a 
		* platform-appropriate touch-based scrolling strategy. Note that if you specify a value 
		* for [strategyKind]{@link enyo.Scroller#strategyKind}, that will take precedence over
		* this setting.
		* 
		* @type {Boolean}
		* @default false
		* @public
		*/
		touch: false,
		/**
		* Specifies a type of scrolling. The [scroller]{@link enyo.Scroller} will attempt to 
		* automatically select a strategy compatible with the runtime environment. Alternatively,
		* you may choose to use a specific strategy:
		* 
		* - [ScrollStrategy]{@link enyo.ScrollStrategy} is the default and implements no 
		*	scrolling, relying instead on the environment to scroll properly.
		* - [TouchScrollStrategy]{@link enyo.TouchScrollStrategy} implements a touch scrolling 
		*	mechanism.
		* - [TranslateScrollStrategy]{@link enyo.TranslateScrollStrategy} implements a touch 
		*	scrolling mechanism using translations; it is currently recommended only for Android
		*	3 and 4, and Windows Phone 8.
		* - [TransitionScrollStrategy]{@link enyo.TransitionScrollStrategy} implements a touch 
		*	scrolling mechanism using CSS transitions; it is currently recommended only for iOS 
		*	5 and later.
		*
		* @type {String}
		* @default 'ScrollStrategy'
		* @public
		*/
		strategyKind: ScrollStrategy,

		/**
		* Set to `true` to display a scroll thumb in touch [scrollers]{@link enyo.Scroller}.
		* 
		* @type {Boolean}
		* @default true
		* @public
		*/
		thumb: true,

		/**
		* If `true`, mouse wheel may be used to move the [scroller]{@link enyo.Scroller}.
		* 
		* @type {Boolean}
		* @default true
		* @public
		*/
		useMouseWheel: true
	},

	/**
	* @private
	*/
	events: {
		onScrollStart: '',
		onScroll: '',
		onScrollStop: ''
	},

	/**
	* If `true`, enables touch scrolling globally.
	*
	* @name touchScrolling
	* @type {Boolean}
	* @default undefined
	* @memberof enyo.Scroller.prototype
	* @public
	*/

	/**
	* If `true` and this is a touch [scroller]{@link enyo.Scroller}, the scroller
	* will overscroll and bounce back at the edges.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	touchOverscroll: true,

	/**
	* If `true`, the [scroller]{@link enyo.Scroller} will not propagate `dragstart` 
	* [events]{@glossary event} that cause it to start scrolling.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	preventDragPropagation: true,

	/**
	* If `true`, the [scroller]{@link enyo.Scroller} will not propagate scroll 
	* [events]{@glossary event}.
	*
	* @type {Boolean}
	* @default true
	* @public
	*/
	preventScrollPropagation: true,

	/**
	* Needed to allow global mods to `enyo.Scroller.touchScrolling`.
	* 
	* @private
	*/


	/**
	* @private
	*/
	handlers: {
		onscroll: 'domScroll',
		onScrollStart: 'scrollStart',
		onScroll: 'scroll',
		onScrollStop: 'scrollStop'
	},

	/**
	* @private
	*/
	classes: 'enyo-scroller',

	/**
	* @private
	*/
	statics: {
		osInfo: [
			{os: 'android', version: 3},
			{os: 'androidChrome', version: 18},
			{os: 'androidFirefox', version: 16},
			{os: 'firefoxOS', version: 16},
			{os: 'ios', version: 5},
			{os: 'webos', version: 1e9},
			{os: 'blackberry', version:1e9},
			{os: 'tizen', version: 2}
		],
		//* Returns true if platform should have touch events.
		hasTouchScrolling: function() {
			for (var i=0, t; (t=this.osInfo[i]); i++) {
				if (platform[t.os]) {
					return true;
				}
			}
			// special detection for IE10+ on touch devices
			if ((platform.ie >= 10 || platform.windowsPhone >= 8) && platform.touch) {
				return true;
			}
		},
		/**
			Returns true if the platform has native div scrollers (desktop
			browsers always have them).
		*/
		hasNativeScrolling: function() {
			for (var i=0, t; (t=this.osInfo[i]); i++) {
				if (platform[t.os] < t.version) {
					return false;
				}
			}
			return true;
		},
		getTouchStrategy: function() {
			return (platform.androidChrome >= 27) || (platform.android >= 3) || (platform.windowsPhone === 8) || (platform.webos >= 4)
				? TranslateScrollStrategy
				: TouchScrollStrategy;
		}
	},

	/**
	* @private
	*/
	controlParentName: 'strategy',

	/**
	* @method
	* @private
	*/
	create: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.horizontalChanged();
			this.verticalChanged();
			this.useMouseWheelChanged();
		};
	}),

	/**
	* @method
	* @private
	*/
	importProps: kind.inherit(function (sup) {
		return function(inProps) {
			sup.apply(this, arguments);
			// allow global overriding of strategy kind
			if (inProps && inProps.strategyKind === undefined && (Scroller.touchScrolling || this.touch)) {
				this.strategyKind = Scroller.getTouchStrategy();
			}
		};
	}),

	/**
	* @method
	* @private
	*/
	initComponents: kind.inherit(function (sup) {
		return function() {
			this.strategyKindChanged();
			sup.apply(this, arguments);
		};
	}),

	/**
	* @method
	* @private
	*/
	rendered: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			this.syncStrategy();
		};
	}),

	/**
	* @method
	* @private
	*/
	syncStrategy: function() {
		this.$.strategy.setScrollLeft(this.scrollLeft);
		this.$.strategy.setScrollTop(this.scrollTop);
	},

	/**
	* @private
	*/
	strategyKindChanged: function () {
		if (this.$.strategy) {
			this.$.strategy.destroy();
			this.controlParent = null;
		}
		// note: createComponents automatically updates controlParent.
		this.createStrategy();
		if (this.hasNode()) {
			this.render();
		}
	},

	/**
	* @private
	*/
	createStrategy: function () {
		this.createComponents([{name: 'strategy', maxHeight: this.maxHeight,
			kind: this.strategyKind, thumb: this.thumb,
			preventDragPropagation: this.preventDragPropagation,
			overscroll:this.touchOverscroll, isChrome: true}]);
	},

	/**
	* @private
	*/
	getStrategy: function () {
		return this.$.strategy;
	},

	/**
	* @private
	*/
	maxHeightChanged: function () {
		this.$.strategy.setMaxHeight(this.maxHeight);
	},

	/**
	* @method
	* @private
	*/
	showingChanged: kind.inherit(function (sup) {
		return function() {
			sup.apply(this, arguments);
			if (this.showing) {
				this.syncStrategy();
			}
		};
	}),

	/**
	* @private
	*/
	showingChangedHandler: kind.inherit(function(sup) {
		return function(sender, event) {
			if (this.showing && event.showing) {
				this.syncStrategy();
			}
		};
	}),

	/**
	* @private
	*/
	thumbChanged: function () {
		this.$.strategy.setThumb(this.thumb);
	},

	/**
	* @private
	*/
	horizontalChanged: function () {
		this.$.strategy.setHorizontal(this.horizontal);
	},

	/**
	* @private
	*/
	verticalChanged: function () {
		this.$.strategy.setVertical(this.vertical);
	},

	// FIXME: these properties are virtual; property changed methods are fired only if
	// property value changes, not if getter changes.
	
	/**
	* Sets the horizontal scroll position.
	*
	* @param {Number} left - The horizontal scroll position in pixels.
	* @public
	*/
	setScrollLeft: function (left) {
		this.$.strategy.setScrollLeft(left);
	},

	/**
	* Sets the vertical scroll position.
	*
	* @param {Number} top - The vertical scroll position in pixels.
	* @public
	*/
	setScrollTop: function (top) {
		this.$.strategy.setScrollTop(top);
	},

	/**
	* Retrieves the horizontal scroll position.
	*
	* @returns {Number} The horizontal scroll position in pixels.
	* @public
	*/
	getScrollLeft: function () {
		// sync our internal property
		this.scrollLeft = this.$.strategy.getScrollLeft();
		return this.scrollLeft;
	},

	/**
	* Retrieves the vertical scroll position.
	*
	* @returns {Number} The vertical scroll position in pixels.
	* @public
	*/
	getScrollTop: function () {
		// sync our internal property
		this.scrollTop = this.$.strategy.getScrollTop();
		return this.scrollTop;
	},

	/**
	* Retrieves the scroll boundaries of the [scroller]{@link enyo.Scroller}.
	* 
	* @returns {enyo.Scroller~BoundaryObject} An [object]{@glossary Object} describing the 
	*	scroll boundaries.
	* @public
	*/
	getScrollBounds: function () {
		var bounds  = this.$.strategy.getScrollBounds();
		if (
			(bounds.xDir !== -1 && bounds.xDir !== 0 && bounds.xDir !== 1) ||
			(bounds.yDir !== -1 && bounds.yDir !== 0 && bounds.yDir !== 1)
		) {
			this.decorateBounds(bounds);
		}
		// keep our properties synchronized always and without extra calls
		this.scrollTop  = bounds.top;
		this.scrollLeft = bounds.left;
		return bounds;
	},

	/** 
	* Trigger a remeasurement of the scroller's metrics (specifically, the
	* size of its viewport, the size of its contents and the difference between
	* the two, which determines the extent to which the scroller may scroll).
	* 
	* You should generally not need to call this from application code, as the
	* scroller usually remeasures automatically whenever needed. This method
	* exists primarily to support an internal use case for
	* [enyo.DataList]{@link enyo.DataList}.
	*
	* @public
	*/
	remeasure: function() {
		var s = this.$.strategy;
		if (s.remeasure) s.remeasure();
	},

	/**
	* Scrolls the given [control]{@link enyo.Control} into view.
	*
	* @param {enyo.Control} ctl - The control to make visible in the
	*	[scroller's]{@link enyo.Scroller} viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top
	* of the scroller.
	* @public
	*/
	scrollIntoView: function (ctl, alignWithTop) {
		this.$.strategy.scrollIntoView(ctl, alignWithTop);
	},

	/** 
	* Scrolls to the specified position.
	*
	* @param {Number} x - The `x` position in pixels.
	* @param {Number} y - The `y` position in pixels.
	* @public
	*/
	scrollTo: function (x, y) {
		this.$.strategy.scrollTo(x, y);
	},

	/**
	* Ensures that the given [control]{@link enyo.Control} is visible in the 
	* [scroller's]{@link enyo.Scroller} viewport. Unlike 
	* [scrollIntoView()]{@link enyo.Scroller#scrollIntoView}, which uses DOM's 
	* [scrollIntoView()]{@glossary scrollIntoView}, this only affects the current 
	* scroller.
	*
	* @param {enyo.Control} ctl - The [control]{@link enyo.Control} to make visible in the
	*	[scroller's]{@link enyo.Scroller} viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the
	*	scroller.
	* @public
	*/
	scrollToControl: function (ctl, alignWithTop) {
		this.scrollToNode(ctl.hasNode(), alignWithTop);
	},

	/** 
	* Ensures that the given node is visible in the [scroller's]{@link enyo.Scroller} viewport.
	*
	* @param {Node} node - The node to make visible in the [scroller's]{@link enyo.Scroller}
	*	viewport.
	* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the
	*	scroller.
	* @public
	*/
	scrollToNode: function (node, alignWithTop) {
		this.$.strategy.scrollToNode(node, alignWithTop);
	},

	/** 
	* Stops the scroller if it is currently animating.
	* 
	* @public
	*/
	stop: function() {
		if (typeof this.$.strategy.stop == 'function') {
			this.$.strategy.stop(true);
		}
	},

	/** 
	* Adds current values of `getScrollBounds()` to {@glossary event}.
	* 
	* @private
	*/
	decorateScrollEvent: function (e) {
		var bounds = e.scrollBounds = e.scrollBounds || this.$.strategy._getScrollBounds();
		// in the off chance that the event already had scrollBounds then we need
		// to make sure they are decorated
		if (
			(bounds.xDir !== -1 && bounds.xDir !== 0 && bounds.xDir !== 1) ||
			(bounds.yDir !== -1 && bounds.yDir !== 0 && bounds.yDir !== 1)
		) {
			this.decorateBounds(bounds);
		}
		// keep our properties synchronized always and without extra calls
		this.scrollTop  = bounds.top;
		this.scrollLeft = bounds.left;
	},

	/**
	* @private
	*/
	decorateBounds: function (bounds) {
		var x       = this.scrollLeft - bounds.left,
			y       = this.scrollTop  - bounds.top;
		bounds.xDir = (x < 0? 1: x > 0? -1: 0);
		bounds.yDir = (y < 0? 1: y > 0? -1: 0);
		// we update our current bounds properties so we don't have to unnecessarily
		// call getScrollTop/getScrollLeft because we already have the current data
		this.scrollLeft = bounds.left;
		this.scrollTop  = bounds.top;
	},

	/** 
	* Normalizes scroll {@glossary event} to `onScroll`.
	*
	* @fires enyo.Scroller#onScroll
	* @private
	*/
	domScroll: function (sender, e) {
		// if a scroll event originated here, pass it to our strategy to handle
		if (this.$.strategy.domScroll && e.originator == this) {
			this.$.strategy.domScroll(sender, e);
		}
		this.decorateScrollEvent(e);
		this.doScroll(e);
		return true;
	},

	/**
	* @returns {Boolean} `true` if the current scroll {@glossary event} should
	* be stopped; `false` if it should be allowed to propagate.
	* @private
	*/
	shouldStopScrollEvent: function (e) {
		return (this.preventScrollPropagation &&
			e.originator.owner != this.$.strategy);
	},

	/**
	* Calls [shouldStopScrollEvent()]{@link enyo.Scroller#shouldStopScrollEvent} to
	* determine whether current scroll {@glossary event} should be stopped.
	*
	* @private
	*/
	scrollStart: function (sender, e) {
		if (!this.shouldStopScrollEvent(e)) {
			this.decorateScrollEvent(e);
			return false;
		}
		return true;
	},

	/** 
	* Either propagates or stops the current scroll {@glossary event}.
	*
	* @private
	*/
	scroll: function (sender, e) {
		// note: scroll event can be native dom or generated.
		var stop;
		if (e.dispatchTarget) {
			// allow a dom event if it orignated with this scroller or its strategy
			stop = this.preventScrollPropagation && !(e.originator == this ||
				e.originator.owner == this.$.strategy);
		} else {
			stop = this.shouldStopScrollEvent(e);
		}
		if (!stop) {
			this.decorateScrollEvent(e);
			return false;
		}
		return true;
	},

	/**
	* Calls [shouldStopScrollEvent()]{@link enyo.Scroller#shouldStopScrollEvent} to
	* determine whether current scroll {@glossary event} should be stopped.
	*
	* @private
	*/
	scrollStop: function (sender, e) {
		if (!this.shouldStopScrollEvent(e)) {
			this.decorateScrollEvent(e);
			return false;
		}
		return true;
	},

	/**
	* Scrolls to the top of the scrolling region.
	*
	* @public
	*/
	scrollToTop: function () {
		this.setScrollTop(0);
	},

	/**
	* Scrolls to the bottom of the scrolling region.
	*
	* @public
	*/
	scrollToBottom: function () {
		this.setScrollTop(this.getScrollBounds().maxTop);
	},

	/**
	* Scrolls to the right edge of the scrolling region.
	*
	* @public
	*/
	scrollToRight: function () {
		this.setScrollLeft(this.getScrollBounds().maxLeft);
	},

	/**
	* Scrolls to the left edge of the scrolling region.
	*
	* @public
	*/
	scrollToLeft: function () {
		this.setScrollLeft(0);
	},

	/**
	* Ensures scroll position is in bounds.
	*
	* @public
	*/
	stabilize: function () {
		var s = this.getStrategy();
		if (s.stabilize) {
			s.stabilize();
		}
	},

	/**
	* Sends the [useMouseWheel]{@link enyo.Scroller#useMouseWheel} property to the scroll 
	* strategy.
	*
	* @private
	*/
	useMouseWheelChanged: function () {
		this.$.strategy.setUseMouseWheel(this.useMouseWheel);
	},

	/**
	* @private
	*/
	resize: kind.inherit(function (sup) {
		return function () {
			if (this.getAbsoluteShowing(true)) {
				sup.apply(this, arguments);
			}
		};
	})
});

// provide a touch scrolling solution by default when the environment is mobile
if (Scroller.hasTouchScrolling()) {
	Scroller.prototype.strategyKind = Scroller.getTouchStrategy();
}
},{"../../../enyo":1,"../Control":16,"../ScrollStrategy":42,"../TouchScrollStrategy":53,"../TranslateScrollStrategy":54,"../kind":66,"../platform":71,"../utils":75}],95:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	utils = require('../../../enyo/lib/utils'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	FlyweightRepeater = require('../../../layout/lib/FlyweightRepeater');

var
	methods = require('./methods');

/**
* A collection of useful metrics about a page.
*
* @typedef {Object} enyo.List~PageInfo
* @property {Number} no       - The page number.
* @property {Number} size     - The page size.
* @property {Number} pos      - The page position.
* @property {Number} startRow - The index of the page's first row.
* @property {Number} endRow   - The index of the page's last row.
*/

/**
* Fires once per row at render time.
*
* @event enyo.List#onSetupItem
* @type {Object}
* @property {Number} index - The current row index.
* @public
*/

/**
* Fires when reordering starts, to setup reordering components. No additional
* data is included with this event.
*
* @event enyo.List#onSetupReorderComponents
* @type {Object}
* @property {Number} index - The current row index.
* @public
*/

/**
* Fires when reordering completes.
*
* @event enyo.List#onReorder
* @type {Object}
* @property {Number} reorderTo   - The index of the destination row.
* @property {Number} reorderFrom - The index of the source row.
* @public
*/

/**
* Fires when pinned reordering starts. No additional data is included with
* this event.
*
* @event enyo.List#onSetupPinnedReorderComponents
* @type {Object}
* @public
*/

/**
* Fires when swiping starts, to set up swipeable components. No additional
* data is included with this event.
*
* @event enyo.List#onSetupSwipeItem
* @type {Object}
* @public
*/

/**
* @todo onSwipeDrag is never fired
* @event enyo.List#onSwipeDrag
* @type {Object}
* @public
*/

/**
* @todo onSwipe is never fired
* @event enyo.List#onSwipe
* @type {Object}
* @public
*/

/**
* Fires when a swipe completes.
*
* @event enyo.List#onSwipeComplete
* @type {Object}
* @property {Number} index      - The index of the row that was swiped.
* @property {Number} xDirection - The direction of the swipe.
* @public
*/

/**
* {@link enyo.List} is a control that displays a scrolling list of rows,
* suitable for displaying very large lists. It is optimized such that only a
* small portion of the list is rendered at a given time. A flyweight pattern
* is employed, in which controls placed inside the list are created once, but
* rendered for each list item. For this reason, it's best to use only simple
* controls in	a List, such as {@link enyo.Control} and {@link enyo.Image}.
*
* A List's `components` block contains the controls to be used for a single
* row. This set of controls will be rendered for each row. You may customize
* row rendering by handling the [onSetupItem]{@link enyo.List#onSetupItem}
* event.
*
* Events fired from within list rows contain the `index` property, which may
* be used to identify the row from which the event originated.
*
* Beginning with Enyo 2.2, lists have built-in support for swipeable and
* reorderable list items.  Individual list items are swipeable by default; to
* enable reorderability, set the [reorderable]{@link enyo.List#reorderable}
* property to `true`.
*
* For more information, see the documentation on
* [Lists]{@linkplain $dev-guide/building-apps/layout/lists.html} in the
* Enyo Developer Guide.
*
* @ui
* @class enyo.List
* @extends enyo.Scroller
* @public
*/
module.exports = kind(utils.mixin(methods,
	/** @lends enyo.List.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.List',

	/**
	* @private
	*/
	kind: Scroller,

	/**
	* @private
	*/
	classes: 'enyo-list',

	/**
	* @lends enyo.List.prototype
	* @private
	*/
	published: {
		/**
		* The number of rows contained in the list. Note that as the amount of
		* list data changes, `setRows()` may be called to adjust the number of
		* rows. To re-render the list at the current position when the count has
		* changed, call the [refresh()]{@link enyo.List#refresh} method.  If the
		* whole data model of the list has changed and you want to redisplay it
		* from the top, call [reset()]{@link enyo.List#reset}.
		*
		* @type {Number}
		* @default 0
		* @public
		*/
		count: 0,
		/**
		* The number of rows to be shown in a given list page segment. There is
		* generally no need to adjust this value.
		*
		* @type {Number}
		* @default 50
		* @public
		*/
		rowsPerPage: 50,
		/**
		* Direction in which the list will be rendered and in which it will be
		* scrollable. Valid values are `'v'` for vertical or `'h'` for horizontal.
		*
		* @type {String}
		* @default 'v'
		* @public
		*/
		orient: 'v',
		/**
		* If `true`, the list is rendered such that row `0` is at the bottom of
		* the viewport and the beginning position of the list is scrolled to the
		* bottom.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		bottomUp: false,
		/**
		* If `true`, the selection mechanism is disabled. Tap events are still
		* sent, but items won't be automatically re-rendered when tapped.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		noSelect: false,

		/**
		 * If `true`, multiple selection is allowed.
		 *
		 * @type {Boolean}
		 * @default false
		 * @public
		 */
		multiSelect: false,

		/**
		* If `true`, the selected item will toggle.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		toggleSelected: false,

		/**
		* If `true`, the list will assume that all rows have the same size to
		* optimize performance.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		fixedSize: false,

		/**
		* If `true`, the list will allow the user to reorder list items.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		reorderable: false,

		/**
		* If `true` and `reorderable` is true, a reorderable item will be centered
		* on finger when created. If `false`, it will be created over the old item
		* and will then track finger.
		*
		* @type {Boolean}
		* @default true
		* @public
		*/
		centerReorderContainer: true,

		/**
		* An array containing components to be shown as a placeholder when
		* reordering list items.
		*
		* @type {enyo.Control[]}
		* @public
		*/
		reorderComponents: [],

		/**
		* An array containing components for the pinned version of a row. If not
		* specified, reordering will not support pinned mode.
		*
		* @type {enyo.Control[]}
		* @public
		*/
		pinnedReorderComponents: [],

		/**
		* An array containing any swipeable components that will be used.
		*
		* @type {enyo.Control[]}
		* @public
		*/
		swipeableComponents: [],

		/**
		* If `true`, swipe functionality is enabled.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		enableSwipe: false,

		/**
		* If `true`, the list will persist the current swipeable item.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		persistSwipeableItem: false
	},

	/**
	* @private
	*/
	events: {
		onSetupItem: '',
		onSetupReorderComponents: '',
		onSetupPinnedReorderComponents: '',
		onReorder: '',
		onSetupSwipeItem: '',
		onSwipeDrag: '',
		onSwipe: '',
		onSwipeComplete: ''
	},

	/**
	* @private
	*/
	handlers: {
		onAnimateFinish: 'animateFinish',
		onRenderRow: 'rowRendered',
		ondragstart: 'dragstart',
		ondrag: 'drag',
		ondragfinish: 'dragfinish',
		onup: 'up',
		onholdpulse: 'holdpulse',
		onflick: 'flick'
	},

	/**
	* Average row size (in pixels), calculated as `(page size / number of rows per page)`.
	*
	* @private
	*/
	rowSize: 0,

	/**
	* @private
	*/
	listTools: [
		{name: 'port', classes: 'enyo-list-port enyo-border-box', components: [
			{name: 'generator', kind: FlyweightRepeater, canGenerate: false, components: [
				{tag: null, name: 'client'}
			]},
			{name: 'holdingarea', allowHtml: true, classes: 'enyo-list-holdingarea'},
			{name: 'page0', allowHtml: true, classes: 'enyo-list-page'},
			{name: 'page1', allowHtml: true, classes: 'enyo-list-page'},
			{name: 'placeholder', classes: 'enyo-list-placeholder'},
			{name: 'swipeableComponents', style: 'position:absolute; display:block; top:-1000px; left:0;'}
		]}
	],

	//* Reorder vars

	/**
	* Length of time, in milliseconds, to wait for to active reordering.
	*
	* @type {Number}
	* @default 600
	* @private
	*/
	reorderHoldTimeMS: 600,

	/**
	* Index of the row that we're moving.
	*
	* @type {Number}
	* @default -1
	* @private
	*/
	draggingRowIndex: -1,

	/**
	* @todo Seems to be cruft ... can't find any references to it in layout.
	* @private
	*/
	initHoldCounter: 3,

	/**
	* @todo Seems to be cruft ... can't find any references to it in layout.
	* @private
	*/
	holdCounter: 3,

	/**
	* @todo Seems to be cruft ... can't find any references to it in layout.
	* @private
	*/
	holding: false,

	/**
	* Index of the row before which the placeholder item will be shown. If the
	* placeholder is at the end of the list, this value will be one larger than
	* the row count.
	*
	* @type {Number}
	* @private
	*/
	placeholderRowIndex: -1,

	/**
	* Determines scroll height at top/bottom of list where dragging will cause scroll.
	*
	* @type {Number}
	* @default 0.1
	* @private
	*/
	dragToScrollThreshold: 0.1,

	/**
	 * Amount to scroll during autoscroll.
	 *
	 * @type {Number}
	 * @default 0
	 * @private
	 */
	scrollDistance: 0,

	/**
	* Used to determine direction of scrolling during reordering.
	*
	* @private
	*/
	prevScrollTop: 0,

	/**
	* Number of milliseconds between scroll events when autoscrolling.
	*
	* @type {Number}
	* @default 20
	* @private
	*/
	autoScrollTimeoutMS: 20,

	/**
	* Holds timeout ID for autoscroll.
	*
	* @private
	*/
	autoScrollTimeout: null,

	/**
	* Keep last event Y coordinate to update placeholder position during autoscroll.
	*
	* @type {Number}
	* @private
	*/
	autoscrollPageY: 0,

	/**
	* Set to `true` to indicate that we're in pinned reordering mode.
	*
	* @type {Boolean}
	* @default false
	* @private
	*/
	pinnedReorderMode: false,

	/**
	* y-coordinate of the original location of the pinned row.
	*
	* @type {Number}
	* @private
	*/
	initialPinPosition: -1,

	/**
	* Set to `true` after drag-and-drop has moved the item to reorder at least
	* one space. Used to activate pin mode if item is dropped immediately.
	*
	* @type {Boolean}
	* @default false
	* @private
	*/
	itemMoved: false,

	/**
	* Tracks the page where the item being dragged is, so we can detect when we
	* switch pages and need to adjust rendering.
	*
	* @type {Number}
	* @private
	*/
	currentPageNumber: -1,

	/**
	* Timeout for completing reorder operation.
	*
	* @private
	*/
	completeReorderTimeout: null,

	//* Swipeable vars

	/**
	* Index of swiped item.
	*
	* @type {Number}
	* @private
	*/
	swipeIndex: null,

	/**
	* Direction of swipe.
	*
	* @type {Number}
	* @private
	*/
	swipeDirection: null,

	/**
	* `true` if a persistent item is currently persisting.
	*
	* @type {Boolean}
	* @default false
	* @private
	*/
	persistentItemVisible: false,

	/**
	* Side from which the persisting item came.
	*
	* @type {String}
	* @private
	*/
	persistentItemOrigin: null,

	/**
	* `true` if swipe was completed.
	*
	* @type {Boolean}
	* @private
	*/
	swipeComplete: false,

	/**
	* Timeout when waiting for swipe action to complete.
	*
	* @private
	*/
	completeSwipeTimeout: null,

	/**
	* Length of time (in milliseconds) to wait before completing swipe action.
	*
	* @type {Number}
	* @default 500
	* @private
	*/
	completeSwipeDelayMS: 500,

	/**
	* Duration (in milliseconds) of normal swipe animation.
	*
	* @type {Number}
	* @default 200
	* @private
	*/
	normalSwipeSpeedMS: 200,

	/**
	* Duration (in milliseconds) of fast swipe animation.
	*
	* @type {Number}
	* @default 100
	* @private
	*/
	fastSwipeSpeedMS: 100,

	/**
	* Percentage of a swipe needed to force completion of the swipe.
	*
	* @type {Number}
	* @default 0.2
	* @private
	*/
	percentageDraggedThreshold: 0.2
}));
},{"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/FlyweightRepeater":89,"./methods":96}],98:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom'),
	platform = require('../../enyo/lib/platform'),
	utils = require('../../enyo/lib/utils'),
	Animator = require('../../enyo/lib/Animator'),
	Scroller = require('../../enyo/lib/Scroller');

/**
* Fires whenever the user adjusts the zoom via double-tap/double-click, mousewheel,
* or pinch-zoom.
*
* @event enyo.PanZoomView#onZoom
* @type {Object}
* @property {Number} scale - The new scaling factor.
* @public
*/

/**
* Fires after a zoom to notify children to position non-zooming controls.
*
* @event enyo.PanZoomView#onPositionPin
* @type {Object}
* @property {Numer} scale   - The new scaling factor.
* @property {Object} bounds - An object containing the current viewport bounds.
* @public
*/

/**
* {@link enyo.PanZoomView} is a control that displays arbitrary content at a given
* scaling factor, with enhanced support for double-tap/double-click to zoom,
* panning, mousewheel zooming and pinch-zoom (on touchscreen devices that
* support it).
*
* ```
* {kind: 'PanZoomView', scale: 'auto', contentWidth: 500, contentHeight: 500,
* 	style: 'width: 500px; height: 400px;',
* 	components: [{content: 'Hello World'}]
* }
* ```
*
* An [onZoom]{@link enyo.PanZoomView#onZoom} event is triggered when the
* user changes the zoom level.
*
* If you wish, you may add {@link enyo.ScrollThumb} indicators, disable zoom
* animation, allow panning overscroll (with a bounce-back effect), and control
* the propagation of drag events, all via Boolean properties.
*
* For the PanZoomView to work, you must either specify the width and height of
* the scaled content (via the `contentWidth` and `contentHeight` properties) or
* bubble an `onSetDimensions` event from one of the underlying components.
*
* Note that it's best to specify a size for the PanZoomView in order to avoid
* complications.
*
* @ui
* @class enyo.PanZoomView
* @extends enyo.Scroller
* @public
*/
module.exports = kind(
	/** @lends enyo.PanZoomView.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.PanZoomView',

	/**
	* @private
	*/
	kind: Scroller,

	/**
	* If `true`, allows overscrolling during panning, with a bounce-back effect.
	*
	* @type {Boolean}
	* @default false
	* @see {@link enyo.Scroller.touchOverscroll}
	* @public
	*/
	touchOverscroll: false,

	/**
	* If `true`, a ScrollThumb is used to indicate scroll position/bounds.
	*
	* @type {Boolean}
	* @default false
	* @see {@link enyo.Scroller.thumb}
	* @public
	*/
	thumb: false,

	/**
	* If `true` (the default), animates the zoom action triggered by a double-tap
	* (or double-click).
	*
	* @type {Boolean}
	* @default true
	* @see {@link enyo.Scroller.animate}
	* @public
	*/
	animate: true,

	/**
	* If `true` (the default), allows propagation of vertical drag events when
	* already at the top or bottom of the pannable area.
	*
	* @type {Boolean}
	* @default true
	* @see {@link enyo.Scroller.verticalDragPropagation}
	* @public
	*/
	verticalDragPropagation: true,

	/**
	* If `true` (the default), allows propagation of horizontal drag events when
	* already at the left or right edge of the pannable area.
	*
	* @type {Boolean}
	* @default true
	* @see {@link enyo.Scroller.horizontalDragPropagation}
	* @public
	*/
	horizontalDragPropagation: true,

	/**
	* @lends enyo.PanZoomViews.prototype
	* @public
	*/
	published: {
		/**
		* The scale at which the content should be displayed. This may be any
		* positive numeric value or one of the following key words (which will
		* be resolved to a value dynamically):
		*
		* * `'auto'`: Fits the content to the size of the PanZoomView.
		* * `'width'`: Fits the content to the width of the PanZoomView.
		* * `'height'`: Fits the content to the height of the PanZoomView.
		* * `'fit'`: Fits the content to the height and width of the PanZoomView; the
		* 	overflow of the larger dimension is cropped and the content is centered
		* 	along that axis.
		*
		* @type {String}
		* @default 'auto'
		* @public
		*/
		scale: 'auto',

		/**
		* If `true`, zoom functionality is disabled.
		*
		* @type {Boolean}
		* @default false
		* @public
		*/
		disableZoom: false,

		/**
		* Width of the scaled content.
		*
		* @type {Number}
		* @default null
		* @private
		*/
		contentWidth: null,

		/**
		* Height of the scaled content.
		*
		* @type {Number}
		* @default null
		* @public
		*/
		contentHeight: null
	},

	/**
	* @private
	*/
	events: {
		onZoom: ''
	},

	/**
	* @private
	*/
	touch: true,

	/**
	* @private
	*/
	preventDragPropagation: false,

	/**
	* @private
	*/
	handlers: {
		ondragstart: 'dragPropagation',
		onSetDimensions: 'setDimensions'
	},

	/**
	* @private
	*/
	components: [
		{name: 'animator', kind: Animator, onStep: 'zoomAnimationStep', onEnd: 'zoomAnimationEnd'},
		{name: 'viewport', style: 'overflow:hidden;min-height:100%;min-width:100%;', classes: 'enyo-fit', ongesturechange: 'gestureTransform', ongestureend: 'saveState', ontap: 'singleTap', ondblclick: 'doubleClick', onmousewheel: 'mousewheel', components: [
			{name: 'content'}
		]}
	],

	/**
	* @method
	* @private
	*/
	create: function () {
		// remember scale keyword
		this.scaleKeyword = this.scale;

		// Cache instance components
		var instanceComponents = this.components;
		this.components = [];
		Scroller.prototype.create.apply(this, arguments);
		this.$.content.applyStyle('width', this.contentWidth + 'px');
		this.$.content.applyStyle('height', this.contentHeight + 'px');

		if (this.unscaledComponents){
			var owner = this.hasOwnProperty('unscaledComponents') ? this.getInstanceOwner() : this;
			this.createComponents(this.unscaledComponents, {owner: owner});
		}

		// Change controlParentName so PanZoomView instance components are created into viewport
		this.controlParentName = 'content';
		this.discoverControlParent();
		this.createComponents(instanceComponents);

		this.canTransform = dom.canTransform();
		if (!this.canTransform) {
			this.$.content.applyStyle('position', 'relative');
		}
		this.canAccelerate = dom.canAccelerate();

		//	For panzoomview, disable drags during gesture (to fix flicker: ENYO-1208)
		this.getStrategy().setDragDuringGesture(false);
	},

	/**
	* @method
	* @private
	*/
	rendered: function () {
		Scroller.prototype.rendered.apply(this, arguments);
		this.getOriginalScale();
	},

	/**
	* @private
	*/
	dragPropagation: function (sender, event) {
		// Propagate drag events at the edges of the content as desired by the
		// verticalDragPropagation and horizontalDragPropagation properties
		var bounds = this.getStrategy().getScrollBounds();
		var verticalEdge = ((bounds.top===0 && event.dy>0) || (bounds.top>=bounds.maxTop-2 && event.dy<0));
		var horizontalEdge = ((bounds.left===0 && event.dx>0) || (bounds.left>=bounds.maxLeft-2 && event.dx<0));
		return !((verticalEdge && this.verticalDragPropagation) || (horizontalEdge && this.horizontalDragPropagation));
	},

	/**
	* @private
	*/
	mousewheel: function (sender, event) {
		event.pageX |= (event.clientX + event.target.scrollLeft);
		event.pageY |= (event.clientY + event.target.scrollTop);
		var zoomInc = (this.maxScale - this.minScale)/10;
		var oldScale = this.scale;
		if ((event.wheelDelta > 0) || (event.detail < 0)) { //zoom in
			this.scale = this.limitScale(this.scale + zoomInc);
		} else if ((event.wheelDelta < 0) || (event.detail > 0)) { //zoom out
			this.scale = this.limitScale(this.scale - zoomInc);
		}
		this.eventPt = this.calcEventLocation(event);
		this.transform(this.scale);
		if (oldScale != this.scale) {
			this.doZoom({scale:this.scale});
		}
		this.ratioX = this.ratioY = null;
		// Prevent default scroll wheel action and prevent event from bubbling up to to touch scroller
		event.preventDefault();
		return true;
	},

	/**
	* @method
	* @private
	*/
	handleResize: function () {
		Scroller.prototype.handleResize.apply(this, arguments);
		this.scaleChanged();
	},

	/**
	* @private
	*/
	setDimensions: function (sender, event) {
		this.$.content.applyStyle('width', event.width + 'px');
		this.$.content.applyStyle('height', event.height + 'px');
		this.originalWidth = event.width;
		this.originalHeight = event.height;
		this.scale = this.scaleKeyword;
		this.scaleChanged();
		return true;
	},

	/**
	* Caches the initial height and width of the component (in `originalHeight`
	* and `originalWidth`, respectively) at render time.
	*
	* @private
	*/
	getOriginalScale : function () {
		if (this.$.content.hasNode()){
			this.originalWidth  = this.$.content.node.clientWidth;
			this.originalHeight = this.$.content.node.clientHeight;
			this.scale = this.scaleKeyword;
			this.scaleChanged();
		}
	},

	/**
	* Calculates the `minScale` and `maxScale` and zooms the content according to the
	* clamped scale value.
	*
	* @private
	*/
	scaleChanged: function () {
		var containerNode = this.hasNode();
		if (containerNode) {
			this.containerWidth = containerNode.clientWidth;
			this.containerHeight = containerNode.clientHeight;
			var widthScale = this.containerWidth / this.originalWidth;
			var heightScale = this.containerHeight / this.originalHeight;
			this.minScale = Math.min(widthScale, heightScale);
			this.maxScale = (this.minScale*3 < 1) ? 1 : this.minScale*3;
			//resolve any keyword scale values to solid numeric values
			if (this.scale == 'auto') {
				this.scale = this.minScale;
			} else if (this.scale == 'width') {
				this.scale = widthScale;
			} else if (this.scale == 'height') {
				this.scale = heightScale;
			} else if (this.scale == 'fit') {
				this.fitAlignment = 'center';
				this.scale = Math.max(widthScale, heightScale);
			} else {
				this.maxScale = Math.max(this.maxScale, this.scale);
				this.scale = this.limitScale(this.scale);
			}
		}
		this.eventPt = this.calcEventLocation();
		this.transform(this.scale);
		// start scroller
		if (this.getStrategy().$.scrollMath) {
			this.getStrategy().$.scrollMath.start();
		}
		this.align();
	},

	/**
	* Centers the content in the scroller.
	*
	* @private
	*/
	align: function () {
		if (this.fitAlignment && this.fitAlignment === 'center') {
			var sb = this.getScrollBounds();
			this.setScrollLeft(sb.maxLeft / 2);
			this.setScrollTop(sb.maxTop / 2);
		}
	},

	/**
	* @private
	*/
	gestureTransform: function (sender, event) {
		this.eventPt = this.calcEventLocation(event);
		this.transform(this.limitScale(this.scale * event.scale));
	},

	/**
	* Determines the target coordinates on the PanZoomView from an event.
	*
	* @private
	*/
	calcEventLocation: function (event) {
		var eventPt = {x: 0, y:0};
		if (event && this.hasNode()) {
			var rect = this.node.getBoundingClientRect();
			eventPt.x = Math.round((event.pageX - rect.left) - this.bounds.x);
			eventPt.x = Math.max(0, Math.min(this.bounds.width, eventPt.x));
			eventPt.y = Math.round((event.pageY - rect.top) - this.bounds.y);
			eventPt.y = Math.max(0, Math.min(this.bounds.height, eventPt.y));
		}
		return eventPt;
	},

	/**
	* Scales the content.
	*
	* @param {Number} scale - The scaling factor.
	* @private
	*/
	transform: function (scale) {
		this.tapped = false;

		var prevBounds = this.bounds || this.innerBounds(scale);
		this.bounds = this.innerBounds(scale);

		//style cursor if needed to indicate the content is movable
		if (this.scale>this.minScale) {
			this.$.viewport.applyStyle('cursor', 'move');
		} else {
			this.$.viewport.applyStyle('cursor', null);
		}
		this.$.viewport.setBounds({width: this.bounds.width + 'px', height: this.bounds.height + 'px'});

		//determine the exact ratio where on the content was tapped
		this.ratioX = this.ratioX || (this.eventPt.x + this.getScrollLeft()) / prevBounds.width;
		this.ratioY = this.ratioY || (this.eventPt.y + this.getScrollTop()) / prevBounds.height;
		var scrollLeft, scrollTop;
		if (this.$.animator.ratioLock) { //locked for smartzoom
			scrollLeft = (this.$.animator.ratioLock.x * this.bounds.width) - (this.containerWidth / 2);
			scrollTop = (this.$.animator.ratioLock.y * this.bounds.height) - (this.containerHeight / 2);
		} else {
			scrollLeft = (this.ratioX * this.bounds.width) - this.eventPt.x;
			scrollTop = (this.ratioY * this.bounds.height) - this.eventPt.y;
		}
		scrollLeft = Math.max(0, Math.min((this.bounds.width - this.containerWidth), scrollLeft));
		scrollTop = Math.max(0, Math.min((this.bounds.height - this.containerHeight), scrollTop));

		if (this.canTransform) {
			var params = {scale: scale};
			// translate needs to be first, or scale and rotation will not be in the correct spot
			if (this.canAccelerate) {
				//translate3d rounded values to avoid distortion; ref: http://martinkool.com/post/27618832225/beware-of-half-pixels-in-css
				params = utils.mixin({translate3d: Math.round(this.bounds.left) + 'px, ' + Math.round(this.bounds.top) + 'px, 0px'}, params);
			} else {
				params = utils.mixin({translate: this.bounds.left + 'px, ' + this.bounds.top + 'px'}, params);
			}
			dom.transform(this.$.content, params);
		} else if (platform.ie) {
			// IE8 does not support transforms, but filter should work
			// http://www.useragentman.com/IETransformsTranslator/
			var matrix = '"progid:DXImageTransform.Microsoft.Matrix(M11='+scale+', M12=0, M21=0, M22='+scale+', SizingMethod=\'auto expand\')"';
			this.$.content.applyStyle('-ms-filter', matrix);
			this.$.content.setBounds({width: this.bounds.width*scale + 'px', height: this.bounds.height*scale + 'px',
					left:this.bounds.left + 'px', top:this.bounds.top + 'px'});
			this.$.content.applyStyle('width', scale*this.bounds.width);
			this.$.content.applyStyle('height', scale*this.bounds.height);
		} else {
			// ...no transforms and not IE... there's nothin' I can do.
		}

		//adjust scroller to new position that keeps ratio with the new content size
		this.setScrollLeft(scrollLeft);
		this.setScrollTop(scrollTop);

		this.positionClientControls(scale);

		//this.stabilize();
	},

	/**
	* Clamps the scaling factor between `minScale` and `maxScale`.
	*
	* @private
	*/
	limitScale: function (scale) {
		if (this.disableZoom) {
			scale = this.scale;
		} else if (scale > this.maxScale) {
			scale = this.maxScale;
		} else if (scale < this.minScale) {
			scale = this.minScale;
		}
		return scale;
	},

	/**
	* Calculates the offsets for the content for the given scaling factor.
	*
	* @param {Number} scale - The scaling factor.
	* @return {Object}      - Object containing offsets for content (in its `left`, `top`,
	* `width`, `height`, `x`, and `y` properties).
	* @private
	*/
	innerBounds: function (scale) {
		var width = this.originalWidth * scale;
		var height = this.originalHeight * scale;
		var offset = {x:0, y:0, transX:0, transY:0};
		if (width < this.containerWidth) {
			offset.x += (this.containerWidth - width)/2;
		}
		if (height < this.containerHeight) {
			offset.y += (this.containerHeight - height)/2;
		}
		if (this.canTransform) { //adjust for the css translate, which doesn't alter content offsetWidth and offsetHeight
			offset.transX -= (this.originalWidth - width)/2;
			offset.transY -= (this.originalHeight - height)/2;
		}
		return {left:offset.x + offset.transX, top:offset.y + offset.transY, width:width, height:height, x:offset.x, y:offset.y};
	},

	/**
	* Persists the scaling factor when a gesture finishes.
	*
	* @fires enyo.PanZoomView#onZoom
	* @private
	*/
	saveState: function (sender, event) {
		var oldScale = this.scale;
		this.scale *= event.scale;
		this.scale = this.limitScale(this.scale);
		if (oldScale != this.scale) {
			this.doZoom({scale:this.scale});
		}
		this.ratioX = this.ratioY = null;
	},

	/**
	* Normalizes the event and forwards it to
	* [singleTap()]{@link enyo.PanZoomView#singleTap}.
	*
	* IE 8 Only
	*
	* @private
	*/
	doubleClick: function (sender, event) {
		//IE 8 fix; dblclick fires rather than multiple successive click events
		if (platform.ie==8) {
			this.tapped = true;
			//normalize event
			event.pageX = event.clientX + event.target.scrollLeft;
			event.pageY = event.clientY + event.target.scrollTop;
			this.singleTap(sender, event);
			event.preventDefault();
		}
	},

	/**
	* Simulates double-tap by watching for two taps within 300ms of each other.
	*
	* @private
	*/
	singleTap: function (sender, event) {
		setTimeout(this.bindSafely(function () {
			this.tapped = false;
		}), 300);
		if (this.tapped) { //dbltap
			this.tapped = false;
			this.smartZoom(sender, event);
		} else {
			this.tapped = true;
		}
	},

	/**
	* Zooms at the event location.
	*
	* @private
	*/
	smartZoom: function (sender, event) {
		var containerNode = this.hasNode();
		var imgNode = this.$.content.hasNode();
		if (containerNode && imgNode && this.hasNode() && !this.disableZoom) {
			var prevScale = this.scale;
			if (this.scale != this.minScale) { //zoom out
				this.scale = this.minScale;
			} else { //zoom in
				this.scale = this.maxScale;
			}
			this.eventPt = this.calcEventLocation(event);
			if (this.animate) {
				//lock ratio position of event, and animate the scale change
				var ratioLock = {
					x: ((this.eventPt.x + this.getScrollLeft()) / this.bounds.width),
					y: ((this.eventPt.y + this.getScrollTop()) / this.bounds.height)
				};
				this.$.animator.play({
					duration: 350,
					ratioLock: ratioLock,
					baseScale: prevScale,
					deltaScale: this.scale - prevScale
				});
			} else {
				this.transform(this.scale);
				this.doZoom({scale:this.scale});
			}
		}
	},

	/**
	* @private
	*/
	zoomAnimationStep: function (inSender, inEvent) {
		var currScale = this.$.animator.baseScale + (this.$.animator.deltaScale * this.$.animator.value);
		this.transform(currScale);
		return true;
	},

	/**
	* @private
	*/
	zoomAnimationEnd: function (inSender, inEvent) {
		this.stabilize();
		this.doZoom({scale:this.scale});
		this.$.animator.ratioLock = undefined;
		return true;
	},

	/**
	* @fires enyo.PanZoomView#onPositionPin
	* @private
	*/
	positionClientControls: function (scale) {
		this.waterfallDown('onPositionPin', {
			scale: scale,
			bounds: this.bounds
		});
	}
});
},{"../../enyo/lib/Animator":5,"../../enyo/lib/Scroller":44,"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"../../enyo/lib/platform":71,"../../enyo/lib/utils":75}],106:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Control = require('../../../enyo/lib/Control'),
	Image = require('../../../enyo/lib/Image'),
	Popup = require('../../../enyo/lib/Popup'),
	Repeater = require('../../../enyo/lib/Repeater'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	ContextualLayout = require('../../../layout/lib/ContextualLayout'),
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');


/**
	sample.ContextualPopup_ is an example of a popup that uses the ContextualLayout layout strategy.
*/
var ContextualPopup = kind({
	kind: Popup,
	layoutKind: ContextualLayout,
	classes: 'sample-contextual-popup',

	floating: true,
	count: 5,

	//layout parameters
	vertFlushMargin: 60,	//vertical flush layout margin
	horizFlushMargin: 50,	//horizontal flush layout margin
	widePopup: 200,			//popups wider than this value are considered wide (for layout purposes)
	longPopup: 200,			//popups longer than this value are considered long (for layout purposes)
	horizBuffer: 16,		//do not allow horizontal flush popups past spec'd amount of buffer space on left/right screen edge

	handlers: {
		onRequestShowMenu: 'requestShow'
	},

	create: function () {
		Popup.prototype.create.apply(this, arguments);
		this.createComponent({kind: Repeater, count: this.count, onSetupItem: 'setupItem', components: [
			{name: 'item'}
		]});
	},
	setupItem: function (sender, event) {
		event.item.$.item.set('content', 'Item ' + event.index);
	},
	requestShow: function(inSender, inEvent) {
		var n = inEvent.activator.hasNode();
		if (n) {
			this.activatorOffset = this.getPageOffset(n);
		}
		this.show();
		return true;
	},
	getPageOffset: function(inNode) {
		// getBoundingClientRect returns top/left values which are relative to the viewport and not absolute
		var r = inNode.getBoundingClientRect();

		var pageYOffset = (window.pageYOffset === undefined) ? document.documentElement.scrollTop : window.pageYOffset;
		var pageXOffset = (window.pageXOffset === undefined) ? document.documentElement.scrollLeft : window.pageXOffset;
		var rHeight = (r.height === undefined) ? (r.bottom - r.top) : r.height;
		var rWidth = (r.width === undefined) ? (r.right - r.left) : r.width;

		return {top: r.top + pageYOffset, left: r.left + pageXOffset, height: rHeight, width: rWidth};
	}
});


module.exports = kind({
	name: 'layout.sample.ContextualLayoutSample',
	kind: FittableRows,
	classes: 'enyo enyo-fit',
	components: [
		{name: 'topToolbar', style: 'background-color: lightgray', components: [
			{kind: FittableColumns, style: 'width:100%;', components:[
				{components: [
					{kind: Control, classes: 'sample-popup-button icon-button', ontap: 'showPopup', style: 'background-image: url(assets/menu-icon-bookmark.png)'},
					{kind: ContextualPopup, count: 2}
				]},
				{fit:true, style: 'position:absolute;right:0;', components: [
					{kind: Control, classes: 'sample-popup-button icon-button', ontap: 'showPopup', style: 'background-image: url(assets/menu-icon-bookmark.png)'},
					{kind: ContextualPopup, count: 6}
				]}
			]}
		]},
		{kind: Scroller, fit: true, thumb: false, components:[
			{name: 'buttonContainer', kind: FittableRows, classes: 'onyx-contextualpopup-button-container enyo-fit', components:[
				//Top row of buttons
				{components:[
					{style: 'display:inline-block', components: [
						{kind: Control, content: 'Average', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, count: 5}
					]},

					{style: 'display:inline-block;float:right', components: [
						{kind: Control, content: 'Small', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, count: 1}
					]}
				]},
				//Center row of buttons
				{fit:true, style: 'padding-top:15%;padding-bottom:15%;', components:[
					{style: 'display:inline-block;', components: [
						{kind: Control, content: 'Wide', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, style: 'width:300px', count: 0, components: [
							{kind: Scroller, style: 'min-width:150px;', horizontal: 'auto',  touch:true, thumb:false,  components:[
								{content: 'testing 1'},
								{content: 'testing 2'}
							]}
						]}
					]},
					{style: 'display:inline-block;float:right', components: [
						{kind: Control, content: 'Long', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, count: 30}
					]}
				]},
				//Bottom row of buttons
				{components:[
					{style: 'display:inline-block;', components: [
						{kind: Control, content: 'Press Me', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, style: 'width:200px', count: 10}
					]},
					{style: 'display:inline-block;float:right', components: [
						{kind: Control, content: 'Try Me', classes: 'sample-popup-button', ontap: 'showPopup'},
						{kind: ContextualPopup, style: 'width:250px', count: 5}
					]}
				]}
			]}
		]},
		{name: 'bottomToolbar', classes: 'onyx-menu-toolbar', style: 'background-color:lightgray', components: [
			{kind: FittableColumns, style: 'width:100%;', components:[
				{components: [
					{kind: Control, classes: 'sample-popup-button icon-button', ontap: 'showPopup', style: 'background-image: url(assets/menu-icon-bookmark.png)'},
					{kind: ContextualPopup, count: 6}
				]},
				{fit: true, style: 'position:absolute;right:0;', components: [
					{kind: Control, classes: 'sample-popup-button icon-button', ontap: 'showPopup', style: 'background-image: url(assets/menu-icon-bookmark.png)'},
					{kind: ContextualPopup, name: 'facebook', count: 6}
				]}
			]}
		]}
	],
	showPopup: function (sender, event) {
		// 
		sender.parent.waterfall('onRequestShowMenu', {
			activator: sender
		});
	}
});
},{"../../../enyo/lib/Control":16,"../../../enyo/lib/Image":23,"../../../enyo/lib/Popup":37,"../../../enyo/lib/Repeater":38,"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../layout/lib/ContextualLayout":83,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],112:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableDescription',
	classes: 'fittable-sample-box enyo-fit',
	style: 'padding:10px;',
	kind: Scroller,
	components: [
		{tag: 'p', allowHtml: true, content: 'FittableColumns, no margin on boxes (all divs have some padding). By default, boxes "stretch" to fit the container (which must have a height).'},
		{kind: FittableColumns, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mlr fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box'},
			{content: 'Fitting BoxB', fit: true, classes: 'fittable-sample-box'},
			{content: 'BoxC', classes: 'fittable-sample-box'}
		]},
		{tag: 'p', allowHtml: true, content: 'Boxes with left/right margins. Note: top/bottom margin on column boxes is NOT supported.'},
		{kind: FittableColumns, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mlr fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'Fitting BoxB', fit: true, classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'BoxC', classes: 'fittable-sample-box fittable-sample-mlr'}
		]},
		{tag: 'p', allowHtml: true, content: 'With <code>noStretch: true</code>, boxes have natural height.'},
		{kind: FittableColumns, noStretch: true, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mlr fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'Fitting BoxB<br><br>with natural height', fit: true, allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr'},
			{content: 'BoxC', classes: 'fittable-sample-box fittable-sample-mlr'}
		]},
		{tag: 'p', allowHtml: true, content: 'FittableRows, no margin on boxes (all divs have some padding).'},
		{kind: FittableRows, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mlr fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box'},
			{content: 'Fitting BoxB', fit: true, classes: 'fittable-sample-box'},
			{content: 'BoxC', classes: 'fittable-sample-box'}
		]},
		{tag: 'p', allowHtml: true, content: 'Row boxes may have margin in any dimension.<br><br> NOTE: Row boxes will collapse vertical margins according to css rules. If margin collapse is not desired, then "enyo-margin-expand" may be applied. Only in this case, left/right margin on row boxes is NOT supported.'},
		{kind: FittableRows, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mlr fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{content: 'Fitting BoxB', fit: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{content: 'BoxC', classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'}
		]},
		{tag: 'p', allowHtml: true, content: 'With <code>noStretch: true</code>, boxes have natural width.<br><br> NOTE: margins will not collapse in this case.'},
		{kind: FittableRows, noStretch: true, classes: 'fittable-sample-height fittable-sample-box fittable-sample-o fittable-sample-mtb', components: [
			{content: 'BoxA', classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{content: 'Fitting BoxB', fit: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{content: 'BoxC', classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'}
		]}
	]
});
},{"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],114:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.FittableTests',
	classes: 'fittable-sample-box enyo-fit',
	kind: Scroller,
	components: [
		{classes: 'fittable-sample-section', content: 'Rows/Columns using a combination of css units and highlighting margin collapse'},
		{kind: FittableRows, classes: 'fittable-sample-box fittable-sample-test', style: 'height: 400px;', components: [
			{content: 'FOO<br>margin-bottom: 1em', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb', style: 'margin-bottom: 1em;'},
			{content: 'margin-top: 1em (collapsed since sibling shows greater of previous bottom and this top)<br>FOO', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb', style: 'margin-top: 1em;'},
			{content: 'FOO<br>FOO', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{kind: FittableColumns, fit: true, classes: 'fittable-sample-box fittable-sample-mtb fittable-sample-mlr fittable-sample-o', components: [
				{content: '111111111111111', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '111111111111111', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '2', fit: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-o'},
				{content: '3333333', classes: 'fittable-sample-box fittable-sample-mlr'}
			]},
			{kind: FittableColumns, content: 'Bat', classes: 'fittable-sample-box fittable-sample-mtb enyo-center', components: [
				{content: 'add enyo-center to FittableColumns', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '1', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '2', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '3', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '4', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '5', classes: 'fittable-sample-box fittable-sample-mlr'}
			]}
		]},
		{classes: 'fittable-sample-section', content: 'Rows with enyo-margin-expand to avoid margin-collapse'},
		{kind: FittableRows, classes: 'fittable-sample-box fittable-sample-test enyo-margin-expand', style: 'height: 250px;', components: [
			{content: 'FOO<br>margin-bottom: 1em', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mtb', style: 'margin-bottom: 1em;'},
			{content: 'margin-top: 3em (not collapsed due to enyo-margin-expand on box)<br>FOO', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mtb', style: 'margin-top: 3em;'},
			{content: 'FOO<br>FOO', allowHtml: true, fit: true, classes: 'fittable-sample-box fittable-sample-mtb'}
		]},
		{classes: 'fittable-sample-section', content: 'Tests to ensure fit region can be first, middle, or last'},
		{kind: FittableRows, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A', fit: true},
			{content: 'B'},
			{content: 'C'}
		]},
		{kind: FittableRows, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A'},
			{content: 'B', fit: true},
			{content: 'C'}
		]},
		{kind: FittableRows, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A'},
			{content: 'B'},
			{content: 'C', fit: true}
		]},
		{kind: FittableColumns, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A', fit: true},
			{content: 'B'},
			{content: 'C'}
		]},
		{kind: FittableColumns, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A'},
			{content: 'B', fit: true},
			{content: 'C'}
		]},
		{style: 'height: 200px;', kind: FittableColumns, classes: 'fittable-sample-boxable fittable-sample-small-test', components: [
			{content: 'A'},
			{content: 'B'},
			{content: 'C', fit: true}
		]},
		{classes: 'fittable-sample-section', content: 'Tests for noStretch: true'},
		{kind: FittableRows, classes: 'fittable-sample-box fittable-sample-test', style: 'height: 400px;', noStretch: true, components: [
			{content: 'FOO<br>margin-bottom: 1em', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb', style: 'margin-bottom: 1em;'},
			{content: 'margin-top: 2em (not collapsed; stretch false does not collapse due to use of float)<br>FOO', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb', style: 'margin-top: 1em;'},
			{content: 'FOO<br>FOO', allowHtml: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-mtb'},
			{kind: FittableColumns, fit: true, noStretch: true, classes: 'fittable-sample-box fittable-sample-mtb fittable-sample-mlr fittable-sample-o', components: [
				{content: '111111111111111', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '111111111111111', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '2<br>2', allowHtml: true, fit: true, classes: 'fittable-sample-box fittable-sample-mlr fittable-sample-o'},
				{content: '3333333', classes: 'fittable-sample-box fittable-sample-mlr'}
			]},
			{kind: FittableColumns, content: 'Bat', noStretch: true, classes: 'fittable-sample-box fittable-sample-mtb enyo-center', components: [
				{content: 'add enyo-center to FittableColumns', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '1', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '2', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '3', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '4', classes: 'fittable-sample-box fittable-sample-mlr'},
				{content: '5', classes: 'fittable-sample-box fittable-sample-mlr'}
			]}
		]}
	]
});
},{"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88}],115:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	FittableRows = require('../../../layout/lib/FittableRows'),
	FlyweightRepeater = require('../../../layout/lib/FlyweightRepeater');

module.exports = kind({
	name: 'enyo.sample.FlyweightRepeaterSample',
	kind: FittableRows,
	classes: 'flyweight-repeater-sample enyo-fit onyx',
	components: [
		{classes: 'layout-sample-toolbar', components: [
			{content: 'FlyweightRepeater Result'}
		]},
		{name:'result', style:'padding:12px; font-size: 20px;', content: 'Nothing selected yet.'},
		{kind: Scroller, fit: true, components: [
			{name:'repeater', kind: FlyweightRepeater, classes:'flyweight-repeater-sample-list', count: 26, onSetupItem: 'setupItem', components: [
				{name: 'item', classes:'flyweight-repeater-sample-item'}
			]}
		]}
	],
	handlers: {
		onSelect: 'itemSelected'
	},
	people: [
		{name: 'Andrew'},
		{name: 'Betty'},
		{name: 'Christopher'},
		{name: 'Donna'},
		{name: 'Ephraim'},
		{name: 'Frankie'},
		{name: 'Gerald'},
		{name: 'Heather'},
		{name: 'Ingred'},
		{name: 'Jack'},
		{name: 'Kevin'},
		{name: 'Lucy'},
		{name: 'Matthew'},
		{name: 'Noreen'},
		{name: 'Oscar'},
		{name: 'Pedro'},
		{name: 'Quentin'},
		{name: 'Ralph'},
		{name: 'Steven'},
		{name: 'Tracy'},
		{name: 'Uma'},
		{name: 'Victor'},
		{name: 'Wendy'},
		{name: 'Xin'},
		{name: 'Yulia'},
		{name: 'Zoltan'}
	],
	setupItem: function(sender, event) {
		var index = event.index;
		this.$.item.setContent((index+1) + '. ' + this.people[index].name);
		this.$.item.applyStyle('background', (event.selected? 'dodgerblue':'lightgray'));
		/* stop propogation */
		return true;
	},
	itemSelected: function(sender, event) {
		var index = event.index;
		var count = event.flyweight.count;
		if(index>=0 && index<count){
			this.$.result.setContent(' [' + (index+1) + '. ' + this.people[index].name + '] is selected');
		}
		return true;
	}
});

},{"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableRows":88,"../../../layout/lib/FlyweightRepeater":89}],130:[function(require,module,exports){

var
	kind = require('../../../enyo/lib/kind'),
	ready = require('../../../enyo/lib/ready'),
	utils = require('../../../enyo/lib/utils'),
	drag = require('../../../enyo/lib/drag'),
	Scroller = require('../../../enyo/lib/Scroller'),
	Select = require('../../../enyo/lib/Select'),
	Button = require('../../../enyo/lib/Button'),
	ToolDecorator = require('../../../enyo/lib/ToolDecorator'),
	Input = require('../../../enyo/lib/Input');

var
	CardArranger = require('../../../layout/lib/CardArranger'),
	CardSlideInArranger = require('../../../layout/lib/CardSlideInArranger'),
	CarouselArranger = require('../../../layout/lib/CarouselArranger'),
	CollapsingArranger = require('../../../layout/lib/CollapsingArranger'),
	DockRightArranger = require('../../../layout/lib/DockRightArranger'),
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	GridArranger = require('../../../layout/lib/GridArranger'),
	LeftRightArranger = require('../../../layout/lib/LeftRightArranger'),
	Panels = require('../../../layout/lib/Panels'),
	SpiralArranger = require('../../../layout/lib/SpiralArranger'),
	TopBottomArranger = require('../../../layout/lib/TopBottomArranger');

var MyGridArranger = kind({
	kind: GridArranger,
	colHeight: '150',
	colWidth: '150'
});

var PanelsSample = module.exports = kind({
	name: 'enyo.sample.PanelsSample',
	kind: FittableRows,
	classes: 'enyo-sample-panelssample enyo-fit',
	components: [
		{classes: 'toolbar', components: [
			{name: 'arrangerPicker', kind: Select, maxHeight: 360, floating: true, onchange: 'arrangerSelected', components: [
				{content: 'Arranger'}
			]},
			{kind: Button, content: 'Previous', ontap: 'prevPanel'},
			{kind: Button, content: 'Next', ontap: 'nextPanel'},
			{kind: ToolDecorator, components: [
				{kind: Input, value: 0, onchange: 'gotoPanel'}
			]},
			{kind: Button, content: 'Go', ontap: 'gotoPanel'},
			{kind: Button, content: 'Add', ontap: 'addPanel'},
			{kind: Button, content: 'Delete', ontap: 'deletePanel'}
		]},
		{kind: Panels, name: 'samplePanels', fit: true, realtimeFit: true, classes: 'panels-sample-panels enyo-border-box', components: [
			{content: 0, style: 'background:red;'},
			{content: 1, style: 'background:orange;'},
			{content: 2, style: 'background:yellow;'},
			{content: 3, style: 'background:green;'},
			{content: 4, style: 'background:blue;'},
			{content: 5, style: 'background:indigo;'},
			{content: 6, style: 'background:violet;'}
		]}
	],
	panelArrangers: [
		{name: 'CardArranger', arrangerKind: CardArranger},
		{name: 'CardSlideInArranger', arrangerKind: CardSlideInArranger},
		{name: 'CarouselArranger', arrangerKind: CarouselArranger, classes: 'panels-sample-wide'},
		{name: 'CollapsingArranger', arrangerKind: CollapsingArranger, classes: 'panels-sample-collapsible'},
		{name: 'LeftRightArranger', arrangerKind: LeftRightArranger},
		{name: 'TopBottomArranger', arrangerKind: TopBottomArranger, classes: 'panels-sample-topbottom'},
		{name: 'SpiralArranger', arrangerKind: SpiralArranger, classes: 'panels-sample-spiral'},
		{name: 'GridArranger', arrangerKind: MyGridArranger, classes: 'panels-sample-grid'},
		{name: 'DockRightArranger', arrangerKind: DockRightArranger, classes: 'panels-sample-collapsible'}
	],
	bgcolors: ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],
	create: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			for (var i=0; i<this.panelArrangers.length; i++) {
				this.$.arrangerPicker.createComponent({content:this.panelArrangers[i].name});
			}
			this.panelCount=this.$.samplePanels.getPanels().length;
		};
	}),
	arrangerSelected: function(sender, event) {
		var sp = this.$.samplePanels;
		var p = this.panelArrangers[sender.selected - 1];
		if (this.currentClass) {
			sp.removeClass(this.currentClass);
		}
		if (p) {
			if (p.classes) {
				sp.addClass(p.classes);
				this.currentClass = p.classes;
			}
			sp.setArrangerKind(p.arrangerKind);
			if (Panels.isScreenNarrow()) {
				this.setIndex(1);
			}
		}
	},
	// panels
	prevPanel: function() {
		this.$.samplePanels.previous();
		this.$.input.setValue(this.$.samplePanels.index);
	},
	nextPanel: function() {
		this.$.samplePanels.next();
		this.$.input.setValue(this.$.samplePanels.index);
	},
	gotoPanel: function() {
		this.$.samplePanels.setIndex(this.$.input.getValue());
	},
	panelCount: 0,
	addPanel: function() {
		var sp = this.$.samplePanels;
		var i = this.panelCount++;
		var p = sp.createComponent({
			style: 'background: ' + this.bgcolors[i % this.bgcolors.length],
			content:i
		});
		p.render();
		sp.reflow();
		sp.setIndex(i);
	},
	deletePanel: function() {
		var p = this.$.samplePanels.getActive();
		if (p) {
			p.destroy();
		}
	}
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Input":24,"../../../enyo/lib/Scroller":44,"../../../enyo/lib/Select":45,"../../../enyo/lib/ToolDecorator":52,"../../../enyo/lib/drag":59,"../../../enyo/lib/kind":66,"../../../enyo/lib/ready":72,"../../../enyo/lib/utils":75,"../../../layout/lib/CardArranger":79,"../../../layout/lib/CardSlideInArranger":80,"../../../layout/lib/CarouselArranger":81,"../../../layout/lib/CollapsingArranger":82,"../../../layout/lib/DockRightArranger":84,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"../../../layout/lib/GridArranger":90,"../../../layout/lib/LeftRightArranger":94,"../../../layout/lib/Panels":99,"../../../layout/lib/SpiralArranger":103,"../../../layout/lib/TopBottomArranger":104}],134:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Scroller = require('../../../enyo/lib/Scroller'),
	Selection = require('../../../enyo/lib/Selection');

var
	FittableRows = require('../../../layout/lib/FittableRows'),
	TreeNode = require('../../../layout/lib/Node');

module.exports = kind({
	name: 'enyo.sample.TreeSample',
	classes: 'enyo-unselectable enyo-fit',
	kind: FittableRows,
	fit: true,
	components: [
		{kind: Selection, onSelect: 'select', onDeselect: 'deselect'},
		{kind: Scroller, fit: true, components: [
			{kind: TreeNode, icon: 'assets/folder-open.png', content: 'Tree', expandable: true, expanded: true, onExpand: 'nodeExpand', onNodeTap: 'nodeTap', components: [
				{icon: 'assets/file.png', content: 'Alpha'},
				{icon: 'assets/folder-open.png', content: 'Bravo', expandable: true, expanded: true, components: [
					{icon: 'assets/file.png', content: 'Bravo-Alpha'},
					{icon: 'assets/file.png', content: 'Bravo-Bravo'},
					{icon: 'assets/file.png', content: 'Bravo-Charlie'}
				]},
				{icon: 'assets/folder.png', content: 'Charlie', expandable: true, components: [
					{icon: 'assets/file.png', content: 'Charlie-Alpha'},
					{icon: 'assets/file.png', content: 'Charlie-Bravo'},
					{icon: 'assets/file.png', content: 'Charlie-Charlie'}
				]},
				{icon: 'assets/folder-open.png', content: 'Delta', expandable: true, expanded: true, components: [
					{icon: 'assets/file.png', content: 'Delta-Alpha'},
					{icon: 'assets/file.png', content: 'Delta-Bravo'},
					{icon: 'assets/file.png', content: 'Delta-Charlie'}
				]},
				{icon: 'assets/file.png', content: 'Epsilon'}
			]}
		]}
	],
	nodeExpand: function (sender, event) {
		sender.setIcon('assets/' + (sender.expanded ? 'folder-open.png' : 'folder.png'));
	},
	nodeTap: function (sender, event) {
		var node = event.originator;
		this.$.selection.select(node.id, node);
	},
	select: function (sender, event) {
		event.data.$.caption.applyStyle('background-color', 'lightblue');
	},
	deselect: function (sender, event) {
		event.data.$.caption.applyStyle('background-color', null);
	}
});
},{"../../../enyo/lib/Scroller":44,"../../../enyo/lib/Selection":46,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableRows":88,"../../../layout/lib/Node":97}],77:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind');

var
	List = require('./List'),
	FlyweightRepeater = require('./FlyweightRepeater');

/**
* {@link enyo.AroundList} is an {@link enyo.List} that allows content to be
* displayed around its rows.
*
* ```
* {kind: 'enyo.AroundList', onSetupItem: 'setupItem',
*     aboveComponents: [
*         {content: 'Content above the list'}
*     ],
*     components: [
*         {content: 'List item'}
*     ]
* }
* ```
*
* @ui
* @class enyo.AroundList
* @extends enyo.List
* @public
*/
module.exports = kind(
	/** @lends enyo.AroundList.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.AroundList',

	/**
	* @private
	*/
	kind: List,

	/**
	* @private
	*/
	listTools: [
		{name: 'port', classes: 'enyo-list-port enyo-border-box', components: [
			{name: 'aboveClient'},
			{name: 'generator', kind: FlyweightRepeater, canGenerate: false, components: [
				{tag: null, name: 'client'}
			]},
			{name: 'holdingarea', allowHtml: true, classes: 'enyo-list-holdingarea'},
			{name: 'page0', allowHtml: true, classes: 'enyo-list-page'},
			{name: 'page1', allowHtml: true, classes: 'enyo-list-page'},
			{name: 'belowClient'},
			{name: 'placeholder'},
			{name: 'swipeableComponents', style: 'position:absolute; display:block; top:-1000px; left:0px;'}
		]}
	],

	/**
	* A block of components to be rendered above the list.
	*
	* @type {Object[]}
	* @default null
	* @public
	*/
	aboveComponents: null,

	/**
	* A block of components to be rendered below the list.
	*
	* @type {Object[]}
	* @default null
	* @public
	*/
	belowComponents: null,

	/**
	* @method
	* @private
	*/
	initComponents: function () {
		List.prototype.initComponents.apply(this, arguments);
		if (this.aboveComponents) {
			this.$.aboveClient.createComponents(this.aboveComponents, {owner: this.owner});
		}
		if (this.belowComponents) {
			this.$.belowClient.createComponents(this.belowComponents, {owner: this.owner});
		}
	},

	/**
	* @see enyo.List.updateMetrics
	* @private
	*/
	updateMetrics: function () {
		this.defaultPageSize = this.rowsPerPage * (this.rowSize || 100);
		this.pageCount = Math.ceil(this.count / this.rowsPerPage);
		this.aboveHeight = this.$.aboveClient.getBounds().height;
		this.belowHeight = this.$.belowClient.getBounds().height;
		this.portSize = this.aboveHeight + this.belowHeight;
		for (var i=0; i < this.pageCount; i++) {
			this.portSize += this.getPageSize(i);
		}
		this.adjustPortSize();
	},

	/**
	* @see enyo.List.positionPage
	* @private
	*/
	positionPage: function (pageNumber, target) {
		target.pageNo = pageNumber;
		var y = this.pageToPosition(pageNumber);
		var o = this.bottomUp ? this.belowHeight : this.aboveHeight;
		y += o;
		target.applyStyle(this.pageBound, y + 'px');
	},

	/**
	* Scrolls past the [aboveComponents]{@link enyo.AroundList#aboveComponents}
	* or [belowComponents]{@link enyo.AroundList#belowComponents} components to
	* reveal the list.
	*
	* @public
	*/
	scrollToContentStart: function () {
		var y = this.bottomUp ? this.belowHeight : this.aboveHeight;
		this.setScrollPosition(y);
	}
});
},{"../../enyo/lib/kind":66,"./FlyweightRepeater":89,"./List":95}],100:[function(require,module,exports){
var
	dom = require('../../../enyo/lib/dom'),
	kind = require('../../../enyo/lib/kind'),
	platform = require('../../../enyo/lib/platform'),
	TouchScrollStrategy = require('../../../enyo/lib/TouchScrollStrategy'),
	TranslateScrollStrategy = require('../../../enyo/lib/TranslateScrollStrategy');

var
	List = require('../List'),
	Puller = require('./Puller');

/**
* Fires when user initiates a pull action. No additional data is included with
* this event.
*
* @event enyo.PulldownList#onPullStart
* @type {Object}
* @public
*/

/**
* Fires when user cancels a pull action. No additional data is included with
* this event.
*
* @event enyo.PulldownList#onPullCancel
* @type {Object}
* @public
*/

/**
* Fires while a pull action is in progress. No additional data is included with
* this event.
*
* @event enyo.PulldownList#onPull
* @type {Object}
* @public
*/

/**
* Fires when the list is released following a pull action, indicating
* that we are ready to retrieve data. No additional data is included with
* this event.
*
* @event enyo.PulldownList#onPullRelease
* @type {Object}
* @public
*/

/**
* Fires when data retrieval is complete, indicating that the data is
* is ready to be displayed. No additional data is included with
* this event.
*
* @event enyo.PulldownList#onPullComplete
* @type {Object}
* @public
*/

/**
* {@link enyo.PulldownList} is a list that provides a pull-to-refresh feature, which
* allows new data to be retrieved and updated in the list.
*
* PulldownList provides the [onPullRelease]{@link enyo.PulldownList#onPullRelease}
* event to allow an application to start retrieving new data.  The
* [onPullComplete]{@link enyo.PulldownList#onPullComplete} event indicates that
* the pull is complete and it's time to update the list with the new data.
*
* ```
* {name: 'list', kind: 'PulldownList', onSetupItem: 'setupItem',
* 	onPullRelease: 'pullRelease', onPullComplete: 'pullComplete',
* 	components: [
* 		{name: 'item'}
* 	]
* }
*
* pullRelease: function () {
* 	this.search();
* },
* processSearchResults: function (inRequest, inResponse) {
* 	this.results = inResponse.results;
* 	this.$.list.setCount(this.results.length);
* 	this.$.list.completePull();
* },
* pullComplete: function () {
* 	this.$.list.reset();
* }
* ```
*
* @ui
* @class enyo.PulldownList
* @extends enyo.List
* @public
*/
var PulldownList = module.exports = kind(
	/** @lends enyo.PulldownList.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.PulldownList',

	/**
	* @private
	*/
	kind: List,

	/**
	* Sets `touch` to `true` in inherited Scroller kind for touch-based scrolling strategy.
	*
	* @see {@link enyo.Scroller.touch}
	* @type {Boolean}
	* @default true
	* @public
	*/
	touch: true,

	/**
	* The pull notification area at the top of the list.
	*
	* @type {enyo.Control}
	* @default null
	* @private
	*/
	pully: null,

	/**
	* @private
	*/
	pulldownTools: [
		{name: 'pulldown', classes: 'enyo-list-pulldown', components: [
			{name: 'puller', kind: Puller}
		]}
	],

	/**
	* @private
	*/
	events: {
		//* Fires when user initiates a pull action.
		onPullStart: '',
		//* Fires when user cancels a pull action.
		onPullCancel: '',
		//* Fires while a pull action is in progress.
		onPull: '',
		//* Fires when the list is released following a pull action, indicating
		//* that we are ready to retrieve data.
		onPullRelease: '',
		//* Fires when data retrieval is complete, indicating that the data is
		//* is ready to be displayed.
		onPullComplete: ''
	},

	/**
	* @private
	*/
	handlers: {
		onScrollStart: 'scrollStartHandler',
		onScrollStop: 'scrollStopHandler',
		ondragfinish: 'dragfinish'
	},

	/**
	* Message displayed when list is not being pulled.
	*
	* @type {String}
	* @default 'Pull down to refresh...'
	* @public
	*/
	pullingMessage: 'Pull down to refresh...',

	/**
	* Message displayed while a pull action is in progress.
	*
	* @type {String}
	* @default 'Release to refresh...'
	* @public
	*/
	pulledMessage: 'Release to refresh...',

	/**
	* Message displayed while data is being retrieved.
	*
	* @type {String}
	* @default 'Loading...'
	* @public
	*/
	loadingMessage: 'Loading...',

	/**
	* @private
	*/
	pullingIconClass: 'enyo-puller-arrow enyo-puller-arrow-down',

	/**
	* @private
	*/
	pulledIconClass: 'enyo-puller-arrow enyo-puller-arrow-up',

	/**
	* @private
	*/
	loadingIconClass: '',

	/**
	* @method
	* @private
	*/
	create: function () {
		var p = {kind: Puller, showing: false, text: this.loadingMessage, iconClass: this.loadingIconClass, onCreate: 'setPully'};
		this.listTools.splice(0, 0, p);
		List.prototype.create.apply(this, arguments);
		this.setPulling();
	},

	/**
	* @method
	* @private
	*/
	initComponents: function () {
		this.createChrome(this.pulldownTools);
		this.accel = dom.canAccelerate();
		this.translation = this.accel ? 'translate3d' : 'translate';
		this.strategyKind = this.resetStrategyKind();
		List.prototype.initComponents.apply(this, arguments);
	},

	/**
	* Temporarily use TouchScrollStrategy on iOS devices (see ENYO-1714).
	*
	* @private
	*/
	resetStrategyKind: function () {
		return (platform.android >= 3)
			? TranslateScrollStrategy
			: TouchScrollStrategy;
	},

	/**
	* @private
	*/
	setPully: function (sender, event) {
		this.pully = event.originator;
	},

	/**
	* @private
	*/
	scrollStartHandler: function () {
		this.firedPullStart = false;
		this.firedPull = false;
		this.firedPullCancel = false;
	},

	/**
	* Monitors the scroll position to display and position the
	* [pully]{@link enyo.PulldownList#pully}.
	*
	* @see {@link enyo.Scroller.scroll}
	* @method
	* @private
	*/
	scroll: function (sender, event) {
		var r = List.prototype.scroll.apply(this, arguments);
		if (this.completingPull) {
			this.pully.setShowing(false);
		}
		var s = this.getStrategy().$.scrollMath || this.getStrategy();
		var over = -1*this.getScrollTop();
		if (s.isInOverScroll() && over > 0) {
			dom.transformValue(this.$.pulldown, this.translation, '0,' + over + 'px' + (this.accel ? ',0' : ''));
			if (!this.firedPullStart) {
				this.firedPullStart = true;
				this.pullStart();
				this.pullHeight = this.$.pulldown.getBounds().height;
			}
			if (over > this.pullHeight && !this.firedPull) {
				this.firedPull = true;
				this.firedPullCancel = false;
				this.pull();
			}
			if (this.firedPull && !this.firedPullCancel && over < this.pullHeight) {
				this.firedPullCancel = true;
				this.firedPull = false;
				this.pullCancel();
			}
		}
		return r;
	},

	/**
	* @private
	*/
	scrollStopHandler: function () {
		if (this.completingPull) {
			this.completingPull = false;
			this.doPullComplete();
		}
	},

	/**
	* If the pull has been fired, offset the scroll top by the height of the
	* [pully]{@link enyo.PulldownList#pully} until
	* [completePull()]{@link enyo.PulldownList#completePull} is called.
	*
	* @private
	*/
	dragfinish: function () {
		if (this.firedPull) {
			var s = this.getStrategy().$.scrollMath || this.getStrategy();
			s.setScrollY(-1*this.getScrollTop() - this.pullHeight);
			this.pullRelease();
		}
	},

	/**
	* Signals that the list should execute pull completion. This is usually
	* called after the application has received new data.
	*
	* @public
	*/
	completePull: function () {
		this.completingPull = true;
		var s = this.getStrategy().$.scrollMath || this.getStrategy();
		s.setScrollY(this.pullHeight);
		s.start();
	},

	/**
	* @fires enyo.PulldownList#onPullStart
	* @private
	*/
	pullStart: function () {
		this.setPulling();
		this.pully.setShowing(false);
		this.$.puller.setShowing(true);
		this.doPullStart();
	},

	/**
	* @fires enyo.PulldownList#onPull
	* @private
	*/
	pull: function () {
		this.setPulled();
		this.doPull();
	},

	/**
	* @fires enyo.PulldownList#onPullCancel
	* @private
	*/
	pullCancel: function () {
		this.setPulling();
		this.doPullCancel();
	},

	/**
	* @fires enyo.PulldownList#onPullRelease
	* @private
	*/
	pullRelease: function () {
		this.$.puller.setShowing(false);
		this.pully.setShowing(true);
		this.doPullRelease();
	},

	/**
	* @private
	*/
	setPulling: function () {
		this.$.puller.setText(this.pullingMessage);
		this.$.puller.setIconClass(this.pullingIconClass);
	},

	/**
	* @private
	*/
	setPulled: function () {
		this.$.puller.setText(this.pulledMessage);
		this.$.puller.setIconClass(this.pulledIconClass);
	}
});

PulldownList.Puller = Puller;
},{"../../../enyo/lib/TouchScrollStrategy":53,"../../../enyo/lib/TranslateScrollStrategy":54,"../../../enyo/lib/dom":58,"../../../enyo/lib/kind":66,"../../../enyo/lib/platform":71,"../List":95,"./Puller":101}],119:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind');

var
	List = require('../../../layout/lib/List');

var
	names = require('./NameGenerator');

module.exports = kind({
	name: 'enyo.sample.ListBasicSample',
	classes: 'list-sample enyo-fit',
	components: [
		{name: 'list', kind: List, count: 20000, multiSelect: false, classes: 'enyo-fit list-sample-list', onSetupItem: 'setupItem', components: [
			{name: 'item', classes: 'list-sample-item enyo-border-box', components: [
				{name: 'index', classes: 'list-sample-index'},
				{name: 'name'}
			]}
		]}
	],
	names: [],
	setupItem: function(sender, event) {
		// this is the row we're setting up
		var i = event.index;
		// make some mock data if we have none for this row
		if (!this.names[i]) {
			this.names[i] = names.makeName(5, 10, '', '');
		}
		var n = this.names[i];
		var ni = ('00000000' + i).slice(-7);
		// apply selection style if sender (the list) indicates that this row is selected.
		this.$.item.addRemoveClass('list-sample-selected', sender.isSelected(i));
		this.$.name.setContent(n);
		this.$.index.setContent(ni);
		return true;
	}
});
},{"../../../enyo/lib/kind":66,"../../../layout/lib/List":95,"./NameGenerator":125}],120:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	job = require('../../../enyo/lib/job'),
	utils = require('../../../enyo/lib/utils'),
	Button = require('../../../enyo/lib/Button'),
	Checkbox = require('../../../enyo/lib/Checkbox'),
	Image = require('../../../enyo/lib/Image'),
	Input = require('../../../enyo/lib/Input'),
	Popup = require('../../../enyo/lib/Popup');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	List = require('../../../layout/lib/List');

var
	names = require('./NameGenerator');


// It's convenient to create a kind for the item we'll render in the contacts list.
var ContactItem = kind({
	events: {
		onRemove: ''
	},
	published: {
		importance: 0
	},
	components: [
		{name: 'avatar', kind: Image, classes: 'list-sample-contacts-avatar'},
		{components: [
			{name: 'name'},
			{name: 'title', classes: 'list-sample-contacts-description'},
			{content: '(415) 711-1234', classes: 'list-sample-contacts-description'}
		]},
		{name: 'remove', classes: 'list-sample-contacts-remove-button', ontap: 'removeTap'}
	],
	setContact: function (contact) {
		this.$.name.setContent(contact.name);
		this.$.avatar.setSrc(contact.avatar);
		this.$.title.setContent(contact.title);
	},
	setSelected: function (selected) {
		this.addRemoveClass('list-sample-contacts-item-selected', selected);
		this.$.remove.applyStyle('display', selected ? 'inline-block' : 'none');
	},
	renderImportance: function () {
		switch(this.importance) {
		case 0:
			this.$.importance.setContent('not important');
			break;
		case -1:
			this.$.importance.setContent('important');
			break;
		case -2:
			this.$.importance.setContent('very important');
			break;
		default:
			window.alert(this.importance+' - wowzer');
			break;
		}
	},
	removeTap: function (inSender, inEvent) {
		this.doRemove({index: inEvent.index});
		return true;
	}
});

module.exports = kind({
	name: 'enyo.sample.ListContactsSample',
	kind: FittableRows,
	classes: 'list-sample-contacts enyo-fit',
	components: [
		{
			kind: FittableColumns,
			classes: 'layout-sample-toolbar',
			style: 'height: 55px;',
			components: [
				{kind: Button, content: 'setup', ontap: 'showSetupPopup'},
				{tag: 'label', components: [
					{name: 'newContactInput', kind: Input, value: 'Frankie Fu'}
				]},
				{kind: Button, content: 'new contact', ontap: 'addItem'},
				{fit: true},
				{tag: 'label', components: [
					{kind: Input, placeholder: 'Search...', style: 'width: 140px;', oninput: 'searchInputChange'},
					{kind: Image, src: 'assets/search-input-search.png', style: 'width: 20px;'}
				]},
				{kind: Button, content: 'remove selected', ontap: 'removeSelected'}
			]
		},
		{
			kind: List,
			classes: 'list-sample-contacts-list enyo-unselectable',
			fit: true,
			multiSelect: true,
			onSetupItem: 'setupItem',
			components: [
				{name: 'divider', classes: 'list-sample-contacts-divider'},
				{name: 'item', kind: ContactItem, classes: 'list-sample-contacts-item enyo-border-box', onRemove: 'removeTap'}
			]
		},
		{
			name: 'popup',
			kind: Popup,
			modal: true,
			centered: true,
			classes: 'list-sample-contacts-popup',
			components: [
				{
					components: [
						{style: 'display:inline-block', components:[
							{content: 'count:', classes: 'list-sample-contacts-label'},
							{name: 'countOutput', kind: Input, type: 'number', value: 200, onchange: 'countChanging'}
						]}
					]
				},
				{
					components: [
						{content: 'rowsPerPage:', classes: 'list-sample-contacts-label'},
						{name: 'rowsPerPageOutput', kind: Input, type: 'number', value: 50, onchange: 'rowsChanging'}
					]
				},
				{
					components: [
						{content: 'hide divider:', classes: 'list-sample-contacts-label'},
						{name: 'hideDividerCheckbox', kind: Checkbox}
					]
				},
				{
					components: [
						{kind: Button, content: 'populate list', classes: 'list-sample-contacts-populate-button', ontap: 'populateList'}
					]
				}
			]
		}
	],
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.populateList();
		};
	}),
	setupItem: function (inSender, inEvent) {
		var i = inEvent.index;
		var data = this.filter ? this.filtered : this.db;
		var item = data[i];
		// content
		this.$.item.setContact(item);
		// selection
		this.$.item.setSelected(inSender.isSelected(i));
		// divider
		if (!this.hideDivider) {
			var d = item.name[0];
			var prev = data[i-1];
			var showd = d != (prev && prev.name[0]);
			this.$.divider.setContent(d);
			this.$.divider.canGenerate = showd;
			this.$.item.applyStyle('border-top', showd ? 'none' : null);
		}
		return true;
	},
	refreshList: function () {
		if (this.filter) {
			this.filtered = this.generateFilteredData(this.filter);
			this.$.list.setCount(this.filtered.length);
		} else {
			this.$.list.setCount(this.db.length);
		}
		this.$.list.refresh();
	},
	addItem: function () {
		var item = this.generateItem(utils.cap(this.$.newContactInput.getValue()));
		var i = 0;
		for (var di; (di=this.db[i]); i++) {
			if (di.name > item.name) {
				this.db.splice(i, 0, item);
				break;
			}
		}
		// if we hit end of for-loop, add to end of list
		if (!di) {
			this.db.push(item);
		}
		this.refreshList();
		this.$.list.scrollToRow(i);
	},
	removeItem: function (inIndex) {
		this._removeItem(inIndex);
		this.$.list.getSelection().remove(inIndex);
		this.refreshList();
	},
	_removeItem: function (inIndex) {
		var i = this.filter ? this.filtered[inIndex].dbIndex : inIndex;
		this.db.splice(i, 1);
	},
	removeTap: function (inSender, inEvent) {
		this.removeItem(inEvent.index);
		return true;
	},
	removeSelected: function () {
		// get selected items, sort numerically in decending order
		var selected = utils.keys(this.$.list.getSelection().getSelected());
		selected.sort(function (a,b) { return b-a; });
		// remove items one-by-one, starting with last in the list
		for (var i=0; i < selected.length; i++) {
			this._removeItem(selected[i]);
		}
		// clear selection, since all selected items are now gone
		this.$.list.getSelection().clear();
		// re-render list in current position
		this.refreshList();
	},
	populateList: function () {
		this.$.popup.hide();
		this.createDb(this.$.countOutput.getValue());
		this.$.list.setCount(this.db.length);
		this.$.list.setRowsPerPage(this.$.rowsPerPageOutput.getValue());
		//
		this.hideDivider = this.$.hideDividerCheckbox.getValue();
		//this.$.divider.canGenerate = !this.hideDivider;
		//
		this.$.list.reset();
	},
	createDb: function (inCount) {
		this.db = [];
		for (var i=0; i<inCount; i++) {
			this.db.push(this.generateItem(names.makeName(4, 6) + ' ' + names.makeName(5, 10)));
		}
		this.sortDb();
	},
	generateItem: function (inName) {
		return {
			name: inName,
			avatar: 'assets/avatars/' + avatars[utils.irand(avatars.length)],
			title: titles[utils.irand(titles.length)],
			importance: 0
		};
	},
	sortDb: function () {
		this.db.sort(function (a, b) {
			if (a.name < b.name) {
				return -1;
			}
			else if (a.name > b.name) {
				return 1;
			}
			else {
				return 0;
			}
		});
	},
	showSetupPopup: function () {
		this.$.popup.show();
	},
	searchInputChange: function (inSender) {
		job(this.id + ':search', this.bindSafely('filterList', inSender.getValue()), 200);
	},
	filterList: function (inFilter) {
		if (inFilter != this.filter) {
			this.filter = inFilter;
			this.filtered = this.generateFilteredData(inFilter);
			this.$.list.setCount(this.filtered.length);
			this.$.list.reset();
		}
	},
	generateFilteredData: function (inFilter) {
		var re = new RegExp('^' + inFilter, 'i');
		var r = [];
		for (var i=0, d; (d=this.db[i]); i++) {
			if (d.name.match(re)) {
				d.dbIndex = i;
				r.push(d);
			}
		}
		return r;
	},
	countChanging: function (inSender, inEvent){
		this.$.countOutput.setContent(Math.round(inSender.getValue()) * 50);
	},
	rowsChanging: function (inSender, inEvent){
		this.$.rowsPerPageOutput.setContent(Math.round(inSender.getValue()) * 5);
	}
});

var avatars = [
	'angel.png',
	'astrologer.png',
	'athlete.png',
	'baby.png',
	'clown.png',
	'devil.png',
	'doctor.png',
	'dude.png',
	'dude2.png',
	'dude3.png',
	'dude4.png',
	'dude5.png',
	'dude6.png'
];
var titles = [
	'Regional Data Producer',
	'Internal Markets Administrator',
	'Central Solutions Producer',
	'Dynamic Program Executive',
	'Direct Configuration Executive',
	'International Marketing Assistant',
	'District Research Consultant',
	'Lead Intranet Coordinator',
	'Central Accountability Director',
	'Product Web Assistant'
];
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Checkbox":11,"../../../enyo/lib/Image":23,"../../../enyo/lib/Input":24,"../../../enyo/lib/Popup":37,"../../../enyo/lib/job":63,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95,"./NameGenerator":125}],121:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button'),
	Component = require('../../../enyo/lib/Component'),
	Image = require('../../../enyo/lib/Image'),
	Input = require('../../../enyo/lib/Input'),
	JsonpRequest = require('../../../enyo/lib/Jsonp');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	List = require('../../../layout/lib/List');

// A simple component to do a Flickr search.
var ListHorizontalFlickrSearch = kind({
	kind: Component,
	published: {
		searchText: ''
	},
	events: {
		onResults: ''
	},
	url: 'https://api.flickr.com/services/rest/',
	pageSize: 200,
	api_key: '2a21b46e58d207e4888e1ece0cb149a5',
	search: function(inSearchText, inPage) {
		this.searchText = inSearchText || this.searchText;
		var i = (inPage || 0) * this.pageSize;
		var params = {
			method: 'flickr.photos.search',
			format: 'json',
			api_key: this.api_key,
			per_page: this.pageSize,
			page: i,
			text: this.searchText
		};
		return new JsonpRequest({url: this.url, callbackName: 'jsoncallback'})
			.response(this, 'processResponse')
			.go(params);
	},
	processResponse: function(inSender, inResponse) {
		var photos = inResponse.photos ? inResponse.photos.photo || [] : [];
		for (var i=0, p; (p=photos[i]); i++) {
			var urlprefix = 'http://farm' + p.farm + '.static.flickr.com/' + p.server + '/' + p.id + '_' + p.secret;
			p.thumbnail = urlprefix + '_s.jpg';
			p.original = urlprefix + '.jpg';
		}
		this.doResults(photos);
		return photos;
	}
});

module.exports = kind({
	name: 'enyo.sample.ListHorizontalFlickrSample',
	classes: 'enyo-unselectable enyo-fit list-sample-flickr',
	components: [
		{kind: FittableRows, components: [
			{classes: 'layout-sample-toolbar', components: [
				{kind: FittableColumns, tag: 'label', style: 'width: 90%;', components: [
					{name: 'searchInput', fit: true, kind: Input, value: 'Japan', onchange: 'search'},
					{kind: Image, src: 'assets/search-input-search.png', style: 'width: 20px; height: 20px;'}
				]},
				{name: 'searchSpinner', kind: Image, src: 'assets/spinner.gif', showing: false}
			]},
			{kind: List, orient: 'h', fit: true, onSetupItem: 'setupItem', components: [
				{name: 'item', style: 'padding: 10px;', classes: 'list-sample-flickr-item enyo-border-box', ontap: 'itemTap', components: [
					{name: 'thumbnail', kind: Image, classes: 'list-sample-flickr-thumbnail'}
				]},
				{name: 'more', style: 'padding: 10px;position:absolute', classes: 'list-sample-flickr-more enyo-border-box', components: [
					{kind: Button, content: 'more',  ontap: 'more'},
					{name: 'moreSpinner', kind: Image, src: 'assets/spinner.gif', classes: 'list-sample-flickr-more-spinner'}
				]}
			]}
		]},
		{kind: ListHorizontalFlickrSearch, name: 'flickrSearch', onResults: 'searchResults'}
	],
	rendered: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.search();
		};
	}),
	search: function() {
		this.searchText = this.$.searchInput.getValue();
		this.page = 0;
		this.results = [];
		this.$.searchSpinner.show();
		this.$.flickrSearch.search(this.searchText);
	},
	searchResults: function(inSender, inResults) {
		this.$.searchSpinner.hide();
		this.$.moreSpinner.hide();
		this.results = this.results.concat(inResults);
		this.$.list.setCount(this.results.length);
		if (this.page === 0) {
			this.$.list.reset();
		} else {
			this.$.list.refresh();
		}
		return true;
	},
	setupItem: function(inSender, inEvent) {
		var i = inEvent.index;
		var item = this.results[i];
		this.$.item.addRemoveClass('onyx-selected', inSender.isSelected(inEvent.index));
		this.$.thumbnail.setSrc(item.thumbnail);
		this.$.more.canGenerate = !this.results[i+1];
		return true;
	},
	more: function() {
        this.page++;
		this.$.moreSpinner.show();
        this.$.flickrSearch.search(this.searchText, this.page);
	},
	showList: function() {
		this.setIndex(0);
	}
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Component":13,"../../../enyo/lib/Image":23,"../../../enyo/lib/Input":24,"../../../enyo/lib/Jsonp":25,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95}],122:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	utils = require('../../../enyo/lib/utils'),
	Button = require('../../../enyo/lib/Button'),
	Input = require('../../../enyo/lib/Input');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	List = require('../../../layout/lib/List');

module.exports = kind({
	name: 'enyo.sample.ListLanguagesSample',
	kind: FittableRows,
	classes: 'list-sample-language enyo-fit',
	data: [],
	languages: {
		English: ['One',  'Two',  'Three', 'Four',    'Five',    'Six',   'Seven',  'Eight', 'Nine',  'Ten'],
		Italian: ['Uno',  'Due',  'Tre',   'Quattro', 'Cinque',  'Sei',   'Sette',  'Otto',  'Nove',  'Dieci'],
		Spanish: ['Uno',  'Dos',  'Tres',  'Cuatro',  'Cinco',   'Seis',  'Siete',  'Ocho',  'Nueve', 'Diez'],
		German:  ['Eins', 'Zwei', 'Drei',  'Vier',    'F\xFCnf', 'Sechs', 'Sieben', 'Acht',  'Neun',  'Zehn'],
		French:  ['Un',   'Deux', 'Trois', 'Quatre',  'Cinq',    'Six',   'Sept',   'Huit',  'Neuf',  'Dix']
	},
	components: [
		{kind: FittableColumns, classes: 'layout-sample-toolbar', style: 'height: 55px;', components: [
			{content: 'Rows:'},
			{tag: 'label', components: [
				{kind: Input, value: '10', name: 'numRows' }
			]},
			{kind: Button, content: 'Repopulate', ontap: 'populateList'}
		]},
		{
			kind: List,
			classes: 'list-sample-language-list enyo-unselectable',
			fit: true,
			multiSelect: true,
			reorderable: true,
			centerReorderContainer: false,
			enableSwipe: true,
			onSetupItem: 'setupItem',
			onReorder: 'listReorder',
			onSetupReorderComponents: 'setupReorderComponents',
			// onSetupPinnedReorderComponents: 'setupPinnedReorderComponents',
			onSetupSwipeItem: 'setupSwipeItem',
			onSwipeComplete: 'swipeComplete',
			components: [
				{name: 'item', classes: 'list-sample-language-item', components: [
					{name: 'text', classes: 'itemLabel'},
					{name: 'rowNumber', classes: 'rowNumberLabel'},
					{name: 'serial', classes: 'serialLabel'}
				]}
			],
			reorderComponents: [
				{name: 'reorderContent', classes: 'enyo-fit reorderDragger', components: [
					{name: 'reorderTitle', tag: 'h2', allowHtml: true}
				]}
			],
			// For Enyo 2.2, we comment out these components to disable pinned mode which is still
			// considered a work in progress.
			/* pinnedReorderComponents: [
				{name: 'pinnedReorderItem', classes: 'enyo-fit swipeGreen', components: [
					{name: 'pinnedReorderTitle', tag: 'h2', allowHtml: true},
					{name: 'dropButton', kind: 'onyx.Button', ontap: 'dropPinnedRow', content: 'Drop', classes: 'dropButton'},
					{name: 'cancelButton', kind: 'onyx.Button', ontap: 'cancelPinnedMode', content: 'Cancel', classes: 'cancelButton'}
				]}
			], */
			swipeableComponents: [
				{name: 'swipeItem', classes: 'enyo-fit swipeGreen', components: [
					{name: 'swipeTitle', classes: 'swipeTitle'}
				]}
			]
		}
	],
	rendered: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.populateList();
		};
	}),
	listReorder: function(inSender, inEvent) {
		var movedItem = utils.clone(this.data[inEvent.reorderFrom]);
		this.data.splice(inEvent.reorderFrom,1);
		this.data.splice((inEvent.reorderTo),0,movedItem);
	},
	setupItem: function(inSender, inEvent) {
		var i = inEvent.index;
		if(!this.data[i]) {
			return;
		}
		var currentLanguage = this.data[i].langs[this.data[i].currentIndex];
		var val = this.data[i].val;
		var number = this.languages[currentLanguage][val];
		var serial = this.data[i].serial;
		this.$.rowNumber.setContent('ROW ' + i);
		this.$.text.setContent(number);
		this.$.serial.setContent('#' + serial);
	},
	setupReorderComponents: function(inSender, inEvent) {
		var i = inEvent.index;
		if(!this.data[i]) {
			return;
		}
		var currentLanguage = this.data[i].langs[this.data[i].currentIndex];
		var val = this.data[i].val;
		var number = this.languages[currentLanguage][val];
		this.$.reorderTitle.setContent(number);
		return true;
	},
	/* setupPinnedReorderComponents: function(inSender, inEvent) {
		var i = inEvent.index;
		if(!this.data[i]) {
			return;
		}
		var currentLanguage = this.data[i].langs[this.data[i].currentIndex];
		var val = this.data[i].val;
		var number = this.languages[currentLanguage][val];
		this.$.pinnedReorderTitle.setContent(number);
	}, */
	//* Called when the 'Drop' button is pressed on the pinned placeholder row
	/* dropPinnedRow: function(inSender, inEvent) {
		this.$.list.dropPinnedRow(inEvent);
	}, */
	//* Called when the 'Cancel' button is pressed on the pinned placeholder row
	/* cancelPinnedMode: function(inSender, inEvent) {
		this.$.list.cancelPinnedMode(inEvent);
	}, */
	setupSwipeItem: function(inSender, inEvent) {
		var i = inEvent.index;
		if(!this.data[i]) {
			return;
		}
		var newLang = (inEvent.xDirection == 1)
			? this.getNextLang(i)
			: this.getPrevLang(i);
		this.$.swipeTitle.setContent(this.data[i].langs[newLang]);
		return true;
	},
	swipeComplete: function(inSender, inEvent) {
		var i = inEvent.index;
		this.data[i].currentIndex = (inEvent.xDirection == 1)
			? this.getNextLang(i)
			: this.getPrevLang(i);
		this.$.list.renderRow(i);
	},
	getNextLang: function(index) {
		var currentLang = this.data[index].currentIndex;
		return (currentLang + 1) % this.data[index].langs.length;
	},
	getPrevLang: function(index) {
		var currentLang = this.data[index].currentIndex;
		return (currentLang - 1 + this.data[index].langs.length) % this.data[index].langs.length;
	},
	populateList: function() {
		this.createRandomData();
		this.$.list.setCount(this.data.length);
		this.$.list.reset();
	},
	createRandomData: function() {
		var languages = this.getLanguages();
		var langs;
		var dataCount = parseInt(this.$.numRows.getValue(), 10);
		this.data = [];
		var sortFunc = function() {return 0.5 - Math.random();};
		for(var i=0;i<dataCount;i++) {
			langs = utils.clone(languages);
			langs.sort(sortFunc);
			this.data.push({
				langs: langs,
				val: i % 10,
				currentIndex: 0,
				serial: i
			});
		}
		this.data.sort(function() {return 0.5 - Math.random();});
	},
	getLanguages: function() {
		return utils.keys(this.languages);
	}
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Input":24,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95}],123:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind');

var
	List = require('../../../layout/lib/List');

var
	names = require('./NameGenerator');

module.exports = kind({
	name: 'enyo.sample.ListNoSelectSample',
	classes: 'list-sample enyo-fit',
	components: [
		{name: 'list', kind: List, count: 20000, noSelect: true, multiSelect: false, classes: 'enyo-fit list-sample-list',
			onSetupItem: 'setupItem', components: [
			{name: 'item', classes: 'list-sample-item enyo-border-box', components: [
				{name: 'index', classes: 'list-sample-index'},
				{name: 'name'}
			]}
		]}
	],
	names: [],
	setupItem: function (sender, event) {
		// this is the row we're setting up
		var i = event.index;
		// make some mock data if we have none for this row
		if (!this.names[i]) {
			this.names[i] = names.makeName(5, 10, '', '');
		}
		var n = this.names[i];
		var ni = ('00000000' + i).slice(-7);
		this.$.name.setContent(n);
		this.$.index.setContent(ni);
		return true;
	}
});
},{"../../../enyo/lib/kind":66,"../../../layout/lib/List":95,"./NameGenerator":125}],129:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	json = require('../../../enyo/lib/json'),
	Button = require('../../../enyo/lib/Button'),
	Component = require('../../../enyo/lib/Component'),
	Image = require('../../../enyo/lib/Image'),
	Input = require('../../../enyo/lib/Input'),
	JsonpRequest = require('../../../enyo/lib/Jsonp');

var
	CollapsingArranger = require('../../../layout/lib/CollapsingArranger'),
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	List = require('../../../layout/lib/List')
	Panels = require('../../../layout/lib/Panels');

// A simple component to do a Flickr search.
var PanelsFlickrSearch = kind({
	kind: Component,
	published: {
		searchText: ''
	},
	events: {
		onResults: ''
	},
	url: 'https://api.flickr.com/services/rest/',
	pageSize: 200,
	api_key: '2a21b46e58d207e4888e1ece0cb149a5',
	search: function(inSearchText, inPage) {
		this.searchText = inSearchText || this.searchText;
		var i = (inPage || 0) * this.pageSize;
		var params = {
			method: 'flickr.photos.search',
			format: 'json',
			api_key: this.api_key,
			per_page: this.pageSize,
			page: i,
			text: this.searchText
		};
		var req;
		if (window.location.protocol === 'ms-appx:') {
			params.nojsoncallback = 1;
			// Use ajax for platforms with no jsonp support (Windows 8)
			req = new enyo.Ajax({url: this.url, handleAs: 'text'})
				.response(this, 'processAjaxResponse')
				.go(params);
		} else {
			req = new JsonpRequest({url: this.url, callbackName: 'jsoncallback'})
				.response(this, 'processResponse')
				.go(params);
		}
		return req;
	},
	processAjaxResponse: function(inSender, inResponse) {
		inResponse = json.parse(inResponse);
		this.processResponse(inSender, inResponse);
	},
	processResponse: function(inSender, inResponse) {
		var photos = inResponse.photos ? inResponse.photos.photo || [] : [];
		for (var i=0, p; (p=photos[i]); i++) {
			var urlprefix = 'http://farm' + p.farm + '.static.flickr.com/' + p.server + '/' + p.id + '_' + p.secret;
			p.thumbnail = urlprefix + '_s.jpg';
			p.original = urlprefix + '.jpg';
		}
		this.doResults(photos);
		return photos;
	}
});

module.exports = kind({
	name: 'enyo.sample.PanelsFlickrSample',
	kind: Panels,
	classes: 'panels-sample-flickr-panels enyo-unselectable enyo-fit',
	arrangerKind: CollapsingArranger,
	components: [
		{kind: FittableRows, components: [
			{components: [
				{kind: FittableColumns, tag: 'label', style: 'width: 90%;', components: [
					{name: 'searchInput', fit: true, kind: Input, value: 'Japan', onchange: 'search'},
					{kind: Image, src: 'assets/search-input-search.png', style: 'width: 20px; height: 20px;'}
				]},
				{name: 'searchSpinner', kind: Image, src: 'assets/spinner.gif', showing: false}
			]},
			{kind: List, fit: true, touch: true, onSetupItem: 'setupItem', components: [
				{name: 'item', style: 'padding: 10px;', classes: 'panels-sample-flickr-item enyo-border-box', ontap: 'itemTap', components: [
					{name: 'thumbnail', kind: Image, classes: 'panels-sample-flickr-thumbnail'},
					{name: 'title', classes: 'panels-sample-flickr-title'}
				]},
				{name: 'more', style: 'background-color: #323232;', components: [
					{kind: Button, content: 'more photos', classes: 'onyx-dark panels-sample-flickr-more-button', ontap: 'more'},
					{name: 'moreSpinner', kind: Image, src: 'assets/spinner.gif', classes: 'panels-sample-flickr-more-spinner'}
				]}
			]}
		]},
		{name: 'pictureView', fit: true, kind: FittableRows, classes: 'enyo-fit panels-sample-flickr-main', components: [
			{name: 'backToolbar', showing: false, components: [
				{kind: Button, content: 'Back', ontap: 'showList'}
			]},
			{fit: true, style: 'position: relative;', components: [
				{name: 'flickrImage', kind: Image, classes: 'enyo-fit panels-sample-flickr-center panels-sample-flickr-image', showing: false, onload: 'imageLoaded', onerror: 'imageLoaded'},
				{name: 'imageSpinner', kind: Image, src: 'assets/spinner-large.gif', classes: 'enyo-fit panels-sample-flickr-center', showing: false}
			]}
		]},
		{name: 'flickrSearch', kind: PanelsFlickrSearch, onResults: 'searchResults'}
	],
	rendered: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.search();
		};
	}),
	reflow: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			var backShowing = this.$.backToolbar.showing;
			this.$.backToolbar.setShowing(Panels.isScreenNarrow());
			if (this.$.backToolbar.showing != backShowing) {
				this.$.pictureView.resize();
			}
		};
	}),
	search: function() {
		this.searchText = this.$.searchInput.getValue();
		this.page = 0;
		this.results = [];
		this.$.searchSpinner.show();
		this.$.flickrSearch.search(this.searchText);
	},
	searchResults: function(inSender, inResults) {
		this.$.searchSpinner.hide();
		this.$.moreSpinner.hide();
		this.results = this.results.concat(inResults);
		this.$.list.setCount(this.results.length);
		if (this.page === 0) {
			this.$.list.reset();
		} else {
			this.$.list.refresh();
		}
	},
	setupItem: function(inSender, inEvent) {
		var i = inEvent.index;
		var item = this.results[i];
		this.$.item.addRemoveClass('onyx-selected', inSender.isSelected(inEvent.index));
		this.$.thumbnail.setSrc(item.thumbnail);
		this.$.title.setContent(item.title || 'Untitled');
		this.$.more.canGenerate = !this.results[i+1];
		return true;
	},
	more: function() {
		this.page++;
		this.$.moreSpinner.show();
		this.$.flickrSearch.search(this.searchText, this.page);
	},
	itemTap: function(inSender, inEvent) {
		if (Panels.isScreenNarrow()) {
			this.setIndex(1);
		}
		this.$.imageSpinner.show();
		var item = this.results[inEvent.index];

		if (item.original == this.$.flickrImage.getSrc()) {
			this.imageLoaded();
		} else {
			this.$.flickrImage.hide();
			this.$.flickrImage.setSrc(item.original);
		}
	},
	imageLoaded: function() {
		var img = this.$.flickrImage;
		img.removeClass('tall');
		img.removeClass('wide');
		img.show();
		var b = img.getBounds();
		var r = b.height / b.width;
		if (r >= 1.25) {
			img.addClass('tall');
		} else if (r <= 0.8 ) {
			img.addClass('wide');
		}
		this.$.imageSpinner.hide();
	},
	showList: function() {
		this.setIndex(0);
	}
});

},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Component":13,"../../../enyo/lib/Image":23,"../../../enyo/lib/Input":24,"../../../enyo/lib/Jsonp":25,"../../../enyo/lib/json":65,"../../../enyo/lib/kind":66,"../../../layout/lib/CollapsingArranger":82,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95,"../../../layout/lib/Panels":99}],131:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Checkbox = require('../../../enyo/lib/Checkbox'),
	Scroller = require('../../../enyo/lib/Scroller');

var
	FittableRows = require('../../../layout/lib/FittableRows'),
	CollapsingArranger = require('../../../layout/lib/CollapsingArranger'),
	Panels = require('../../../layout/lib/Panels'),
	List = require('../../../layout/lib/List');

var PanelsSlidingSample = module.exports = kind({
	name: 'enyo.sample.PanelsSlidingSample',
	kind: FittableRows,
	classes: 'enyo-fit',
	components: [
		{tag: 'label', components: [
			{tag: 'span', content: 'Realtime'},
			{kind: Checkbox, onchange: 'checkboxChange'}
		]},
		{kind: Panels, fit: true, classes: 'panels-sample-sliding-panels', arrangerKind: CollapsingArranger, wrap: false, components: [
			{name: 'left', components: [
				{kind: List, classes: 'enyo-fit', touch: true, count: 1000, onSetupItem: 'setupItem', item: 'item1', components: [
					{name: 'item1', classes: 'panels-sample-sliding-item'}
				]}
			]},
			{name: 'middle', components: [
				{kind: List, classes: 'enyo-fit', touch: true, count: 1000, onSetupItem: 'setupItem', item: 'item2', components: [
					{name: 'item2', classes: 'panels-sample-sliding-item'}
				]}
			]},
			{name: 'body', fit: true, components: [
				{kind: Scroller, classes: 'enyo-fit', touch: true, components: [
					{classes: 'panels-sample-sliding-content', content: 'Broke, down dumb hospitality firewood chitlins. Has mud tired uncle everlastin\' cold, out. Hauled thar, up thar tar heffer quarrel farmer fish water is. Simple gritts dogs soap give kickin\'. Ain\'t shiney water range, preacher java rent thar go. Skinned wirey tin farm, trespassin\' it, rodeo. Said roped caught creosote go simple. Buffalo butt, jig fried commencin\' cipherin\' maw, wash. Round-up barefoot jest bible rottgut sittin\' trailer shed jezebel. Crop old over poker drinkin\' dirt where tools skinned, city-slickers tools liniment mush tarnation. Truck lyin\' snakeoil creosote, old a inbred pudneer, slap dirty cain\'t. Hairy, smokin\', nothin\' highway hootch pigs drinkin\', barefoot bootleg hoosegow mule. Tax-collectors uncle wuz, maw watchin\' had jumpin\' got redblooded gimmie truck shootin\' askin\' hootch. No fat ails fire soap cabin jail, reckon if trespassin\' fixin\' rustle jest liniment. Ya huntin\' catfish shot good bankrupt. Fishin\' sherrif has, fat cooked shed old. Broke, down dumb hospitality firewood chitlins. Has mud tired uncle everlastin\' cold, out. Hauled thar, up thar tar heffer quarrel farmer fish water is. Simple gritts dogs soap give kickin\'. Ain\'t shiney water range, preacher java rent thar go. Skinned wirey tin farm, trespassin\' it, rodeo. Said roped caught creosote go simple. Buffalo butt, jig fried commencin\' cipherin\' maw, wash. Round-up barefoot jest bible rottgut sittin\' trailer shed jezebel. Crop old over poker drinkin\' dirt where tools skinned, city-slickers tools liniment mush tarnation. Truck lyin\' snakeoil creosote, old a inbred pudneer, slap dirty cain\'t. Hairy, smokin\', nothin\' highway hootch pigs drinkin\', barefoot bootleg hoosegow mule. Tax-collectors uncle wuz, maw watchin\' had jumpin\' got redblooded gimmie truck shootin\' askin\' hootch. No fat ails fire soap cabin jail, reckon if trespassin\' fixin\' rustle jest liniment. Ya huntin\' catfish shot good bankrupt. Fishin\' sherrif has, fat cooked shed old. Broke, down dumb hospitality firewood chitlins. Has mud tired uncle everlastin\' cold, out. Hauled thar, up thar tar heffer quarrel farmer fish water is. Simple gritts dogs soap give kickin\'. Ain\'t shiney water range, preacher java rent thar go. Skinned wirey tin farm, trespassin\' it, rodeo. Said roped caught creosote go simple. Buffalo butt, jig fried commencin\' cipherin\' maw, wash. Round-up barefoot jest bible rottgut sittin\' trailer shed jezebel. Crop old over poker drinkin\' dirt where tools skinned, city-slickers tools liniment mush tarnation. Truck lyin\' snakeoil creosote, old a inbred pudneer, slap dirty cain\'t. Hairy, smokin\', nothin\' highway hootch pigs drinkin\', barefoot bootleg hoosegow mule. Tax-collectors uncle wuz, maw watchin\' had jumpin\' got redblooded gimmie truck shootin\' askin\' hootch. No fat ails fire soap cabin jail, reckon if trespassin\' fixin\' rustle jest liniment. Ya huntin\' catfish shot good bankrupt. Fishin\' sherrif has, fat cooked shed old. Broke, down dumb hospitality firewood chitlins. Has mud tired uncle everlastin\' cold, out. Hauled thar, up thar tar heffer quarrel farmer fish water is. Simple gritts dogs soap give kickin\'. Ain\'t shiney water range, preacher java rent thar go. Skinned wirey tin farm, trespassin\' it, rodeo. Said roped caught creosote go simple. Buffalo butt, jig fried commencin\' cipherin\' maw, wash. Round-up barefoot jest bible rottgut sittin\' trailer shed jezebel. Crop old over poker drinkin\' dirt where tools skinned, city-slickers tools liniment mush tarnation. Truck lyin\' snakeoil creosote, old a inbred pudneer, slap dirty cain\'t. Hairy, smokin\', nothin\' highway hootch pigs drinkin\', barefoot bootleg hoosegow mule. Tax-collectors uncle wuz, maw watchin\' had jumpin\' got redblooded gimmie truck shootin\' askin\' hootch. No fat ails fire soap cabin jail, reckon if trespassin\' fixin\' rustle jest liniment. Ya huntin\' catfish shot good bankrupt. Fishin\' sherrif has, fat cooked shed old.'}
				]}
			]}
		]}
	],
	setupItem: function (sender, event) {
		this.$[sender.item].setContent('This is row number: ' + event.index);
		return true;
	},
	checkboxChange: function (sender) {
		this.$.panels.realtimeFit = sender.getValue();
		return true;
	}
});
},{"../../../enyo/lib/Checkbox":11,"../../../enyo/lib/Scroller":44,"../../../enyo/lib/kind":66,"../../../layout/lib/CollapsingArranger":82,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95,"../../../layout/lib/Panels":99}],132:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind');

var
	FittableRows = require('../../../layout/lib/FittableRows'),
	List = require('../../../layout/lib/List');

module.exports = kind({
	name: 'enyo.sample.PersistentSwipeableItemSample',
	kind: FittableRows,
	classes: 'list-sample-persistent-swipeable-item enyo-fit',
	data: ['Cat','Dog','Hippopotamus'],
	components: [
		{
			kind: List,
			classes: 'list-sample-persistent-swipeable-item-list enyo-unselectable',
			fit: true,
			multiSelect: true,
			reorderable: false,
			enableSwipe: true,
			centerReorderContainer: false,
			onSetupItem: 'setupItem',
			onSetupSwipeItem: 'setupSwipeItem',
			onSwipeComplete: 'swipeComplete',
			components: [
				{name: 'item', classes: 'list-sample-persistent-swipeable-item-item', components: [
					{name: 'text', classes: 'itemLabel', allowHtml: true}
				]}
			],
			swipeableComponents: [
				{name: 'swipeItem', classes: 'enyo-fit swipeGreen', components: [
					{name: 'swipeTitle', classes: 'swipeTitle', content: 'This is a test'}
				]}
			]
		}
	],
	rendered: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.populateList();
		};
	}),
	populateList: function () {
		this.$.list.setCount(this.data.length);
		this.$.list.reset();
	},
	setupItem: function (sender, event) {
		if(!this.data[event.index]) {
			return;
		}

		this.$.text.setContent(this.data[event.index]);
		return true;
	},
	setupSwipeItem: function (sender, event) {
		if(!this.data[event.index]) {
			return true;
		}

		if(event.xDirection === -1) {
			// Persist swipeable item if swiped from right to left
			this.$.list.setPersistSwipeableItem(true);
			this.$.swipeTitle.setContent('This is a persistent item');
			this.$.swipeItem.removeClass('swipeGreen');
			this.$.swipeItem.addClass('swipeRed');
		} else {
			// Don't persist swipeable item if swiped from left to right
			this.$.list.setPersistSwipeableItem(false);
			this.$.swipeTitle.setContent('This is not a persistent item');
			this.$.swipeItem.removeClass('swipeRed');
			this.$.swipeItem.addClass('swipeGreen');
		}
		return true;
	},
	swipeComplete: function (sender, event) {
	}
});
},{"../../../enyo/lib/kind":66,"../../../layout/lib/FittableRows":88,"../../../layout/lib/List":95}],92:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	dom = require('../../enyo/lib/dom'),
	logger = require('../../enyo/lib/logger'),
	platform = require('../../enyo/lib/platform'),
	Image = require('../../enyo/lib/Image');

var
	PanZoomView = require('./PanZoomView');

/**
* {@link enyo.ImageView} is a control that displays an image at a given scaling
* factor, with enhanced support for double-tap/double-click to zoom, panning,
* mousewheel zooming and pinch-zoom (on touchscreen devices that support it).
*
* ```
* {kind: 'ImageView', src: 'assets/globe.jpg', scale: 'auto', style: 'width:500px; height:400px;'}
* ```
*
* The `onload` and `onerror` events bubble up from the underlying image
* element and an [onZoom]{@link enyo.PanZoomView#onZoom} event is triggered
* when the user changes the zoom level of the image.
*
* If you wish, you may add {@link enyo.ScrollThumb} indicators, disable zoom
* animation, allow panning overscroll (with a bounce-back effect), and control
* the propagation of drag events, all using this kind's Boolean properties.
*
* Note that it's best to specify a size for the ImageView in order to avoid
* complications.
*
* @ui
* @class enyo.ImageView
* @extends enyo.PanZoomView
* @public
*/
module.exports = kind(
	/** @lends enyo.ImageView.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.ImageView',

	/**
	* @private
	*/
	kind: PanZoomView,

	/**
	* @private
	*/
	subKindComponents: [
		{kind: Image, ondown: 'down', style: 'vertical-align: text-top;'}
	],

	/**
	* @method
	* @private
	*/
	create: function () {
		// move components (most likely imageViewPins) to unscaledComponents
		this.unscaledComponents = this.components;
		this.components = [];

		//amend kindComponents
		this.kindComponents[1].components[0].components = this.subKindComponents;

		PanZoomView.prototype.create.apply(this, arguments);

		// set content as inline-block to mimic behaviour of an image
		this.$.content.applyStyle('display', 'inline-block');

		//offscreen buffer image to get initial image dimensions
		//before displaying a scaled down image that can fit in the container
		this.bufferImage = new Image();
		this.bufferImage.onload = this.bindSafely('imageLoaded');
		this.bufferImage.onerror = this.bindSafely('imageError');
		this.srcChanged();
		//	Needed to kickoff pin redrawing (otherwise they won't redraw on intitial scroll)
		if(this.getStrategy().$.scrollMath) {
			this.getStrategy().$.scrollMath.start();
		}
	},

	/**
	* @method
	* @private
	*/
	destroy: function () {
		if (this.bufferImage) {
			this.bufferImage.onerror = undefined;
			this.bufferImage.onerror = undefined;
			delete this.bufferImage;
		}
		PanZoomView.prototype.destroy.apply(this, arguments);
	},

	/**
	* @private
	*/
	down: function (sender, event) {
		// Fix to prevent image drag in Firefox
		event.preventDefault();
	},

	/**
	* @private
	*/
	srcChanged: function () {
		if(this.src && this.src.length>0 && this.bufferImage && this.src!=this.bufferImage.src) {
			this.bufferImage.src = this.src;
		}
	},

	/**
	* Handles `onload` events bubbled up from children to reset the scale when
	* the image changes.
	*
	* @private
	*/
	imageLoaded: function (event) {
		this.scale = this.scaleKeyword;
		this.originalWidth = this.contentWidth = this.bufferImage.width;
		this.originalHeight = this.contentHeight = this.bufferImage.height;

		//scale to fit before setting src, so unscaled image isn't visible
		this.scaleChanged();
		this.$.image.setSrc(this.bufferImage.src);

		// There appears to be a bug in Safari where due to the translation of these elements it
		// doesn't correctly render unless prodded
		if (platform.safari) {
			var n = this.$.image.hasNode(),
				src = this.bufferImage.src;

			if (n) {
				setTimeout(function () { n.src = src; }, 100);
			}
		}

		// Needed to ensure scroller contents height/width is calculated correctly when contents use enyo-fit
		dom.transformValue(this.getStrategy().$.client, 'translate3d', '0px, 0px, 0');

		this.positionClientControls(this.scale);
		this.align();
	},

	/**
	* @private
	*/
	imageError: function (event) {
		logger.error('Error loading image: ' + this.src);
		//bubble up the error event
		this.bubble('onerror', event);
	}
});
},{"../../enyo/lib/Image":23,"../../enyo/lib/dom":58,"../../enyo/lib/kind":66,"../../enyo/lib/logger":67,"../../enyo/lib/platform":71,"./PanZoomView":98}],126:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	PanZoomView = require('../../../layout/lib/PanZoomView');

module.exports = kind({
	name: 'enyo.sample.PanZoomViewSample',
	components: [
		{kind: PanZoomView, contentWidth: 600, contentHeight: 600, classes: 'panzoomview-demo', onZoom: 'zoom', components: [
			{kind: FittableColumns, components: [
				{content: 'Hello World', style: 'background: orange; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: blue; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: cyan; width: 200px; height: 200px;'}
			]},
			{kind: FittableColumns, components: [
				{content: 'Hello World', style: 'background: lightblue; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: yellow; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: red; width: 200px; height: 200px;'}
			]},
			{kind: FittableColumns, components: [
				{content: 'Hello World', style: 'background: brown; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: green; width: 200px; height: 200px;'},
				{content: 'Hello World', style: 'background: pink; width: 200px; height: 200px;'}
			]}
		]},

		{style: 'padding-top:10px; width:60%; margin:auto;', components: [
			{content: 'panZoomView Scale'},
			{style: 'text-align:center;', components: [
				{kind: Button, content: 'auto',   ontap: 'autoScale',   classes: 'panzoomview-demoButton'},
				{kind: Button, content: 'width',  ontap: 'widthScale',  classes: 'panzoomview-demoButton'},
				{kind: Button, content: 'height', ontap: 'heightScale', classes: 'panzoomview-demoButton'},
				{kind: Button, content: 'fit',    ontap: 'fitScale',    classes: 'panzoomview-demoButton'},
				{kind: Button, content: '0.5', ontap: 'halfScale', classes: 'panzoomview-demoButton'},
				{kind: Button, content: '1.0', ontap: 'normalScale', classes: 'panzoomview-demoButton'},
				{kind: Button, content: '2.0', ontap: 'doubleScale', classes: 'panzoomview-demoButton'}
			]}
		]}
	],
	create: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.scale = 'auto';
		};
	}),
	handleResize: function (sender, event) {
		this.inherited(arguments);
		this.$.panZoomView.setScale(this.scale);
	},
	autoScale: function (sender, event) {
		this.scale = 'auto';
		this.$.panZoomView.setScale(this.scale);
	},
	widthScale: function (sender, event) {
		this.scale = 'width';
		this.$.panZoomView.setScale(this.scale);
	},
	heightScale: function (sender, event) {
		this.scale = 'height';
		this.$.panZoomView.setScale(this.scale);
	},
	fitScale: function (sender, event) {
		this.scale = 'fit';
		this.$.panZoomView.setScale(this.scale);
	},
	halfScale: function (sender, event) {
		this.scale = 0.5;
		this.$.panZoomView.setScale(this.scale);
	},
	normalScale: function (sender, event) {
		this.scale = 1.0;
		this.$.panZoomView.setScale(this.scale);
	},
	doubleScale: function (sender, event) {
		this.scale = 2.0;
		this.$.panZoomView.setScale(this.scale);
	}
});

},{"../../../enyo/lib/Button":10,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/PanZoomView":98}],127:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind');

var
	PanZoomView = require('../../../layout/lib/PanZoomView');

module.exports = kind({
	name: 'enyo.sample.PanZoomViewSample2',
	classes: 'enyo-unselectable',
	style: 'width: 600px; padding: 20px; border: 1px solid #ccc; margin: auto;',
	components: [

	// add zoom in and zoom out controls
	// add down and up controls
		{content: 'Please review this fine print:', tag: 'h1'},
		{kind: PanZoomView, style: 'width: 600px; height: 400px; font-size: .5em;', touchOverscroll: true, thumb: true, scale: 'width', contentWidth: 1200, components: [
			{classes: 'enyo-unselectable', content: 'Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.Truly cross-platform Use the same framework to develop apps for the web and for all major platforms, desktop and mobile.  Free and open-source 100% free to use, Enyo is available under the Apache License, Version 2.0.  Extensible With a small, rock-solid core, Enyo is modular and designed to be extended by the developer community. Built to manage complexity Enyo\'s elegant component model makes it simple to build and maintain even the most complex apps.  Optimized for mobile Enyo has roots in mobile and was built from the ground up to shine on tablets and phones.  Lightweight & Fast Enyo is small (core is <25k gzipped) and tuned for speed and responsiveness on all supported platforms.'}
		]}
	]
});
},{"../../../enyo/lib/kind":66,"../../../layout/lib/PanZoomView":98}],128:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	utils = require('../../../enyo/lib/utils'),
	Button = require('../../../enyo/lib/Button'),
	Image = require('../../../enyo/lib/Image');

var
	PanZoomView = require('../../../layout/lib/PanZoomView');

var ImagesView = kind({
	width: 0,
	height: 0,
	published: {
		src : ''
	},
	components:[
		{kind: Image, onload: 'load', ondown: 'down'},
		{kind: Image, onload: 'load', ondown: 'down'}
	],
	create: kind.inherit(function(sup) {
		return function(){
			sup.apply(this, arguments);
			this.srcChanged();
		};
	}),
	srcChanged: function(){
		this.height = this.width = 0;
		this.$.image.setSrc(this.src);
		this.$.image2.setSrc(this.src);
	},
	load: function(inSender, inEvent){
		this.width += inEvent.originator.node.clientWidth;
		this.height = Math.max(this.height, inEvent.originator.node.clientHeight);
		this.bubble('onSetDimensions', { width: this.width, height: this.height });
	},
	down: function(inSender, inEvent) {
		// Fix to prevent image drag in Firefox
		inEvent.preventDefault();
	}
});


module.exports = kind({
	name: 'enyo.sample.PanZoomViewSample3',
	classes: 'enyo-unselectable',
	style: 'width: 600px; border: 1px solid #ccc; margin: auto;',
	components: [
		{kind: PanZoomView, style: 'width: 100%; height: 400px;', scale: 'fit', components: [
			{name: 'imagesView', kind: ImagesView, src: 'assets/globe.jpg'}
		]},
		{kind: Button, content: 'change image', ontap: 'changeImage'}
	],
	planets: ['assets/globe.jpg', 'assets/earth.jpg', 'assets/jupiter.jpg', 'assets/mars.jpg', 'assets/mercury.jpg', 'assets/neptune.jpg', 'assets/saturn.jpg', 'assets/uranus.jpg', 'assets/venus.jpg'],
	changeImage: function(){
		var imageview = this.$.panZoomView.$.imagesView;
		imageview.setSrc( this.planets[ (utils.indexOf(imageview.src, this.planets)+1)%this.planets.length ] );
	}
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Image":23,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/PanZoomView":98}],118:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	job = require('../../../enyo/lib/job'),
	utils = require('../../../enyo/lib/utils'),
	Button = require('../../../enyo/lib/Button'),
	Checkbox = require('../../../enyo/lib/Checkbox'),
	Image = require('../../../enyo/lib/Image'),
	Input = require('../../../enyo/lib/Input'),
	Popup = require('../../../enyo/lib/Popup');

var
	FittableColumns = require('../../../layout/lib/FittableColumns'),
	FittableRows = require('../../../layout/lib/FittableRows'),
	AroundList = require('../../../layout/lib/AroundList');

var
	names = require('./NameGenerator');

// It's convenient to create a kind for the item we'll render in the contacts list.
var AroundListContactItem = kind({
	events: {
		onRemove: ''
	},
	components: [
		{name: 'avatar', kind: Image, classes: 'list-sample-around-avatar'},
		{components: [
			{name: 'name', classes: 'list-sample-around-name'},
			{name: 'title', classes: 'list-sample-around-description'},
			{content: '(415) 711-1234', classes: 'list-sample-around-description'}
		]},
		{name: 'remove', kind: Image, classes: 'list-sample-around-remove-button', src: 'assets/remove-icon.png', ontap: 'removeTap'}
	],
	setContact: function (contact) {
		this.$.name.setContent(contact.name);
		this.$.avatar.setSrc(contact.avatar);
		this.$.title.setContent(contact.title);
	},
	setSelected: function (selected) {
		this.addRemoveClass('list-sample-around-item-selected', selected);
		this.$.remove.applyStyle('display', selected ? 'inline-block' : 'none');
	},
	removeTap: function (sender, event) {
		this.doRemove({index: event.index});
		return true;
	}
});

module.exports = kind({
	name: 'enyo.sample.ListAroundSample',
	kind: FittableRows,
	classes: 'enyo-fit enyo-unselectable',
	components: [
		{name: 'list', kind: AroundList, classes: 'list-sample-around', fit: true, multiSelect: true, onSetupItem: 'setupItem', aboveComponents: [
			{kind: FittableColumns, classes: 'layout-sample-toolbar', components: [
				{kind: FittableColumns, tag: 'label', fit: true, noStretch: true, components: [
					{kind: Input, placeholder: 'Search...', fit: true, oninput: 'searchInputChange'},
					{kind: Image, src: 'assets/search-input-search.png', style: 'height: 20px; width: 20px;'}
				]}
			]}
		], components: [
			{name: 'divider', classes: 'list-sample-around-divider'},
			{name: 'item', kind: AroundListContactItem, classes: 'list-sample-around-item enyo-border-box', onRemove: 'removeTap'}
		]},
		{name: 'popup', kind: Popup, modal: true, centered: true, classes: 'list-sample-around-popup', components: [
			{components: [
				{content: 'count:', classes: 'list-sample-around-label'},
				{tag: 'label', components: [
					{name: 'countInput', kind: Input, style: 'width: 80px', value: 100}
				]}
			]},
			{components: [
				{content: 'rowsPerPage:', classes: 'list-sample-around-label'},
				{tag: 'label', components: [
					{name: 'rowsPerPageInput', kind: Input, style: 'width: 80px', value: 50}
				]}
			]},
			{components: [
				{content: 'hide divider:', classes: 'list-sample-around-label'},
				{name: 'hideDividerCheckbox', kind: Checkbox}
			]},
			{components: [
				{kind: Button, content: 'populate list', classes: 'list-sample-around-populate-button', ontap: 'populateList'}
			]}
		]}
	],
	rendered: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.populateList();
		};
	}),
	setupItem: function(inSender, inEvent) {
		var i = inEvent.index;
		var data = this.filter ? this.filtered : this.db;
		var item = data[i];
		// content
		this.$.item.setContact(item);
		// selection
		this.$.item.setSelected(inSender.isSelected(i));
		// divider
		if (!this.hideDivider) {
			var d = item.name[0];
			var prev = data[i-1];
			var showd = d != (prev && prev.name[0]);
			this.$.divider.setContent(d);
			this.$.divider.canGenerate = showd;
			this.$.item.applyStyle('border-top', showd ? 'none' : null);
		}
		return true;
	},
	refreshList: function() {
		if (this.filter) {
			this.filtered = this.generateFilteredData(this.filter);
			this.$.list.setCount(this.filtered.length);
		} else {
			this.$.list.setCount(this.db.length);
		}
		this.$.list.refresh();
	},
	addItem: function() {
		var item = this.generateItem(utils.cap(this.$.newContactInput.getValue()));
		var i = 0;
		for (var di; (di=this.db[i]); i++) {
			if (di.name > item.name) {
				this.db.splice(i, 0, item);
				break;
			}
		}
		this.refreshList();
		this.$.list.scrollToRow(i);
	},
	removeItem: function(inIndex) {
		this._removeItem(inIndex);
		this.refreshList();
		this.$.list.getSelection().deselect(inIndex);
	},
	_removeItem: function(inIndex) {
		var i = this.filter ? this.filtered[inIndex].dbIndex : inIndex;
		this.db.splice(i, 1);
	},
	removeTap: function(inSender, inEvent) {
		this.removeItem(inEvent.index);
		return true;
	},
	populateList: function() {
		this.$.popup.hide();
		this.createDb(this.$.countInput.getValue());
		this.$.list.setCount(this.db.length);
		this.$.list.setRowsPerPage(this.$.rowsPerPageInput.getValue());
		//
		this.hideDivider = this.$.hideDividerCheckbox.getValue();
		this.$.divider.canGenerate = !this.hideDivider;
		//
		this.$.list.reset();
		this.$.list.scrollToContentStart();
	},
	createDb: function(inCount) {
		/* global makeName */
		this.db = [];
		for (var i=0; i<inCount; i++) {
			this.db.push(this.generateItem(names.makeName(4, 6) + ' ' + names.makeName(5, 10)));
		}
		this.sortDb();
	},
	generateItem: function(inName) {
		return {
			name: inName,
			avatar: 'assets/avatars/' + avatars[utils.irand(avatars.length)],
			title: titles[utils.irand(titles.length)]
		};
	},
	sortDb: function() {
		this.db.sort(function(a, b) {
			if (a.name < b.name) {
				return -1;
			}
			else if (a.name > b.name) {
				return 1;
			}
			else {
				return 0;
			}
		});
	},
	showSetupPopup: function() {
		this.$.popup.show();
	},
	searchInputChange: function(inSender) {
		job(this.id + ':search', this.bindSafely('filterList', inSender.getValue()), 200);
		return true;
	},
	filterList: function(inFilter) {
		if (inFilter != this.filter) {
			this.filter = inFilter;
			this.filtered = this.generateFilteredData(inFilter);
			this.$.list.setCount(this.filtered.length);
			this.$.list.reset();
		}
	},
	generateFilteredData: function(inFilter) {
		var re = new RegExp('^' + inFilter, 'i');
		var r = [];
		for (var i=0, d; (d=this.db[i]); i++) {
			if (d.name.match(re)) {
				d.dbIndex = i;
				r.push(d);
			}
		}
		return r;
	}
});

var avatars = [
	'angel.png',
	'astrologer.png',
	'athlete.png',
	'baby.png',
	'clown.png',
	'devil.png',
	'doctor.png',
	'dude.png',
	'dude2.png',
	'dude3.png',
	'dude4.png',
	'dude5.png',
	'dude6.png'
];
var titles = [
	'Regional Data Producer',
	'Internal Markets Administrator',
	'Central Solutions Producer',
	'Dynamic Program Executive',
	'Direct Configuration Executive',
	'International Marketing Assistant',
	'District Research Consultant',
	'Lead Intranet Coordinator',
	'Central Accountability Director',
	'Product Web Assistant'
];
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Checkbox":11,"../../../enyo/lib/Image":23,"../../../enyo/lib/Input":24,"../../../enyo/lib/Popup":37,"../../../enyo/lib/job":63,"../../../enyo/lib/kind":66,"../../../enyo/lib/utils":75,"../../../layout/lib/AroundList":77,"../../../layout/lib/FittableColumns":85,"../../../layout/lib/FittableRows":88,"./NameGenerator":125}],124:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	json = require('../../../enyo/lib/json'),
	Ajax = require('../../../enyo/lib/Ajax'),
	Button = require('../../../enyo/lib/Button'),
	Image = require('../../../enyo/lib/Image'),
	Input = require('../../../enyo/lib/Input'),
	JsonpRequest = require('../../../enyo/lib/Jsonp');

var
	PulldownList = require('../../../layout/lib/PulldownList'),
	FittableRows = require('../../../layout/lib/FittableRows');

module.exports = kind({
	name: 'enyo.sample.ListPulldownSample',
	classes: 'enyo-unselectable enyo-fit onyx',
	kind: FittableRows,
	components: [
		{classes: 'layout-sample-toolbar', components: [
			{label: 'label', components: [
				{name: 'searchInput', kind: Input, value: 'nature', placeholder: 'Enter seach term'},
				{kind: Image, src: 'assets/search-input-search.png', style: 'width: 20px;'}
			]},
			{kind: Button, content: 'search', ontap: 'search'}
		]},
		{name: 'list', kind: PulldownList, classes: 'list-sample-pulldown-list', fit: true, onSetupItem: 'setupItem', onPullRelease: 'pullRelease', onPullComplete: 'pullComplete', components: [
			{style: 'padding: 10px; height:70px', classes: 'list-sample-pulldown-item enyo-border-box', components: [
				{name: 'icon', kind: Image, style: 'float: left; width: 48px; height: 48px; padding: 0 10px 10px 0;'},
				{name: 'name', tag: 'span', style: 'font-weight: bold;'}
			]}
		]}
	],
	rendered: kind.inherit(function(sup) {
		return function() {
			sup.apply(this, arguments);
			this.search();
		};
	}),
	pullRelease: function() {
		this.pulled = true;
		// add 1 second delay so we can see the loading message
		setTimeout(this.bindSafely(function() {
			this.search();
		}), 1000);
	},
	pullComplete: function() {
		this.pulled = false;
		this.$.list.reset();
	},
	search: function() {
		// Capture searchText and strip any whitespace
		var searchText = this.$.searchInput.getValue().replace(/^\s+|\s+$/g, '');
		if (searchText === '') {
			// For whitespace searches, set new content value in order to display placeholder
			this.$.searchInput.setValue(searchText);
			return;
		}
		this.searchFlickr(searchText);
	},
	searchFlickr: function(inSearchText) {
		var params = {
			method: 'flickr.photos.search',
			format: 'json',
			api_key: '2a21b46e58d207e4888e1ece0cb149a5',
			per_page: 50,
			page: 0,
			text: inSearchText,
			sort: 'date-posted-desc',
			extras: 'url_m'
		}, url = 'https://api.flickr.com/services/rest/';
		if (window.location.protocol === 'ms-appx:') {
			params.nojsoncallback = 1;
			// Use ajax for platforms with no jsonp support (Windows 8)
			new Ajax({url: url, handleAs: 'text'})
				.response(this, 'processAjaxSearchResults')
				.go(params);
		} else {
			new JsonpRequest({url: url, callbackName: 'jsoncallback'})
				.response(this, 'processSearchResults')
				.go(params);
		}
	},
	processAjaxSearchResults: function(inRequest, inResponse) {
		inResponse = json.parse(inResponse);
		this.processSearchResults(inRequest, inResponse);
	},
	processSearchResults: function(inRequest, inResponse) {
		this.results = inResponse.photos.photo;
		this.$.list.setCount(this.results.length);
		if (this.pulled) {
			this.$.list.completePull();
		} else {
			this.$.list.reset();
		}
	},
	setupItem: function(inSender, inEvent) {
		var i = inEvent.index;
		var item = this.results[i];
		if (!item.url_m) {
			return true;
		}
		this.$.icon.setSrc(item.url_m);
		this.$.name.setContent(item.title);
		return true;
	}
});
},{"../../../enyo/lib/Ajax":2,"../../../enyo/lib/Button":10,"../../../enyo/lib/Image":23,"../../../enyo/lib/Input":24,"../../../enyo/lib/Jsonp":25,"../../../enyo/lib/json":65,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableRows":88,"../../../layout/lib/PulldownList":100}],91:[function(require,module,exports){
var
	kind = require('../../enyo/lib/kind'),
	utils = require('../../enyo/lib/utils');

var
	ImageView = require('./ImageView'),
	Panels = require('./Panels'),
	CarouselArranger = require('./CarouselArranger');

/**
* {@link enyo.ImageCarousel} is an {@link enyo.Panels} that uses {@link enyo.CarouselArranger}
* as its arrangerKind. An ImageCarousel dynamically creates and loads instances of
* {@link enyo.ImageView} as needed, creating a gallery of images.
*
* ```
* {kind: 'ImageCarousel', images: [
* 	'assets/mercury.jpg',
* 	'assets/venus.jpg',
* 	'assets/earth.jpg',
* 	'assets/mars.jpg',
* 	'assets/jupiter.jpg',
* 	'assets/saturn.jpg',
* 	'assets/uranus.jpg',
* 	'assets/neptune.jpg'
* ], defaultScale: 'auto'},
* ```
*
* All of the events (`onload`, `onerror`, and `onZoom`) from the contained
* ImageView objects are bubbled up to the ImageCarousel, which also inherits
* the [onTransitionStart]{@link enyo.Panels#onTransitionStart} and
* [onTransitionFinish]{@link enyo.Panels#onTransitionFinish} events from
* {@link enyo.Panels}.
*
* The [images]{@link enyo.ImageCarousel#images} property is an array containing the
* file paths of the images in the gallery.  The `images` array may be altered and
* updated at any time, and the current index may be manipulated at runtime via the
* inherited functions [getIndex()]{@link enyo.Panels#getIndex} and
* [setIndex()]{@link enyo.Panels#setIndex}.
*
* Note that it's best to specify a size for the ImageCarousel in order to
* avoid complications.
*
* @ui
* @class enyo.ImageCarousel
* @extends enyo.Panels
* @public
*/
module.exports = kind(
	/** @lends enyo.ImageCarousel.prototype */ {

	/**
	* @private
	*/
	name: 'enyo.ImageCarousel',

	/**
	* @private
	*/
	kind: Panels,

	/**
	* @private
	*/
	arrangerKind: CarouselArranger,

	/**
	* The default scaling to be applied to each ImageView. Can be `'auto'`,
	* `'width'`, `'height'`, or any positive numeric value.
	*
	* @type {String|Number}
	* @default 'auto'
	* @public
	*/
	defaultScale: 'auto',

	/**
	* If `true`, ImageView instances are created with zooming disabled.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	disableZoom:  false,

	/**
	* If `true`, any ImageViews that are not in the immediate viewing area
	* (i.e., any images other than the currently active image and the first image
	* on either side of it) will be destroyed to free up memory. This has the
	* benefit of minimizing memory usage (which is good for mobile devices), but
	* also has the downside that, if you want to view the images again, you'll need
	* to recreate the ImageViews refetch the images (thus increasing the number of
	* image-related GET calls). Defaults to `false`.
	*
	* @type {Boolean}
	* @default false
	* @public
	*/
	lowMemory: false,

	/**
	* @lends enyo.ImageCarousel.prototype
	* @private
	*/
	published: {

		/**
		* Array of paths to image files.
		*
		* @type {String[]}
		* @default `[]`
		* @public
		*/
		images: []
	},

	/**
	* @private
	*/
	handlers: {
		onTransitionStart: 'transitionStart',
		onTransitionFinish: 'transitionFinish'
	},

	/**
	* @method
	* @private
	*/
	create: function () {
		Panels.prototype.create.apply(this, arguments);
		this.imageCount = this.images.length;
		if (this.images.length > 0) {
			this.initContainers();
			this.loadNearby();
		}
	},

	/**
	* Builds a container for each image and destroys any extra containers and images.
	*
	* @private
	*/
	initContainers: function () {
		for (var i=0; i<this.images.length; i++) {
			if (!this.$['container' + i]) {
				this.createComponent({
					name: 'container' + i,
					style: 'height:100%; width:100%;'
				});
				this.$['container' + i].render();
			}
		}
		for (i=this.images.length; i<this.imageCount; i++) {
			if (this.$['image' + i]) {
				this.$['image' + i].destroy();
			}
			this.$['container' + i].destroy();
		}
		this.imageCount = this.images.length;
	},

	/**
	* Loads images that are in view or may come into view soon.
	*
	* @private
	*/
	loadNearby: function () {
		var range = this.getBufferRange();
		for (var i in range) {
			this.loadImageView(range[i]);
		}
	},

	/**
	* Determines which image indices are `'near'` the active image.
	*
	* @private
	*/
	getBufferRange: function () {
		var range = [];
		if (this.layout.containerBounds) {
			var prefetchRange = 1;
			var bounds = this.layout.containerBounds;
			var c, i, x, xEnd;
			// get the lower range
			i=this.index-1;
			x=0;
			xEnd = bounds.width * prefetchRange;
			while (i>=0 && x<=xEnd) {
				c = this.$['container' + i];
				x+= c.width + c.marginWidth;
				range.unshift(i);
				i--;
			}
			// get the upper range
			i=this.index;
			x=0;
			xEnd = bounds.width * (prefetchRange + 1);
			while (i<this.images.length && x<=xEnd) {
				c = this.$['container' + i];
				x+= c.width + c.marginWidth;
				range.push(i);
				i++;
			}
		}
		return range;
	},

	/**
	* @method
	* @private
	*/
	reflow: function () {
		Panels.prototype.reflow.apply(this, arguments);
		this.loadNearby();
	},

	/**
	* Loads the image whose path is found at the specified index in the
	* [images]{@link enyo.ImageCarousel#images} array.
	*
	* @param {Number} index - The index of the image to load.
	* @private
	*/
	loadImageView: function (index) {
		// NOTE: wrap bugged in enyo.CarouselArranger, but once fixed, wrap should work in this
		if (this.wrap) {
			// Used this modulo technique to get around javascript issue with negative values
			// ref: http://javascript.about.com/od/problemsolving/a/modulobug.htm
			index = ((index % this.images.length)+this.images.length)%this.images.length;
		}
		if (index>=0 && index<=this.images.length-1) {
			if (!this.$['image' + index]) {
				this.$['container' + index].createComponent({
					name: 'image' + index,
					kind: ImageView,
					scale: this.defaultScale,
					disableZoom: this.disableZoom,
					src: this.images[index],
					verticalDragPropagation: false,
					style: 'height:100%; width:100%;'
				}, {owner: this});
				this.$['image' + index].render();
			} else {
				if (this.$['image' + index].src != this.images[index]) {
					this.$['image' + index].setSrc(this.images[index]);
					this.$['image' + index].setScale(this.defaultScale);
					this.$['image' + index].setDisableZoom(this.disableZoom);
				}
			}
		}
		return this.$['image' + index];
	},

	/**
	* Updates the array of images.
	*
	* @todo Probably a defect here. Simply calling `set()` won't force the observer to fire
	* if `images` is a ref to the same array. Need to add the `force` parameter.
	* @public
	*/
	setImages: function (images) {
		// always invoke imagesChanged because this is an array property
		// which might otherwise seem to be the same object
		this.set('images', images);
	},

	/**
	* @private
	*/
	imagesChanged: function () {
		this.initContainers();
		this.loadNearby();
	},

	/**
	* @method
	* @private
	*/
	indexChanged: function () {
		this.loadNearby();
		if (this.lowMemory) {
			this.cleanupMemory();
		}
		Panels.prototype.indexChanged.apply(this, arguments);
	},

	/**
	* @private
	*/
	transitionStart: function (sender, event) {
		if (event.fromIndex==event.toIndex) {
			return true; //prevent from bubbling if there's no change
		}
	},

	/**
	* @private
	*/
	transitionFinish: function (sender, event) {
		this.loadNearby();
		if (this.lowMemory) {
			this.cleanupMemory();
		}
	},

	/**
	* Returns the currently displayed ImageView.
	*
	* @return {enyo.Control} - The active image control.
	* @public
	*/
	getActiveImage: function () {
		return this.getImageByIndex(this.index);
	},

	/**
	* Returns the ImageView with the specified index.
	*
	* @param {Number} index  - The index of the image to be retrieved.
	* @return {enyo.Control} - The image control at `index`.
	* @public
	*/
	getImageByIndex: function (index) {
		return this.$['image' + index] || this.loadImageView(index);
	},

	/**
	* Destroys any ImageView objects that are not in the immediate viewing area
	* (i.e., any images other than the currently active image and the first
	* image on either side of it) to free up memory. If you set the ImageCarousel's
	* [lowMemory]{@link enyo.ImageCarousel#lowMemory} property to `true`, this
	* function will be called automatically as needed.
	*
	* @public
	*/
	cleanupMemory: function () {
		var buffer = this.getBufferRange();
		for (var i=0; i<this.images.length; i++) {
			if (utils.indexOf(i, buffer) ===-1) {
				if (this.$['image' + i]) {
					this.$['image' + i].destroy();
				}
			}
		}
	}
});
},{"../../enyo/lib/kind":66,"../../enyo/lib/utils":75,"./CarouselArranger":81,"./ImageView":92,"./Panels":99}],117:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind');

var
	ImageView = require('../../../layout/lib/ImageView'),
	ImageViewPin = require('../../../layout/lib/ImageViewPin');

/**
	Our map pin icon is based in whole or in part on the OpenStructs open source information and documentation,
	largely developed by Structured Dynamics LLC. You are free to use this content and system as you wish, so long
	as any derivative works acknowledge these contributions. TechWiki is provided under the Creative Commons
	Attribution License, version 3.0. - http://techwiki.openstructs.org/index.php/Open_Source_Icons
*/
module.exports = kind({
	name: 'enyo.sample.ImageViewSample',
	components: [
		{name: 'sampleImageView', kind: ImageView, src: 'assets/globe.jpg', scale: 'auto', classes: 'enyo-fit', components: [
			{kind: ImageViewPin, highlightAnchorPoint:true, anchor: {top:79, right:224}, position: {bottom:0, left:-16}, components: [
				{kind: 'Image', src: 'assets/pin.png'}
			]},
			{kind: ImageViewPin, anchor: {top:280, left:415}, position: {bottom:0, right:-16}, components: [
				{kind: 'Image', src: 'assets/pin.png'}
			]},
			{kind: ImageViewPin, highlightAnchorPoint:true, anchor: {bottom: '20%', left: '400px'}, position: {bottom:0, left:0}, components: [
				{style: 'background:rgba(255,255,255,0.8);border:1px solid #888;margin:0px;padding:0px;width:300px', components: [
					{tag: 'h3', content: 'This is a text box'}
				]}
			]},
			{name: 'testPin', kind: ImageViewPin, anchor: {top: '10%', right: '10%'}, position: {top:0, left:0}, components: [
				{style: 'border:1px solid yellow;width:10px;background:red;height:10px;'}
			]}
		]}
	]
});


},{"../../../enyo/lib/kind":66,"../../../layout/lib/ImageView":92,"../../../layout/lib/ImageViewPin":93}],116:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	Button = require('../../../enyo/lib/Button'),
	Input = require('../../../enyo/lib/Input');

var
	FittableRows = require('../../../layout/lib/FittableRows'),
	ImageCarousel = require('../../../layout/lib/ImageCarousel');

module.exports = kind({
	name: 'enyo.sample.ImageCarouselSample',
	kind: FittableRows,
	classes: 'enyo-fit',
	components: [
		{classes: 'layout-sample-toolbar', style: 'text-align:center;', components: [
			{kind: Button, content: '&larr;', allowHtml: true, ontap: 'previous'},
			{kind: Button, content: '&rarr;', allowHtml: true, ontap: 'next'},
			{tag: 'label', classes: 'imagecarousel-sample-input', components: [
				{name: 'carouselIndexInput', kind: Input, value: '0', onchange: 'updateIndex'}
			]}
		]},
		{name: 'carousel', kind: ImageCarousel, fit:true, onload: 'load', onZoom: 'zoom', onerror: 'error', onTransitionStart: 'transitionStart', onTransitionFinish: 'transitionFinish'}
	],
	create: kind.inherit(function (sup) {
		return function () {
			sup.apply(this, arguments);
			this.urls = [
				'assets/mercury.jpg',
				'assets/venus.jpg',
				'assets/earth.jpg',
				'assets/mars.jpg',
				'assets/jupiter.jpg',
				'assets/saturn.jpg',
				'assets/uranus.jpg',
				'assets/neptune.jpg'
			];
			// although we're specifying all the image urls now, the images themselves
			// only get created/loaded as needed
			this.$.carousel.setImages(this.urls);
		};
	}),
	load: function (sender, event) {
		//enyo.log('image loaded: ' + event.originator.src);
	},
	zoom: function (sender, event) {
		//enyo.log('image zoomed: ' + event.scale + ' scale on ' + event.originator.src);
	},
	error: function (sender, event) {
		//enyo.log('image error: ' + event.originator.src);
	},
	transitionStart: function (sender, event) {
		//enyo.log('image now transitioning from: ' + this.$.carousel.getImageByIndex(event.fromIndex).src
		//		+ ' to ' + this.$.carousel.getImageByIndex(event.toIndex).src);
	},
	transitionFinish: function (sender, event) {
		//enyo.log('image transitioned to: ' + this.$.carousel.getActiveImage().src);
		if (this.$.carouselIndexInput) {
			this.$.carouselIndexInput.setValue(event.toIndex);
		}
	},
	previous: function (sender, event) {
		this.$.carousel.previous();
	},
	next: function (sender, event) {
		this.$.carousel.next();
	},
	getRandomIndex: function () {
		var i = Math.floor(Math.random()*this.$.carousel.images.length);
		while(i==this.$.carousel.index) { //make sure it isn't the active index
			i = Math.floor(Math.random()*this.$.carousel.images.length);
		}
		return i;
	},
	updateIndex: function (sender, event) {
		var index = this.trimWhitespace(this.$.carouselIndexInput.getValue());
		if (index === '' || isNaN(index)) {
			//enyo.log('Numbers only please.')
			return;
		}
		this.$.carousel.setIndex(parseInt(index, 10));
	},
	trimWhitespace: function (str) {
		return str.replace(/^\s+|\s+$/g,'');
	}
});
},{"../../../enyo/lib/Button":10,"../../../enyo/lib/Input":24,"../../../enyo/lib/kind":66,"../../../layout/lib/FittableRows":88,"../../../layout/lib/ImageCarousel":91}],135:[function(require,module,exports){
var
	kind = require('../../../enyo/lib/kind'),
	ready = require('../../../enyo/lib/ready'),
	Anchor = require('../../../enyo/lib/Anchor'),
	Collection = require('../../../enyo/lib/Collection'),
	Control = require('../../../enyo/lib/Control'),
	DataRepeater = require('../../../enyo/lib/DataRepeater');

var
	samples = {
		ContextualLayout			: require('./ContextualLayoutSample'),
		Easing						: require('./EasingSample'),
		FittableAppLayout1			: require('./FittableAppLayout1'),
		FittableAppLayout2			: require('./FittableAppLayout2'),
		FittableAppLayout3			: require('./FittableAppLayout3'),
		FittableAppLayout4			: require('./FittableAppLayout4'),
		FittableDescription			: require('./FittableDescription'),
		FittableTests				: require('./FittableTests'),
		Fittable					: require('./FittableSample'),
		FlyweightRepeater			: require('./FlyweightRepeaterSample'),
		ImageCarousel				: require('./ImageCarouselSample'),
		ImageView					: require('./ImageViewSample'),
		ListAround					: require('./ListAroundSample'),
		ListBasic					: require('./ListBasicSample'),
		ListContacts				: require('./ListContactsSample'),
		ListHorizontalFlickr		: require('./ListHorizontalFlickrSample'),
		ListLanguages				: require('./ListLanguagesSample'),
		ListNoSelect				: require('./ListNoSelectSample'),
		ListPulldown				: require('./ListPulldownSample'),
		PersistentSwipeableItem		: require('./PersistentSwipeableItemSample'),
		Panels						: require('./PanelsSample'),
		PanelsFlickr				: require('./PanelsFlickrSample'),		
		PanelsSliding				: require('./PanelsSlidingSample'),
		PanZoomView1				: require('./PanZoomViewSample'),
		PanZoomView2				: require('./PanZoomViewSample2'),
		PanZoomView3				: require('./PanZoomViewSample3'),
		Slideable					: require('./SlideableSample'),
		Tree						: require('./TreeSample')
	};

var List = kind({
	kind: Control,
	components: [
		{name: 'list', kind: DataRepeater, components: [
			{style: 'margin: 10px;', components: [
				{name: 'a', kind: Anchor}
			], bindings: [
				{from: 'model.name', to: '$.a.href', transform: function (v) { return '?' + v; }},
				{from: 'model.name', to: '$.a.content', transform: function (v) { return v + ' Sample'; }}
			]}
		]}
	],
	create: function () {
		Control.prototype.create.apply(this, arguments);
		this.$.list.set('collection', new Collection(Object.keys(samples).map(function (key) {
			return {name: key};
		})));
	}
});

ready(function () {
	var name = window.document.location.search.substring(1),
		sample = samples[name] || List;

	new sample({samples: samples}).renderInto(document.body);
});
},{"../../../enyo/lib/Anchor":4,"../../../enyo/lib/Collection":12,"../../../enyo/lib/Control":16,"../../../enyo/lib/DataRepeater":18,"../../../enyo/lib/kind":66,"../../../enyo/lib/ready":72,"./ContextualLayoutSample":106,"./EasingSample":107,"./FittableAppLayout1":108,"./FittableAppLayout2":109,"./FittableAppLayout3":110,"./FittableAppLayout4":111,"./FittableDescription":112,"./FittableSample":113,"./FittableTests":114,"./FlyweightRepeaterSample":115,"./ImageCarouselSample":116,"./ImageViewSample":117,"./ListAroundSample":118,"./ListBasicSample":119,"./ListContactsSample":120,"./ListHorizontalFlickrSample":121,"./ListLanguagesSample":122,"./ListNoSelectSample":123,"./ListPulldownSample":124,"./PanZoomViewSample":126,"./PanZoomViewSample2":127,"./PanZoomViewSample3":128,"./PanelsFlickrSample":129,"./PanelsSample":130,"./PanelsSlidingSample":131,"./PersistentSwipeableItemSample":132,"./SlideableSample":133,"./TreeSample":134}]},{},[135]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJpbnNlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuXG52YXIgUGF0aFJlc29sdmVyRmFjdG9yeSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMucGF0aHMgPSB7fTtcblx0dGhpcy5wYXRoTmFtZXMgPSBbXTtcbn07XG5cblBhdGhSZXNvbHZlckZhY3RvcnkucHJvdG90eXBlID0ge1xuXHRhZGRQYXRoOiBmdW5jdGlvbihpbk5hbWUsIGluUGF0aCkge1xuXHRcdHRoaXMucGF0aHNbaW5OYW1lXSA9IGluUGF0aDtcblx0XHR0aGlzLnBhdGhOYW1lcy5wdXNoKGluTmFtZSk7XG5cdFx0dGhpcy5wYXRoTmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcblx0XHR9KTtcblx0XHRyZXR1cm4gaW5QYXRoO1xuXHR9LFxuXHRhZGRQYXRoczogZnVuY3Rpb24oaW5QYXRocykge1xuXHRcdGlmIChpblBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBuIGluIGluUGF0aHMpIHtcblx0XHRcdFx0dGhpcy5hZGRQYXRoKG4sIGluUGF0aHNbbl0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aW5jbHVkZVRyYWlsaW5nU2xhc2g6IGZ1bmN0aW9uKGluUGF0aCkge1xuXHRcdHJldHVybiAoaW5QYXRoICYmIGluUGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSA/IGluUGF0aCArIFwiL1wiIDogaW5QYXRoO1xuXHR9LFxuXHQvLyByZXBsYWNlIG1hY3JvcyBvZiB0aGUgZm9ybSAkcGF0aG5hbWUgd2l0aCB0aGUgbWFwcGVkIHZhbHVlIG9mIHBhdGhzLnBhdGhuYW1lXG5cdHJld3JpdGU6IGZ1bmN0aW9uIChpblBhdGgpIHtcblx0XHR2YXIgd29ya2luZywgaXRzID0gdGhpcy5pbmNsdWRlVHJhaWxpbmdTbGFzaCwgcGF0aHMgPSB0aGlzLnBhdGhzO1xuXHRcdHZhciBmbiA9IGZ1bmN0aW9uKG1hY3JvLCBuYW1lKSB7XG5cdFx0XHR3b3JraW5nID0gdHJ1ZTtcblx0XHRcdHJldHVybiBpdHMocGF0aHNbbmFtZV0pIHx8ICcnO1xuXHRcdH07XG5cdFx0dmFyIHJlc3VsdCA9IGluUGF0aDtcblx0XHRkbyB7XG5cdFx0XHR3b3JraW5nID0gZmFsc2U7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5wYXRoTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIlxcXFwkKFwiICsgdGhpcy5wYXRoTmFtZXNbaV0gKyBcIikoXFxcXC8pP1wiLCBcImdcIik7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHJlZ2V4LCBmbik7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAod29ya2luZyk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcbn0se31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZ2xvYmFsLmVueW8gJiYgZ2xvYmFsLmVueW8ub3B0aW9ucykgfHwge307XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDEyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBMaWNlbnNlZCB1bmRlciBDcmVhdGl2ZSBDb21tb25zIEF0dHJpYnV0aW9uIDMuMCBMaWNlbnNlXG4vLyBhdHRyaWJ1dGVkIHRvOiBodHRwOi8vbGVhcG9uLm5ldC9lbi9yYW5kb20tbmFtZS1nZW5lcmF0b3ItamF2YXNjcmlwdFxuXG4vKiBleHBvcnRlZCBtYWtlTmFtZSAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG1ha2VOYW1lOiBmdW5jdGlvbiAobWlubGVuZ3RoLCBtYXhsZW5ndGgsIHByZWZpeCwgc3VmZml4KSB7XG5cblx0XHRmdW5jdGlvbiBybmQobWludiwgbWF4dikge1xuXHRcdFx0aWYgKG1heHYgPCBtaW52KSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWF4di1taW52KzEpKSArIG1pbnY7XG5cdFx0fVxuXG5cdFx0cHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXHRcdHN1ZmZpeCA9IHN1ZmZpeCB8fCAnJztcblx0XHQvLyB0aGVzZSB3ZWlyZCBjaGFyYWN0ZXIgc2V0cyBhcmUgaW50ZW5kZWQgdG8gY29wZSB3aXRoIHRoZSBuYXR1cmUgb2YgRW5nbGlzaCAoZS5nLiBjaGFyICd4JyBwb3BzIHVwIGxlc3MgZnJlcXVlbnRseSB0aGFuIGNoYXIgJ3MnKVxuXHRcdC8vIG5vdGU6ICdoJyBhcHBlYXJzIGFzIGNvbnNvbmFudHMgYW5kIHZvY2Fsc1xuXHRcdHZhciB2b2NhbHMgPSAnYWVpb3V5aCcgKyAnYWVpb3UnICsgJ2FlaW91Jztcblx0XHR2YXIgY29ucyA9ICdiY2RmZ2hqa2xtbnBxcnN0dnd4eicgKyAnYmNkZmdqa2xtbnByc3R2dycgKyAnYmNkZmdqa2xtbnByc3QnO1xuXHRcdHZhciBhbGxjaGFycyA9IHZvY2FscyArIGNvbnM7XG5cdFx0dmFyIGxlbmd0aCA9IHJuZChtaW5sZW5ndGgsIG1heGxlbmd0aCkgLSBwcmVmaXgubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDtcblx0XHRpZiAobGVuZ3RoIDwgMSkge1xuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR9XG5cdFx0dmFyIGNvbnNudW0gPSAwO1xuXHRcdHZhciBpO1xuXHRcdGlmIChwcmVmaXgubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoY29uc251bSA9PSAyKSB7XG5cdFx0XHRcdFx0Y29uc251bSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNvbnMuaW5kZXhPZihwcmVmaXhbaV0pICE9IC0xKSB7XG5cdFx0XHRcdFx0Y29uc251bSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc251bSA9IDE7XG5cdFx0fVxuXHRcdHZhciBuYW1lID0gcHJlZml4O1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHR7XG5cdFx0XHR2YXIgdG91c2U7XG5cdFx0XHQvL2lmIHdlIGhhdmUgdXNlZCAyIGNvbnNvbmFudHMsIHRoZSBuZXh0IGNoYXIgbXVzdCBiZSB2b2NhbC5cblx0XHRcdGlmIChjb25zbnVtID09IDIpXG5cdFx0XHR7XG5cdFx0XHRcdHRvdXNlID0gdm9jYWxzO1xuXHRcdFx0XHRjb25zbnVtID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0b3VzZSA9IGFsbGNoYXJzO1xuXHRcdFx0fVxuXHRcdFx0Ly9waWNrIGEgcmFuZG9tIGNoYXJhY3RlciBmcm9tIHRoZSBzZXQgd2UgYXJlIGdvaW4gdG8gdXNlLlxuXHRcdFx0dmFyIGMgPSB0b3VzZS5jaGFyQXQocm5kKDAsIHRvdXNlLmxlbmd0aCAtIDEpKTtcblx0XHRcdG5hbWUgPSBuYW1lICsgYztcblx0XHRcdGlmIChjb25zLmluZGV4T2YoYykgIT0gLTEpIHtcblx0XHRcdFx0Y29uc251bSsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRuYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEsIG5hbWUubGVuZ3RoKSArIHN1ZmZpeDtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbn0se31dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBQYXRoUmVzb2x2ZXJGYWN0b3J5ID0gcmVxdWlyZSgnLi9QYXRoUmVzb2x2ZXJGYWN0b3J5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFBhdGhSZXNvbHZlckZhY3RvcnkoKTtcbn0se1wiLi9QYXRoUmVzb2x2ZXJGYWN0b3J5XCI6MzZ9XSwxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvb3B0aW9ucycpO1xuZXhwb3J0cy52ZXJzaW9uID0gJzIuNi4wLXByZSc7XG59LHtcIi4vbGliL29wdGlvbnNcIjo2OX1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG4vKipcbiogVGhlIGF2YWlsYWJsZSBvcHRpb25zIHVzZWQgYnkge0BsaW5rIGVueW8uQWpheH0gYW5kIHtAbGluayBlbnlvLldlYlNlcnZpY2V9LlxuKlxuKiBAbmFtZXNwYWNlIGVueW8uQWpheFByb3BlcnRpZXNcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0gLyoqIEBsZW5kcyBlbnlvLkFqYXhQcm9wZXJ0aWVzICovIHtcblx0XG5cdC8qKlxuXHQqIFdoZW4gYHRydWVgLCBhcHBlbmRzIGEgcmFuZG9tIG51bWJlciBhcyBhIHBhcmFtZXRlciBmb3IgYEdFVGAgcmVxdWVzdHMgdG8gdHJ5IHRvXG5cdCogZm9yY2UgYSBuZXcgZmV0Y2ggb2YgdGhlIHJlc291cmNlIGluc3RlYWQgb2YgcmV1c2luZyBhIGxvY2FsIGNhY2hlLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2FjaGVCdXN0OiB0cnVlLFxuXHRcblx0LyoqXG5cdCogVGhlIFVSTCBmb3IgdGhlIHNlcnZpY2UuIFRoaXMgbWF5IGJlIGEgcmVsYXRpdmUgVVJMIGlmIHVzZWQgdG8gZmV0Y2ggcmVzb3VyY2VzIGJ1bmRsZWRcblx0KiB3aXRoIHRoZSBhcHBsaWNhdGlvbi5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJydcblx0KiBAcHVibGljXG5cdCovXG5cdHVybDogJycsXG5cdFxuXHQvKipcblx0KiBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIGZvciB0aGUgcmVxdWVzdDsgZGVmYXVsdHMgdG8gYCdHRVQnYC4gIFN1cHBvcnRlZCB2YWx1ZXMgaW5jbHVkZVxuXHQqIGAnR0VUJ2AsIGAnUE9TVCdgLCBgJ1BVVCdgLCBhbmQgYCdERUxFVEUnYC5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ0dFVCdcblx0KiBAcHVibGljXG5cdCovXG5cdG1ldGhvZDogJ0dFVCcsIC8vIHt2YWx1ZTogJ0dFVCcsIG9wdGlvbnM6IFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddfVxuXHRcblx0LyoqXG5cdCogSG93IHRoZSByZXNwb25zZSB3aWxsIGJlIGhhbmRsZWQuIFN1cHBvcnRlZCB2YWx1ZXMgYXJlIGAnanNvbidgLCBgJ3RleHQnYCwgYW5kIGAneG1sJ2AuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICdqc29uJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGFuZGxlQXM6ICdqc29uJywgLy8ge3ZhbHVlOiAnanNvbicsIG9wdGlvbnM6IFsndGV4dCcsICdqc29uJywgJ3htbCddfVxuXHRcblx0LyoqXG5cdCogVGhlIGBDb250ZW50LVR5cGVgIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QgYXMgYSBTdHJpbmcuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG5cdFxuXHQvKipcblx0KiBJZiBgdHJ1ZWAsIG1ha2VzIGEgc3luY2hyb25vdXMgKGJsb2NraW5nKSBjYWxsLCBpZiBzdXBwb3J0ZWQuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c3luYzogZmFsc2UsXG5cdFxuXHQvKipcblx0KiBPcHRpb25hbCBhZGRpdGlvbmFsIHJlcXVlc3QgaGVhZGVycyBhcyBhIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSwgb3IgYG51bGxgLlxuXHRcblx0KiBgYGBqYXZhc2NyaXB0XG5cdCogeyAnWC1NeS1IZWFkZXInOiAnTXkgVmFsdWUnLCAnTW9vZCc6ICdIYXBweScgfVxuXHQqIGBgYFxuXHQqXG5cdCogQHR5cGUge09iamVjdH1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRoZWFkZXJzOiBudWxsLFxuXHRcblx0LyoqXG5cdCogVGhlIGNvbnRlbnQgZm9yIHRoZSByZXF1ZXN0IGJvZHkgZm9yIGBQT1NUL1BVVGAgbWV0aG9kcy4gV2hlbiBgcG9zdEJvZHlgIGlzIGFcblx0KiBbYnVmZmVyXXtAZ2xvc3NhcnkgQnVmZmVyfSBvciBhIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9LCBpdCBpcyBwYXNzZWRcblx0KiB2ZXJiYXRpbSBpbiB0aGUgcmVxdWVzdCBib2R5LiBXaGVuIGl0IGlzIGEgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9LCB0aGUgd2F5IGl0IGlzXG5cdCogZW5jb2RlZCBkZXBlbmRzIG9uIHRoZSBgY29udGVudFR5cGVgOlxuXHQqXG5cdCogLSBgJ2FwcGxpY2F0aW9uL2pzb24nYCA9PiBbSlNPTi5zdHJpbmdpZnkoKV17QGdsb3NzYXJ5IEpTT04uc3RyaW5naWZ5fVxuXHQqIC0gYCdhcHBsaWNhdGlvbi94LXd3dy11cmxlbmNvZGVkJ2AgPT4gdXJsLWVuY29kZWQgcGFyYW1ldGVyc1xuXHQqIC0gYCdtdWx0aXBhcnQvZm9ybS1kYXRhJ2AgPT4gcGFzc2VkIGFzIGZpZWxkcyBpbiB7QGxpbmsgZW55by5Gb3JtRGF0YX0gKFhIUjIgZW11bGF0aW9uKVxuXHQqXG5cdCogQHR5cGUgeyhTdHJpbmd8QnVmZmVyfE9iamVjdCl9XG5cdCogQGRlZmF1bHQgJydcblx0KiBAcHVibGljXG5cdCovXG5cdHBvc3RCb2R5OiAnJyxcblxuXHQvKipcblx0KiBUaGUgb3B0aW9uYWwgdXNlcm5hbWUgdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvbiBwdXJwb3Nlcy5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJydcblx0KiBAcHVibGljXG5cdCovXG5cdHVzZXJuYW1lOiAnJyxcblx0XG5cdC8qKlxuXHQqIFRoZSBvcHRpb25hbCBwYXNzd29yZCB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uIHB1cnBvc2VzLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0cGFzc3dvcmQ6ICcnLFxuXHRcblx0LyoqXG5cdCogT3B0aW9uYWwgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHdpdGggZmllbGRzIHRvIHBhc3MgZGlyZWN0bHkgdG8gdGhlIHVuZGVybHlpbmcgWEhSXG5cdCogb2JqZWN0LiBPbmUgZXhhbXBsZSBpcyB0aGUgYHdpdGhDcmVkZW50aWFsc2AgZmxhZyB1c2VkIGZvciBjcm9zcy1vcmlnaW4gcmVxdWVzdHMuXG5cdCpcblx0KiBAdHlwZSB7T2JqZWN0fVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdHhockZpZWxkczogbnVsbCxcblx0XG5cdC8qKlxuXHQqIE9wdGlvbmFsIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IHRvIG92ZXJyaWRlIHRoZSBgTUlNRS1UeXBlYCBoZWFkZXIuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdG1pbWVUeXBlOiBudWxsXG59O1xufSx7XCIuLi8uLi9lbnlvXCI6MX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxuLyoqXG4qIEEgc3BlY2lhbCB0eXBlIG9mIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSB1c2VkIGludGVybmFsbHkgYnkgZGF0YSBsYXllclxuKiBba2luZHNde0BnbG9zc2FyeSBraW5kfS5cbipcbiogQGNsYXNzIGVueW8uTW9kZWxMaXN0XG4qIEBwcm90ZWN0ZWRcbiovXG5mdW5jdGlvbiBNb2RlbExpc3QgKGFyZ3MpIHtcblx0QXJyYXkuY2FsbCh0aGlzKTtcblx0dGhpcy50YWJsZSA9IHt9O1xuXHRpZiAoYXJncykgdGhpcy5hZGQoYXJncywgMCk7XG59XG5cbk1vZGVsTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWxMaXN0O1xuXG4vKipcbiogQWRkcyBbbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfSB0byB0aGUgW2xpc3Rde0BsaW5rIGVueW8uTW9kZWxMaXN0fSwgdXBkYXRpbmcgYW5cbiogaW50ZXJuYWwgdGFibGUgYnkgdGhlIG1vZGVsJ3MgW3ByaW1hcnlLZXlde0BsaW5rIGVueW8uTW9kZWwjcHJpbWFyeUtleX0gKGlmXG4qIHBvc3NpYmxlKSBhbmQgaXRzIFtldWlkXXtAZ2xvc3NhcnkgZXVpZH0uXG4qXG4qIEBuYW1lIGVueW8uTW9kZWxMaXN0I2FkZFxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7KGVueW8uTW9kZWx8ZW55by5Nb2RlbFtdKX0gbW9kZWxzIFRoZSBbbW9kZWwgb3IgbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfVxuKlx0dG8gYWRkIHRvIHRoZSBbbGlzdF17QGxpbmsgZW55by5Nb2RlbExpc3R9LlxuKiBAcGFyYW0ge051bWJlcn0gW2lkeF0gLSBJZiBwcm92aWRlZCBhbmQgdmFsaWQsIHRoZSBtb2RlbHMgd2lsbCBiZVxuKiBbc3BsaWNlZF17QGdsb3NzYXJ5IEFycmF5LnNwbGljZX0gaW50byB0aGUgbGlzdCBhdCB0aGlzIHBvc2l0aW9uLlxuKiBAcmV0dXJucyB7ZW55by5Nb2RlbFtdfSBBbiBpbW11dGFibGUgW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IG9mIG1vZGVsc1xuKiB0aGF0IHdlcmUgYWN0dWFsbHkgYWRkZWQgdG8gdGhlIGxpc3QuXG4qIEBwcm90ZWN0ZWRcbiovXG5Nb2RlbExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtb2RlbHMsIGlkeCkge1xuXHR2YXIgdGFibGUgPSB0aGlzLnRhYmxlLFxuXHRcdGFkZGVkID0gW10sXG5cdFx0bW9kZWwsXG5cdFx0ZXVpZCxcblx0XHRpZCxcblx0XHRpID0gMDtcblx0XG5cdGlmIChtb2RlbHMgJiYgIShtb2RlbHMgaW5zdGFuY2VvZiBBcnJheSkpIG1vZGVscyA9IFttb2RlbHNdO1xuXHRcblx0Zm9yICg7IChtb2RlbCA9IG1vZGVsc1tpXSk7ICsraSkge1xuXHRcdGV1aWQgPSBtb2RlbC5ldWlkO1xuXHRcdFxuXHRcdC8vIHdlIG9ubHkgd2FudCB0byBhY3R1YWxseSBhZGQgbW9kZWxzIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZWVuLi4uXG5cdFx0aWYgKCF0YWJsZVtldWlkXSkge1xuXHRcdFx0aWQgPSBtb2RlbC5nZXQobW9kZWwucHJpbWFyeUtleSk7XG5cdFx0XG5cdFx0XHRpZiAoaWQgIT0gbnVsbCkge1xuXHRcdFx0XG5cdFx0XHRcdC8vIEBUT0RPOiBGb3Igbm93IGlmIHdlIGFscmVhZHkgaGF2ZSBhbiBlbnRyeSBmb3IgYSBtb2RlbCBieSBpdHMgc3VwcG9zZWQgdW5pcXVlXG5cdFx0XHRcdC8vIGlkZW50aWZpZXIgYnV0IGl0IGlzbid0IHRoZSBpbnN0YW5jZSB3ZSBqdXN0IGZvdW5kIHdlIGNhbid0IGp1c3Rcblx0XHRcdFx0Ly8gb3ZlcndyaXRlIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBzbyB3ZSBtYXJrIHRoZSBuZXcgb25lIGFzIGhlYWRsZXNzXG5cdFx0XHRcdGlmICh0YWJsZVtpZF0gJiYgdGFibGVbaWRdICE9PSBtb2RlbCkgbW9kZWwuaGVhZGxlc3MgPSB0cnVlO1xuXHRcdFx0XHQvLyBvdGhlcndpc2Ugd2UgZG8gdGhlIG5vcm1hbCB0aGluZyBhbmQgYWRkIHRoZSBlbnRyeSBmb3IgaXRcblx0XHRcdFx0ZWxzZSB0YWJsZVtpZF0gPSBtb2RlbDsgXG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvLyBub21hdHRlciB3aGF0IHRob3VnaCB0aGUgZXVpZCBzaG91bGQgYmUgdW5pcXVlXG5cdFx0XHR0YWJsZVtldWlkXSA9IG1vZGVsO1xuXHRcdFx0YWRkZWQucHVzaChtb2RlbCk7XG5cdFx0fVxuXHR9XG5cdFxuXHRpZiAoYWRkZWQubGVuZ3RoKSB7XG5cdFx0aWR4ID0gIWlzTmFOKGlkeCkgPyBNYXRoLm1pbihNYXRoLm1heCgwLCBpZHgpLCB0aGlzLmxlbmd0aCkgOiAwO1xuXHRcdGFkZGVkLnVuc2hpZnQoMCk7XG5cdFx0YWRkZWQudW5zaGlmdChpZHgpO1xuXHRcdHRoaXMuc3BsaWNlLmFwcGx5KHRoaXMsIGFkZGVkKTtcblx0fVxuXHRcblx0cmV0dXJuIGFkZGVkLmxlbmd0aCA+IDAgPyBhZGRlZC5zbGljZSgyKSA6IGFkZGVkOyBcbn07XG5cbi8qKlxuKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgW21vZGVsc117QGxpbmsgZW55by5Nb2RlbH0gZnJvbSB0aGUgW2xpc3Rde0BsaW5rIGVueW8uTW9kZWxMaXN0fS5cbipcbiogQG5hbWUgZW55by5Nb2RlbExpc3QjcmVtb3ZlXG4qIEBtZXRob2RcbiogQHBhcmFtIHsoZW55by5Nb2RlbHxlbnlvLk1vZGVsW10pfSBtb2RlbHMgVGhlIFttb2RlbCBvciBtb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9XG4qXHR0byByZW1vdmUgZnJvbSB0aGUgW2xpc3Rde0BsaW5rIGVueW8uTW9kZWxMaXN0fS5cbiogQHJldHVybnMge2VueW8uTW9kZWxbXX0gQW4gaW1tdXRhYmxlIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZlxuKlx0bW9kZWxzIHRoYXQgd2VyZSBhY3R1YWxseSByZW1vdmVkIGZyb20gdGhlIGxpc3QuXG4qIEBwcm90ZWN0ZWRcbiovXG5Nb2RlbExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChtb2RlbHMpIHtcblx0dmFyIHRhYmxlID0gdGhpcy50YWJsZSxcblx0XHRyZW1vdmVkID0gW10sXG5cdFx0bW9kZWwsXG5cdFx0aWR4LFxuXHRcdGlkLFxuXHRcdGksXG5cdFx0XG5cdFx0Ly8gdGhlc2UgbW9kaWZpY2F0aW9ucyBhcmUgbWFkZSB0byBhbGxvdyBtb3JlIHBlcmZvcm1hbnQgbG9naWMgdG8gdGFrZSBwbGFjZSBpblxuXHRcdC8vIHZpZXdzIHRoYXQgbWF5IG5lZWQgdG8ga25vdyB0aGlzIGluZm9ybWF0aW9uXG5cdFx0bG93ID0gSW5maW5pdHk7XG5cdFxuXHRpZiAobW9kZWxzICYmICEobW9kZWxzIGluc3RhbmNlb2YgQXJyYXkpKSBtb2RlbHMgPSBbbW9kZWxzXTtcblx0XG5cdC8vIHdlIHN0YXJ0IGF0IHRoZSBlbmQgdG8gZW5zdXJlIHRoYXQgeW91IGNvdWxkIGV2ZW4gcGFzcyB0aGUgbGlzdCBpdHNlbGZcblx0Ly8gYW5kIGl0IHdpbGwgd29ya1xuXHRmb3IgKGkgPSBtb2RlbHMubGVuZ3RoIC0gMTsgKG1vZGVsID0gbW9kZWxzW2ldKTsgLS1pKSB7XG5cdFx0dGFibGVbbW9kZWwuZXVpZF0gPSBudWxsO1xuXHRcdGlkID0gbW9kZWwuZ2V0KG1vZGVsLnByaW1hcnlLZXkpO1xuXHRcdFxuXHRcdGlmIChpZCAhPSBudWxsKSB0YWJsZVtpZF0gPSBudWxsO1xuXHRcdFxuXHRcdGlkeCA9IG1vZGVscyA9PT0gdGhpcyA/IGkgOiB0aGlzLmluZGV4T2YobW9kZWwpO1xuXHRcdGlmIChpZHggPiAtMSkge1x0XHRcdFx0XG5cdFx0XHRpZiAoaWR4IDwgbG93KSBsb3cgPSBpZHg7XG5cdFx0XHRcblx0XHRcdHRoaXMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRyZW1vdmVkLnB1c2gobW9kZWwpO1xuXHRcdH1cblx0fVxuXHRcblx0Ly8gc2luY2UgdGhpcyBpcyBhIHNlcGFyYXRlIGFycmF5IHdlIHdpbGwgYWRkIHRoaXMgcHJvcGVydHkgdG8gaXQgZm9yIGludGVybmFsIHVzZSBvbmx5XG5cdHJlbW92ZWQubG93ID0gbG93O1xuXHRcblx0cmV0dXJuIHJlbW92ZWQ7XG59O1xuXG4vKipcbiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBpcyBwcmVzZW50IGluIHRoZVxuKiBbbGlzdF17QGxpbmsgZW55by5Nb2RlbExpc3R9LiBXaWxsIGF0dGVtcHQgdG8gcmVzb2x2ZSBhIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9XG4qIG9yIFtudW1iZXJde0BnbG9zc2FyeSBOdW1iZXJ9IHRvIGVpdGhlciBhIFtwcmltYXJ5S2V5XXtAbGluayBlbnlvLk1vZGVsI3ByaW1hcnlLZXl9XG4qIG9yIFtldWlkXXtAZ2xvc3NhcnkgZXVpZH0uXG4qXG4qIEBuYW1lIGVueW8uTW9kZWxMaXN0I2hhc1xuKiBAbWV0aG9kXG4qIEBwYXJhbSB7KGVueW8uTW9kZWx8U3RyaW5nfE51bWJlcil9IG1vZGVsIEFuIGlkZW50aWZpZXIgcmVwcmVzZW50aW5nIGVpdGhlciB0aGVcbipcdFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gaW5zdGFuY2UsIGl0cyBbcHJpbWFyeUtleV17QGxpbmsgZW55by5Nb2RlbCNwcmltYXJ5S2V5fSxcbiogb3IgaXRzIFtldWlkXXtAZ2xvc3NhcnkgZXVpZH0uXG4qIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbW9kZWwgaXMgcHJlc2VudCBpbiB0aGUgW2xpc3Rde0BsaW5rIGVueW8uTW9kZWxMaXN0fS5cbiogQHByb3RlY3RlZFxuKi9cbk1vZGVsTGlzdC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG1vZGVsKSB7XG5cdGlmIChtb2RlbCA9PT0gdW5kZWZpbmVkIHx8IG1vZGVsID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdFxuXHRpZiAodHlwZW9mIG1vZGVsID09ICdzdHJpbmcnIHx8IHR5cGVvZiBtb2RlbCA9PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiAhISB0aGlzLnRhYmxlW21vZGVsXTtcblx0fSBlbHNlIHJldHVybiB0aGlzLmluZGV4T2YobW9kZWwpID4gLTE7XG59O1xuXG4vKipcbiogR2l2ZW4gYW4gaWRlbnRpZmllciwgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBhc3NvY2lhdGVkIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0uXG4qIFRoZSBpZGVudGlmaWVyIHNob3VsZCBiZSBhIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IG9yIFtudW1iZXJde0BnbG9zc2FyeSBOdW1iZXJ9LlxuKlxuKiBAbmFtZSBlbnlvLk1vZGVsTGlzdCNyZXNvbHZlXG4qIEBtZXRob2RcbiogQHBhcmFtIHsoU3RyaW5nfE51bWJlcil9IG1vZGVsIC0gQW4gaWRlbnRpZmllciAoZWl0aGVyIGFcbipcdFtwcmltYXJ5S2V5XXtAbGluayBlbnlvLk1vZGVsI3ByaW1hcnlLZXl9IG9yIGFuIFtldWlkXXtAZ2xvc3NhcnkgZXVpZH0pLlxuKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxudWxsfGVueW8uTW9kZWwpfSBJZiB0aGUgaWRlbnRpZmllciBjb3VsZCBiZSByZXNvbHZlZCwgYVxuKlx0W21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBpbnN0YW5jZSBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYCwgb3JcbiogcG9zc2libHkgYG51bGxgIGlmIHRoZSBtb2RlbCBvbmNlIGJlbG9uZ2VkIHRvIHRoZSBbbGlzdF17QGxpbmsgZW55by5Nb2RlbExpc3R9LlxuKiBAcHJvdGVjdGVkXG4qL1xuTW9kZWxMaXN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG5cdGlmICh0eXBlb2YgbW9kZWwgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG1vZGVsID09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHRoaXMudGFibGVbbW9kZWxdO1xuXHR9IGVsc2UgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4qIENvcGllcyB0aGUgY3VycmVudCBbbGlzdF17QGxpbmsgZW55by5Nb2RlbExpc3R9IGFuZCByZXR1cm5zIGFuIHNoYWxsb3cgY29weS4gVGhpc1xuKiBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBbc2xpY2UoKV17QGdsb3NzYXJ5IEFycmF5LnNsaWNlfSBtZXRob2QgaW5oZXJpdGVkIGZyb21cbiogbmF0aXZlIFtBcnJheV17QGdsb3NzYXJ5IEFycmF5fSBpbiB0aGF0IHRoaXMgcmV0dXJucyBhbiB7QGxpbmsgZW55by5Nb2RlbExpc3R9LFxuKiB3aGlsZSBgc2xpY2UoKWAgcmV0dXJucyBhbiBhcnJheS5cbiogXG4qIEBuYW1lIGVueW8uTW9kZWxMaXN0I2NvcHlcbiogQG1ldGhvZFxuKiBAcmV0dXJucyB7ZW55by5Nb2RlbExpc3R9IEEgc2hhbGxvdyBjb3B5IG9mIHRoZSBjYWxsZWUuXG4qIEBwcm90ZWN0ZWRcbiovXG5Nb2RlbExpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgTW9kZWxMaXN0KHRoaXMpO1xufTtcbn0se1wiLi4vLi4vZW55b1wiOjF9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbi8qKlxuKiBTaGFyZWQgdmFsdWVzIGZvciB2YXJpb3VzIFtraW5kc117QGdsb3NzYXJ5IGtpbmR9IHVzZWQgdG8gaW5kaWNhdGUgYSBzdGF0ZSBvclxuKiAobXVsdGlwbGUsIHNpbXVsdGFuZW91cykgc3RhdGVzLiBUaGVzZSBmbGFncyBhcmUgYmluYXJ5IHZhbHVlcyByZXByZXNlbnRlZCBieVxuKiBoZXhhZGVjaW1hbCBudW1lcmFscy4gVGhleSBtYXkgYmUgbW9kaWZpZWQgYW5kIGNvbXBhcmVkIChvciBldmVuIGV4dGVuZGVkKSB1c2luZ1xuKiBbYml0d2lzZSBvcGVyYXRpb25zXXtAZ2xvc3NhcnkgYml0d2lzZX0gb3IgdmFyaW91c1xuKiBbQVBJIG1ldGhvZHNde0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0fSBhdmFpbGFibGUgdG8gdGhlIGtpbmRzIHRoYXQgc3VwcG9ydCB0aGVtLlxuKiBNYWtlIHN1cmUgdG8gZXhwbG9yZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgaW5kaXZpZHVhbCBraW5kcywgYXMgdGhleSBtYXkgaGF2ZVxuKiBzcGVjaWZpYyB1c2VzIGZvciBhIGdpdmVuIGZsYWcuXG4qIFxuKiBBcyBhIGN1cnNvcnkgb3ZlcnZpZXcsIGhlcmUgaXMgYSB0YWJsZSBvZiB0aGUgdmFsdWVzIGFscmVhZHkgZGVjbGFyZWQgYnkgYnVpbHQtaW4gZmxhZ3MuXG4qIEVhY2ggaGV4YWRlY2ltYWwgbnVtZXJhbCByZXByZXNlbnRzIGEgdW5pcXVlIHBvd2VyIG9mIDIgaW4gYmluYXJ5LCBmcm9tIHdoaWNoIHdlIGNhbiB1c2VcbiogW2JpdHdpc2UgbWFza3Nde0BnbG9zc2FyeSBiaXR3aXNlfSB0byBkZXRlcm1pbmUgaWYgYSBwYXJ0aWN1bGFyIHZhbHVlIGlzIHByZXNlbnQuXG4qIFxuKiBgYGBqYXZhc2NyaXB0XG4qIEhFWCAgICAgICAgICAgICBERUMgICAgICAgICAgICAgQklOXG4qIDB4MDAwMSAgICAgICAgICAgICAxICAgICAgICAgICAgMDAwMCAwMDAwIDAwMDAgMDAwMVxuKiAweDAwMDIgICAgICAgICAgICAgMiAgICAgICAgICAgIDAwMDAgMDAwMCAwMDAwIDAwMTBcbiogMHgwMDA0ICAgICAgICAgICAgIDQgICAgICAgICAgICAwMDAwIDAwMDAgMDAwMCAwMTAwXG4qIDB4MDAwOCAgICAgICAgICAgICA4ICAgICAgICAgICAgMDAwMCAwMDAwIDAwMDAgMTAwMFxuKiAweDAwMTAgICAgICAgICAgICAxNiAgICAgICAgICAgIDAwMDAgMDAwMCAwMDAxIDAwMDBcbiogMHgwMDIwICAgICAgICAgICAgMzIgICAgICAgICAgICAwMDAwIDAwMDAgMDAxMCAwMDAwXG4qIDB4MDA0MCAgICAgICAgICAgIDY0ICAgICAgICAgICAgMDAwMCAwMDAwIDAxMDAgMDAwMFxuKiAweDAwODAgICAgICAgICAgIDEyOCAgICAgICAgICAgIDAwMDAgMDAwMCAxMDAwIDAwMDBcbiogMHgwMTAwICAgICAgICAgICAyNTYgICAgICAgICAgICAwMDAwIDAwMDEgMDAwMCAwMDAwXG4qIDB4MDIwMCAgICAgICAgICAgNTEyICAgICAgICAgICAgMDAwMCAwMDEwIDAwMDAgMDAwMFxuKiAweDA0MDAgICAgICAgICAgMTAyNCAgICAgICAgICAgIDAwMDAgMDEwMCAwMDAwIDAwMDBcbiogMHgwODAwICAgICAgICAgIDIwNDggICAgICAgICAgICAwMDAwIDEwMDAgMDAwMCAwMDAwXG4qIFxuKiAuLi5cbiogXG4qIDB4MTAwMCAgICAgICAgICA0MDk2ICAgICAgICAgICAgMDAwMSAwMDAwIDAwMDAgMDAwMFxuKiBgYGBcbipcbiogQXMgYSBoaW50LCBjb252ZXJ0aW5nIChIRVgpIDB4MDgwMCB0byBERUMgZG86XG4qXG4qIGBgYGphdmFzY3JpcHRcbiogKDAqMTZeMykgKyAoOCoxNl4yKSArICgwKjE2XjEpICsgKDAqMTZeMCkgPSAyMDQ4XG4qIGBgYFxuKlxuKiBBcyBhIGhpbnQsIGNvbnZlcnRpbmcgKEhFWCkgMHgwODAwIHRvIEJJTiBkbzpcbipcbiogYGBgamF2YXNjcmlwdFxuKiAwICAgIDggICAgMCAgICAwICAgIChIRVgpXG4qIC0tLS0gLS0tLSAtLS0tIC0tLS1cbiogMDAwMCAxMDAwIDAwMDAgMDAwMCAoQklOKVxuKiBgYGBcbipcbiogQG5hbWUgZW55by5TdGF0ZXNcbiogQGVudW0ge051bWJlcn1cbiogQHB1YmxpY1xuKiBAc2VlIGVueW8uU3RhdGVTdXBwb3J0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFxuXHQvKipcblx0KiBPbmx5IGV4aXN0cyBpbiB0aGUgY2xpZW50IGFuZCB3YXMgY3JlYXRlZCBkdXJpbmcgdGhlIHJ1bnRpbWUgb2YgdGhlXG5cdCogW2FwcGxpY2F0aW9uXXtAZ2xvc3NhcnkgYXBwbGljYXRpb259LlxuXHQqXG5cdCogQG5hbWUgZW55by5TdGF0ZXMuTkVXXG5cdCogQGRlZmF1bHQgMVxuXHQqL1xuXHRORVc6IDB4MDAwMSxcblx0XG5cdC8qKlxuXHQqIEhhcyBiZWVuIG1vZGlmaWVkIGxvY2FsbHkgb25seS5cblx0KlxuXHQqIEBuYW1lIGVueW8uU3RhdGVzLkRJUlRZXG5cdCogQGRlZmF1bHQgMlxuXHQqL1xuXHRESVJUWTogMHgwMDAyLFxuXHRcblx0LyoqXG5cdCogSGFzIG5vdCBiZWVuIG1vZGlmaWVkIGxvY2FsbHkuXG5cdCpcblx0KiBAbmFtZSBlbnlvLlN0YXRlcy5DTEVBTlxuXHQqIEBkZWZhdWx0IDRcblx0Ki9cblx0Q0xFQU46IDB4MDAwNCxcblx0XG5cdC8qKlxuXHQqIENhbiBubyBsb25nZXIgYmUgbW9kaWZpZWQuXG5cdCpcblx0KiBAZGVmYXVsdCA4XG5cdCovXG5cdERFU1RST1lFRDogMHgwMDA4LFxuXHRcblx0LyoqXG5cdCogQ3VycmVudGx5IGF0dGVtcHRpbmcgdG8gZmV0Y2guXG5cdCogXG5cdCogQHNlZSBlbnlvLk1vZGVsLmZldGNoXG5cdCogQHNlZSBlbnlvLlJlbGF0aW9uYWxNb2RlbC5mZXRjaFxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmZldGNoXG5cdCpcblx0KiBAZGVmYXVsdCAxNlxuXHQqL1xuXHRGRVRDSElORzogMHgwMDEwLFxuXHRcblx0LyoqXG5cdCogQ3VycmVudGx5IGF0dGVtcHRpbmcgdG8gY29tbWl0LlxuXHQqIFxuXHQqIEBzZWUgZW55by5Nb2RlbC5jb21taXRcblx0KiBAc2VlIGVueW8uUmVsYXRpb25hbE1vZGVsLmNvbW1pdFxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmNvbW1pdFxuXHQqXG5cdCogQGRlZmF1bHQgMzJcblx0Ki9cblx0Q09NTUlUVElORzogMHgwMDIwLFxuXHRcblx0LyoqXG5cdCogQ3VycmVudGx5IGF0dGVtcHRpbmcgdG8gZGVzdHJveS5cblx0KiBcblx0KiBAc2VlIGVueW8uTW9kZWwuZGVzdHJveVxuXHQqIEBzZWUgZW55by5SZWxhdGlvbmFsTW9kZWwuZGVzdHJveVxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmRlc3Ryb3lcblx0KlxuXHQqIEBkZWZhdWx0IDY0XG5cdCovXG5cdERFU1RST1lJTkc6IDB4MDA0MCxcblx0XG5cdC8qKlxuXHQqIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29tbWl0LlxuXHQqIFxuXHQqIEBzZWUgZW55by5Nb2RlbC5jb21taXRcblx0KiBAc2VlIGVueW8uUmVsYXRpb25hbE1vZGVsLmNvbW1pdFxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmNvbW1pdFxuXHQqXG5cdCogQGRlZmF1bHQgMTI4XG5cdCovXG5cdEVSUk9SX0NPTU1JVFRJTkc6IDB4MDA4MCxcblx0XG5cdC8qKlxuXHQqIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgZmV0Y2guXG5cdCogXG5cdCogQHNlZSBlbnlvLk1vZGVsLmZldGNoXG5cdCogQHNlZSBlbnlvLlJlbGF0aW9uYWxNb2RlbC5mZXRjaFxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmZldGNoXG5cdCpcblx0KiBAZGVmYXVsdCAyNTZcblx0Ki9cblx0RVJST1JfRkVUQ0hJTkc6IDB4MDEwMCxcblx0XG5cdC8qKlxuXHQqIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgZGVzdHJveS5cblx0KiBcblx0KiBAc2VlIGVueW8uTW9kZWwuZGVzdHJveVxuXHQqIEBzZWUgZW55by5SZWxhdGlvbmFsTW9kZWwuZGVzdHJveVxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLmRlc3Ryb3lcblx0KlxuXHQqIEBkZWZhdWx0IDUxMlxuXHQqL1xuXHRFUlJPUl9ERVNUUk9ZSU5HOiAweDAyMDAsXG5cdFxuXHQvKipcblx0KiBBbiBlcnJvciB3YXMgZW5jb3VudGVyZWQgZm9yIHdoaWNoIHRoZXJlIHdhcyBubyBleGFjdCBmbGFnLCBvciBhbiBpbnZhbGlkIGVycm9yIHdhc1xuXHQqIHNwZWNpZmllZC5cblx0KlxuXHQqIEBkZWZhdWx0IDEwMjRcblx0Ki9cblx0RVJST1JfVU5LTk9XTjogMHgwNDAwLFxuXHRcblx0LyoqXG5cdCogQSBtdWx0aS1zdGF0ZSBbYml0bWFza117QGdsb3NzYXJ5IGJpdHdpc2V9LiBDb21wYXJlcyBhIGdpdmVuIGZsYWcgdG8gdGhlIHN0YXRlc1xuXHQqIGluY2x1ZGVkIGluIHRoZSBkZWZpbml0aW9uIG9mIGBCVVNZYC4gQnkgZGVmYXVsdCwgdGhpcyBpcyBvbmUgb2Zcblx0KiBbRkVUQ0hJTkdde0BsaW5rIGVueW8uU3RhdGVzLkZFVENISU5HfSwgW0NPTU1JVFRJTkdde0BsaW5rIGVueW8uU3RhdGVzLkNPTU1JVFRJTkd9LCBvclxuXHQqIFtERVNUUk9ZSU5HXXtAbGluayBlbnlvLlN0YXRlcy5ERVNUUk9ZSU5HfS4gSXQgbWF5IGJlIGV4dGVuZGVkIHRvIGluY2x1ZGUgYWRkaXRpb25hbFxuXHQqIHZhbHVlcyB1c2luZyB0aGUgW2JpdHdpc2Vde0BnbG9zc2FyeSBiaXR3aXNlfSBgT1JgIG9wZXJhdG9yIChgfGApLlxuXHQqXG5cdCogQGRlZmF1bHQgMTEyXG5cdCovXG5cdEJVU1k6IDB4MDAxMCB8IDB4MDAyMCB8IDB4MDA0MCxcblx0XG5cdC8qKlxuXHQqIEEgbXVsdGktc3RhdGUgW2JpdG1hc2tde0BnbG9zc2FyeSBiaXR3aXNlfS4gQ29tcGFyZXMgYSBnaXZlbiBmbGFnIHRvIHRoZSBzdGF0ZXNcblx0KiBpbmNsdWRlZCBpbiB0aGUgZGVmaW5pdGlvbiBvZiBgRVJST1JgLiBCeSBkZWZhdWx0LCB0aGlzIGlzIG9uZSBvZlxuXHQqIFtFUlJPUl9GRVRDSElOR117QGxpbmsgZW55by5TdGF0ZXMuRVJST1JfRkVUQ0hJTkd9LFxuXHQqIFtFUlJPUl9DT01NSVRUSU5HXXtAbGluayBlbnlvLlN0YXRlcy5FUlJPUl9DT01NSVRUSU5HfSxcblx0KiBbRVJST1JfREVTVFJPWUlOR117QGxpbmsgZW55by5TdGF0ZXMuRVJST1JfREVTVFJPWUlOR30sIG9yXG5cdCogW0VSUk9SX1VOS05PV05de0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SX1VOS05PV059LiBJdCBtYXkgYmUgZXh0ZW5kZWQgdG8gaW5jbHVkZVxuXHQqIGFkZGl0aW9uYWwgdmFsdWVzIHVzaW5nIHRoZSBbYml0d2lzZV17QGdsb3NzYXJ5IGJpdHdpc2V9IGBPUmAgb3BlcmF0b3IgKGB8YCkuXG5cdCpcblx0KiBAbmFtZSBlbnlvLlN0YXRlcy5FUlJPUlxuXHQqIEBkZWZhdWx0IDE5MjBcblx0Ki9cblx0RVJST1I6IDB4MDA4MCB8IDB4MDEwMCB8IDB4MDIwMCB8IDB4MDQwMCxcblx0XG5cdC8qKlxuXHQqIEEgbXVsdGktc3RhdGUgW2JpdG1hc2tde0BnbG9zc2FyeSBiaXR3aXNlfS4gQ29tcGFyZXMgYSBnaXZlbiBmbGFnIHRvIHRoZSBzdGF0ZXNcblx0KiBpbmNsdWRlZCBpbiB0aGUgZGVmaW5pdGlvbiBvZiBgUkVBRFlgLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBpbnZlcnNlIG9mIGFueVxuXHQqIHZhbHVlcyBpbmNsdWRlZCBpbiBbQlVTWV17QGxpbmsgZW55by5TdGF0ZXMuQlVTWX0gb3IgW0VSUk9SXXtAbGluayBlbnlvLlN0YXRlcy5FUlJPUn0uXG5cdCpcblx0KiBAbmFtZSBlbnlvLlN0YXRlcy5SRUFEWVxuXHQqIEBkZWZhdWx0IC0yMDQxXG5cdCovXG5cdFJFQURZOiB+KDB4MDAwOCB8IDB4MDAxMCB8IDB4MDAyMCB8IDB4MDA0MCB8IDB4MDA4MCB8IDB4MDEwMCB8IDB4MDIwMCB8IDB4MDQwMClcbn07XG59LHtcIi4uLy4uL2VueW9cIjoxfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXIgX2pvYnMgPSB7fTtcblxuLyoqXG4qIFJ1bnMgYSBbam9iXXtAbGluayBleHBvcnRzfSBhZnRlciB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGhhcyBlbGFwc2VkXG4qIHNpbmNlIGEgam9iIHdpdGggdGhlIHNhbWUgbmFtZSBoYXMgcnVuLlxuKiBcbiogSm9icyBjYW4gYmUgdXNlZCB0byB0aHJvdHRsZSBiZWhhdmlvcnMuICBJZiBzb21lIGV2ZW50IG1heSBvY2N1ciBvbmUgdGltZSBvclxuKiBtdWx0aXBsZSB0aW1lcywgYnV0IHdlIHdhbnQgYSByZXNwb25zZSB0byBvY2N1ciBvbmx5IG9uY2UgZXZlcnkgYG5gIHNlY29uZHMsXG4qIHdlIGNhbiB1c2UgYSBqb2IuXG4qXG4qIEBleGFtcGxlXG4qIG9uc2Nyb2xsOiBmdW5jdGlvbigpIHtcbipcdC8vIHVwZGF0ZVRodW1iIHdpbGwgYmUgY2FsbGVkLCBidXQgb25seSB3aGVuIDEgc2Vjb25kIGhhcyBlbGFwc2VkIHNpbmNlIHRoZVxuKlx0Ly8gbGFzdCBvbnNjcm9sbFxuKlx0ZXhwb3J0cyhcInVwZGF0ZVRodW1iXCIsIHRoaXMuYmluZFNhZmVseShcInVwZGF0ZVRodW1iXCIpLCAxMDAwKTtcbiogfVxuKlxuKiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIFtqb2Jde0BsaW5rIGV4cG9ydHN9IHRvIHRocm90dGxlLlxuKiBAcGFyYW0geyhGdW5jdGlvbnxTdHJpbmcpfSBqb2IgLSBFaXRoZXIgdGhlIG5hbWUgb2YgYSBtZXRob2Qgb3IgYSBbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn1cbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGV4ZWN1dGUgYXMgdGhlIHJlcXVlc3RlZCBqb2IuXG4qIEBwYXJhbSB7TnVtYmVyfSB3YWl0IC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSBqb2IgYWdhaW4uXG4qIEBzdGF0aWNcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChub20sIGpvYiwgd2FpdCkge1xuXHRleHBvcnRzLnN0b3Aobm9tKTtcblx0X2pvYnNbbm9tXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ZXhwb3J0cy5zdG9wKG5vbSk7XG5cdFx0am9iKCk7XG5cdH0sIHdhaXQpO1xufTtcblxuLyoqXG4qIENhbmNlbHMgdGhlIG5hbWVkIFtqb2Jde0BsaW5rIGV4cG9ydHN9LCBpZiBpdCBoYXMgbm90IGFscmVhZHkgZmlyZWQuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBub20gLSBUaGUgbmFtZSBvZiB0aGUgW2pvYl17QGxpbmsgZXhwb3J0c30gdG8gY2FuY2VsLlxuKiBAc3RhdGljXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLnN0b3AgPSBmdW5jdGlvbiAobm9tKSB7XG5cdGlmIChfam9ic1tub21dKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KF9qb2JzW25vbV0pO1xuXHRcdGRlbGV0ZSBfam9ic1tub21dO1xuXHR9XG59O1xuXG4vKipcbiogSW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgW2pvYl17QGxpbmsgZXhwb3J0c30gYW5kIHByZXZlbnRzIGFueSBvdGhlciBjYWxsc1xuKiB0byBgZXhwb3J0cy50aHJvdHRsZSgpYCB3aXRoIHRoZSBzYW1lIGpvYiBuYW1lIGZyb20gcnVubmluZyBmb3IgdGhlXG4qIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZS5cbiogXG4qIFRoaXMgaXMgdXNlZCBmb3IgdGhyb3R0bGluZyB1c2VyIGV2ZW50cyB3aGVuIHlvdSB3YW50IHRvIHByb3ZpZGUgYW5cbiogaW1tZWRpYXRlIHJlc3BvbnNlLCBidXQgbGF0ZXIgaW52b2NhdGlvbnMgbWlnaHQganVzdCBiZSBub2lzZSBpZiB0aGV5IGFycml2ZVxuKiB0b28gb2Z0ZW4uXG4qIFxuKiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIFtqb2Jde0BsaW5rIGV4cG9ydHN9IHRvIHRocm90dGxlLlxuKiBAcGFyYW0geyhGdW5jdGlvbnxTdHJpbmcpfSBqb2IgLSBFaXRoZXIgdGhlIG5hbWUgb2YgYSBtZXRob2Qgb3IgYSBbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn1cbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGV4ZWN1dGUgYXMgdGhlIHJlcXVlc3RlZCBqb2IuXG4qIEBwYXJhbSB7TnVtYmVyfSB3YWl0IC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICBqb2IgYWdhaW4uXG4qIEBzdGF0aWNcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbiAobm9tLCBqb2IsIHdhaXQpIHtcblx0Ly8gaWYgd2Ugc3RpbGwgaGF2ZSBhIGpvYiB3aXRoIHRoaXMgbmFtZSBwZW5kaW5nLCByZXR1cm4gaW1tZWRpYXRlbHlcblx0aWYgKF9qb2JzW25vbV0pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0am9iKCk7XG5cdF9qb2JzW25vbV0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdGV4cG9ydHMuc3RvcChub20pO1xuXHR9LCB3YWl0KTtcbn07XG59LHtcIi4uLy4uL2VueW9cIjoxfV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG5cbi8qKlxuKiBbSlNPTl17QGdsb3NzYXJ5IEpTT059IHJlbGF0ZWQgbWV0aG9kcyBhbmQgd3JhcHBlcnMuXG4qXG4qIEBuYW1lc3BhY2UgZW55by5qc29uXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IC8qKiBAbGVuZHMgZW55by5qc29uICovIHtcblx0XG5cdC8qKlxuXHQqIFdyYXBwZXIgZm9yIFtKU09OLnN0cmluZ2lmeSgpXXtAZ2xvc3NhcnkgSlNPTi5zdHJpbmdpZnl9LiBDcmVhdGVzIGFcblx0KiBbSlNPTl17QGdsb3NzYXJ5IEpTT059IFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IGZyb20gYW5cblx0KiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fS5cblx0KlxuXHQqIEBzZWUge0BnbG9zc2FyeSBKU09OLnN0cmluZ2lmeX1cblx0KiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdG8gY29udmVydCB0byBhXG5cdCpcdFtKU09OXXtAZ2xvc3NhcnkgSlNPTn0gW3N0cmluZ117QGdsb3NzYXJ5IFN0cmluZ30uXG5cdCogQHBhcmFtIHsoRnVuY3Rpb258U3RyaW5nW10pfSBbcmVwbGFjZXJdIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGVpdGhlciBhblxuXHQqXHRbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2Yga2V5cyB0byBpbmNsdWRlIGluIHRoZSBmaW5hbCBvdXRwdXQgb3IgYVxuXHQqXHRbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn0gdGhhdCB3aWxsIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIGR5bmFtaWNhbGx5IHJldHVyblxuXHQqXHR2YWx1ZXMgdG8gaW5jbHVkZSBmb3Iga2V5cy5cblx0KiBAcGFyYW0geyhOdW1iZXJ8U3RyaW5nKX0gW3NwYWNlXSAtIERldGVybWluZXMgdGhlIHNwYWNpbmcgKGlmIGFueSkgZm9yIHByZXR0eS1wcmludGVkXG5cdCpcdG91dHB1dCBvZiB0aGUgSlNPTiBzdHJpbmcuIEEgW251bWJlcl17QGdsb3NzYXJ5IE51bWJlcn0gaW5kaWNhdGVzIHRoZSBudW1iZXIgb2Zcblx0KiBzcGFjZXMgdG8gdXNlIGluIHRoZSBvdXRwdXQsIHdoaWxlIGEgc3RyaW5nIHdpbGwgYmUgdXNlZCB2ZXJiYXRpbS5cblx0KiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSlNPTiBzdHJpbmcgZm9yIHRoZSBnaXZlbiBvYmplY3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBXcmFwcGVyIGZvciBbSlNPTi5wYXJzZSgpXXtAZ2xvc3NhcnkgSlNPTi5wYXJzZX0uIFBhcnNlcyBhIHZhbGlkXG5cdCogW0pTT05de0BnbG9zc2FyeSBKU09OfSBbc3RyaW5nXXtAZ2xvc3NhcnkgU3RyaW5nfSBhbmQgcmV0dXJucyBhblxuXHQqIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LCBvciBgbnVsbGAgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGludmFsaWQuXG5cdCpcblx0KiBAc2VlIHtAZ2xvc3NhcnkgSlNPTi5wYXJzZX1cblx0KiBAcGFyYW0ge1N0cmluZ30ganNvbiAtIFRoZSBbSlNPTl17QGdsb3NzYXJ5IEpTT059IFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IHRvXG5cdCpcdHBhcnNlIGludG8gYW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0uXG5cdCogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIC0gVGhlIG9wdGlvbmFsIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSB0byB1c2UgdG9cblx0Klx0cGFyc2UgaW5kaXZpZHVhbCBrZXlzIG9mIHRoZSByZXR1cm4gb2JqZWN0LlxuXHQqIEByZXR1cm5zIHsoT2JqZWN0fG51bGwpfSBJZiBwYXJhbWV0ZXJzIGFyZSB2YWxpZCwgYW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH1cblx0KiBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlLCBgbnVsbGAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRwYXJzZTogZnVuY3Rpb24oanNvbiwgcmV2aXZlcikge1xuXHRcdHJldHVybiBqc29uID8gSlNPTi5wYXJzZShqc29uLCByZXZpdmVyKSA6IG51bGw7XG5cdH1cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxfV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG4vLyB3ZSBuZWVkIHRvIHJlZ2lzdGVyIGFwcHJvcHJpYXRlbHkgdG8ga25vdyB3aGVuXG4vLyB0aGUgZG9jdW1lbnQgaXMgb2ZmaWNpYWxseSByZWFkeSwgdG8gZW5zdXJlIHRoYXRcbi8vIGNsaWVudCBjb2RlIGlzIG9ubHkgZ29pbmcgdG8gZXhlY3V0ZSBhdCB0aGVcbi8vIGFwcHJvcHJpYXRlIHRpbWVcblxudmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIHJlYWR5ID0gKFwiY29tcGxldGVcIiA9PT0gZG9jLnJlYWR5U3RhdGUpO1xudmFyIHJ1bjtcbnZhciBpbml0O1xudmFyIHJlbW92ZTtcbnZhciBhZGQ7XG52YXIgZmx1c2g7XG52YXIgZmx1c2hTY2hlZHVsZWQgPSBmYWxzZTtcblxuLyoqXG4qIFJlZ2lzdGVycyBhIGNhbGxiYWNrIChhbmQgb3B0aW9uYWwgYHRoaXNgIGNvbnRleHQpIHRvIHJ1biBhZnRlciBhbGwgdGhlIEVueW8gYW5kIGxpYnJhcnkgY29kZVxuKiBoYXMgbG9hZGVkIGFuZCB0aGUgYERPTUNvbnRlbnRMb2FkZWRgIGV2ZW50IChvciBlcXVpdmFsZW50IG9uIG9sZGVyIGJyb3dzZXJzKSBoYXMgYmVlbiBzZW50LlxuKiBcbiogSWYgY2FsbGVkIGFmdGVyIHRoZSBzeXN0ZW0gaXMgaW4gYSByZWFkeSBzdGF0ZSwgcnVucyB0aGUgc3VwcGxpZWQgY29kZSBhc3luY2hyb25vdXNseSBhdCB0aGVcbiogZWFybGllc3Qgb3Bwb3J0dW5pdHkuXG4qXG4qIEBuYW1lIGVueW8ucmVhZHlcbiogQG1ldGhvZFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBtZXRob2QgdG8gZXhlY3V0ZSB3aGVuIHRoZSBET00gaXMgcmVhZHkuXG4qIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gLSBUaGUgb3B0aW9uYWwgY29udGV4dCAoYHRoaXNgKSB1bmRlciB3aGljaCB0byBleGVjdXRlIHRoZVxuKlx0Y2FsbGJhY2sgbWV0aG9kLlxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcblx0cXVldWUucHVzaChbZm4sIGNvbnRleHRdKTtcblx0Ly8gc2NoZWR1bGUgYW5vdGhlciBxdWV1ZSBmbHVzaCBpZiBuZWVkZWQgdG8gcnVuIG5ldyByZWFkeSBjYWxsc1xuXHRpZiAocmVhZHkgJiYgIWZsdXNoU2NoZWR1bGVkKSB7XG5cdFx0c2V0VGltZW91dChmbHVzaCwgMCk7XG5cdFx0Zmx1c2hTY2hlZHVsZWQgPSB0cnVlO1xuXHR9XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5ydW4gPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcblx0Zm4uY2FsbChjb250ZXh0IHx8IGdsb2JhbCk7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5pbml0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdC8vIGlmIHdlJ3JlIGludGVyYWN0aXZlLCBpdCBzaG91bGQgYmUgc2FmZSB0byBtb3ZlXG5cdC8vIGZvcndhcmQgYmVjYXVzZSB0aGUgY29udGVudCBoYXMgYmVlbiBwYXJzZWRcblx0aWYgKChyZWFkeSA9IChcImludGVyYWN0aXZlXCIgPT09IGRvYy5yZWFkeVN0YXRlKSkpIHtcblx0XHRpZiAoXCJET01Db250ZW50TG9hZGVkXCIgIT09IGV2ZW50LnR5cGUgJiYgXCJyZWFkeXN0YXRlY2hhbmdlXCIgIT09IGV2ZW50LnR5cGUpIHtcblx0XHRcdHJlbW92ZShldmVudC50eXBlLCBpbml0KTtcblx0XHRcdGZsdXNoKCk7XG5cdFx0fVxuXHR9XG5cdC8vIGZvciBhbiBJRTggZmFsbGJhY2sgYW5kIGxlZ2FjeSBXZWJLaXQgKGluY2x1ZGluZyB3ZWJPUyAzLnggYW5kIGxlc3MpIGFuZCBhc3N1cmFuY2Vcblx0aWYgKChyZWFkeSA9IChcImNvbXBsZXRlXCIgPT09IGRvYy5yZWFkeVN0YXRlIHx8IFwibG9hZGVkXCIgPT09IGRvYy5yZWFkeVN0YXRlKSkpIHtcblx0XHRyZW1vdmUoZXZlbnQudHlwZSwgaW5pdCk7XG5cdFx0Zmx1c2goKTtcblx0fVxufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuYWRkID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHR2YXIgbmFtZSA9IGRvYy5hZGRFdmVudExpc3RlbmVyPyBcImFkZEV2ZW50TGlzdGVuZXJcIjogXCJhdHRhY2hFdmVudFwiO1xuXHR2YXIgb24gPSBuYW1lID09PSBcImF0dGFjaEV2ZW50XCI/IFwib25cIjogXCJcIjtcblx0ZG9jW25hbWVdKG9uICsgZXZlbnQsIGZuLCBmYWxzZSk7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5yZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG5cdHZhciBuYW1lID0gZG9jLmFkZEV2ZW50TGlzdGVuZXI/IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiOiBcImRldGFjaEV2ZW50XCI7XG5cdHZhciBvbiA9IG5hbWUgPT09IFwiZGV0YWNoRXZlbnRcIj8gXCJvblwiOiBcIlwiO1xuXHRkb2NbbmFtZV0ob24gKyBldmVudCwgZm4sIGZhbHNlKTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXHRpZiAocmVhZHkgJiYgcXVldWUubGVuZ3RoKSB7XG5cdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0cnVuLmFwcGx5KGdsb2JhbCwgcXVldWUuc2hpZnQoKSk7XG5cdFx0fVxuXHR9XG5cdGZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG59O1xuXG4vLyBvaywgbGV0J3MgaG9vayB0aGlzIHVwXG5hZGQoXCJET01Db250ZW50TG9hZGVkXCIsIGluaXQpO1xuYWRkKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBpbml0KTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi9lbnlvXCI6MX1dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xudmFyIGNhbGxiYWNrcyA9IFtdLFxuXHRyb290cyA9IFtdO1xuXG5leHBvcnRzLnJvb3RzID0gcm9vdHM7XG5cbi8qKlxuKiBSZWdpc3RlcnMgYSBzaW5nbGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgYSByb290IHZpZXcgaXMgcmVuZGVyZWQuXG4qIFxuKiBAbmFtZSBlbnlvLnJlbmRlcmVkXG4qIEBtZXRob2RcbiogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIC0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXG4qIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1lbnlvLmdsb2JhbF0gVGhlIGNvbnRleHQgdW5kZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLnJlbmRlcmVkID0gZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRjYWxsYmFja3MucHVzaCh7bWV0aG9kOiBtZXRob2QsIGNvbnRleHQ6IGNvbnRleHQgfHwgZ2xvYmFsfSk7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5leHBvcnRzLnJvb3RzID0gcm9vdHM7XG5cbi8qKlxuKiBJbnZva2VzIGFsbCBrbm93biBjYWxsYmFja3MgKGlmIGFueSkgYWdhaW5zdCB0aGUgcm9vdCB2aWV3IG9uY2UgaXQgaGFzIGJlZW4gcmVuZGVyZWQuXG4qIFRoaXMgbWV0aG9kIGlzIG5vdCBsaWtlbHkgdG8gYmUgZXhlY3V0ZWQgdmVyeSBvZnRlbi5cbiogXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gaW52b2tlIChyb290KSB7XG5cdGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChsbikge1xuXHRcdGxuLm1ldGhvZC5jYWxsKGxuLmNvbnRleHQsIHJvb3QpO1xuXHR9KTtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZXhwb3J0cy5hZGRUb1Jvb3RzID0gZnVuY3Rpb24gKHZpZXcpIHtcblx0dmFyIHJlbmRlcmVkLFxuXHRcdGRlc3Ryb3k7XG5cdFxuXHQvLyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBjYWxsIHJlbmRlckludG8gbW9yZSB0aGFuIG9uY2Ugb24gYSBnaXZlbiB2aWV3IHdlIGVuc3VyZSB3ZVxuXHQvLyBkb24ndCByZWdpc3RlciBpdCB0d2ljZSB1bm5lY2Vzc2FyaWx5XG5cdGlmIChyb290cy5pbmRleE9mKHZpZXcpID09PSAtMSkge1xuXHRcdFxuXHRcdHJvb3RzLnB1c2godmlldyk7XG5cdFx0XG5cdFx0Ly8gaGlqYWNrIHRoZSByZW5kZXJlZCBtZXRob2Rcblx0XHRyZW5kZXJlZCA9IHZpZXcucmVuZGVyZWQ7XG5cdFx0XG5cdFx0Ly8gaGlqYWNrIHRoZSBkZXN0cm95IG1ldGhvZFxuXHRcdGRlc3Ryb3kgPSB2aWV3LmRlc3Ryb3k7XG5cdFx0XG5cdFx0Ly8gc3VwcGx5IG91ciByZW5kZXJlZCBob29rXG5cdFx0dmlldy5yZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIHdlIGNhbGwgdGhlIG9yaWdpbmFsIGZpcnN0XG5cdFx0XHRyZW5kZXJlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHQvLyBhbmQgbm93IHdlIGludm9rZSB0aGUga25vd24gY2FsbGJhY2tzIGFnYWluc3QgdGhpcyByb290XG5cdFx0XHRpbnZva2UodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBzdXBwbHkgb3VyIGRlc3Ryb3kgaG9va1xuXHRcdHZpZXcuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpZHggPSByb290cy5pbmRleE9mKHRoaXMpO1xuXHRcdFx0XG5cdFx0XHQvLyByZW1vdmUgaXQgZnJvbSB0aGUgcm9vdHMgYXJyYXlcblx0XHRcdGlmIChpZHggPiAtMSkgcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcblx0XHRcdC8vIG5vdyB3ZSBjYW4gY2FsbCB0aGUgb3JpZ2luYWxcblx0XHRcdGRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxfV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG5cbi8qKlxuKiBBIHBvbHlmaWxsIGZvciBwbGF0Zm9ybXMgdGhhdCBkb24ndCB5ZXQgc3VwcG9ydFxuKiBbYmluZCgpXXtAZ2xvc3NhcnkgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmR9LiBBcyBleHBsYWluZWQgaW4gdGhlIGxpbmtlZCBhcnRpY2xlLCB0aGlzXG4qIHBvbHlmaWxsIGhhbmRsZXMgdGhlIGdlbmVyYWwgdXNlIGNhc2UgYnV0IGNhbm5vdCBleGFjdGx5IG1pcnJvciB0aGUgRUNNQS0yNjIgdmVyc2lvbiA1XG4qIGltcGxlbWVudGF0aW9uIHNwZWNpZmljYXRpb24uIFRoaXMgaXMgYW4gYWRhcHRhdGlvbiBvZiB0aGUgZXhhbXBsZSBwcm9tb3RlZFxuKiBbaGVyZV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZH0uXG4qL1xuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuXHRGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjdHgpIHtcblx0XHQvLyBkZWxpYmVyYXRlbHkgdXNlZCBoZXJlLi4uXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuXHRcdFx0c2NvcCA9IHRoaXMsXG5cdFx0XHRub3AgPSBmdW5jdGlvbiAoKSB7fSxcblx0XHRcdHJldDtcblx0XHRcblx0XHQvLyBhcy1wZXIgTUROJ3MgZXhwbGFuYXRpb24gb2YgdGhpcyBwb2x5ZmlsbCB3ZSdyZSBmaWxsaW5nIGluIGZvciB0aGUgSXNDYWxsYWJsZVxuXHRcdC8vIGludGVybmFsICh3ZSBjYW4ndCBhY2Nlc3MgaXQpXG5cdFx0aWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBub24tY2FsbGFibGUgb2JqZWN0LicpO1xuXHRcdH1cblx0XHRcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbGFyZ3MgPSBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSxcblx0XHRcdFx0bGN0eCA9IHRoaXMgaW5zdGFuY2VvZiBub3AgJiYgY3R4ID8gdGhpcyA6IGN0eDtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHNjb3AuYXBwbHkobGN0eCwgbGFyZ3MpO1xuXHRcdH07XG5cdFx0XG5cdFx0bm9wLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuXHRcdFxuXHRcdC8qanNoaW50IC1XMDU1ICovXG5cdFx0cmV0LnByb3RvdHlwZSA9IG5ldyBub3AoKTtcblx0XHQvKmpzaGludCArVzA1NSAqL1xuXHRcdFxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmV4cG9ydHMubm9wID0gZnVuY3Rpb24gKCkge307XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmV4cG9ydHMubm9iID0ge307XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmV4cG9ydHMubmFyID0gW107XG5cbi8qKlxuKiBUaGlzIG5hbWUgaXMgcmVwb3J0ZWQgaW4gaW5zcGVjdG9ycyBhcyB0aGUgdHlwZSBvZiBvYmplY3RzIGNyZWF0ZWQgdmlhIGRlbGVnYXRlO1xuKiBvdGhlcndpc2UsIHdlIHdvdWxkIGp1c3QgdXNlIHtAbGluayBlbnlvLm5vcH0uXG4qXG4qIEBwcml2YXRlXG4qL1xudmFyIEluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBzZXRQcm90b3R5cGUgPSBleHBvcnRzLnNldFByb3RvdHlwZSA9IGZ1bmN0aW9uIChjdG9yLCBwcm90bykge1xuXHRjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xufTtcblxuLyoqXG4qIEJvb2RtYW4vY3JvY2tmb3JkIGRlbGVnYXRpb24gdy9jb3JuZm9yZCBvcHRpbWl6YXRpb25cbiogXG4qIEBwcml2YXRlXG4qL1xuZXhwb3J0cy5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIChwcm90bykge1xuXHRzZXRQcm90b3R5cGUoSW5zdGFuY2UsIHByb3RvKTtcblx0cmV0dXJuIG5ldyBJbnN0YW5jZSgpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2VuZXJhbCBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4qIERldGVybWluZXMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4qIFxuKiBAcGFyYW0geyp9IHRhcmdldCAtIEFueXRoaW5nIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHRvIGB1bmRlZmluZWRgLlxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGRlZmluZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuKiBAcHVibGljXG4qL1xudmFyIGV4aXN0cyA9IGV4cG9ydHMuZXhpc3RzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gKHRhcmdldCAhPT0gdW5kZWZpbmVkKTtcbn07XG5cbnZhciB1aWRDb3VudGVyID0gMDtcblxuLyoqXG4qIENyZWF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciAod2l0aCBhbiBvcHRpb25hbCBwcmVmaXgpIGFuZCByZXR1cm5zIHRoZSBpZGVudGlmaWVyIGFzIGEgc3RyaW5nLlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gLSBUaGUgcHJlZml4IHRvIHByZXBlbmQgdG8gdGhlIGdlbmVyYXRlZCB1bmlxdWUgaWQuXG4qIEByZXR1cm5zIHtTdHJpbmd9IEFuIG9wdGlvbmFsbHktcHJlZml4ZWQgaWRlbnRpZmllci5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMudWlkID0gZnVuY3Rpb24gKHByZWZpeCkge1xuXHRyZXR1cm4gU3RyaW5nKChwcmVmaXg/IHByZWZpeDogJycpICsgdWlkQ291bnRlcisrKTtcbn07XG5cbi8qKlxuKiBSRkM0MTIyIHV1aWQgZ2VuZXJhdG9yIGZvciB0aGUgYnJvd3Nlci5cbipcbiogQHJldHVybnMge1N0cmluZ30gQW4gW1JGQzQxMjJde0BnbG9zc2FyeSBVVUlEfS1jb21wbGlhbnQsIHVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy51dWlkID0gZnVuY3Rpb24gKCkge1xuXHQvLyBAVE9ETzogQ291bGQgcG9zc2libHkgYmUgZmFzdGVyXG5cdHZhciB0LCBwID0gKFxuXHRcdChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiw4KSkgKyAnLScgK1xuXHRcdCgodD1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiw4KSkuc3Vic3RyKDAsNCkpICsgJy0nICtcblx0XHQodC5zdWJzdHIoNCw0KSkgK1xuXHRcdCgodD1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiw4KSkuc3Vic3RyKDAsNCkpICsgJy0nICtcblx0XHQodC5zdWJzdHIoNCw0KSkgK1xuXHRcdChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiw4KSlcblx0KTtcblx0cmV0dXJuIHA7XG59O1xuXG4vKipcbiogR2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciB1c2luZyBbTWF0aC5yYW5kb21de0BnbG9zc2FyeSBNYXRoLnJhbmRvbX0uXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBib3VuZCAtIFRoZSBtdWx0aXBsaWVyIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHByb2R1Y3QuXG4qIEByZXR1cm5zIHtOdW1iZXJ9IEEgcmFuZG9tIG51bWJlci5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuaXJhbmQgPSBmdW5jdGlvbiAoYm91bmQpIHtcblx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJvdW5kKTtcbn07XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiB2YXJpYWJsZSBpcyBhIFtTdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9LlxuKlxuKiBAcGFyYW0geyp9IGl0IC0gVGhlIHZhcmlhYmxlIHRvIGJlIHRlc3RlZC5cbiogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB2YXJpYWJsZSBpcyBhIFtTdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9O1xuKiBvdGhlcndpc2UsIGBmYWxzZWAuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKGl0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG4vKipcbiogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gdmFyaWFibGUgaXMgYSBbRnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn0uXG4qIFxuKiBAcGFyYW0geyp9IGl0IC0gVGhlIHZhcmlhYmxlIHRvIGJlIHRlc3RlZC5cbiogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB2YXJpYWJsZSBpcyBhIFtGdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufTtcbiogb3RoZXJ3aXNlLCBgZmFsc2VgLlxuKiBAcHVibGljXG4qL1xudmFyIGlzRnVuY3Rpb24gPSBleHBvcnRzLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXQpIHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxuLyoqXG4qIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHZhcmlhYmxlIGlzIGFuIFtBcnJheV17QGdsb3NzYXJ5IEFycmF5fS5cbipcbiogQHBhcmFtIHsqfSBpdCAtIFRoZSB2YXJpYWJsZSB0byBiZSB0ZXN0ZWQuXG4qIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdmFyaWFibGUgaXMgYW4gW0FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9O1xuKiBvdGhlcndpc2UsIGBmYWxzZWAuXG4qIEBtZXRob2RcbiogQHB1YmxpY1xuKi9cbnZhciBpc0FycmF5ID0gZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoaXQpIHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4qIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIHZhcmlhYmxlIGlzIGFuIFtPYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LlxuKlxuKiBAcGFyYW0geyp9IGl0IC0gVGhlIHZhcmlhYmxlIHRvIGJlIHRlc3RlZC5cbiogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB2YXJpYWJsZSBpcyBhbiBbT2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fTtcbiogb3RoZXJ3aXNlLCBgZmFsc2VgLlxuKiBAbWV0aG9kXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmlzT2JqZWN0ID0gT2JqZWN0LmlzT2JqZWN0IHx8IGZ1bmN0aW9uIChpdCkge1xuXHQvLyBleHBsaWNpdCBudWxsL3VuZGVmaW5lZCBjaGVjayBmb3IgSUU4IGNvbXBhdGliaWxpdHlcblx0cmV0dXJuIChpdCAhPSBudWxsKSAmJiAodG9TdHJpbmcuY2FsbChpdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKTtcbn07XG5cbi8qKlxuKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBleHBsaWNpdCBib29sZWFuIGB0cnVlYC5cbipcbiogQHBhcmFtIHsqfSBpdCAtIFRoZSB2YXJpYWJsZSB0byBiZSB0ZXN0ZWQuXG4qIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdmFyaWFibGUgaXMgYW4gZXhwbGljaXQgYHRydWVgOyBvdGhlcndpc2UsXG4qIGBmYWxzZWAuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmlzVHJ1ZSA9IGZ1bmN0aW9uIChpdCkge1xuXHRyZXR1cm4gIShpdCA9PT0gJ2ZhbHNlJyB8fCBpdCA9PT0gZmFsc2UgfHwgaXQgPT09IDAgfHwgaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZCk7XG59O1xuXG4vKipcbiogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1lcmljIHZhbHVlLlxuKlxuKiBAcGFyYW0geyp9IGl0IC0gVGhlIHZhcmlhYmxlIHRvIGJlIHRlc3RlZC5cbiogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB2YXJpYWJsZSBpcyBhIG51bWVyaWMgdmFsdWU7IG90aGVyd2lzZSxcbiogYGZhbHNlYC5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuaXNOdW1lcmljID0gZnVuY3Rpb24gKGl0KSB7XG5cdC8vIGJvcnJvd2VkIGZyb20galF1ZXJ5XG5cdHJldHVybiAhaXNBcnJheShpdCkgJiYgKGl0IC0gcGFyc2VGbG9hdChpdCkgKyAxKSA+PSAwO1xufTtcblxuLyoqXG4qIEJpbmRzIHRoZSBgdGhpc2AgY29udGV4dCBvZiBhbnkgbWV0aG9kIHRvIGEgc2NvcGUgYW5kIGEgdmFyaWFibGUgbnVtYmVyIG9mIHByb3ZpZGVkIGluaXRpYWxcbiogcGFyYW1ldGVycy5cbipcbiogQHBhcmFtIHtPYmplY3R9IHNjb3BlIC0gVGhlIGB0aGlzYCBjb250ZXh0IGZvciB0aGUgbWV0aG9kLlxuKiBAcGFyYW0geyhGdW5jdGlvbnxTdHJpbmcpfSBtZXRob2QgLSBBIEZ1bmN0aW9uIG9yIHRoZSBuYW1lIG9mIGEgbWV0aG9kIHRvIGJpbmQuXG4qIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIEFueSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHByb3ZpZGVkIGFzIHRoZSBpbml0aWFsIGFyZ3VtZW50cyB0byB0aGVcbiogICAgICAgICAgICAgICAgICAgICAgZW5jbG9zZWQgbWV0aG9kLlxuKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QvY2xvc3VyZS5cbiogQHB1YmxpY1xuKi9cbnZhciBiaW5kID0gZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24gKHNjb3BlLCBtZXRob2QpIHtcblx0aWYgKCFtZXRob2QpIHtcblx0XHRtZXRob2QgPSBzY29wZTtcblx0XHRzY29wZSA9IG51bGw7XG5cdH1cblx0c2NvcGUgPSBzY29wZSB8fCBnbG9iYWw7XG5cdGlmICh0eXBlb2YgbWV0aG9kID09ICdzdHJpbmcnKSB7XG5cdFx0aWYgKHNjb3BlW21ldGhvZF0pIHtcblx0XHRcdG1ldGhvZCA9IHNjb3BlW21ldGhvZF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93KCdlbnlvLmJpbmQ6IHNjb3BlW1wiJyArIG1ldGhvZCArICdcIl0gaXMgbnVsbCAoc2NvcGU9XCInICsgc2NvcGUgKyAnXCIpJyk7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgbWV0aG9kID09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgYXJncyA9IGNsb25lQXJyYXkoYXJndW1lbnRzLCAyKTtcblx0XHRpZiAobWV0aG9kLmJpbmQpIHtcblx0XHRcdHJldHVybiBtZXRob2QuYmluZC5hcHBseShtZXRob2QsIFtzY29wZV0uY29uY2F0KGFyZ3MpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbmFyZ3MgPSBjbG9uZUFycmF5KGFyZ3VtZW50cyk7XG5cdFx0XHRcdC8vIGludm9rZSB3aXRoIGNvbGxlY3RlZCBhcmdzXG5cdFx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIGFyZ3MuY29uY2F0KG5hcmdzKSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aHJvdygnZW55by5iaW5kOiBzY29wZVtcIicgKyBtZXRob2QgKyAnXCJdIGlzIG5vdCBhIGZ1bmN0aW9uIChzY29wZT1cIicgKyBzY29wZSArICdcIiknKTtcblx0fVxufTtcblxuLyoqXG4qIEJpbmRzIGEgY2FsbGJhY2sgdG8gYSBzY29wZS4gSWYgdGhlIG9iamVjdCBoYXMgYSBgZGVzdHJveWVkYCBwcm9wZXJ0eSB0aGF0J3MgdHJ1dGh5LCB0aGVuIHRoZVxuKiBjYWxsYmFjayB3aWxsIG5vdCBiZSBydW4gaWYgY2FsbGVkLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBib3RoXG4qIHtAbGluayBlbnlvLk9iamVjdC5iaW5kU2FmZWx5fSBhbmQge0BsaW5rIGVueW8uT2JqZWN0fS1saWtlIG9iamVjdHMgbGlrZVxuKiB7QGxpbmsgZW55by5Nb2RlbH0gYW5kIHtAbGluayBlbnlvLkNvbGxlY3Rpb259LlxuKlxuKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgLSBUaGUgYHRoaXNgIGNvbnRleHQgZm9yIHRoZSBtZXRob2QuXG4qIEBwYXJhbSB7KEZ1bmN0aW9ufFN0cmluZyl9IG1ldGhvZCAtIEEgRnVuY3Rpb24gb3IgdGhlIG5hbWUgb2YgYSBtZXRob2QgdG8gYmluZC5cbiogQHBhcmFtIHsuLi4qfSBbYXJnc10gQW55IGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcHJvdmlkZWQgYXMgdGhlIGluaXRpYWwgYXJndW1lbnRzIHRvIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICBlbmNsb3NlZCBtZXRob2QuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC9jbG9zdXJlLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5iaW5kU2FmZWx5ID0gZnVuY3Rpb24gKHNjb3BlLCBtZXRob2QpIHtcblx0aWYgKHR5cGVvZiBtZXRob2QgPT0gJ3N0cmluZycpIHtcblx0XHRpZiAoc2NvcGVbbWV0aG9kXSkge1xuXHRcdFx0bWV0aG9kID0gc2NvcGVbbWV0aG9kXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3coJ2VueW8uYmluZFNhZmVseTogc2NvcGVbXCInICsgbWV0aG9kICsgJ1wiXSBpcyBudWxsICh0aGlzPVwiJyArIHRoaXMgKyAnXCIpJyk7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2YgbWV0aG9kID09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgYXJncyA9IGNsb25lQXJyYXkoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoc2NvcGUuZGVzdHJveWVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBuYXJncyA9IGNsb25lQXJyYXkoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIGFyZ3MuY29uY2F0KG5hcmdzKSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdygnZW55by5iaW5kU2FmZWx5OiBzY29wZVtcIicgKyBtZXRob2QgKyAnXCJdIGlzIG5vdCBhIGZ1bmN0aW9uICh0aGlzPVwiJyArIHRoaXMgKyAnXCIpJyk7XG5cdH1cbn07XG5cbi8qKlxuKiBDYWxscyB0aGUgcHJvdmlkZWQgYG1ldGhvZGAgb24gYHNjb3BlYCwgYXN5bmNocm9ub3VzbHkuXG4qXG4qIFVzZXMgW3dpbmRvdy5zZXRUaW1lb3V0KClde0BnbG9zc2FyeSB3aW5kb3cuc2V0VGltZW91dH0gd2l0aCBtaW5pbXVtIGRlbGF5LFxuKiB1c3VhbGx5IGFyb3VuZCAxMG1zLlxuKlxuKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIGBtZXRob2RgIHdoZW4gaXQgaXMgaW52b2tlZC5cbipcbiogSWYgb25seSBhIHNpbmdsZSBhcmd1bWVudCBpcyBzdXBwbGllZCwgd2lsbCBqdXN0IGNhbGwgdGhhdCBmdW5jdGlvbiBhc3luY2hyb25vdXNseSB3aXRob3V0XG4qIGRvaW5nIGFueSBhZGRpdGlvbmFsIGJpbmRpbmcuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBzY29wZSAtIFRoZSBgdGhpc2AgY29udGV4dCBmb3IgdGhlIG1ldGhvZC5cbiogQHBhcmFtIHsoRnVuY3Rpb258U3RyaW5nKX0gbWV0aG9kIC0gQSBGdW5jdGlvbiBvciB0aGUgbmFtZSBvZiBhIG1ldGhvZCB0byBiaW5kLlxuKiBAcGFyYW0gey4uLip9IFthcmdzXSBBbnkgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwcm92aWRlZCBhcyB0aGUgaW5pdGlhbCBhcmd1bWVudHMgdG8gdGhlXG4qICAgICAgICAgICAgICAgICAgICAgIGVuY2xvc2VkIG1ldGhvZC5cbiogQHJldHVybnMge051bWJlcn0gVGhlIGBzZXRUaW1lb3V0YCBpZC5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuYXN5bmNNZXRob2QgPSBmdW5jdGlvbiAoc2NvcGUsIG1ldGhvZCkge1xuXHRpZiAoIW1ldGhvZCkge1xuXHRcdC8vIHBhc3NlZCBqdXN0IGEgc2luZ2xlIGFyZ3VtZW50XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoc2NvcGUsIDEpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KGJpbmQuYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyksIDEpO1xuXHR9XG59O1xuXG4vKipcbiogQ2FsbHMgdGhlIHByb3ZpZGVkIGBtZXRob2RgIChbU3RyaW5nXXtAZ2xvc3NhcnkgU3RyaW5nfSkgb24gYHNjb3BlYCB3aXRoIG9wdGlvbmFsXG4qIGFyZ3VtZW50cyBgYXJnc2AgKFtBcnJheV17QGdsb3NzYXJ5IEFycmF5fSksIGlmIHRoZSBvYmplY3QgYW5kIG1ldGhvZCBleGlzdC5cbipcbiogQGV4YW1wbGVcbiogXHRlbnlvLmNhbGwobXlXb3JrT2JqZWN0LCAnZG9Xb3JrJywgWzMsICdmb28nXSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBzY29wZSAtIFRoZSBgdGhpc2AgY29udGV4dCBmb3IgdGhlIG1ldGhvZC5cbiogQHBhcmFtIHsoRnVuY3Rpb258U3RyaW5nKX0gbWV0aG9kIC0gQSBGdW5jdGlvbiBvciB0aGUgbmFtZSBvZiBhIG1ldGhvZCB0byBiaW5kLlxuKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuKiBAcmV0dXJucyB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWV0aG9kLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5jYWxsID0gZnVuY3Rpb24gKHNjb3BlLCBtZXRob2QsIGFyZ3MpIHtcblx0dmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xuXHRpZiAobWV0aG9kKSB7XG5cdFx0dmFyIGZuID0gY29udGV4dFttZXRob2RdIHx8IG1ldGhvZDtcblx0XHRpZiAoZm4gJiYgZm4uYXBwbHkpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLiBPbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IGl0LFxuKiBbRGF0ZS5ub3coKV17QGdsb3NzYXJ5IERhdGUubm93fSB3aWxsIGJlIHVzZWQ7IG90aGVyd2lzZSB0aGlzIHdpbGxcbiogYmUgZXF1aXZhbGVudCB0byBbbmV3IERhdGUoKS5nZXRUaW1lKClde0BnbG9zc2FyeSBEYXRlLmdldFRpbWV9LlxuKiBcbiogQHJldHVybnMge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiogQG1ldGhvZFxuKiBAcHVibGljXG4qL1xuXG52YXIgbm93ID0gZXhwb3J0cy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5cbi8qKlxuKiBXaGVuIFt3aW5kb3cucGVyZm9ybWFuY2Vde0BnbG9zc2FyeSB3aW5kb3cucGVyZm9ybWFuY2V9IGlzIGF2YWlsYWJsZSwgc3VwcGxpZXNcbiogYSBoaWdoLXByZWNpc2lvbiwgaGlnaC1wZXJmb3JtYW5jZSBtb25vdG9uaWMgdGltZXN0YW1wLCB3aGljaCBpcyBpbmRlcGVuZGVudCBvZlxuKiBjaGFuZ2VzIHRvIHRoZSBzeXN0ZW0gY2xvY2sgYW5kIHRodXMgc2FmZXIgZm9yIHVzZSBpbiBhbmltYXRpb24sIGV0Yy4gRmFsbHMgYmFjayB0b1xuKiBbZW55by5ub3coKV17QGxpbmsgZW55byNub3d9IChiYXNlZCBvbiB0aGUgSmF2YVNjcmlwdCBbRGF0ZV17QGdsb3NzYXJ5IERhdGV9XG4qIG9iamVjdCksIHdoaWNoIGlzIHN1YmplY3QgdG8gc3lzdGVtIHRpbWUgY2hhbmdlcy5cbiogXG4qIEByZXR1cm5zIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHRpbWUgb3IgdGltZSBzaW5jZVxuKiAgICAgICAgICAgICAgICAgICBzdGFydCBvZiBhcHBsaWNhdGlvbiBleGVjdXRpb24gYXMgcmVwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLlxuKiBAbWV0aG9kXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLnBlcmZOb3cgPSAoZnVuY3Rpb24gKCkge1xuXHQvLyB3ZSBoYXZlIHRvIGNoZWNrIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGhhcyBzdXBwbGllZCBhIHZhbGlkXG5cdC8vIG1ldGhvZCB0byB1c2Vcblx0dmFyIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge307XG5cdC8vIHRlc3QgYWdhaW5zdCBhbGwga25vd24gdmVuZG9yLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucywgYnV0IHVzZVxuXHQvLyBhIGZhbGxiYWNrIGp1c3QgaW4gY2FzZVxuXHRwZXJmLm5vdyA9IHBlcmYubm93IHx8IHBlcmYubW96Tm93IHx8IHBlcmYubXNOb3cgfHwgcGVyZi5vTm93IHx8IHBlcmYud2Via2l0Tm93IHx8IG5vdztcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gcGVyZi5ub3coKTtcblx0fTtcbn0oKSk7XG5cbi8qKlxuKiBBIGZhc3QtcGF0aCBlbmFibGVkIGdsb2JhbCBnZXR0ZXIgdGhhdCB0YWtlcyBhIHN0cmluZyBwYXRoLCB3aGljaCBtYXkgYmUgYSBmdWxsIHBhdGggKGZyb21cbiogY29udGV4dCB3aW5kb3cvRW55bykgb3IgYSByZWxhdGl2ZSBwYXRoICh0byB0aGUgZXhlY3V0aW9uIGNvbnRleHQgb2YgdGhlIG1ldGhvZCkuIEl0IGtub3dzIGhvd1xuKiB0byBjaGVjayBmb3IgYW5kIGNhbGwgdGhlIGJhY2t3YXJkcy1jb21wYXRpYmxlIGdlbmVyYXRlZCBnZXR0ZXJzLCBhcyB3ZWxsIGFzIGhvdyB0byBoYW5kbGVcbiogY29tcHV0ZWQgcHJvcGVydGllcy4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgb2JqZWN0IGF0IHRoZSBnaXZlbiBwYXRoIGNhbm5vdCBiZSBmb3VuZC4gTWF5XG4qIHNhZmVseSBiZSBjYWxsZWQgb24gbm9uLWV4aXN0ZW50IHBhdGhzLlxuKlx0XG4qIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggZnJvbSB3aGljaCB0byByZXRyaWV2ZSBhIHZhbHVlLlxuKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHBhdGggY291bGQgbm90IGJlXG4qICAgICAgICAgICAgICAgICAgY29tcGxldGVseSByZXNvbHZlZC5cbiogQG1ldGhvZCBlbnlvLmdldFBhdGhcbiogQHB1YmxpY1xuKi9cbnZhciBnZXRQYXRoID0gZXhwb3J0cy5nZXRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0Ly8gd2UncmUgdHJ5aW5nIHRvIGNhdGNoIG9ubHkgbnVsbC91bmRlZmluZWQgbm90IGVtcHR5IHN0cmluZyBvciAwIGNhc2VzXG5cdGlmICghcGF0aCAmJiBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHVuZGVmaW5lZCkgcmV0dXJuIHBhdGg7XG5cdFxuXHR2YXIgbmV4dCA9IHRoaXMsXG5cdFx0cGFydHMsXG5cdFx0cGFydCxcblx0XHRnZXR0ZXIsXG5cdFx0cHJldjtcblx0XG5cdC8vIG9idmlvdXNseSB0aGVyZSBpcyBhIHNldmVyZSBwZW5hbHR5IGZvciByZXF1ZXN0aW5nIGdldCB3aXRoIGEgcGF0aCBsZWFkXG5cdC8vIGJ5IHVubmVjZXNzYXJ5IHJlbGF0aXZlIG5vdGF0aW9uLi4uXG5cdGlmIChwYXRoWzBdID09ICcuJykgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLisvLCAnJyk7XG5cdFxuXHQvLyBoZXJlJ3Mgd2hlcmUgd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGhhdmUgYSB0cnV0aHkgc3RyaW5nLWlzaFxuXHRpZiAoIXBhdGgpIHJldHVybjtcblx0XG5cdHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuXHRwYXJ0ID0gcGFydHMuc2hpZnQoKTtcblx0XG5cdGRvIHtcblx0XHRwcmV2ID0gbmV4dDtcblx0XHQvLyBmb3IgY29uc3RydWN0b3JzIHdlIG11c3QgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHVuZGVmZXJyZWQgYmVmb3JlXG5cdFx0Ly8gbG9va2luZyBmb3Igc3RhdGljIHByb3BlcnRpZXNcblx0XHQvLyBmb3IgdGhlIGF1dG8gZ2VuZXJhdGVkIG9yIHByb3ZpZGVkIHB1Ymxpc2hlZCBwcm9wZXJ0eSBzdXBwb3J0IHdlIGhhdmUgc2VwYXJhdGVcblx0XHQvLyByb3V0aW5lcyB0aGF0IG11c3QgYmUgY2FsbGVkIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHlcblx0XHRpZiAobmV4dC5fZ2V0dGVycyAmJiAoKGdldHRlciA9IG5leHQuX2dldHRlcnNbcGFydF0pKSAmJiAhZ2V0dGVyLmdlbmVyYXRlZCkgbmV4dCA9IG5leHRbZ2V0dGVyXSgpO1xuXHRcdC8vIGZvciBhbGwgb3RoZXIgc3BlY2lhbCBjYXNlcyB0byBlbnN1cmUgd2UgdXNlIGFueSBvdmVybG9hZGVkIGdldHRlciBtZXRob2RzXG5cdFx0ZWxzZSBpZiAobmV4dC5nZXQgJiYgbmV4dCAhPT0gdGhpcyAmJiBuZXh0LmdldCAhPT0gZ2V0UGF0aCkgbmV4dCA9IG5leHQuZ2V0KHBhcnQpO1xuXHRcdC8vIGFuZCBmb3IgcmVndWxhciBjYXNlc1xuXHRcdGVsc2UgbmV4dCA9IG5leHRbcGFydF07XG5cdH0gd2hpbGUgKG5leHQgJiYgKHBhcnQgPSBwYXJ0cy5zaGlmdCgpKSk7XG5cdFx0XHRcblx0Ly8gaWYgbmVjZXNzYXJ5IHdlIGVuc3VyZSB3ZSd2ZSB1bmRlZmVycmVkIGFueSBjb25zdHJ1Y3RvciB0aGF0IHdlJ3JlXG5cdC8vIHJldHJpZXZpbmcgaGVyZSBhcyBhIGZpbmFsIHByb3BlcnR5IGFzIHdlbGxcblx0cmV0dXJuIG5leHQ7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5nZXRQYXRoLmZhc3QgPSBmdW5jdGlvbiAocGF0aCkge1xuXHQvLyB0aGUgY3VycmVudCBjb250ZXh0XG5cdHZhciBiID0gdGhpcywgZm4sIHY7XG5cdGlmIChiLl9nZXR0ZXJzICYmIChmbiA9IGIuX2dldHRlcnNbcGF0aF0pKSB7XG5cdFx0diA9IGJbZm5dKCk7XG5cdH0gZWxzZSB7XG5cdFx0diA9IGJbcGF0aF07XG5cdH1cblx0XG5cdHJldHVybiB2O1xufTtcblxuLyoqXG4qIEBUT0RPOiBPdXQgb2YgZGF0ZS4uLlxuKiBBIGdsb2JhbCBzZXR0ZXIgdGhhdCB0YWtlcyBhIHN0cmluZyBwYXRoIChyZWxhdGl2ZSB0byB0aGUgbWV0aG9kJ3MgZXhlY3V0aW9uIGNvbnRleHQpIG9yIGFcbiogZnVsbCBwYXRoIChyZWxhdGl2ZSB0byB3aW5kb3cpLiBBdHRlbXB0cyB0byBhdXRvbWF0aWNhbGx5IHJldHJpZXZlIGFueSBwcmV2aW91c2x5IGV4aXN0aW5nXG4qIHZhbHVlIHRvIHN1cHBseSB0byBhbnkgb2JzZXJ2ZXJzLiBJZiB0aGUgY29udGV4dCBpcyBhbiB7QGxpbmsgZW55by5PYmplY3R9IG9yIHN1YmtpbmQsIHRoZVxuKiB7QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnQubm90aWZ5fSBtZXRob2QgaXMgdXNlZCB0byBub3RpZnkgbGlzdGVuZXJzIGZvciB0aGUgcGF0aCdzIGJlaW5nXG4qIHNldC4gSWYgdGhlIHByZXZpb3VzIHZhbHVlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIG5ld2x5IHNldCB2YWx1ZSwgb2JzZXJ2ZXJzIHdpbGwgbm90IGJlXG4qIHRyaWdnZXJlZCBieSBkZWZhdWx0LiBJZiB0aGUgdGhpcmQgcGFyYW1ldGVyIGlzIHByZXNlbnQgYW5kIGlzIGFuIGV4cGxpY2l0IGJvb2xlYW4gdHJ1ZSwgdGhlXG4qIG9ic2VydmVycyB3aWxsIGJlIHRyaWdnZXJlZCByZWdhcmRsZXNzLiBSZXR1cm5zIHRoZSBjb250ZXh0IGZyb20gd2hpY2ggdGhlIG1ldGhvZCB3YXMgZXhlY3V0ZWQuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggZm9yIHdoaWNoIHRvIHNldCB0aGUgZ2l2ZW4gdmFsdWUuXG4qIEBwYXJhbSB7Kn0gaXMgLSBUaGUgdmFsdWUgdG8gc2V0LlxuKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gQW4gb3B0aW9ucyBoYXNoLlxuKiBAcmV0dXJucyB7dGhpc30gV2hhdGV2ZXIgdGhlIGdpdmVuIGNvbnRleHQgd2FzIHdoZW4gZXhlY3V0ZWQuXG4qIEBtZXRob2QgZW55by5zZXRQYXRoXG4qIEBwdWJsaWNcbiovXG52YXIgc2V0UGF0aCA9IGV4cG9ydHMuc2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBpcywgb3B0cykge1xuXHQvLyB3ZSdyZSB0cnlpbmcgdG8gY2F0Y2ggb25seSBudWxsL3VuZGVmaW5lZCBub3QgZW1wdHkgc3RyaW5nIG9yIDAgY2FzZXNcblx0aWYgKCFwYXRoIHx8ICghcGF0aCAmJiBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHVuZGVmaW5lZCkpIHJldHVybiB0aGlzO1xuXHRcblx0dmFyIG5leHQgPSB0aGlzLFxuXHRcdG9wdGlvbnMgPSB7Y3JlYXRlOiB0cnVlLCBzaWxlbnQ6IGZhbHNlLCBmb3JjZTogZmFsc2V9LFxuXHRcdGJhc2UgPSBuZXh0LFxuXHRcdHBhcnRzLFxuXHRcdHBhcnQsXG5cdFx0d2FzLFxuXHRcdGZvcmNlLFxuXHRcdGNyZWF0ZSxcblx0XHRzaWxlbnQsXG5cdFx0Y29tcGFyYXRvcjtcblx0XG5cdGlmICh0eXBlb2Ygb3B0cyA9PSAnb2JqZWN0Jykgb3B0cyA9IG1peGluKHt9LCBbb3B0aW9ucywgb3B0c10pO1xuXHRlbHNlIHtcblx0XHRmb3JjZSA9IG9wdHM7XG5cdFx0b3B0cyA9IG9wdGlvbnM7XG5cdH1cblx0XG5cdGlmIChvcHRzLmZvcmNlKSBmb3JjZSA9IHRydWU7XG5cdHNpbGVudCA9IG9wdHMuc2lsZW50O1xuXHRjcmVhdGUgPSBvcHRzLmNyZWF0ZTtcblx0Y29tcGFyYXRvciA9IG9wdHMuY29tcGFyYXRvcjtcblx0XG5cdFxuXHQvLyBvYnZpb3VzbHkgdGhlcmUgaXMgYSBzZXZlcmUgcGVuYWx0eSBmb3IgcmVxdWVzdGluZyBnZXQgd2l0aCBhIHBhdGggbGVhZFxuXHQvLyBieSB1bm5lY2Vzc2FyeSByZWxhdGl2ZSBub3RhdGlvbi4uLlxuXHRpZiAocGF0aFswXSA9PSAnLicpIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC4rLywgJycpO1xuXHRcblx0Ly8gaGVyZSdzIHdoZXJlIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgdHJ1dGh5IHN0cmluZy1pc2hcblx0aWYgKCFwYXRoKSByZXR1cm4gbmV4dDtcblx0XG5cdHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuXHRwYXJ0ID0gcGFydHMuc2hpZnQoKTtcblx0XG5cdGRvIHtcblx0XHRcblx0XHRpZiAoIXBhcnRzLmxlbmd0aCkgd2FzID0gbmV4dC5nZXQgJiYgbmV4dC5nZXQgIT09IGdldFBhdGg/IG5leHQuZ2V0KHBhcnQpOiBuZXh0W3BhcnRdO1xuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gdGhpcyBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgaWYgd2UncmUgc2V0dGluZyBhIHN0YXRpYyBwcm9wZXJ0eSBvZiBhIGNvbnN0cnVjdG9yIHdlIGhhdmUgdGhlXG5cdFx0XHQvLyBjb3JyZWN0IGNvbnN0cnVjdG9yXG5cdFx0XHQvLyBAVE9ETzogSXQgc2VlbXMgbHVkaWNyb3VzIHRvIGhhdmUgdG8gY2hlY2sgdGhpcyBvbiBldmVyeSBzaW5nbGUgcGFydCBvZiBhIGNoYWluOyBpZiB3ZSBkaWRuJ3QgaGF2ZVxuXHRcdFx0Ly8gZGVmZXJyZWQgY29uc3RydWN0b3JzIHRoaXMgd291bGRuJ3QgYmUgbmVjZXNzYXJ5IGFuZCBpcyBleHBlbnNpdmUgLSB1bm5lY2Vzc2FyaWx5IHNvIHdoZW4gc3BlZWQgaXMgc28gaW1wb3J0YW50XG5cdFx0XHRpZiAobmV4dCAhPT0gYmFzZSAmJiBuZXh0LnNldCAmJiBuZXh0LnNldCAhPT0gc2V0UGF0aCkge1xuXHRcdFx0XHRwYXJ0cy51bnNoaWZ0KHBhcnQpO1xuXHRcdFx0XHRuZXh0LnNldChwYXJ0cy5qb2luKCcuJyksIGlzLCBvcHRzKTtcblx0XHRcdFx0cmV0dXJuIGJhc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV4dCAhPT0gYmFzZSAmJiBuZXh0LmdldCkgbmV4dCA9IChuZXh0LmdldCAhPT0gZ2V0UGF0aD8gbmV4dC5nZXQocGFydCk6IG5leHRbcGFydF0pIHx8IChjcmVhdGUgJiYgKG5leHRbcGFydF0gPSB7fSkpO1xuXHRcdFx0ZWxzZSBuZXh0ID0gbmV4dFtwYXJ0XSB8fCAoY3JlYXRlICYmIChuZXh0W3BhcnRdID0ge30pKTtcblx0XHR9XG5cdFx0XG5cdH0gd2hpbGUgKG5leHQgJiYgcGFydHMubGVuZ3RoICYmIChwYXJ0ID0gcGFydHMuc2hpZnQoKSkpO1xuXHRcblx0aWYgKCFuZXh0KSByZXR1cm4gYmFzZTtcblx0XG5cdC8vIG5vdyB1cGRhdGUgdG8gdGhlIG5ldyB2YWx1ZVxuXHRpZiAobmV4dCAhPT0gYmFzZSAmJiBuZXh0LnNldCAmJiBuZXh0LnNldCAhPT0gc2V0UGF0aCkge1xuXHRcdG5leHQuc2V0KHBhcnQsIGlzLCBvcHRzKTtcblx0XHRyZXR1cm4gYmFzZTtcblx0fSBlbHNlIG5leHRbcGFydF0gPSBpcztcblx0XG5cdC8vIGlmIHBvc3NpYmxlIHdlIG5vdGlmeSB0aGUgY2hhbmdlcyBidXQgdGhpcyBjaGFuZ2UgaXMgbm90aWZpZWQgZnJvbSB0aGUgaW1tZWRpYXRlXG5cdC8vIHBhcmVudCBub3QgdGhlIHJvb3Qgb2JqZWN0IChjb3VsZCBiZSB0aGUgc2FtZSlcblx0aWYgKG5leHQubm90aWZ5ICYmICFzaWxlbnQgJiYgKGZvcmNlIHx8IHdhcyAhPT0gaXMgfHwgKGNvbXBhcmF0b3IgJiYgY29tcGFyYXRvcih3YXMsIGlzKSkpKSBuZXh0Lm5vdGlmeShwYXJ0LCB3YXMsIGlzLCBvcHRzKTtcblx0Ly8gd2Ugd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBvcmlnaW5hbCByb290LW9iamVjdCBvZiB0aGUgY2FsbFxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbnNldFBhdGguZmFzdCA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xuXHQvLyB0aGUgY3VycmVudCBjb250ZXh0XG5cdHZhciBiID0gdGhpcyxcblx0XHQvLyB0aGUgcHJldmlvdXMgdmFsdWUgYW5kIGhlbHBlciB2YXJpYWJsZVxuXHRcdHJ2LCBmbjtcblx0Ly8gd2UgaGF2ZSB0byBjaGVjayBhbmQgZW5zdXJlIHRoYXQgd2UncmUgbm90IHNldHRpbmcgYSBjb21wdXRlZCBwcm9wZXJ0eVxuXHQvLyBhbmQgaWYgd2UgYXJlLCBkbyBub3RoaW5nXG5cdGlmIChiLl9jb21wdXRlZCAmJiBiLl9jb21wdXRlZFtwYXRoXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKGIuX2dldHRlcnMgJiYgKGZuPWIuX2dldHRlcnNbcGF0aF0pKSB7XG5cdFx0cnYgPSBiW2ZuXSgpO1xuXHR9IGVsc2Uge1xuXHRcdHJ2ID0gYltwYXRoXTtcblx0fVxuXHQvLyBzZXQgdGhlIG5ldyB2YWx1ZSBub3cgdGhhdCB3ZSBjYW5cblx0YltwYXRoXSA9IHZhbHVlO1xuXHRcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSBldmVyIGNhbGxlZCBmcm9tIHRoZSBjb250ZXh0IG9mIGVueW8gb2JqZWN0c1xuXHQvLyBhcyBhIHByb3RlY3RlZCBtZXRob2Rcblx0aWYgKHJ2ICE9PSB2YWx1ZSkgeyBiLm5vdGlmeU9ic2VydmVycyhwYXRoLCBydiwgdmFsdWUpOyB9XG5cdC8vIHJldHVybiB0aGUgY29udGV4dFxuXHRyZXR1cm4gYjtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0cmluZyBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4qIFVwcGVyY2FzZXMgYSBnaXZlbiBzdHJpbmcuIFdpbGwgY29lcmNlIHRvIGEgW1N0cmluZ117QGdsb3NzYXJ5IFN0cmluZ31cbiogaWYgcG9zc2libGUvbmVjZXNzYXJ5LlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byB1cHBlcmNhc2UuXG4qIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB1cHBlcmNhc2VkIHN0cmluZy5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMudG9VcHBlckNhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmIChzdHIgIT0gbnVsbCkge1xuXHRcdHJldHVybiBzdHIudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuXHR9XG5cdHJldHVybiBzdHI7XG59O1xuXG4vKipcbiogTG93ZXJjYXNlcyBhIGdpdmVuIHN0cmluZy4gV2lsbCBjb2VyY2UgdG8gYSBbU3RyaW5nXXtAZ2xvc3NhcnkgU3RyaW5nfVxuKiBpZiBwb3NzaWJsZS9uZWNlc3NhcnkuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGxvd2VyY2FzZS5cbiogQHJldHVybnMge1N0cmluZ30gVGhlIGxvd2VyY2FzZWQgc3RyaW5nLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy50b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHN0ciAhPSBudWxsKSB7XG5cdFx0cmV0dXJuIHN0ci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuKiBDYXBpdGFsaXplcyBhIGdpdmVuIHN0cmluZy5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiogQHJldHVybnMge1N0cmluZ30gVGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuY2FwID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG4vKipcbiogVW4tY2FwaXRhbGl6ZXMgYSBnaXZlbiBzdHJpbmcuXG4qIFxuKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byB1bi1jYXBpdGFsaXplLlxuKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdW4tY2FwaXRhbGl6ZWQgc3RyaW5nLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy51bmNhcCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zbGljZSgwLCAxKS50b0xvd2VyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxuLyoqXG4qIEluamVjdHMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiB2YWx1ZXMsIGluIG9yZGVyLCBpbnRvIGEgdGVtcGxhdGUgc3RyaW5nIGF0XG4qIHBvc2l0aW9ucyBtYXJrZWQgYnkgYFwiJS5cImAuXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSBzdHJpbmcgdGVtcGxhdGUgdG8gaW5qZWN0IHdpdGggdmFsdWVzLlxuKiBAcGFyYW0gey4uLlN0cmluZ30gdmFsIFRoZSB2YWx1ZXMgdG8gaW5qZWN0IGludG8gdGhlIHRlbXBsYXRlLlxuKiBAcmV0dXJucyB7U3RyaW5nfSBBIGNvcHkgb2YgdGhlIHRlbXBsYXRlIHBvcHVsYXRlZCB3aXRoIHZhbHVlcy5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG5cdHZhciBwYXR0ZXJuID0gL1xcJS4vZyxcblx0XHRhcmcgPSAwLFxuXHRcdHRtcCA9IHRlbXBsYXRlLFxuXHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0cmVwbGFjZXI7XG5cdFxuXHRyZXBsYWNlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXJnc1srK2FyZ107XG5cdH07XG5cdFxuXHRyZXR1cm4gdG1wLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuU3RyaW5nLnByb3RvdHlwZS50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltIHx8IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufTtcblxuLyoqXG4qIFRha2VzIGEgc3RyaW5nIGFuZCB0cmltcyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMuIFN0cmluZ3Mgd2l0aCBubyBsZW5ndGgsXG4qIG5vbi1zdHJpbmdzLCBhbmQgZmFsc3kgdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIGZyb20gd2hpY2ggdG8gcmVtb3ZlIHdoaXRlc3BhY2UuXG4qIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMudHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuICh0eXBlb2Ygc3RyID09ICdzdHJpbmcnICYmIHN0ci50cmltKCkpIHx8IHN0cjtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4qIEEgW3BvbHlmaWxsXXtAZ2xvc3NhcnkgcG9seWZpbGx9IGZvciBwbGF0Zm9ybXMgdGhhdCBkb24ndCBzdXBwb3J0XG4qIFtPYmplY3QuY3JlYXRlKClde0BnbG9zc2FyeSBPYmplY3QuY3JlYXRlfS5cbiovXG5PYmplY3QuY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHR2YXIgQW5vbiA9IGZ1bmN0aW9uICgpIHt9O1xuXHRyZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHRcdC8vIGluIHRoZSBwb2x5ZmlsbCB3ZSBjYW4ndCBzdXBwb3J0IHRoZSBhZGRpdGlvbmFsIGZlYXR1cmVzIHNvIHdlIGFyZSBpZ25vcmluZ1xuXHRcdC8vIHRoZSBleHRyYSBwYXJhbWV0ZXJzXG5cdFx0aWYgKCFvYmogfHwgb2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT0gJ29iamVjdCcpIHRocm93ICdPYmplY3QuY3JlYXRlOiBJbnZhbGlkIHBhcmFtZXRlcic7XG5cdFx0QW5vbi5wcm90b3R5cGUgPSBvYmo7XG5cdFx0cmV0dXJuIG5ldyBBbm9uKCk7XG5cdH07XG59KSgpO1xuXG4vKipcbiogQSBbcG9seWZpbGxde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHN1cHBvcnRcbiogW09iamVjdC5rZXlzKClde0BnbG9zc2FyeSBPYmplY3Qua2V5c30uXG4qL1xuT2JqZWN0LmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciByZXN1bHRzID0gW107XG5cdHZhciBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRmb3IgKHZhciBwcm9wIGluIG9iaikge1xuXHRcdGlmIChob3AuY2FsbChvYmosIHByb3ApKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2gocHJvcCk7XG5cdFx0fVxuXHR9XG5cdC8vICpzaWdoKiBJRSA4XG5cdGlmICghKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpKSB7XG5cdFx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHRcdCd0b1N0cmluZycsXG5cdFx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdFx0J3ZhbHVlT2YnLFxuXHRcdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0XHQnY29uc3RydWN0b3InXG5cdFx0XTtcblx0XHRmb3IgKHZhciBpID0gMCwgcDsgKHAgPSBkb250RW51bXNbaV0pOyBpKyspIHtcblx0XHRcdGlmIChob3AuY2FsbChvYmosIHApKSB7XG5cdFx0XHRcdHJlc3VsdHMucHVzaChwKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwga25vd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvdW5kIG9uIGEgZ2l2ZW4gb2JqZWN0LlxuKlxuKiBAYWxpYXMgT2JqZWN0LmtleXMuXG4qIEBtZXRob2QgZW55by5rZXlzXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcblxuLyoqXG4qIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHRha2VzIGFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBwcm9wZXJ0aWVzXG4qIGFuZCBhbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBhcyBwYXJhbWV0ZXJzLiBSZXR1cm5zIGEgbmV3IG9iamVjdFxuKiB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcyBuYW1lZCBpbiB0aGUgYXJyYXkgdGhhdCBhcmUgZm91bmQgdG8gZXhpc3Qgb24gdGhlXG4qIGJhc2Ugb2JqZWN0LiBJZiB0aGUgdGhpcmQgcGFyYW1ldGVyIGlzIGB0cnVlYCwgZmFsc3kgdmFsdWVzIHdpbGwgYmUgaWdub3JlZC5cbipcbiogQHBhcmFtIHtTdHJpbmdbXX0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBpbmNsdWRlIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4qIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgdmFsdWVzIGZvciB0aGUgcmVxdWVzdGVkIHByb3BlcnRpZXMuXG4qIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gaWdub3JlIGNvcHlpbmcgZmFsc3kgdmFsdWVzLlxuKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBvYmplY3QgcG9wdWxhdGVkIHdpdGggdGhlIHJlcXVlc3RlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgZnJvbVxuKiAgICAgICAgICAgICAgICAgICAgIHRoZSBnaXZlbiBvYmplY3QuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLm9ubHkgPSBmdW5jdGlvbiAocHJvcGVydGllcywgb2JqZWN0LCBpZ25vcmUpIHtcblx0dmFyIHJldCA9IHt9LFxuXHRcdHByb3AsXG5cdFx0bGVuLFxuXHRcdGk7XG5cdFxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aCA+Pj4gMDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0cHJvcCA9IHByb3BlcnRpZXNbaV07XG5cdFx0XG5cdFx0aWYgKGlnbm9yZSAmJiAob2JqZWN0W3Byb3BdID09PSB1bmRlZmluZWQgfHwgb2JqZWN0W3Byb3BdID09PSBudWxsKSkgY29udGludWU7XG5cdFx0cmV0W3Byb3BdID0gb2JqZWN0W3Byb3BdO1xuXHR9XG5cdFxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4qIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHRha2VzIHR3byBbb2JqZWN0c117QGdsb3NzYXJ5IE9iamVjdH0gYXMgcGFyYW1ldGVycy5cbiogRm9yIGVhY2gga2V5IGZyb20gdGhlIGZpcnN0IG9iamVjdCwgaWYgdGhlIGtleSBhbHNvIGV4aXN0cyBpbiB0aGUgc2Vjb25kIG9iamVjdCxcbiogYSBtYXBwaW5nIG9mIHRoZSBrZXkgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBrZXkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdCBpc1xuKiBhZGRlZCB0byBhIHJlc3VsdCBvYmplY3QsIHdoaWNoIGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQuIEluIG90aGVyIHdvcmRzLCB0aGVcbiogcmV0dXJuZWQgb2JqZWN0IG1hcHMgdGhlIG5hbWVkIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgbmFtZWRcbiogcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdC4gVGhlIG9wdGlvbmFsIHRoaXJkIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cbiogZGVzaWduYXRpbmcgd2hldGhlciB0byBwYXNzIHVua25vd24ga2V5L3ZhbHVlIHBhaXJzIHRocm91Z2ggdG8gdGhlIG5ldyBvYmplY3QuXG4qIElmIGB0cnVlYCwgdGhvc2Uga2V5cyB3aWxsIGV4aXN0IG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBtYXAgLSBUaGUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzLlxuKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSB2YWx1ZXMgd2lsbCBiZSB1c2VkLlxuKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXNzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBwYXNzIHVubmFtZWQgcHJvcGVydGllcyB0aHJvdWdoXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cbiogQHJldHVybnMge09iamVjdH0gQSBuZXcgb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG1hcHBlZC5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMucmVtYXAgPSBmdW5jdGlvbiAobWFwLCBvYmosIHBhc3MpIHtcblx0dmFyIHJldCA9IHBhc3MgPyBjbG9uZShvYmopIDoge30sXG5cdFx0a2V5O1xuXHRcblx0Zm9yIChrZXkgaW4gbWFwKSB7XG5cdFx0aWYgKGtleSBpbiBvYmopIHJldFttYXBba2V5XV0gPSBvYmouZ2V0ID8gb2JqLmdldChrZXkpIDogb2JqW2tleV07XG5cdH1cblx0cmV0dXJuIHJldDtcbn07XG5cbi8qKlxuKiBIZWxwZXIgbWV0aG9kIHRoYXQgYWNjZXB0cyBhbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2ZcbiogW29iamVjdHNde0BnbG9zc2FyeSBPYmplY3R9IGFuZCByZXR1cm5zIGEgaGFzaCBvZiB0aG9zZSBvYmplY3RzIGluZGV4ZWRcbiogYnkgdGhlIHNwZWNpZmllZCBgcHJvcGVydHlgLiBJZiBhIGBmaWx0ZXJgIGlzIHByb3ZpZGVkLCB0aGUgZmlsdGVyIHNob3VsZFxuKiBhY2NlcHQgZm91ciBwYXJhbWV0ZXJzOiB0aGUga2V5LCB0aGUgdmFsdWUgKG9iamVjdCksIHRoZSBjdXJyZW50IG11dGFibGUgbWFwXG4qIHJlZmVyZW5jZSwgYW5kIGFuIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBhcnJheSBvZiBvYmplY3RzIGZvclxuKiBjb21wYXJpc29uLlxuKlxuKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdG8gaW5kZXggdGhlIGFycmF5IGJ5LlxuKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEFuIGFycmF5IG9mIHByb3BlcnR5IG9iamVjdHMuXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJdIC0gVGhlIGZpbHRlciBmdW5jdGlvbiB0byB1c2U7IGFjY2VwdHMgZm91ciBhcmd1bWVudHMuXG4qIEByZXR1cm5zIHtPYmplY3R9IEEgaGFzaCAob2JqZWN0KSBpbmRleGVkIGJ5IHRoZSBgcHJvcGVydHlgIGFyZ3VtZW50XG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmluZGV4QnkgPSBmdW5jdGlvbiAocHJvcGVydHksIGFycmF5LCBmaWx0ZXIpIHtcblx0Ly8gdGhlIHJldHVybiB2YWx1ZSAtIGluZGV4ZWQgbWFwIGZyb20gdGhlIGdpdmVuIGFycmF5XG5cdHZhciBtYXAgPSB7fSxcblx0XHR2YWx1ZSxcblx0XHRsZW4sXG5cdFx0aWR4ID0gMDtcblx0Ly8gc2FuaXR5IGNoZWNrIGZvciB0aGUgYXJyYXkgd2l0aCBhbiBlZmZpY2llbnQgbmF0aXZlIGFycmF5IGNoZWNrXG5cdGlmICghZXhpc3RzKGFycmF5KSB8fCAhKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXHQvLyBzYW5pdHkgY2hlY2sgdGhlIHByb3BlcnR5IGFzIGEgc3RyaW5nXG5cdGlmICghZXhpc3RzKHByb3BlcnR5KSB8fCAnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXHQvLyB0aGUgaW1tdXRhYmxlIGNvcHkgb2YgdGhlIGFycmF5XG5cdHZhciBjb3B5ID0gY2xvbmUoYXJyYXkpO1xuXHQvLyB0ZXN0IHRvIHNlZSBpZiBmaWx0ZXIgYWN0dWFsbHkgZXhzaXRzXG5cdGZpbHRlciA9IGV4aXN0cyhmaWx0ZXIpICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBmaWx0ZXIgPyBmaWx0ZXIgOiB1bmRlZmluZWQ7XG5cdGZvciAobGVuID0gYXJyYXkubGVuZ3RoOyBpZHggPCBsZW47ICsraWR4KSB7XG5cdFx0Ly8gZ3JhYiB0aGUgdmFsdWUgZnJvbSB0aGUgYXJyYXlcblx0XHR2YWx1ZSA9IGFycmF5W2lkeF07XG5cdFx0Ly8gbWFrZSBzdXJlIHRoYXQgaXQgZXhpc3RzIGFuZCBoYXMgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBhdCBhbGxcblx0XHRpZiAoZXhpc3RzKHZhbHVlKSAmJiBleGlzdHModmFsdWVbcHJvcGVydHldKSkge1xuXHRcdFx0aWYgKGZpbHRlcikge1xuXHRcdFx0XHQvLyBpZiB0aGVyZSB3YXMgYSBmaWx0ZXIgdXNlIGl0IC0gaXQgaXMgcmVzcG9uc2libGUgZm9yXG5cdFx0XHRcdC8vIHVwZGF0aW5nIHRoZSBtYXAgYWNjb3JkaW5nbHlcblx0XHRcdFx0ZmlsdGVyKHByb3BlcnR5LCB2YWx1ZSwgbWFwLCBjb3B5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvciAtIGNoZWNrIHRvIHNlZSBpZiB0aGUga2V5XG5cdFx0XHRcdC8vIGFscmVhZHkgZXhpc3RzIG9uIHRoZSBtYXAgaXQgd2lsbCBiZSBvdmVyd3JpdHRlblxuXHRcdFx0XHRtYXBbdmFsdWVbcHJvcGVydHldXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBnbyBhaGVhZCBhbmQgcmV0dXJuIG91ciBtb2RpZmllZCBtYXBcblx0cmV0dXJuIG1hcDtcbn07XG5cbi8qKlxuKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGFuIFtPYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IG9yIGFuXG4qIFtBcnJheV17QGdsb3NzYXJ5IEFycmF5fS4gRm9yIG9iamVjdHMsIGJ5IGRlZmF1bHQsIHByb3BlcnRpZXMgd2lsbCBiZSBzY2FubmVkIGFuZFxuKiBjb3BpZWQgZGlyZWN0bHkgdG8gdGhlIGNsb25lIHN1Y2ggdGhhdCB0aGV5IHdvdWxkIHBhc3MgdGhlXG4qIFtoYXNPd25Qcm9wZXJ0eSgpXXtAZ2xvc3NhcnkgT2JqZWN0Lmhhc093blByb3BlcnR5fSB0ZXN0LiBUaGlzIGlzIGV4cGVuc2l2ZSBhbmQgb2Z0ZW4gbm90XG4qIHJlcXVpcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBvcHRpb25hbCBzZWNvbmQgcGFyYW1ldGVyIG1heSBiZSB1c2VkIHRvIGFsbG93IGEgbW9yZSBlZmZpY2llbnRcbiogW2NvcHlde0BsaW5rIE9iamVjdC5jcmVhdGV9IHRvIGJlIG1hZGUuXG4qIFxuKiBAcGFyYW0geyhPYmplY3R8QXJyYXkpfSBiYXNlIC0gVGhlIFtPYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IG9yXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IHRvIGJlIGNsb25lZC5cbiogQHBhcmFtIHtCb29sZWFufSBbcXVpY2tdIC0gSWYgYHRydWVgLCB3aGVuIGNsb25pbmcgb2JqZWN0cywgYSBmYXN0ZXIgW2NvcHlde0BsaW5rIE9iamVjdC5jcmVhdGV9XG4qICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Qgd2lsbCBiZSB1c2VkLiBUaGlzIHBhcmFtZXRlciBoYXMgbm8gbWVhbmluZyB3aGVuIGNsb25pbmcgYXJyYXlzLlxuKiBAcmV0dXJucyB7Kn0gQSBjbG9uZSBvZiB0aGUgcHJvdmlkZWQgYGJhc2VgIGlmIGBiYXNlYCBpcyBvZiB0aGUgY29ycmVjdCB0eXBlOyBvdGhlcndpc2UsXG4qICAgICAgICAgICAgICByZXR1cm5zIGBiYXNlYCBhcyBpdCB3YXMgcGFzc2VkIGluLlxuKiBAcHVibGljXG4qL1xudmFyIGNsb25lID0gZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChiYXNlLCBxdWljaykge1xuXHRpZiAoYmFzZSkge1xuXHRcdFxuXHRcdC8vIGF2b2lkIHRoZSBvdmVyaGVhZCBvZiBjYWxsaW5nIHlldCBhbm90aGVyIGludGVybmFsIGZ1bmN0aW9uIHRvIGRvIHR5cGUtY2hlY2tpbmdcblx0XHQvLyBqdXN0IGNvcHkgdGhlIGFycmF5IGFuZCBiZSBkb25lIHdpdGggaXRcblx0XHRpZiAoYmFzZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gYmFzZS5zbGljZSgpO1xuXHRcdGVsc2UgaWYgKGJhc2UgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdHJldHVybiBxdWljayA/IE9iamVjdC5jcmVhdGUoYmFzZSkgOiBtaXhpbih7fSwgYmFzZSk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvLyB3ZSB3aWxsIG9ubHkgZG8gdGhpcyBpZiBpdCBpcyBub3QgYW4gYXJyYXkgb3IgbmF0aXZlIG9iamVjdFxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbnZhciBlbXB0eSA9IHt9O1xudmFyIG1peGluRGVmYXVsdHMgPSB7XG5cdGV4aXN0czogZmFsc2UsXG5cdGlnbm9yZTogZmFsc2UsXG5cdGZpbHRlcjogbnVsbFxufTtcblxuLyoqXG5cdEB0b2RvIFJld3JpdGUgd2l0aCBhcHByb3ByaWF0ZSBkb2N1bWVudGF0aW9uIGZvciBvcHRpb25zIHBhcmFtZXRlciAodHlwZWRlZilcblx0QHRvZG8gZG9jdW1lbnQgJ3F1aWNrJyBvcHRpb25cblxuXHRXaWxsIHRha2UgYSB2YXJpZXR5IG9mIG9wdGlvbnMgdG8gdWx0aW1hdGVseSBtaXggYSBzZXQgb2YgcHJvcGVydGllc1xuXHRmcm9tIG9iamVjdHMgaW50byBzaW5nbGUgb2JqZWN0LiBBbGwgY29uZmlndXJhdGlvbnMgYWNjZXB0IGEgYm9vbGVhbiBhc1xuXHR0aGUgZmluYWwgcGFyYW1ldGVyIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSBfdHJ1dGh5Xy9fZXhpc3RpbmdfXG5cdHZhbHVlcyBvbiBhbnkgX29iamVjdHNfIHByaW9yLlxuXG5cdElmIF90YXJnZXRfIGV4aXN0cyBhbmQgaXMgYW4gb2JqZWN0LCBpdCB3aWxsIGJlIHRoZSBiYXNlIGZvciBhbGwgcHJvcGVydGllc1xuXHRhbmQgdGhlIHJldHVybmVkIHZhbHVlLiBJZiB0aGUgcGFyYW1ldGVyIGlzIHVzZWQgYnV0IGlzIF9mYWxzeV8sIGEgbmV3XG5cdG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLiBJZiBubyBzdWNoIHBhcmFtZXRlciBleGlzdHMsIHRoZSBmaXJzdFxuXHRwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCBhIG5ldyBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkIGFzXG5cdHRoZSBfdGFyZ2V0Xy5cblxuXHRUaGUgX3NvdXJjZV8gcGFyYW1ldGVyIG1heSBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cy4gSWYgbm9cblx0X3RhcmdldF8gcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBfc291cmNlXyBtdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMuXG5cblx0VGhlIF9vcHRpb25zXyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBzZXQgdGhlIF9pZ25vcmVfIGFuZC9vciBfZXhpc3RzXyBmbGFnc1xuXHRzdWNoIHRoYXQgaWYgX2lnbm9yZV8gaXMgdHJ1ZSwgaXQgd2lsbCBub3Qgb3ZlcnJpZGUgYW55IHRydXRoeSB2YWx1ZXMgaW4gdGhlXG5cdHRhcmdldCwgYW5kIGlmIF9leGlzdHNfIGlzIHRydWUsIGl0IHdpbGwgb25seSB1c2UgdHJ1dGh5IHZhbHVlcyBmcm9tIGFueSBvZlxuXHR0aGUgc291cmNlcy4gWW91IG1heSBvcHRpb25hbGx5IGFkZCBhIF9maWx0ZXJfIG1ldGhvZC1vcHRpb24gdGhhdCByZXR1cm5zIGFcblx0dHJ1ZSBvciBmYWxzZSB2YWx1ZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSB2YWx1ZSBzaG91bGQgYmUgdXNlZC4gSXQgcmVjZWl2ZXNcblx0cGFyYW1ldGVycyBpbiB0aGlzIG9yZGVyOiBfcHJvcGVydHlfLCBfc291cmNlIHZhbHVlXywgX3NvdXJjZSB2YWx1ZXNfLFxuXHRfdGFyZ2V0XywgX29wdGlvbnNfLiBOb3RlIHRoYXQgbW9kaWZ5aW5nIHRoZSB0YXJnZXQgaW4gdGhlIGZpbHRlciBtZXRob2QgY2FuXG5cdGhhdmUgdW5leHBlY3RlZCByZXN1bHRzLlxuXG5cdFNldHRpbmcgX29wdGlvbnNfIHRvIHRydWUgd2lsbCBzZXQgYWxsIG9wdGlvbnMgdG8gdHJ1ZS5cblxuKiBAbWV0aG9kIGVueW8ubWl4aW5cbiogQHB1YmxpY1xuKi9cbnZhciBtaXhpbiA9IGV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSBhcmd1bWVudHNbMF0sXG5cdFx0c3JjID0gYXJndW1lbnRzWzFdLFxuXHRcdG9wdHMgPSBhcmd1bWVudHNbMl0sXG5cdFx0dmFsO1xuXHRcblx0aWYgKCFyZXQpIHJldCA9IHt9O1xuXHRlbHNlIGlmIChyZXQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdG9wdHMgPSBzcmM7XG5cdFx0c3JjID0gcmV0O1xuXHRcdHJldCA9IHt9O1xuXHR9XG5cdFxuXHRpZiAoIW9wdHMgfHwgb3B0cyA9PT0gdHJ1ZSkgb3B0cyA9IG1peGluRGVmYXVsdHM7XG5cblx0aWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5KSBmb3IgKHZhciBpPTAsIGl0OyAoaXQ9c3JjW2ldKTsgKytpKSBtaXhpbihyZXQsIGl0LCBvcHRzKTtcblx0ZWxzZSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHNyYykge1xuXHRcdFx0dmFsID0gc3JjW2tleV07XG5cdFx0XHRcblx0XHRcdC8vIHF1aWNrbHkgZW5zdXJlIHRoZSBwcm9wZXJ0eSBpc24ndCBhIGRlZmF1bHRcblx0XHRcdGlmIChlbXB0eVtrZXldICE9PSB2YWwpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghb3B0cy5leGlzdHMgfHwgdmFsKSAmJlxuXHRcdFx0XHRcdCghb3B0cy5pZ25vcmUgfHwgIXJldFtrZXldKSAmJlxuXHRcdFx0XHRcdChvcHRzLmZpbHRlcj8gb3B0cy5maWx0ZXIoa2V5LCB2YWwsIHNyYywgcmV0LCBvcHRzKTogdHJ1ZSlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcbiogUmV0dXJucyBhbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgdGhlIHZhbHVlcyBvZiBhbGwgcHJvcGVydGllcyBpbiBhblxuKiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fS5cbipcbiogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBbT2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0byByZWFkIHRoZSB2YWx1ZXMgZnJvbS5cbiogQHJldHVybnMge0FycmF5fSBBbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gd2l0aCB0aGUgdmFsdWVzIGZyb20gdGhlIGBvYmpgLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciByZXQgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0LnB1c2gob2JqW2tleV0pO1xuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBcnJheSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4qIEJlY2F1c2Ugb3VyIG9sZGVyIEFQSSBwYXJhbWV0ZXJzIGFyZSBub3QgY29uc2lzdGVudCB3aXRoIG90aGVyIGFycmF5IEFQSSBtZXRob2RzLCBhbmQgYWxzb1xuKiBiZWNhdXNlIG9ubHkgW0lFOCBsYWNrcyBpbnRlZ3JhdGVkIHN1cHBvcnRde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yXG4qIFtpbmRleE9mKClde0BsaW5rY29kZSBleHRlcm5hbDpBcnJheS5pbmRleE9mfSwgd2UgZW5zdXJlIGl0IGlzIGRlZmluZWQgKG9ubHkgSUU4KSBhbmQgYWR2aXNlLFxuKiBtb3ZpbmcgZm9yd2FyZCwgdGhhdCB0aGUgYnVpbHQtaW4gbWV0aG9kIGJlIHVzZWQuIEJ1dCB0byBwcmVzZXJ2ZSBvdXIgb3JpZ2luYWwgQVBJLCBpdCB3aWxsXG4qIHNpbXBseSBjYWxsIHRoaXMgbWV0aG9kLCBrbm93aW5nIGl0IGV4aXN0cy5cbipcbiogQHByaXZhdGVcbiovXG5BcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uIChlbCwgb2Zmc2V0KSB7XG5cdHZhciBsZW4gPSB0aGlzLmxlbmd0aCA+Pj4gMDtcblx0XG5cdG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcblx0XG5cdGlmIChNYXRoLmFicyhvZmZzZXQpID09PSBJbmZpbml0eSkgb2Zmc2V0ID0gMDtcblx0aWYgKG9mZnNldCA8IDApIG9mZnNldCArPSBsZW47XG5cdGlmIChvZmZzZXQgPCAwKSBvZmZzZXQgPSAwO1xuXHRcblx0Zm9yICg7IG9mZnNldCA8IGxlbjsgKytvZmZzZXQpIHtcblx0XHRpZiAodGhpc1tvZmZzZXRdID09PSBlbCkgcmV0dXJuIG9mZnNldDtcblx0fVxuXHRcblx0cmV0dXJuIC0xO1xufTtcblxuLyoqXG4qIEJlY2F1c2Ugb3VyIG9sZGVyIEFQSSBwYXJhbWV0ZXJzIGFyZSBub3QgY29uc2lzdGVudCB3aXRoIG90aGVyIGFycmF5IEFQSSBtZXRob2RzLCBhbmQgYWxzb1xuKiBiZWNhdXNlIG9ubHkgW0lFOCBsYWNrcyBpbnRlZ3JhdGVkIHN1cHBvcnRde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yXG4qIFtsYXN0SW5kZXhPZigpXXtAZ2xvc3NhcnkgQXJyYXkubGFzdEluZGV4T2Z9IHdlIGVuc3VyZSBpdCBpcyBkZWZpbmVkIChvbmx5IElFOCkgYW5kXG4qIGFkdmlzZSwgbW92aW5nIGZvcndhcmQsIHRoYXQgdGhlIGJ1aWx0LWluIG1ldGhvZCBiZSB1c2VkLiBCdXQgdG8gcHJlc2VydmUgb3VyIG9yaWdpbmFsIEFQSSwgaXRcbiogd2lsbCBzaW1wbHkgY2FsbCB0aGlzIG1ldGhvZCwga25vd2luZyBpdCBleGlzdHMuXG4qXG4qIEBwcml2YXRlXG4qL1xuQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mIHx8IGZ1bmN0aW9uIChlbCwgb2Zmc2V0KSB7XG5cdHZhciBhcnJheSA9IE9iamVjdCh0aGlzKVxuXHRcdCwgbGVuID0gYXJyYXkubGVuZ3RoID4+PiAwO1xuXHRcdFxuXHRpZiAobGVuID09PSAwKSByZXR1cm4gLTE7XG5cdFxuXHRpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KTtcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0KSA+IGxlbikgb2Zmc2V0ID0gbGVuO1xuXHRcdGlmIChvZmZzZXQgPT09IEluZmluaXR5IHx8IG9mZnNldCA9PT0gLUluZmluaXR5KSBvZmZzZXQgPSBsZW47XG5cdFx0aWYgKG9mZnNldCA8IDApIG9mZnNldCArPSBsZW47XG5cdH0gZWxzZSBvZmZzZXQgPSBsZW47XG5cdFxuXHRmb3IgKDsgb2Zmc2V0ID4gLTE7IC0tb2Zmc2V0KSB7XG5cdFx0aWYgKGFycmF5W29mZnNldF0gPT09IGVsKSByZXR1cm4gb2Zmc2V0O1xuXHR9XG5cdFxuXHRyZXR1cm4gLTE7XG59O1xuXG4vKipcbiogQSBbcG9seWZpbGxde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHN1cHBvcnRcbiogW0FycmF5LmZpbmRJbmRleCgpXXtAZ2xvc3NhcnkgQXJyYXkuZmluZEluZGV4fS5cbiovXG5BcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCB8fCBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHRmb3IgKHZhciBpPTAsIGxlbj10aGlzLmxlbmd0aCA+Pj4gMDsgaTxsZW47ICsraSkge1xuXHRcdGlmIChmbi5jYWxsKGN0eCwgdGhpc1tpXSwgaSwgdGhpcykpIHJldHVybiBpO1xuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8qKlxuKiBBIFtwb2x5ZmlsbF17QGdsb3NzYXJ5IHBvbHlmaWxsfSBmb3IgcGxhdGZvcm1zIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuKiBbQXJyYXkuZmluZCgpXXtAZ2xvc3NhcnkgQXJyYXkuZmluZH0uXG4qL1xuQXJyYXkucHJvdG90eXBlLmZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZCB8fCBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHRmb3IgKHZhciBpPTAsIGxlbj10aGlzLmxlbmd0aCA+Pj4gMDsgaTxsZW47ICsraSkge1xuXHRcdGlmIChmbi5jYWxsKGN0eCwgdGhpc1tpXSwgaSwgdGhpcykpIHJldHVybiB0aGlzW2ldO1xuXHR9XG59O1xuXG4vKipcbiogQSBbcG9seWZpbGxde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHN1cHBvcnRcbiogW0FycmF5LmZvckVhY2goKV17QGdsb3NzYXJ5IEFycmF5LmZvckVhY2h9LlxuKi9cbkFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2ggfHwgZnVuY3Rpb24gKGZuLCBjdHgpIHtcblx0Zm9yICh2YXIgaT0wLCBsZW49dGhpcy5sZW5ndGggPj4+IDA7IGk8bGVuOyArK2kpIGZuLmNhbGwoY3R4LCB0aGlzW2ldLCB0aGlzKTtcbn07XG5cbi8qKlxuKiBBIFtwb2x5ZmlsbF17QGdsb3NzYXJ5IHBvbHlmaWxsfSBmb3IgcGxhdGZvcm1zIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuKiBbQXJyYXkubWFwKClde0BnbG9zc2FyeSBBcnJheS5tYXB9LlxuKi9cbkFycmF5LnByb3RvdHlwZS5tYXAgPSBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChmbiwgY3R4KSB7XG5cdHZhciByZXQgPSBbXTtcblx0Zm9yICh2YXIgaT0wLCBsZW49dGhpcy5sZW5ndGggPj4+IDA7IGk8bGVuOyArK2kpIHtcblx0XHRyZXQucHVzaChmbi5jYWxsKGN0eCwgdGhpc1tpXSwgaSwgdGhpcykpO1xuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcbiogQSBbcG9seWZpbGxde0BnbG9zc2FyeSBwb2x5ZmlsbH0gZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHN1cHBvcnRcbiogW0FycmF5LmZpbHRlcigpXXtAZ2xvc3NhcnkgQXJyYXkuZmlsdGVyfS5cbiovXG5BcnJheS5wcm90b3R5cGUuZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlciB8fCBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHR2YXIgcmV0ID0gW107XG5cdGZvciAodmFyIGk9MCwgbGVuPXRoaXMubGVuZ3RoID4+PiAwOyBpPGxlbjsgKytpKSB7XG5cdFx0Zm4uY2FsbChjdHgsIHRoaXNbaV0sIGksIHRoaXMpICYmIHJldC5wdXNoKHRoaXNbaV0pO1xuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcbiogQW4gRW55byBjb252ZW5pZW5jZSBtZXRob2QgcmVmZXJlbmNlIHRvIFtBcnJheS5pbmRleE9mKClde0BnbG9zc2FyeSBBcnJheS5pbmRleE9mfS5cbiogXG4qIFRoaXMgYWxzbyBzdXBwb3J0cyB0aGUgbGVnYWN5IEVueW8gYXJndW1lbnQgb3JkZXIgYGVsLmluZGV4T2YoYXJyYXksIG9mZnNldClgIGFuZCBjYW5cbiogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBzdGFuZGFyZCBgYXJyYXkuaW5kZXhPZihlbCwgb2Zmc2V0KWAuXG4qXG4qICoqV2hlbiBwb3NzaWJsZSwgeW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZSBlcXVpdmFsZW50LioqXG4qIFxuKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG5hdGl2ZSB2ZXJzaW9uLCBwbHVzIGFuIGV4dHJhIGFyZ3VtZW50IGF0IHRoZVxuKiBiZWdpbm5pbmcgcmVmZXJyaW5nIHRvIHRoZSBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gdG8gcnVuIHRoaXMgbWV0aG9kIG9uLlxuKlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBlbCwgb2Zmc2V0KSB7XG5cdGlmICghKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm4gZWwuaW5kZXhPZihhcnJheSwgb2Zmc2V0KTtcblx0cmV0dXJuIGFycmF5LmluZGV4T2YoZWwsIG9mZnNldCk7XG59O1xuXG4vKipcbiogQW4gRW55byBjb252ZW5pZW5jZSBtZXRob2QgcmVmZXJlbmNlIHRvIFtBcnJheS5sYXN0SW5kZXhPZigpXXtAZ2xvc3NhcnkgQXJyYXkubGFzdEluZGV4T2Z9LlxuKiBcbiogVGhpcyBhbHNvIHN1cHBvcnRzIHRoZSBsZWdhY3kgRW55byBhcmd1bWVudCBvcmRlciBgZWwubGFzdEluZGV4T2YoYXJyYXksIG9mZnNldClgIGFuZCBjYW5cbiogZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBzdGFuZGFyZCBgYXJyYXkubGFzdEluZGV4T2YoZWwsIG9mZnNldClgLlxuKlxuKiAqKldoZW4gcG9zc2libGUsIHlvdSBzaG91bGQgdXNlIHRoZSBuYXRpdmUgZXF1aXZhbGVudC4qKlxuKiBcbiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBuYXRpdmUgdmVyc2lvbiwgcGx1cyBhbiBleHRyYSBhcmd1bWVudCBhdCB0aGVcbiogYmVnaW5uaW5nIHJlZmVycmluZyB0byB0aGUgW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IHRvIHJ1biB0aGlzIG1ldGhvZCBvbi5cbipcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIGVsLCBvZmZzZXQpIHtcblx0aWYgKCEoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSkpIHJldHVybiBlbC5sYXN0SW5kZXhPZihhcnJheSwgb2Zmc2V0KTtcblx0cmV0dXJuIGFycmF5Lmxhc3RJbmRleE9mKGVsLCBvZmZzZXQpO1xufTtcblxuLyoqXG4qIEFuIEVueW8gY29udmVuaWVuY2UgbWV0aG9kIHJlZmVyZW5jZSB0byBbQXJyYXkuZmluZEluZGV4KClde0BnbG9zc2FyeSBBcnJheS5maW5kSW5kZXh9LlxuKiBcbiogKipXaGVuIHBvc3NpYmxlLCB5b3Ugc2hvdWxkIHVzZSB0aGUgbmF0aXZlIGVxdWl2YWxlbnQuKipcbiogXG4qIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgbmF0aXZlIHZlcnNpb24sIHBsdXMgYW4gZXh0cmEgYXJndW1lbnQgYXQgdGhlXG4qIGJlZ2lubmluZyByZWZlcnJpbmcgdG8gdGhlIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSB0byBydW4gdGhpcyBtZXRob2Qgb24uXG4qIFxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5maW5kSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjdHgpIHtcblx0cmV0dXJuIGFycmF5LmZpbmRJbmRleChmbiwgY3R4KTtcbn07XG5cbi8qKlxuKiBBbiBFbnlvIGNvbnZlbmllbmNlIG1ldGhvZCByZWZlcmVuY2UgdG8gW0FycmF5LmZpbmQoKV17QGdsb3NzYXJ5IEFycmF5LmZpbmR9LlxuKiBcbiogKipXaGVuIHBvc3NpYmxlLCB5b3Ugc2hvdWxkIHVzZSB0aGUgbmF0aXZlIGVxdWl2YWxlbnQuKipcbiogXG4qIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgbmF0aXZlIHZlcnNpb24sIHBsdXMgYW4gZXh0cmEgYXJndW1lbnQgYXQgdGhlXG4qIGJlZ2lubmluZyByZWZlcnJpbmcgdG8gdGhlIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSB0byBydW4gdGhpcyBtZXRob2Qgb24uXG4qIFxuKiBAbWV0aG9kIGVueW8uZmluZFxuKiBAcHVibGljXG4qL1xudmFyIGZpbmQgPSBleHBvcnRzLmZpbmQgPSBmdW5jdGlvbiAoYXJyYXksIGZuLCBjdHgpIHtcblx0cmV0dXJuIGFycmF5LmZpbmQoZm4sIGN0eCk7XG59O1xuXG4vKipcbiogQGFsaWFzIGVueW8uZmluZFxuKiBAbWV0aG9kIGVueW8ud2hlcmVcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMud2hlcmUgPSBmaW5kO1xuXG4vKipcbiogQW4gRW55byBjb252ZW5pZW5jZSBtZXRob2QgcmVmZXJlbmNlIHRvIFtBcnJheS5mb3JFYWNoKClde0BnbG9zc2FyeSBBcnJheS5mb3JFYWNofS5cbiogXG4qICoqV2hlbiBwb3NzaWJsZSwgeW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZSBlcXVpdmFsZW50LioqXG4qIFxuKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhlIG5hdGl2ZSB2ZXJzaW9uLCBwbHVzIGFuIGV4dHJhIGFyZ3VtZW50IGF0IHRoZVxuKiBiZWdpbm5pbmcgcmVmZXJyaW5nIHRvIHRoZSBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gdG8gcnVuIHRoaXMgbWV0aG9kIG9uLlxuKiBcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uIChhcnJheSwgZm4sIGN0eCkge1xuXHRyZXR1cm4gYXJyYXkuZm9yRWFjaChmbiwgY3R4KTtcbn07XG5cbi8qKlxuKiBBbiBFbnlvIGNvbnZlbmllbmNlIG1ldGhvZCByZWZlcmVuY2UgdG8gW0FycmF5Lm1hcCgpXXtAZ2xvc3NhcnkgQXJyYXkubWFwfS5cbipcbiogKipXaGVuIHBvc3NpYmxlLCB5b3Ugc2hvdWxkIHVzZSB0aGUgbmF0aXZlIGVxdWl2YWxlbnQuKipcbiogXG4qIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgbmF0aXZlIHZlcnNpb24sIHBsdXMgYW4gZXh0cmEgYXJndW1lbnQgYXQgdGhlXG4qIGJlZ2lubmluZyByZWZlcnJpbmcgdG8gdGhlIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSB0byBydW4gdGhpcyBtZXRob2Qgb24uXG4qXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLm1hcCA9IGZ1bmN0aW9uIChhcnJheSwgZm4sIGN0eCkge1xuXHRyZXR1cm4gYXJyYXkubWFwKGZuLCBjdHgpO1xufTtcblxuLyoqXG4qIEFuIEVueW8gY29udmVuaWVuY2UgbWV0aG9kIHJlZmVyZW5jZSB0byBbQXJyYXkuZmlsdGVyKClde0BnbG9zc2FyeSBBcnJheS5maWx0ZXJ9LlxuKlxuKiAqKldoZW4gcG9zc2libGUsIHlvdSBzaG91bGQgdXNlIHRoZSBuYXRpdmUgZXF1aXZhbGVudC4qKlxuKiBcbiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoZSBuYXRpdmUgdmVyc2lvbiwgcGx1cyBhbiBleHRyYSBhcmd1bWVudCBhdCB0aGVcbiogYmVnaW5uaW5nIHJlZmVycmluZyB0byB0aGUgW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IHRvIHJ1biB0aGlzIG1ldGhvZCBvbi5cbipcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY3R4KSB7XG5cdHJldHVybiBhcnJheS5maWx0ZXIoZm4sIGN0eCk7XG59O1xuXG4vKipcbiogV2hlbiBnaXZlbiBhbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgW29iamVjdHNde0BnbG9zc2FyeSBPYmplY3R9LFxuKiBzZWFyY2hlcyB0aHJvdWdoIHRoZSBhcnJheSdzIG9iamVjdHM7IGVhY2ggb2JqZWN0IHdpdGggYSBwcm9wZXJ0eSBuYW1lIG1hdGNoaW5nXG4qIGBwcm9wYCBoYXMgaXRzIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IGNvbXBpbGVkIGludG8gYSByZXN1bHQgYXJyYXksIHdoaWNoIGlzXG4qIGV2ZW50dWFsbHkgcmV0dXJuZWQuIEZvciBlYWNoIGFycmF5IG9iamVjdCB0aGF0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5LFxuKiBhbiBgdW5kZWZpbmVkYCBwbGFjZWhvbGRlciBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgYXJyYXksIHN1Y2ggdGhhdCB0aGVcbiogcmV0dXJuZWQgcmVzdWx0IGFycmF5IGhhcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHBhc3NlZC1pbiBgYXJyYXlgIHBhcmFtZXRlci5cbiogXG4qIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBbb2JqZWN0c117QGdsb3NzYXJ5IE9iamVjdH1cbiogICAgICAgICAgICAgICAgICAgICAgaW4gd2hpY2ggdGhlIGBwcm9wYCB3aWxsIGJlIHNlYXJjaGVkIGZvci5cbiogQHBhcmFtIHtTdHJpbmd9IHByb3AgLSBBIHN0cmluZyBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZWFyY2ggZm9yLlxuKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBmcm9tXG4qICAgICAgICAgICAgICAgICAgICAgb2JqZWN0cyBjb250YWluZWQgaW4gdGhlIGBhcnJheWAuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLnBsdWNrID0gZnVuY3Rpb24gKGFycmF5LCBwcm9wKSB7XG5cdGlmICghKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0dmFyIHRtcCA9IGFycmF5O1xuXHRcdGFycmF5ID0gcHJvcDtcblx0XHRwcm9wID0gdG1wO1xuXHR9XG5cdFxuXHR2YXIgcmV0ID0gW107XG5cdGZvciAodmFyIGk9MCwgbGVuPWFycmF5Lmxlbmd0aCA+Pj4gMDsgaTxsZW47ICsraSkge1xuXHRcdHJldC5wdXNoKGFycmF5W2ldPyBhcnJheVtpXVtwcm9wXTogdW5kZWZpbmVkKTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4qIENvbmNhdGVuYXRlcyBhIHZhcmlhYmxlIG51bWJlciBvZiBbYXJyYXlzXXtAZ2xvc3NhcnkgQXJyYXl9LCByZW1vdmluZyBhbnkgZHVwbGljYXRlXG4qIGVudHJpZXMuXG4qIFxuKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB1bmlxdWUgdmFsdWVzIGZyb20gYWxsIFthcnJheXNde0BnbG9zc2FyeSBBcnJheX0uXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKC8qIF9hcnJheXNfICovKSB7XG5cdHZhciByZXQgPSBbXSxcblx0XHR2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpO1xuXHRmb3IgKHZhciBpPTAsIGxlbj12YWx1ZXMubGVuZ3RoID4+PiAwOyBpPGxlbjsgKytpKSB7XG5cdFx0aWYgKCF+cmV0LmluZGV4T2YodmFsdWVzW2ldKSkgcmV0LnB1c2godmFsdWVzW2ldKTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4qIENsb25lcyBhbiBleGlzdGluZyBbQXJyYXlde0BnbG9zc2FyeSBBcnJheX0sIG9yIGNvbnZlcnRzIGFuIGFycmF5LWxpa2Vcbiogb2JqZWN0IGludG8gYW4gQXJyYXkuXG4qIFxuKiBJZiBgb2Zmc2V0YCBpcyBub24temVybywgdGhlIGNsb25pbmcgc3RhcnRzIGZyb20gdGhhdCBpbmRleCBpbiB0aGUgc291cmNlXG4qIEFycmF5LiBUaGUgY2xvbmUgbWF5IGJlIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIEFycmF5IGJ5IHBhc3NpbmcgaW4gdGhlXG4qIGV4aXN0aW5nIEFycmF5IGFzIGBpbml0aWFsQXJyYXlgLlxuKiBcbiogQXJyYXktbGlrZSBvYmplY3RzIGhhdmUgYGxlbmd0aGAgcHJvcGVydGllcywgYW5kIHN1cHBvcnQgc3F1YXJlLWJyYWNrZXRcbiogbm90YXRpb24gYChbXSlgLiBBcnJheS1saWtlIG9iamVjdHMgb2Z0ZW4gZG8gbm90IHN1cHBvcnQgQXJyYXkgbWV0aG9kc1xuKiBzdWNoIGFzIGBwdXNoKClgIG9yIGBjb25jYXQoKWAsIGFuZCBzbyBtdXN0IGJlIGNvbnZlcnRlZCB0byBBcnJheXMgYmVmb3JlXG4qIHVzZS5cbiogXG4qIFRoZSBzcGVjaWFsIGBhcmd1bWVudHNgIHZhcmlhYmxlIGlzIGFuIGV4YW1wbGUgb2YgYW4gYXJyYXktbGlrZSBvYmplY3QuXG4qXG4qIEBwdWJsaWNcbiovXG52YXIgY2xvbmVBcnJheSA9IGV4cG9ydHMuY2xvbmVBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgb2Zmc2V0LCBpbml0aWFsQXJyYXkpIHtcblx0dmFyIHJldCA9IGluaXRpYWxBcnJheSB8fCBbXTtcblx0Zm9yKHZhciBpID0gb2Zmc2V0IHx8IDAsIGwgPSBhcnJheS5sZW5ndGg7IGk8bDsgaSsrKXtcblx0XHRyZXQucHVzaChhcnJheVtpXSk7XG5cdH1cblx0Ly8gQWx0ZXJuYXRlIHNtYXJ0ZXIgaW1wbGVtZW50YXRpb246XG5cdC8vIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgb2Zmc2V0KTtcblx0Ly8gQXJyYXkub2Zcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2Zcblx0cmV0dXJuIHJldDtcbn07XG5cbi8qKlxuKiBAYWxpYXMgY2xvbmVBcnJheVxuKiBAbWV0aG9kIGVueW8udG9BcnJheVxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy50b0FycmF5ID0gY2xvbmVBcnJheTtcblxuLyoqXG4qIFdpdGhpbiBhIGdpdmVuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSwgcmVtb3ZlcyB0aGUgZmlyc3RcbiogW3N0cmljdGx5IGVxdWFsIHRvXXtAZ2xvc3NhcnkgPT09fSBvY2N1cnJlbmNlIG9mIGBlbGAuXG4qIE5vdGUgdGhhdCBgYXJyYXlgIGlzIG1vZGlmaWVkIGRpcmVjdGx5LlxuKlxuKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBbQXJyYXlde0BnbG9zc2FyeSBBcnJheX0gdG8gbG9vayB0aHJvdWdoLlxuKiBAcGFyYW0geyp9IGVsIC0gVGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvciBhbmQgcmVtb3ZlLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiAoYXJyYXksIGVsKSB7XG5cdGlmICghKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0dmFyIHRtcCA9IGFycmF5O1xuXHRcdGFycmF5ID0gZWw7XG5cdFx0ZWwgPSB0bXA7XG5cdH1cblx0XG5cdHZhciBpID0gYXJyYXkuaW5kZXhPZihlbCk7XG5cdGlmICgtMSA8IGkpIGFycmF5LnNwbGljZShpLCAxKTtcblx0cmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4qIFRoaXMgcmVnZXggcGF0dGVybiBpcyB1c2VkIGJ5IHRoZSBbZW55by5pc1J0bCgpXXtAbGluayBlbnlvLmlzUnRsfSBmdW5jdGlvbi5cbiogXG4qIEFyYWJpYzogXFx1MDYwMC1cXHUwNkZGXFx1MDc1MC1cXHUwNzdGXFx1MDhBMC1cXHUwOEZGXFx1RkI1MC1cXHVGREZGXFx1RkU3MC1cXHVGRUZFXG4qIEhlYnJldzogXFx1MDU5MC1cXHUwNUZGXFx1RkIxRC1cXHVGQjRGXG4qIFxuKiBAcHJpdmF0ZVxuKi9cbnZhciBydGxQYXR0ZXJuID0gL1tcXHUwNjAwLVxcdTA2RkZcXHUwNzUwLVxcdTA3N0ZcXHUwOEEwLVxcdTA4RkZcXHVGQjUwLVxcdUZERkZcXHVGRTcwLVxcdUZFRkVcXHUwNTkwLVxcdTA1RkZcXHVGQjFELVxcdUZCNEZdLztcblxuLyoqXG4qIFRha2VzIGNvbnRlbnQgYHN0cmAgYW5kIGRldGVybWluZXMgd2hldGhlciBvciBub3QgaXQgaXMgW1JUTF17QGdsb3NzYXJ5IFJUTH0uXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBBIFtTdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IHRvIGNoZWNrIHRoZSBbUlRMXXtAZ2xvc3NhcnkgUlRMfS1uZXNzIG9mLlxuKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHN0cmAgc2hvdWxkIGJlIFJUTDsgYGZhbHNlYCBpZiBub3QuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmlzUnRsID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gcnRsUGF0dGVybi50ZXN0KHN0cik7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vZW55b1wiOjF9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRTdGF0ZXMgPSByZXF1aXJlKCcuL1N0YXRlcycpO1xuXG4vKipcbiogUHJvdmlkZXMgZ2VuZXJpYyBBUEkgbWV0aG9kcyByZWxhdGVkIHRvIHVzaW5nIHtAbGluayBlbnlvLlN0YXRlc30uXG4qXG4qIEBtaXhpbiBlbnlvLlN0YXRlU3VwcG9ydFxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnU3RhdGVTdXBwb3J0Jyxcblx0XG5cdC8qKlxuXHQqIFRoZSBnaXZlbiBzdGF0dXMuIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBtb2RpZmllZCBieSB0aGUgb3RoZXIgQVBJIG1ldGhvZHMgb2Zcblx0KiB7QGxpbmsgZW55by5TdGF0ZVN1cHBvcnR9LlxuXHQqXG5cdCogQHR5cGUgZW55by5TdGF0ZXNcblx0KiBAZGVmYXVsdCBudWxsXG5cdCovXG5cdHN0YXR1czogbnVsbCxcblx0XG5cdC8qKlxuXHQqIFdpbGwgcmVtb3ZlIGFueSBbZXJyb3IgZmxhZ3Nde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfSBmcm9tIHRoZSBnaXZlblxuXHQqIFtzdGF0dXNde0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LnN0YXR1c30uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGNsZWFyRXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzICYgflN0YXRlcy5FUlJPUjtcblx0fSxcblx0XG5cdC8qKlxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhdm9pZCB1c2luZyBbYml0d2lzZV17QGdsb3NzYXJ5IGJpdHdpc2V9IGNvbXBhcmlzb24gZm9yIHRoZVxuXHQqIFtzdGF0dXNde0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LnN0YXR1c30uIERldGVybWluZXMgd2hldGhlciB0aGUgY3VycmVudCBzdGF0dXNcblx0KiAob3IgdGhlIG9wdGlvbmFsIHBhc3NlZC1pbiB2YWx1ZSkgaXMgYW4gW2Vycm9yIHN0YXRlXXtAbGluayBlbnlvLlN0YXRlcy5FUlJPUn0uXG5cdCogVGhlIHBhc3NlZC1pbiB2YWx1ZSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBpdCBpcyBhIFtOdW1iZXJde0BnbG9zc2FyeSBOdW1iZXJ9LlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLlN0YXRlc30gW3N0YXR1c10gLSBUaGUgc3BlY2lmaWMgdmFsdWUgdG8gY29tcGFyZSBhcyBhblxuXHQqXHRbZXJyb3Igc3RhdGVde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfS5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdmFsdWUgaXMgYW4gW2Vycm9yIHN0YXRlXXtAbGluayBlbnlvLlN0YXRlcy5FUlJPUn0gb3Igbm90LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNFcnJvcjogZnVuY3Rpb24gKHN0YXR1cykge1xuXHRcdHJldHVybiAhISAoKGlzTmFOKHN0YXR1cykgPyB0aGlzLnN0YXR1cyA6IHN0YXR1cykgJiBTdGF0ZXMuRVJST1IpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGF2b2lkIHVzaW5nIFtiaXR3aXNlXXtAZ2xvc3NhcnkgYml0d2lzZX0gY29tcGFyaXNvbiBmb3IgdGhlXG5cdCogW3N0YXR1c117QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuc3RhdHVzfS4gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IHN0YXR1c1xuXHQqIChvciB0aGUgb3B0aW9uYWwgcGFzc2VkLWluIHZhbHVlKSBpcyBhIFtidXN5IHN0YXRlXXtAbGluayBlbnlvLlN0YXRlcy5CVVNZfS4gVGhlXG5cdCogcGFzc2VkLWluIHZhbHVlIHdpbGwgb25seSBiZSB1c2VkIGlmIGl0IGlzIGEgW051bWJlcl17QGdsb3NzYXJ5IE51bWJlcn0uXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uU3RhdGVzfSBbc3RhdHVzXSAtIFRoZSBzcGVjaWZpYyB2YWx1ZSB0byBjb21wYXJlIGFzIGFcblx0Klx0W2J1c3kgc3RhdGVde0BsaW5rIGVueW8uU3RhdGVzLkJVU1l9LlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIFtidXN5IHN0YXRlXXtAbGluayBlbnlvLlN0YXRlcy5CVVNZfSBvciBub3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc0J1c3k6IGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRyZXR1cm4gISEgKChpc05hTihzdGF0dXMpID8gdGhpcy5zdGF0dXMgOiBzdGF0dXMpICYgU3RhdGVzLkJVU1kpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGF2b2lkIHVzaW5nIFtiaXR3aXNlXXtAZ2xvc3NhcnkgYml0d2lzZX0gY29tcGFyaXNvbiBmb3IgdGhlXG5cdCogW3N0YXR1c117QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuc3RhdHVzfS4gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IHN0YXR1c1xuXHQqIChvciB0aGUgb3B0aW9uYWwgcGFzc2VkLWluIHZhbHVlKSBpcyBhIFtyZWFkeSBzdGF0ZV17QGxpbmsgZW55by5TdGF0ZXMuUkVBRFl9LiBUaGVcblx0KiBwYXNzZWQtaW4gdmFsdWUgd2lsbCBvbmx5IGJlIHVzZWQgaWYgaXQgaXMgYSBbTnVtYmVyXXtAZ2xvc3NhcnkgTnVtYmVyfS5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5TdGF0ZXN9IFtzdGF0dXNdIC0gVGhlIHNwZWNpZmljIHZhbHVlIHRvIGNvbXBhcmUgYXMgYVxuXHQqXHRbcmVhZHkgc3RhdGVde0BsaW5rIGVueW8uU3RhdGVzLlJFQURZfS5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdmFsdWUgaXMgYSBbcmVhZHkgc3RhdGVde0BsaW5rIGVueW8uU3RhdGVzLkJVU1l9IG9yIG5vdC5cblx0KiBAcHVibGljXG5cdCovXG5cdGlzUmVhZHk6IGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0XHRyZXR1cm4gISEgKChpc05hTihzdGF0dXMpID8gdGhpcy5zdGF0dXMgOiBzdGF0dXMpICYgU3RhdGVzLlJFQURZKTtcblx0fVxufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL1N0YXRlc1wiOjUwfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhclxuXHRldmVudFRhYmxlID0ge307XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG9iaiwgZSwgZm4sIGN0eCkge1xuXG5cdG9iai5saXN0ZW5lcnMoKS5wdXNoKHtcblx0XHRldmVudDogZSxcblx0XHRtZXRob2Q6IGZuLFxuXHRcdGN0eDogY3R4IHx8IG9ialxuXHR9KTtcblx0XG5cdHJldHVybiBvYmo7XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG9iaiwgZSwgZm4sIGN0eCkge1xuXHR2YXIgbGlzdGVuZXJzID0gb2JqLmxpc3RlbmVycygpXG5cdFx0LCBpZHg7XG5cdFx0XG5cdGlmIChsaXN0ZW5lcnMubGVuZ3RoKSB7XG5cdFx0aWR4ID0gbGlzdGVuZXJzLmZpbmRJbmRleChmdW5jdGlvbiAobG4pIHtcblx0XHRcdHJldHVybiBsbi5ldmVudCA9PSBlICYmIGxuLm1ldGhvZCA9PT0gZm4gJiYgKGN0eD8gbG4uY3R4ID09PSBjdHg6IHRydWUpO1xuXHRcdH0pO1xuXHRcdGlkeCA+PSAwICYmIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0fVxuXHRcblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZW1pdChvYmosIGFyZ3MpIHtcblx0dmFyIGxlbiA9IGFyZ3MubGVuZ3RoXG5cdFx0LCBlID0gYXJnc1swXVxuXHRcdCwgbGlzdGVuZXJzID0gb2JqLmxpc3RlbmVycyhlKTtcblx0XHRcblx0aWYgKGxpc3RlbmVycy5sZW5ndGgpIHtcblx0XHRpZiAobGVuID4gMSkge1xuXHRcdFx0YXJncyA9IHV0aWxzLnRvQXJyYXkoYXJncyk7XG5cdFx0XHRhcmdzLnVuc2hpZnQob2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncyA9IFtvYmosIGVdO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGk9MCwgbG47IChsbj1saXN0ZW5lcnNbaV0pOyArK2kpIGxuLm1ldGhvZC5hcHBseShsbi5jdHgsIGFyZ3MpO1xuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuKiB7QGxpbmsgZW55by5FdmVudEVtaXR0ZXJ9IGlzIGEge0BnbG9zc2FyeSBtaXhpbn0gdGhhdCBhZGRzIHN1cHBvcnQgZm9yXG4qIHJlZ2lzdGVyZWQge0BnbG9zc2FyeSBldmVudH0gbGlzdGVuZXJzLiBUaGVzZSBldmVudHMgYXJlIGRpZmZlcmVudCBmcm9tXG4qIGJ1YmJsZWQgZXZlbnRzIChlLmcuLCBET00gZXZlbnRzIGFuZCBbaGFuZGxlcnNde0BsaW5rIGVueW8uQ29tcG9uZW50I2hhbmRsZXJzfSkuXG4qIFdoZW4gW2VtaXR0ZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyI2VtaXR9LCB0aGVzZSBldmVudHMgKipkbyBub3QgYnViYmxlKipcbiogYW5kIHdpbGwgb25seSBiZSBoYW5kbGVkIGJ5IFtyZWdpc3RlcmVkIGxpc3RlbmVyc117QGxpbmsgZW55by5FdmVudEVtaXR0ZXIjb259LlxuKlxuKiBAbWl4aW4gZW55by5FdmVudEVtaXR0ZXJcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ0V2ZW50RW1pdHRlcicsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfc2lsZW5jZWQ6IGZhbHNlLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X3NpbGVuY2VDb3VudDogMCxcblx0XG5cdC8qKlxuXHQqIERpc2FibGVzIHByb3BhZ2F0aW9uIG9mIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uIFRoaXMgaXMgYSBjb3VudGluZ1xuXHQqIHNlbWFwaG9yIGFuZCBbdW5zaWxlbmNlKClde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyI3Vuc2lsZW5jZX0gd2lsbCBuZWVkIHRvXG5cdCogYmUgY2FsbGVkIHRoZSBzYW1lIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cblx0KlxuXHQqIEBzZWUgZW55by5FdmVudEVtaXR0ZXIudW5zaWxlbmNlXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2lsZW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3NpbGVuY2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9zaWxlbmNlQ291bnQrKztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIEVuYWJsZXMgcHJvcGFnYXRpb24gb2YgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fS4gVGhpcyBpcyBhIGNvdW50aW5nXG5cdCogc2VtYXBob3IgYW5kIHRoaXMgbWV0aG9kIHdpbGwgbmVlZCB0byBiZSBjYWxsZWQgdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzXG5cdCogdGhhdCBbc2lsZW5jZSgpXXtAbGluayBlbnlvLkV2ZW50RW1pdHRlciNzaWxlbmNlfSB3YXMgY2FsbGVkLlxuXHQqXG5cdCogQHNlZSBlbnlvLkV2ZW50RW1pdHRlci5zaWxlbmNlXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dW5zaWxlbmNlOiBmdW5jdGlvbiAoZm9yY2UpIHtcblx0XHRpZiAoZm9yY2UpIHtcblx0XHRcdHRoaXMuX3NpbGVuY2VDb3VudCA9IDA7XG5cdFx0XHR0aGlzLl9zaWxlbmNlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zaWxlbmNlQ291bnQgJiYgdGhpcy5fc2lsZW5jZUNvdW50LS07XG5cdFx0XHR0aGlzLl9zaWxlbmNlQ291bnQgPT09IDAgJiYgKHRoaXMuX3NpbGVuY2VkID0gZmFsc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB0aGUgY2FsbGVlIGlzIGN1cnJlbnRseSBbc2lsZW5jZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyI3NpbGVuY2V9LlxuXHQqXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjYWxsZWUgaXNcblx0Klx0W3NpbGVuY2VkXXtAbGluayBlbnlvLkV2ZW50RW1pdHRlci5zaWxlbmNlfS5cblx0KiBAcHVibGljXG5cdCovXG5cdGlzU2lsZW5jZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2lsZW5jZWQ7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAYWxpYXMgZW55by5FdmVudEVtaXR0ZXIub25cblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkTGlzdGVuZXI6IGZ1bmN0aW9uIChlLCBmbiwgY3R4KSB7XG5cdFx0cmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGUsIGZuLCBjdHgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQWRkcyBhbiB7QGdsb3NzYXJ5IGV2ZW50fSBsaXN0ZW5lci4gVW50aWwgW3JlbW92ZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyI29mZn0sXG5cdCogdGhpcyBsaXN0ZW5lciB3aWxsIGZpcmUgZXZlcnkgdGltZSB0aGUgZXZlbnQgaXNcblx0KiBbZW1pdHRlZF17QGxpbmsgZW55by5FdmVudEVtaXR0ZXIjZW1pdH0uXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gZSAtIFRoZSB7QGdsb3NzYXJ5IGV2ZW50fSBuYW1lIHRvIHJlZ2lzdGVyIGZvci5cblx0KiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lci5cblx0KiBAcGFyYW0ge09iamVjdH0gW2N0eF0gLSBUaGUgb3B0aW9uYWwgY29udGV4dCB1bmRlciB3aGljaCB0byBleGVjdXRlIHRoZSBsaXN0ZW5lci5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRvbjogZnVuY3Rpb24gKGUsIGZuLCBjdHgpIHtcblx0XHRyZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZSwgZm4sIGN0eCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAYWxpYXMgZW55by5FdmVudEVtaXR0ZXIub2ZmXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiAoZSwgZm4sIGN0eCkge1xuXHRcdHJldHVybiByZW1vdmVMaXN0ZW5lcih0aGlzLCBlLCBmbiwgY3R4KTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIFJlbW92ZXMgYW4ge0BnbG9zc2FyeSBldmVudH0gbGlzdGVuZXIuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gZSAtIFRoZSB7QGdsb3NzYXJ5IGV2ZW50fSBuYW1lLlxuXHQqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIHRvIHVucmVnaXN0ZXIuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtjdHhdIC0gSWYgdGhlIGxpc3RlbmVyIHdhcyByZWdpc3RlcmVkIHdpdGggYSBjb250ZXh0LCBpdFxuXHQqIHNob3VsZCBiZSBwcm92aWRlZCB3aGVuIHVucmVnaXN0ZXJpbmcgYXMgd2VsbC5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRvZmY6IGZ1bmN0aW9uIChlLCBmbiwgY3R4KSB7XG5cdFx0cmV0dXJuIHJlbW92ZUxpc3RlbmVyKHRoaXMsIGUsIGZuLCBjdHgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciBhbGwgbGlzdGVuZXJzIGZvciBhIGdpdmVuIHtAZ2xvc3NhcnkgZXZlbnR9LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IFtlXSAtIFRoZSBvcHRpb25hbCB0YXJnZXQge0BnbG9zc2FyeSBldmVudH0uXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqL1xuXHRyZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGV1aWQgPSB0aGlzLmV1aWRcblx0XHRcdCwgbG9jID0gZXVpZCAmJiBldmVudFRhYmxlW2V1aWRdO1xuXHRcdFxuXHRcdGlmIChsb2MpIHtcblx0XHRcdGlmIChlKSB7XG5cdFx0XHRcdGV2ZW50VGFibGVbZXVpZF0gPSBsb2MuZmlsdGVyKGZ1bmN0aW9uIChsbikge1xuXHRcdFx0XHRcdHJldHVybiBsbi5ldmVudCAhPSBlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2ZW50VGFibGVbZXVpZF0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIFByaW1hcmlseSBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIGltbXV0YWJsZSBjb3B5XG5cdCogb2YgYWxsIGxpc3RlbmVycywgb3IgYWxsIGxpc3RlbmVycyBmb3IgYSBwYXJ0aWN1bGFyIHtAZ2xvc3NhcnkgZXZlbnR9IChpZiBhbnkpLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IFtlXSAtIFRoZSB0YXJnZXRlZCB7QGdsb3NzYXJ5IGV2ZW50fS5cblx0KiBAcmV0dXJucyB7T2JqZWN0W119IEV2ZW50IGxpc3RlbmVycyBhcmUgc3RvcmVkIGluIFtoYXNoZXNde0BnbG9zc2FyeSBPYmplY3R9LlxuXHQqXHRUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYW4gW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IG9mIHRoZXNlIGhhc2hlc1xuXHQqIGlmIGFueSBsaXN0ZW5lcnMgZXhpc3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRsaXN0ZW5lcnM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGV1aWQgPSB0aGlzLmV1aWQgfHwgKHRoaXMuZXVpZCA9IHV0aWxzLnVpZCgnZScpKVxuXHRcdFx0LCBsb2MgPSBldmVudFRhYmxlW2V1aWRdIHx8IChldmVudFRhYmxlW2V1aWRdID0gW10pO1xuXHRcdFxuXHRcdHJldHVybiAhZT8gbG9jOiBsb2MuZmlsdGVyKGZ1bmN0aW9uIChsbikge1xuXHRcdFx0cmV0dXJuIGxuLmV2ZW50ID09IGUgfHwgbG4uZXZlbnQgPT0gJyonO1xuXHRcdH0pO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQGFsaWFzIGVueW8uRXZlbnRFbWl0dGVyLmVtaXRcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dHJpZ2dlckV2ZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zaWxlbmNlZD8gZW1pdCh0aGlzLCBhcmd1bWVudHMpOiBmYWxzZTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEVtaXRzIHRoZSBuYW1lZCB7QGdsb3NzYXJ5IGV2ZW50fS4gQWxsIHN1YnNlcXVlbnQgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkXG5cdCogdG8gdGhlIGV2ZW50IGxpc3RlbmVycy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBlIC0gVGhlIHtAZ2xvc3NhcnkgZXZlbnR9IHRvIGVtaXQuXG5cdCogQHBhcmFtIHsuLi4qfSBhcmdzIEFsbCBzdWJzZXF1ZW50IGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCBhbnkgbGlzdGVuZXJzIHdlcmUgbm90aWZpZWQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRlbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zaWxlbmNlZD8gZW1pdCh0aGlzLCBhcmd1bWVudHMpOiBmYWxzZTtcblx0fVxufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL3V0aWxzXCI6NzV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4qIEFuIFtYSFIyXXtAbGlua3BsYWluIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0L30gRm9ybURhdGEgaW1wbGVtZW50YXRpb24uXG4qIEl0IGlzIHVzZWQgdG8gc2VuZCBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgW0FqYXhde0BnbG9zc2FyeSBhamF4fSByZXF1ZXN0cy4gVGhlXG4qIGludGVybmFsIGBlbnlvLkJsb2JgIFtraW5kXXtAZ2xvc3Nhcnkga2luZH0gaXMgdGhlIGNvbnRlbnQgcHJvdmlkZXIgZm9yIGZpbGUtcGFydHMuXG4qXG4qIE5vdGUgdGhhdCBpbiBJbnRlcm5ldCBFeHBsb3JlciA8IDEwLCBib3RoIHtAbGluayBlbnlvLkZvcm1EYXRhfSBhbmQgYGVueW8uQmxvYmAgYXJlXG4qIGxpbWl0ZWQgdG8gW3N0cmluZ117QGdsb3NzYXJ5IFN0cmluZ30gY29udGVudCBhbmQgYGVueW8uQmxvYmAgbWF5IG9ubHkgYmVcbiogaW5zdGFudGlhdGVkIHVzaW5nIGFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvciBbc3RyaW5nXXtAZ2xvc3NhcnkgU3RyaW5nfS5cbipcbiogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbnNwaXJlZCBieVxuKiBbaHRtbDUtZm9ybWRhdGFde0BsaW5rcGxhaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZyYW5jb2lzMm1ldHovaHRtbDUtZm9ybWRhdGEvYmxvYi9tYXN0ZXIvZm9ybWRhdGEuanN9LlxuKlxuKiBgYGBcbiogRW11bGF0ZSBGb3JtRGF0YSBmb3Igc29tZSBicm93c2Vyc1xuKiBNSVQgTGljZW5zZVxuKiAoYykgMjAxMCBGcmFuY29pcyBkZSBNZXR6XG4qIGBgYFxuKlxuKiBAY2xhc3MgZW55by5Gb3JtRGF0YVxuKiBAcHVibGljXG4qL1xuZXhwb3J0cyA9IG51bGw7XG5cbmlmICh0eXBlb2YgRm9ybURhdGEgIT0gJ3VuZGVmaW5lZCcpIHtcblx0dHJ5IHtcblx0XHRuZXcgRm9ybURhdGEoKTtcblx0XHRcblx0XHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGb3JtRGF0YTtcblx0Ly8gQW5kcm9pZCBDaHJvbWUgMTggd2lsbCB0aHJvdyBhbiBlcnJvciB0cnlpbmcgdG8gY3JlYXRlIHRoaXNcblx0fSBjYXRjaCAoZSkge31cbn1cblxuaWYgKCFleHBvcnRzKSB7XG5cblx0Lypqc2hpbnQgLVcwODIgKi9cblx0ZnVuY3Rpb24gRm9ybURhdGEoKSB7XG5cdFx0dGhpcy5mYWtlID0gdHJ1ZTtcblx0XHR0aGlzLl9maWVsZHMgPSBbXTtcblx0XHQvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvXG5cdFx0Ly8gdGhvc2UgdXNlZCBieSBGaXJlZm94LiAgVGhleSBhcmUgb3B0aW1pemVkIGZvclxuXHRcdC8vIGJveWVyLW1vb3JlIHBhcnNpbmcuXG5cdFx0dGhpcy5ib3VuZGFyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSc7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG5cdFx0XHR0aGlzLmJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XG5cdFx0fVxuXHR9XG5cdEZvcm1EYXRhLnByb3RvdHlwZS5nZXRDb250ZW50VHlwZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PVwiICsgdGhpcy5ib3VuZGFyeTtcblx0fTtcblx0Rm9ybURhdGEucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGZpbGVuYW1lKSB7XG5cdFx0dGhpcy5fZmllbGRzLnB1c2goW2tleSwgdmFsdWUsIGZpbGVuYW1lXSk7XG5cdH07XG5cdEZvcm1EYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib3VuZGFyeSA9IHRoaXMuYm91bmRhcnk7XG5cdFx0dmFyIGJvZHkgPSBcIlwiO1xuXHRcdHV0aWxzLmZvckVhY2godGhpcy5fZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xuXHRcdFx0Ym9keSArPSBcIi0tXCIgKyBib3VuZGFyeSArIFwiXFxyXFxuXCI7XG5cdFx0XHRpZiAoZmllbGRbMl0gfHwgZmllbGRbMV0ubmFtZSkge1xuXHRcdFx0XHQvLyBmaWxlIHVwbG9hZFxuXHRcdFx0XHR2YXIgZmlsZSA9IGZpZWxkWzFdLCBmaWxlbmFtZSA9IGZpZWxkWzJdIHx8IGZpbGUubmFtZTtcblx0XHRcdFx0Ym9keSArPSBcIkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cXFwiXCIrIGZpZWxkWzBdICtcIlxcXCI7IGZpbGVuYW1lPVxcXCJcIisgZmlsZW5hbWUgK1wiXFxcIlxcclxcblwiO1xuXHRcdFx0XHRib2R5ICs9IFwiQ29udGVudC1UeXBlOiBcIisgZmlsZS50eXBlICtcIlxcclxcblxcclxcblwiO1xuXHRcdFx0XHRib2R5ICs9IGZpbGUuZ2V0QXNCaW5hcnkoKSArIFwiXFxyXFxuXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBrZXktdmFsdWUgZmllbGRcblx0XHRcdFx0Ym9keSArPSBcIkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cXFwiXCIrIGZpZWxkWzBdICtcIlxcXCI7XFxyXFxuXFxyXFxuXCI7XG5cdFx0XHRcdGJvZHkgKz0gZmllbGRbMV0gKyBcIlxcclxcblwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGJvZHkgKz0gXCItLVwiICsgYm91bmRhcnkgK1wiLS1cIjtcblx0XHRyZXR1cm4gYm9keTtcblx0fTtcblx0Lypqc2hpbnQgK1cwODIgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gRm9ybURhdGE7XG59XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi91dGlsc1wiOjc1fV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuKiBEZXRlcm1pbmVzIE9TIHZlcnNpb25zIG9mIHBsYXRmb3JtcyB0aGF0IG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQuIENhbiBoYXZlIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4qIHByb3BlcnRpZXM6XG4qXG4qICogYW5kcm9pZFxuKiAqIGFuZHJvaWRDaHJvbWUgKENocm9tZSBvbiBBbmRyb2lkLCBzdGFuZGFyZCBzdGFydGluZyBpbiA0LjEpXG4qICogYW5kcm9pZEZpcmVmb3hcbiogKiBpZVxuKiAqIGlvc1xuKiAqIHdlYm9zXG4qICogd2luZG93c1Bob25lXG4qICogYmxhY2tiZXJyeVxuKiAqIHRpemVuXG4qICogc2FmYXJpIChkZXNrdG9wIHZlcnNpb24pXG4qICogY2hyb21lIChkZXNrdG9wIHZlcnNpb24pXG4qICogZmlyZWZveCAoZGVza3RvcCB2ZXJzaW9uKVxuKiAqIGZpcmVmb3hPU1xuKlxuKiBJZiB0aGUgcHJvcGVydHkgaXMgZGVmaW5lZCwgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBwbGF0Zm9ybS5cbipcbiogRXhhbXBsZTpcbiogYGBgamF2YXNjcmlwdFxuKiAvLyBhbmRyb2lkIDIgZG9lcyBub3QgaGF2ZSAzZCBjc3NcbiogaWYgKGVueW8ucGxhdGZvcm0uYW5kcm9pZCA8IDMpIHtcbiogXHR0ID0gJ3RyYW5zbGF0ZSgzMHB4LCA1MHB4KSc7XG4qIH0gZWxzZSB7XG4qIFx0dCA9ICd0cmFuc2xhdGUzZCgzMHB4LCA1MHB4LCAwKSc7XG4qIH1cbiogdGhpcy5hcHBseVN0eWxlKCctd2Via2l0LXRyYW5zZm9ybScsIHQpO1xuKiBgYGBcbipcbiogQG5hbWUgZW55by5wbGF0Zm9ybVxuKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFxuXHQvKiogQGxlbmRzIGVueW8ucGxhdGZvcm0gKi8ge1xuXHQvLyogYHRydWVgIGlmIHRoZSBwbGF0Zm9ybSBoYXMgbmF0aXZlIHNpbmdsZS1maW5nZXIgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fS5cblx0dG91Y2g6IEJvb2xlYW4oKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzKSxcblx0Ly8qIGB0cnVlYCBpZiB0aGUgcGxhdGZvcm0gaGFzIG5hdGl2ZSBkb3VibGUtZmluZ2VyIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uXG5cdGdlc3R1cmU6IEJvb2xlYW4oKCdvbmdlc3R1cmVzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMpXG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xudmFyIGVwID0gZXhwb3J0cztcbnZhciBwbGF0Zm9ybXMgPSBbXG5cdC8vIEFuZHJvaWQgNCsgdXNpbmcgQ2hyb21lXG5cdHtwbGF0Zm9ybTogJ2FuZHJvaWRDaHJvbWUnLCByZWdleDogL0FuZHJvaWQgLiogQ2hyb21lXFwvKFxcZCspWy5cXGRdKy99LFxuXHQvLyBBbmRyb2lkIDIgLSA0XG5cdHtwbGF0Zm9ybTogJ2FuZHJvaWQnLCByZWdleDogL0FuZHJvaWQgKFxcZCspL30sXG5cdC8vIEtpbmRsZSBGaXJlXG5cdC8vIEZvcmNlIHZlcnNpb24gdG8gMiwgKGRlc2t0b3AgbW9kZSBkb2VzIG5vdCBsaXN0IGFuZHJvaWQgdmVyc2lvbilcblx0e3BsYXRmb3JtOiAnYW5kcm9pZCcsIHJlZ2V4OiAvU2lsa1xcLzEuLywgZm9yY2VWZXJzaW9uOiAyLCBleHRyYToge3NpbGs6IDF9fSxcblx0Ly8gS2luZGxlIEZpcmUgSEQgKFNpbGsgdmVyc2lvbnMgMiBvciAzKVxuXHQvLyBGb3JjZSB2ZXJzaW9uIHRvIDRcblx0e3BsYXRmb3JtOiAnYW5kcm9pZCcsIHJlZ2V4OiAvU2lsa1xcLzIuLywgZm9yY2VWZXJzaW9uOiA0LCBleHRyYToge3NpbGs6IDJ9fSxcblx0e3BsYXRmb3JtOiAnYW5kcm9pZCcsIHJlZ2V4OiAvU2lsa1xcLzMuLywgZm9yY2VWZXJzaW9uOiA0LCBleHRyYToge3NpbGs6IDN9fSxcblx0Ly8gV2luZG93cyBQaG9uZSA3IC0gOFxuXHR7cGxhdGZvcm06ICd3aW5kb3dzUGhvbmUnLCByZWdleDogL1dpbmRvd3MgUGhvbmUgKD86T1MgKT8oXFxkKylbLlxcZF0rL30sXG5cdC8vIElFIDggLSAxMFxuXHR7cGxhdGZvcm06ICdpZScsIHJlZ2V4OiAvTVNJRSAoXFxkKykvfSxcblx0Ly8gSUUgMTFcblx0e3BsYXRmb3JtOiAnaWUnLCByZWdleDogL1RyaWRlbnRcXC8uKjsgcnY6KFxcZCspL30sXG5cdC8vIGlPUyAzIC0gNVxuXHQvLyBBcHBsZSBsaWtlcyB0byBtYWtlIHRoaXMgY29tcGxpY2F0ZWRcblx0e3BsYXRmb3JtOiAnaW9zJywgcmVnZXg6IC9pUCg/OmhvbmV8YWQ7KD86IFU7KT8gQ1BVKSBPUyAoXFxkKykvfSxcblx0Ly8gd2ViT1MgMSAtIDNcblx0e3BsYXRmb3JtOiAnd2Vib3MnLCByZWdleDogLyg/OndlYnxocHcpT1NcXC8oXFxkKykvfSxcblx0Ly8gd2ViT1MgNCAvIE9wZW5XZWJPU1xuXHR7cGxhdGZvcm06ICd3ZWJvcycsIHJlZ2V4OiAvV2ViQXBwTWFuYWdlcnxJc2lzfHdlYk9TXFwuLywgZm9yY2VWZXJzaW9uOiA0fSxcblx0Ly8gT3BlbiB3ZWJPUyByZWxlYXNlIEx1bmVPU1xuXHR7cGxhdGZvcm06ICd3ZWJvcycsIHJlZ2V4OiAvTHVuZU9TLywgZm9yY2VWZXJzaW9uOiA0LCBleHRyYToge2x1bmVvczogMX19LFxuXHQvLyBkZXNrdG9wIFNhZmFyaVxuXHR7cGxhdGZvcm06ICdzYWZhcmknLCByZWdleDogL1ZlcnNpb25cXC8oXFxkKylbLlxcZF0rXFxzK1NhZmFyaS99LFxuXHQvLyBkZXNrdG9wIENocm9tZVxuXHR7cGxhdGZvcm06ICdjaHJvbWUnLCByZWdleDogL0Nocm9tZVxcLyhcXGQrKVsuXFxkXSsvfSxcblx0Ly8gRmlyZWZveCBvbiBBbmRyb2lkXG5cdHtwbGF0Zm9ybTogJ2FuZHJvaWRGaXJlZm94JywgcmVnZXg6IC9BbmRyb2lkOy4qRmlyZWZveFxcLyhcXGQrKS99LFxuXHQvLyBGaXJlZm94T1Ncblx0e3BsYXRmb3JtOiAnZmlyZWZveE9TJywgcmVnZXg6IC9Nb2JpbGU7LipGaXJlZm94XFwvKFxcZCspL30sXG5cdC8vIGRlc2t0b3AgRmlyZWZveFxuXHR7cGxhdGZvcm06ICdmaXJlZm94JywgcmVnZXg6IC9GaXJlZm94XFwvKFxcZCspL30sXG5cdC8vIEJsYWNrYmVycnkgUGxheWJvb2tcblx0e3BsYXRmb3JtOiAnYmxhY2tiZXJyeScsIHJlZ2V4OiAvUGxheUJvb2svaSwgZm9yY2VWZXJzaW9uOiAyfSxcblx0Ly8gQmxhY2tiZXJyeSAxMCtcblx0e3BsYXRmb3JtOiAnYmxhY2tiZXJyeScsIHJlZ2V4OiAvQkIxXFxkOy4qVmVyc2lvblxcLyhcXGQrXFwuXFxkKykvfSxcblx0Ly8gVGl6ZW5cblx0e3BsYXRmb3JtOiAndGl6ZW4nLCByZWdleDogL1RpemVuIChcXGQrKS99XG5dO1xuZm9yICh2YXIgaSA9IDAsIHAsIG0sIHY7IChwID0gcGxhdGZvcm1zW2ldKTsgaSsrKSB7XG5cdG0gPSBwLnJlZ2V4LmV4ZWModWEpO1xuXHRpZiAobSkge1xuXHRcdGlmIChwLmZvcmNlVmVyc2lvbikge1xuXHRcdFx0diA9IHAuZm9yY2VWZXJzaW9uO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2ID0gTnVtYmVyKG1bMV0pO1xuXHRcdH1cblx0XHRlcFtwLnBsYXRmb3JtXSA9IHY7XG5cdFx0aWYgKHAuZXh0cmEpIHtcblx0XHRcdHV0aWxzLm1peGluKGVwLCBwLmV4dHJhKTtcblx0XHR9XG5cdFx0ZXAucGxhdGZvcm1OYW1lID0gcC5wbGF0Zm9ybTtcblx0XHRicmVhaztcblx0fVxufVxuXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi91dGlsc1wiOjc1fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgbXMgPSBNYXRoLnJvdW5kKDEwMDAvNjApO1xudmFyIHByZWZpeCA9IFsnd2Via2l0JywgJ21veicsICdtcycsICdvJywgJyddO1xudmFyIHIgPSAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJztcbnZhciBjID0gJ2NhbmNlbCcgKyB1dGlscy5jYXAocik7XG5cbi8qXG4qIEZhbGxiYWNrIG9uIHNldFRpbWVvdXRcbipcbiogQHByaXZhdGVcbiovXG52YXIgX3JlcXVlc3RGcmFtZSA9IGZ1bmN0aW9uKGluQ2FsbGJhY2spIHtcblx0cmV0dXJuIGdsb2JhbC5zZXRUaW1lb3V0KGluQ2FsbGJhY2ssIG1zKTtcbn07XG5cbi8qXG4qIEZhbGxiYWNrIG9uIGNsZWFyVGltZW91dFxuKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBfY2FuY2VsRnJhbWUgPSBmdW5jdGlvbihpbklkKSB7XG5cdHJldHVybiBnbG9iYWwuY2xlYXJUaW1lb3V0KGluSWQpO1xufTtcblxuZm9yICh2YXIgaSA9IDAsIHBsID0gcHJlZml4Lmxlbmd0aCwgcCwgd2MsIHdyOyAocCA9IHByZWZpeFtpXSkgfHwgaSA8IHBsOyBpKyspIHtcblx0Ly8gaWYgd2UncmUgb24gaW9zIDYganVzdCB1c2Ugc2V0VGltZW91dCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhhcyBzb21lIGtpbmtzIGN1cnJlbnRseVxuXHRpZiAocGxhdGZvcm0uaW9zID49IDYpIHtcblx0XHRicmVhaztcblx0fVxuXG5cdC8vIGlmIHByZWZpeGVkLCBiZWNvbWVzIFJlcXVlc3QgYW5kIENhbmNlbFxuXHR3YyA9IHAgPyAocCArIHV0aWxzLmNhcChjKSkgOiBjO1xuXHR3ciA9IHAgPyAocCArIHV0aWxzLmNhcChyKSkgOiByO1xuXHQvLyBUZXN0IGZvciBjYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGJlY2F1c2Ugc29tZSBicm93c2VycyAoRmlyZWZpeCA0LTEwKSBoYXZlIGEgcmVxdWVzdCB3aXRob3V0IGEgY2FuY2VsXG5cdGlmIChnbG9iYWxbd2NdKSB7XG5cdFx0X2NhbmNlbEZyYW1lID0gZ2xvYmFsW3djXTtcblx0XHRfcmVxdWVzdEZyYW1lID0gZ2xvYmFsW3dyXTtcblx0XHRpZiAocCA9PSAnd2Via2l0Jykge1xuXHRcdFx0Lypcblx0XHRcdFx0Tm90ZTogSW4gQ2hyb21lLCB0aGUgZmlyc3QgcmV0dXJuIHZhbHVlIG9mIHdlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyAwLlxuXHRcdFx0XHRXZSBtYWtlIDEgYm9ndXMgY2FsbCBzbyB0aGUgZmlyc3QgdXNlZCByZXR1cm4gdmFsdWUgb2Ygd2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzID4gMCwgYXMgdGhlIHNwZWMgcmVxdWlyZXMuXG5cdFx0XHRcdFRoaXMgbWFrZXMgaXQgc28gdGhhdCB0aGUgcmVxdWVzdElkIGlzIGFsd2F5cyB0cnV0aHkuXG5cdFx0XHRcdCh3ZSBjaG9vc2UgdG8gZG8gdGhpcyByYXRoZXIgdGhhbiB3cmFwcGluZyB0aGUgbmF0aXZlIGZ1bmN0aW9uIHRvIGF2b2lkIHRoZSBvdmVyaGVhZClcblx0XHRcdCovXG5cdFx0XHRfY2FuY2VsRnJhbWUoX3JlcXVlc3RGcmFtZSh1dGlscy5ub3ApKTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdH1cbn1cbi8qKlxuKiBSZXF1ZXN0cyBhbiBhbmltYXRpb24gY2FsbGJhY2suXG4qXG4qIE9uIGNvbXBhdGlibGUgYnJvd3NlcnMsIGlmIGBub2RlYCBpcyBkZWZpbmVkLCB0aGUgW2NhbGxiYWNrXXtAZ2xvc3NhcnkgY2FsbGJhY2t9IHdpbGxcbiogZmlyZSBvbmx5IGlmIGBub2RlYCBpcyB2aXNpYmxlLlxuKlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgW2NhbGxiYWNrXXtAZ2xvc3NhcnkgY2FsbGJhY2t9IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gZnJhbWUuXG4qIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBET00gbm9kZSB0byByZXF1ZXN0IHRoZSBhbmltYXRpb24gZnJhbWUgZm9yLlxuKiBAcmV0dXJucyB7T2JqZWN0fSBBIHJlcXVlc3QgaWQgdG8gYmUgdXNlZCB3aXRoXG4qICAgICAgICAgICAgICAgICAgICAgW2VueW8uY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKClde0BsaW5rIGVueW8uY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lfS5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIG5vZGUpIHtcblx0cmV0dXJuIF9yZXF1ZXN0RnJhbWUoY2FsbGJhY2ssIG5vZGUpO1xufTtcbi8qKlxuKiBDYW5jZWxzIGEgcmVxdWVzdGVkIGFuaW1hdGlvbiBjYWxsYmFjayB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuXG4qXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGluSWQpIHtcblx0cmV0dXJuIF9jYW5jZWxGcmFtZShpbklkKTtcbn07XG5cbi8qKlxuKiBBIHNldCBvZiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucyBmb3IgYW5pbWF0aW9ucywgc2ltaWxhciBpbiBmdW5jdGlvbiB0byBDU1MzXG4qIHRyYW5zaXRpb25zLlxuKlxuKiBUaGVzZSBhcmUgaW50ZW5kZWQgZm9yIHVzZSB3aXRoIHtAbGluayBlbnlvLmVhc2VkTGVycH0uIEVhY2ggZWFzaW5nIGZ1bmN0aW9uXG4qIGFjY2VwdHMgb25lICgxKSBbTnVtYmVyXXtAZ2xvc3NhcnkgTnVtYmVyfSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgb25lICgxKVxuKiBbTnVtYmVyXXtAZ2xvc3NhcnkgTnVtYmVyfSB2YWx1ZS5cbipcbiogQG5hbWVzcGFjZSBlbnlvLmVhc2luZ1xuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5lYXNpbmcgPSAvKiogQGxlbmRzIGVueW8uZWFzaW5nICovIHtcblx0LyoqXG5cdCogY3ViaWNJblxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjdWJpY0luOiBmdW5jdGlvbihuKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KG4sIDMpO1xuXHR9LFxuXHQvKipcblx0KiBjdWJpY091dFxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjdWJpY091dDogZnVuY3Rpb24obikge1xuXHRcdHJldHVybiBNYXRoLnBvdyhuIC0gMSwgMykgKyAxO1xuXHR9LFxuXHQvKipcblx0KiBleHBvT3V0XG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGV4cG9PdXQ6IGZ1bmN0aW9uKG4pIHtcblx0XHRyZXR1cm4gKG4gPT0gMSkgPyAxIDogKC0xICogTWF0aC5wb3coMiwgLTEwICogbikgKyAxKTtcblx0fSxcblx0LyoqXG5cdCogcXVhZEluT3V0XG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHF1YWRJbk91dDogZnVuY3Rpb24obikge1xuXHRcdG4gPSBuICogMjtcblx0XHRpZiAobiA8IDEpIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyhuLCAyKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiAtMSAqICgoLS1uKSAqIChuIC0gMikgLSAxKSAvIDI7XG5cdH0sXG5cdC8qKlxuXHQqIGxpbmVhclxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRsaW5lYXI6IGZ1bmN0aW9uKG4pIHtcblx0XHRyZXR1cm4gbjtcblx0fVxufTtcblxuLyoqXG4qIEdpdmVzIGFuIGludGVycG9sYXRpb24gb2YgYW4gYW5pbWF0ZWQgdHJhbnNpdGlvbidzIGRpc3RhbmNlIGZyb20gMCB0byAxLlxuKlxuKiBHaXZlbiBhIHN0YXJ0IHRpbWUgKGB0MGApIGFuZCBhbiBhbmltYXRpb24gZHVyYXRpb24gKGBkdXJhdGlvbmApLCB0aGlzXG4qIG1ldGhvZCBhcHBsaWVzIHRoZSBgZWFzaW5nYCBmdW5jdGlvbiB0byB0aGUgcGVyY2VudGFnZSBvZiB0aW1lIGVsYXBzZWRcbiogZGl2aWRlZCBieSBkdXJhdGlvbiwgY2FwcGVkIGF0IDEwMCUuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB0MCAtIFN0YXJ0IHRpbWUuXG4qIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiAtIER1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nIC0gQW4gZWFzaW5nIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSByZWZlcmVuY2UgZnJvbVxuKlx0e0BsaW5rIGVueW8uZWFzaW5nfS5cbiogQHBhcmFtIHtCb29sZWFufSByZXZlcnNlIC0gV2hldGhlciB0aGUgYW5pbWF0aW9uIHdpbGwgcnVuIGluIHJldmVyc2UuXG4qIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSByZXN1bHRpbmcgcG9zaXRpb24sIGNhcHBlZCBhdCBhIG1heGltdW0gb2YgMTAwJS5cbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuZWFzZWRMZXJwID0gZnVuY3Rpb24odDAsIGR1cmF0aW9uLCBlYXNpbmcsIHJldmVyc2UpIHtcblx0dmFyIGxlcnAgPSAodXRpbHMucGVyZk5vdygpIC0gdDApIC8gZHVyYXRpb247XG5cdGlmIChyZXZlcnNlKSB7XG5cdFx0cmV0dXJuIGxlcnAgPj0gMSA/IDAgOiAoMSAtIGVhc2luZygxIC0gbGVycCkpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBsZXJwID49IDEgPyAxIDogZWFzaW5nKGxlcnApO1xuXHR9XG59O1xuXG4vKipcbiogR2l2ZXMgYW4gaW50ZXJwb2xhdGlvbiBvZiBhbiBhbmltYXRlZCB0cmFuc2l0aW9uJ3MgZGlzdGFuY2UgZnJvbVxuKiBgc3RhcnRWYWx1ZWAgdG8gYHZhbHVlQ2hhbmdlYC5cbipcbiogQXBwbGllcyB0aGUgYGVhc2luZ2AgZnVuY3Rpb24gd2l0aCBhIHdpZGVyIHJhbmdlIG9mIHZhcmlhYmxlcyB0byBhbGxvdyBmb3JcbiogbW9yZSBjb21wbGV4IGFuaW1hdGlvbnMuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB0MCAtIFN0YXJ0IHRpbWUuXG4qIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiAtIER1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nIC0gQW4gZWFzaW5nIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSByZWZlcmVuY2UgZnJvbVxuKlx0e0BsaW5rIGVueW8uZWFzaW5nfS5cbiogQHBhcmFtIHtCb29sZWFufSByZXZlcnNlIC0gV2hldGhlciB0aGUgYW5pbWF0aW9uIHdpbGwgcnVuIGluIHJldmVyc2UuXG4qIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4qIEBwYXJhbSB7TnVtYmVyfSBzdGFydFZhbHVlIC0gU3RhcnRpbmcgdmFsdWUuXG4qIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZUNoYW5nZVxuKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uLCBjYXBwZWQgYXQgYSBtYXhpbXVtIG9mIDEwMCUuXG4qIEBwdWJsaWNcbiovXG5leHBvcnRzLmVhc2VkQ29tcGxleExlcnAgPSBmdW5jdGlvbih0MCwgZHVyYXRpb24sIGVhc2luZywgcmV2ZXJzZSwgdGltZSwgc3RhcnRWYWx1ZSwgdmFsdWVDaGFuZ2UpIHtcblx0dmFyIGxlcnAgPSAodXRpbHMucGVyZk5vdygpIC0gdDApIC8gZHVyYXRpb247XG5cdGlmIChyZXZlcnNlKSB7XG5cdFx0cmV0dXJuIGVhc2luZygxIC0gbGVycCwgdGltZSwgc3RhcnRWYWx1ZSwgdmFsdWVDaGFuZ2UsIGR1cmF0aW9uKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZWFzaW5nKGxlcnAsIHRpbWUsIHN0YXJ0VmFsdWUsIHZhbHVlQ2hhbmdlLCBkdXJhdGlvbik7XG5cdH1cbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL3BsYXRmb3JtXCI6NzEsXCIuL3V0aWxzXCI6NzV9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRyb290cyA9IHJlcXVpcmUoJy4vcm9vdHMnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi9wbGF0Zm9ybScpO1xuXG4vKipcbiogQG5hbWVzcGFjZSBlbnlvLmRvbVxuKi9cbnZhciBkb20gPSBtb2R1bGUuZXhwb3J0cyA9XG5cdC8qKiBAbGVuZHMgZW55by5kb20gKi8ge1xuXG5cdC8qKlxuXHQqIFNob3J0Y3V0IGZvciBgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoKWAgaWYgYGlkYCBpcyBhIHN0cmluZzsgb3RoZXJ3aXNlLFxuXHQqIHJldHVybnMgYGlkYC4gVXNlcyBgZ2xvYmFsLmRvY3VtZW50YCB1bmxlc3MgYSBkb2N1bWVudCBpcyBzcGVjaWZpZWQgaW4gdGhlXG5cdCogKG9wdGlvbmFsKSBgZG9jYCBwYXJhbWV0ZXIuXG5cdCpcblx0KiBgYGBqYXZhc2NyaXB0XG5cdCogLy8gZmluZCAnbm9kZScgaWYgaXQncyBhIHN0cmluZyBpZCwgb3IgcmV0dXJuIGl0IHVuY2hhbmdlZCBpZiBpdCdzIGFscmVhZHkgYSBub2RlIHJlZmVyZW5jZVxuXHQqIHZhciBkb21Ob2RlID0gZW55by5kb20uYnlJZChub2RlKTtcblx0KiBgYGBcblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFRoZSBkb2N1bWVudCBlbGVtZW50IElEIHRvIGdldC5cblx0KiBAcGFyYW0ge05vZGV9IFtkb2NdIC0gQSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIHNlYXJjaCBpbi4gRGVmYXVsdCBpcyB0aGUgd2hvbGVcblx0Klx0ZG9jdW1lbnQuXG5cdCogQHJldHVybnMge0VsZW1lbnR9IEEgcmVmZXJlbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRieUlkOiBmdW5jdGlvbihpZCwgZG9jKXtcblx0XHRyZXR1cm4gKHR5cGVvZiBpZCA9PSAnc3RyaW5nJykgPyAoZG9jIHx8IGRvY3VtZW50KS5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYW1wZXJzYW5kLCBsZXNzLXRoYW4sIGFuZCBncmVhdGVyLXRoYW4gY2hhcmFjdGVycyByZXBsYWNlZCB3aXRoIEhUTUxcblx0KiBlbnRpdGllcywgZS5nLixcblx0KiBgYGBcblx0KiAnJmx0O2NvZGUmZ3Q7J1RoaXMgJmFtcDsgVGhhdCcmbHQ7L2NvZGUmZ3Q7J1xuXHQqIGBgYFxuXHQqIGJlY29tZXNcblx0KiBgYGBcblx0KiAnJmFtcDtsdDtjb2RlJmFtcDtndDsnVGhpcyAmYW1wO2FtcDsgVGhhdCcmYW1wO2x0Oy9jb2RlJmFtcDtndDsnXG5cdCogYGBgXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIEEgc3RyaW5nIHdpdGggZW50aXRpZXMgeW91J2QgbGlrZSB0byBlc2NhcGUvY29udmVydC5cblx0KiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyB0aGF0IGlzIHByb3Blcmx5IGVzY2FwZWQgKHRoZSBhYm92ZSBjaGFyYWN0ZXJzLilcblx0KiBAcHVibGljXG5cdCovXG5cdGVzY2FwZTogZnVuY3Rpb24odGV4dCkge1xuXHRcdHJldHVybiB0ZXh0ICE9PSBudWxsID8gU3RyaW5nKHRleHQpLnJlcGxhY2UoLyYvZywnJmFtcDsnKS5yZXBsYWNlKC88L2csJyZsdDsnKS5yZXBsYWNlKC8+L2csJyZndDsnKSA6ICcnO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGdlb21ldHJ5IG9mIHRoaXMgbm9kZS5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbiAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIG1lYXN1cmUuXG5cdCogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgYHRvcGAsIGBsZWZ0YCxcblx0KiBgaGVpZ2h0YCwgYW5kIGB3aWR0aGAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKG4pIHtcblx0XHRpZiAobikge1xuXHRcdFx0cmV0dXJuIHtsZWZ0OiBuLm9mZnNldExlZnQsIHRvcDogbi5vZmZzZXRUb3AsIHdpZHRoOiBuLm9mZnNldFdpZHRoLCBoZWlnaHQ6IG4ub2Zmc2V0SGVpZ2h0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogVGhpcyBpcyBkZXNpZ25lZCB0byBiZSBjb3BpZWQgaW50byB0aGUgYGNvbXB1dGVkU3R5bGVgIG9iamVjdC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9pZThHZXRDb21wdXRlZFN0eWxlOiBmdW5jdGlvbihwcm9wKSB7XG5cdFx0dmFyIHJlID0gLyhcXC0oW2Etel0pezF9KS9nO1xuXHRcdGlmIChwcm9wID09PSAnZmxvYXQnKSB7XG5cdFx0XHRwcm9wID0gJ3N0eWxlRmxvYXQnO1xuXHRcdH0gZWxzZSBpZiAocmUudGVzdChwcm9wKSkge1xuXHRcdFx0cHJvcCA9IHByb3AucmVwbGFjZShyZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzWzJdLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF0gIT09IHVuZGVmaW5lZCA/IHRoaXNbcHJvcF0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldENvbXB1dGVkU3R5bGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRpZihwbGF0Zm9ybS5pZSA8IDkgJiYgbm9kZSAmJiBub2RlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0Ly9zaW1wbGUgZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUgcG9seWZpbGwgZm9yIElFOFxuXHRcdFx0dmFyIGNvbXB1dGVkU3R5bGUgPSB1dGlscy5jbG9uZShub2RlLmN1cnJlbnRTdHlsZSk7XG5cdFx0XHRjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUgPSB0aGlzLl9pZThHZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0Y29tcHV0ZWRTdHlsZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5jdXJyZW50U3R5bGUuc2V0RXhwcmVzc2lvbi5hcHBseShub2RlLmN1cnJlbnRTdHlsZSwgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRjb21wdXRlZFN0eWxlLnJlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBub2RlLmN1cnJlbnRTdHlsZS5yZW1vdmVBdHRyaWJ1dGUuYXBwbHkobm9kZS5jdXJyZW50U3R5bGUsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVkU3R5bGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZSAmJiBub2RlICYmIGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRDb21wdXRlZFN0eWxlVmFsdWU6IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5LCBjb21wdXRlZFN0eWxlKSB7XG5cdFx0dmFyIHMgICA9IGNvbXB1dGVkU3R5bGUgfHwgdGhpcy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLFxuXHRcdFx0bklFID0gcGxhdGZvcm0uaWU7XG5cblx0XHRzID0gcyA/IHMuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgOiBudWxsO1xuXG5cdFx0aWYgKG5JRSkge1xuXHRcdFx0dmFyIG9Db252ZXJzaW9uID0ge1xuXHRcdFx0XHQndGhpbicgICA6IChuSUUgPiA4ID8gMiA6IDEpICsgJ3B4Jyxcblx0XHRcdFx0J21lZGl1bScgOiAobklFID4gOCA/IDQgOiAzKSArICdweCcsXG5cdFx0XHRcdCd0aGljaycgIDogKG5JRSA+IDggPyA2IDogNSkgKyAncHgnLFxuXHRcdFx0XHQnbm9uZScgICA6ICcwJ1xuXHRcdFx0fTtcblx0XHRcdGlmICh0eXBlb2Ygb0NvbnZlcnNpb25bc10gIT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cyA9IG9Db252ZXJzaW9uW3NdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocyA9PSAnYXV0bycpIHtcblx0XHRcdFx0c3dpdGNoIChwcm9wZXJ0eSkge1xuXHRcdFx0XHRjYXNlICd3aWR0aCc6XG5cdFx0XHRcdFx0cyA9IG5vZGUub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2hlaWdodCc6XG5cdFx0XHRcdFx0cyA9IG5vZGUub2Zmc2V0SGVpZ2h0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHM7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0Rmlyc3RFbGVtZW50QnlUYWdOYW1lOiBmdW5jdGlvbih0YWdOYW1lKSB7XG5cdFx0dmFyIGUgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcblx0XHRyZXR1cm4gZSAmJiBlWzBdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFwcGx5Qm9keUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGggPSB0aGlzLmdldEZpcnN0RWxlbWVudEJ5VGFnTmFtZSgnaHRtbCcpO1xuXHRcdGlmIChoKSB7XG5cdFx0XHR0aGlzLmFkZENsYXNzKGgsICdlbnlvLWRvY3VtZW50LWZpdCcpO1xuXHRcdH1cblx0XHRkb20uYWRkQm9keUNsYXNzKCdlbnlvLWJvZHktZml0Jyk7XG5cdFx0ZG9tLmJvZHlJc0ZpdHRpbmcgPSB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFdpbmRvd1dpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoZ2xvYmFsLmlubmVyV2lkdGgpIHtcblx0XHRcdHJldHVybiBnbG9iYWwuaW5uZXJXaWR0aDtcblx0XHR9XG5cdFx0aWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG5cdFx0fVxuXHRcdGlmIChkb2N1bWVudC5jb21wYXRNb2RlPT0nQ1NTMUNvbXBhdCcgJiZcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoICkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIDMyMDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRXaW5kb3dIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChnbG9iYWwuaW5uZXJIZWlnaHQpIHtcblx0XHRcdHJldHVybiBnbG9iYWwuaW5uZXJIZWlnaHQ7XG5cdFx0fVxuXHRcdGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cdFx0fVxuXHRcdGlmIChkb2N1bWVudC5jb21wYXRNb2RlPT0nQ1NTMUNvbXBhdCcgJiZcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCApIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXHRcdH1cblx0XHRyZXR1cm4gNDgwO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFRoZSBwcm9wb3J0aW9uIGJ5IHdoaWNoIHRoZSBgYm9keWAgdGFnIGRpZmZlcnMgZnJvbSB0aGUgZ2xvYmFsIHNpemUsIGluIGJvdGggWCBhbmQgWVxuXHQqIGRpbWVuc2lvbnMuIFRoaXMgaXMgcmVsZXZhbnQgd2hlbiB3ZSBuZWVkIHRvIHNjYWxlIHRoZSB3aG9sZSBpbnRlcmZhY2UgZG93biBmcm9tIDE5MjB4MTA4MFxuXHQqICgxMDgwcCkgdG8gMTI4MHg3MjAgKDcyMHApLCBmb3IgZXhhbXBsZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9ib2R5U2NhbGVGYWN0b3JZOiAxLFxuXHRfYm9keVNjYWxlRmFjdG9yWDogMSxcblx0dXBkYXRlU2NhbGVGYWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib2R5Qm91bmRzID0gdGhpcy5nZXRCb3VuZHMoZG9jdW1lbnQuYm9keSk7XG5cdFx0dGhpcy5fYm9keVNjYWxlRmFjdG9yWSA9IGJvZHlCb3VuZHMuaGVpZ2h0IC8gdGhpcy5nZXRXaW5kb3dIZWlnaHQoKTtcblx0XHR0aGlzLl9ib2R5U2NhbGVGYWN0b3JYID0gYm9keUJvdW5kcy53aWR0aCAvIHRoaXMuZ2V0V2luZG93V2lkdGgoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHQvLyBXb3JrYXJvdW5kIGZvciBsYWNrIG9mIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHN1cHBvcnQgaW4gSUU4XG5cdC8vIENvZGUgTUlUIExpY2Vuc2VkLCBKb2huIFJlc2lnOyBzb3VyY2U6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9jb21wYXJpbmctZG9jdW1lbnQtcG9zaXRpb24vXG5cdGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0cmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gP1xuXHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOlxuXHRcdGEuY29udGFpbnMgP1xuXHRcdFx0KGEgIT0gYiAmJiBhLmNvbnRhaW5zKGIpICYmIDE2KSArXG5cdFx0XHQoYSAhPSBiICYmIGIuY29udGFpbnMoYSkgJiYgOCkgK1xuXHRcdFx0KGEuc291cmNlSW5kZXggPj0gMCAmJiBiLnNvdXJjZUluZGV4ID49IDAgP1xuXHRcdFx0XHQoYS5zb3VyY2VJbmRleCA8IGIuc291cmNlSW5kZXggJiYgNCkgK1xuXHRcdFx0XHQoYS5zb3VyY2VJbmRleCA+IGIuc291cmNlSW5kZXggJiYgMikgOlxuXHRcdFx0XHQxKSArXG5cdFx0XHQwIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Ly8gbW92ZWQgZnJvbSBGaXR0YWJsZUxheW91dC5qcyBpbnRvIGNvbW1vbiBwcm90ZWN0ZWQgY29kZVxuXHRfaWVDc3NUb1BpeGVsVmFsdWU6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG5cdFx0dmFyIHYgPSB2YWx1ZTtcblx0XHQvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG5cdFx0Ly8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuXHRcdHZhciBzID0gbm9kZS5zdHlsZTtcblx0XHQvLyBzdG9yZSBzdHlsZSBhbmQgcnVudGltZSBzdHlsZSB2YWx1ZXNcblx0XHR2YXIgbCA9IHMubGVmdDtcblx0XHR2YXIgcmwgPSBub2RlLnJ1bnRpbWVTdHlsZSAmJiBub2RlLnJ1bnRpbWVTdHlsZS5sZWZ0O1xuXHRcdC8vIHRoZW4gcHV0IGN1cnJlbnQgc3R5bGUgaW4gcnVudGltZSBzdHlsZS5cblx0XHRpZiAocmwpIHtcblx0XHRcdG5vZGUucnVudGltZVN0eWxlLmxlZnQgPSBub2RlLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdH1cblx0XHQvLyBhcHBseSBnaXZlbiB2YWx1ZSBhbmQgbWVhc3VyZSBpdHMgcGl4ZWwgdmFsdWVcblx0XHRzLmxlZnQgPSB2O1xuXHRcdHYgPSBzLnBpeGVsTGVmdDtcblx0XHQvLyBmaW5hbGx5IHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcblx0XHRzLmxlZnQgPSBsO1xuXHRcdGlmIChybCkge1xuXHRcdFx0cy5ydW50aW1lU3R5bGUubGVmdCA9IHJsO1xuXHRcdH1cblx0XHRyZXR1cm4gdjtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfcHhNYXRjaDogL3B4L2ksXG5cdGdldENvbXB1dGVkQm94VmFsdWU6IGZ1bmN0aW9uKG5vZGUsIHByb3AsIGJvdW5kYXJ5LCBjb21wdXRlZFN0eWxlKSB7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRpZiAocyAmJiAoIXBsYXRmb3JtLmllIHx8IHBsYXRmb3JtLmllID49IDkpKSB7XG5cdFx0XHR2YXIgcCA9IHMuZ2V0UHJvcGVydHlWYWx1ZShwcm9wICsgJy0nICsgYm91bmRhcnkpO1xuXHRcdFx0cmV0dXJuIHAgPT09ICdhdXRvJyA/IDAgOiBwYXJzZUludChwLCAxMCk7XG5cdFx0fSBlbHNlIGlmIChub2RlICYmIG5vZGUuY3VycmVudFN0eWxlKSB7XG5cdFx0XHR2YXIgdiA9IG5vZGUuY3VycmVudFN0eWxlW3Byb3AgKyB1dGlscy5jYXAoYm91bmRhcnkpXTtcblx0XHRcdGlmICghdi5tYXRjaCh0aGlzLl9weE1hdGNoKSkge1xuXHRcdFx0XHR2ID0gdGhpcy5faWVDc3NUb1BpeGVsVmFsdWUobm9kZSwgdik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodiwgMCk7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEdldHMgdGhlIGJvdW5kYXJpZXMgb2YgYSBbbm9kZSdzXXtAZ2xvc3NhcnkgTm9kZX0gYG1hcmdpbmAgb3IgYHBhZGRpbmdgIGJveC5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIG1lYXN1cmUuXG5cdCogQHBhcmFtIHtOb2RlfSBib3ggLSBUaGUgYm91bmRhcnkgdG8gbWVhc3VyZSBmcm9tICgncGFkZGluZycgb3IgJ21hcmdpbicpLlxuXHQqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGB0b3BgLCBgcmlnaHRgLCBgYm90dG9tYCwgYW5kXG5cdCpcdGBsZWZ0YC5cblx0KiBAcHVibGljXG5cdCovXG5cdGNhbGNCb3hFeHRlbnRzOiBmdW5jdGlvbihub2RlLCBib3gpIHtcblx0XHR2YXIgcyA9IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiB0aGlzLmdldENvbXB1dGVkQm94VmFsdWUobm9kZSwgYm94LCAndG9wJywgcyksXG5cdFx0XHRyaWdodDogdGhpcy5nZXRDb21wdXRlZEJveFZhbHVlKG5vZGUsIGJveCwgJ3JpZ2h0JywgcyksXG5cdFx0XHRib3R0b206IHRoaXMuZ2V0Q29tcHV0ZWRCb3hWYWx1ZShub2RlLCBib3gsICdib3R0b20nLCBzKSxcblx0XHRcdGxlZnQ6IHRoaXMuZ2V0Q29tcHV0ZWRCb3hWYWx1ZShub2RlLCBib3gsICdsZWZ0Jywgcylcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIEdldHMgdGhlIGNhbGN1bGF0ZWQgcGFkZGluZyBvZiBhIG5vZGUuIFNob3J0Y3V0IGZvclxuXHQqIFtlbnlvLmRvbS5jYWxjQm94RXh0ZW50cygpXXtAbGluayBlbnlvLmRvbS5jYWxjQm94RXh0ZW50c30uXG5cdCpcblx0KiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgW25vZGVde0BnbG9zc2FyeSBOb2RlfSB0byBtZWFzdXJlLlxuXHQqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGB0b3BgLCBgcmlnaHRgLCBgYm90dG9tYCwgYW5kXG5cdCpcdGBsZWZ0YC5cblx0KiBAcHVibGljXG5cdCovXG5cdGNhbGNQYWRkaW5nRXh0ZW50czogZnVuY3Rpb24obm9kZSkge1xuXHRcdHJldHVybiB0aGlzLmNhbGNCb3hFeHRlbnRzKG5vZGUsICdwYWRkaW5nJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogR2V0cyB0aGUgY2FsY3VsYXRlZCBtYXJnaW4gb2YgYSBub2RlLiBTaG9ydGN1dCBmb3Jcblx0KiBbZW55by5kb20uY2FsY0JveEV4dGVudHMoKV17QGxpbmsgZW55by5kb20uY2FsY0JveEV4dGVudHN9LlxuXHQqXG5cdCogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gdG8gbWVhc3VyZS5cblx0KiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBgdG9wYCwgYHJpZ2h0YCwgYGJvdHRvbWAsIGFuZFxuXHQqXHRgbGVmdGAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjYWxjTWFyZ2luRXh0ZW50czogZnVuY3Rpb24obm9kZSkge1xuXHRcdHJldHVybiB0aGlzLmNhbGNCb3hFeHRlbnRzKG5vZGUsICdtYXJnaW4nKTtcblx0fSxcblx0LyoqXG5cdCogUmV0dXJucyBhbiBvYmplY3QgbGlrZSBge3RvcDogMCwgbGVmdDogMCwgYm90dG9tOiAxMDAsIHJpZ2h0OiAxMDAsIGhlaWdodDogMTAsIHdpZHRoOiAxMH1gXG5cdCogdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QncyBwb3NpdGlvbiByZWxhdGl2ZSB0byBgcmVsYXRpdmVUb05vZGVgIChzdWl0YWJsZSBmb3IgYWJzb2x1dGVcblx0KiBwb3NpdGlvbmluZyB3aXRoaW4gdGhhdCBwYXJlbnQgbm9kZSkuIE5lZ2F0aXZlIHZhbHVlcyBtZWFuIHBhcnQgb2YgdGhlIG9iamVjdCBpcyBub3Rcblx0KiB2aXNpYmxlLiBJZiB5b3UgbGVhdmUgYHJlbGF0aXZlVG9Ob2RlYCBhcyBgdW5kZWZpbmVkYCAob3IgaXQgaXMgbm90IGEgcGFyZW50IGVsZW1lbnQpLCB0aGVuXG5cdCogdGhlIHBvc2l0aW9uIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGFuZCBzdWl0YWJsZSBmb3IgYWJzb2x1dGUgcG9zaXRpb25pbmcgaW4gYVxuXHQqIGZsb2F0aW5nIGxheWVyLlxuXHQqXG5cdCogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gdG8gbWVhc3VyZS5cblx0KiBAcGFyYW0ge05vZGV9IHJlbGF0aXZlVG9Ob2RlIC0gVGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gdG8gbWVhc3VyZSB0aGUgZGlzdGFuY2UgZnJvbS5cblx0KiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBgdG9wYCwgYHJpZ2h0YCwgYGJvdHRvbWAsIGBsZWZ0YCxcblx0Klx0YGhlaWdodGAsIGFuZCBgd2lkdGhgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2FsY05vZGVQb3NpdGlvbjogZnVuY3Rpb24odGFyZ2V0Tm9kZSwgcmVsYXRpdmVUb05vZGUpIHtcblx0XHQvLyBQYXJzZSB1cHdhcmQgYW5kIGdyYWIgb3VyIHBvc2l0aW9uaW5nIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuXHRcdHZhciB0b3AgPSAwLFxuXHRcdFx0bGVmdCA9IDAsXG5cdFx0XHRub2RlID0gdGFyZ2V0Tm9kZSxcblx0XHRcdHdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCxcblx0XHRcdGhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0dHJhbnNmb3JtUHJvcCA9IGRvbS5nZXRTdHlsZVRyYW5zZm9ybVByb3AoKSxcblx0XHRcdHhyZWdleCA9IC90cmFuc2xhdGVYXFwoKC0/XFxkKylweFxcKS9pLFxuXHRcdFx0eXJlZ2V4ID0gL3RyYW5zbGF0ZVlcXCgoLT9cXGQrKXB4XFwpL2ksXG5cdFx0XHRib3JkZXJMZWZ0ID0gMCwgYm9yZGVyVG9wID0gMCxcblx0XHRcdHRvdGFsSGVpZ2h0ID0gMCwgdG90YWxXaWR0aCA9IDAsXG5cdFx0XHRvZmZzZXRBZGp1c3RMZWZ0ID0gMCwgb2Zmc2V0QWRqdXN0VG9wID0gMDtcblxuXHRcdGlmIChyZWxhdGl2ZVRvTm9kZSkge1xuXHRcdFx0dG90YWxIZWlnaHQgPSByZWxhdGl2ZVRvTm9kZS5vZmZzZXRIZWlnaHQ7XG5cdFx0XHR0b3RhbFdpZHRoID0gcmVsYXRpdmVUb05vZGUub2Zmc2V0V2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvdGFsSGVpZ2h0ID0gKGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgPiB0aGlzLmdldFdpbmRvd0hlaWdodCgpID8gdGhpcy5nZXRXaW5kb3dIZWlnaHQoKSAtIGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxUb3AgOiBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0KTtcblx0XHRcdHRvdGFsV2lkdGggPSAoZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLm9mZnNldFdpZHRoID4gdGhpcy5nZXRXaW5kb3dXaWR0aCgpID8gdGhpcy5nZXRXaW5kb3dXaWR0aCgpIC0gZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbExlZnQgOiBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUub2Zmc2V0V2lkdGgpO1xuXHRcdH1cblxuXHRcdGlmIChub2RlLm9mZnNldFBhcmVudCkge1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHQvLyBBZGp1c3QgdGhlIG9mZnNldCBpZiByZWxhdGl2ZVRvTm9kZSBpcyBhIGNoaWxkIG9mIHRoZSBvZmZzZXRQYXJlbnRcblx0XHRcdFx0Ly8gRm9yIElFIDggY29tcGF0aWJpbGl0eSwgaGF2ZSB0byB1c2UgaW50ZWdlciA4IGluc3RlYWQgb2YgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOU1xuXHRcdFx0XHRpZiAocmVsYXRpdmVUb05vZGUgJiYgdGhpcy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyZWxhdGl2ZVRvTm9kZSwgbm9kZS5vZmZzZXRQYXJlbnQpICYgOCkge1xuXHRcdFx0XHRcdG9mZnNldEFkanVzdExlZnQgPSByZWxhdGl2ZVRvTm9kZS5vZmZzZXRMZWZ0O1xuXHRcdFx0XHRcdG9mZnNldEFkanVzdFRvcCA9IHJlbGF0aXZlVG9Ob2RlLm9mZnNldFRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBanVzdCBvdXIgdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXMgYmFzZWQgb24gdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcblx0XHRcdFx0bGVmdCArPSBub2RlLm9mZnNldExlZnQgLSAobm9kZS5vZmZzZXRQYXJlbnQgPyBub2RlLm9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IDogMCkgLSBvZmZzZXRBZGp1c3RMZWZ0O1xuXHRcdFx0XHRpZiAodHJhbnNmb3JtUHJvcCAmJiB4cmVnZXgudGVzdChub2RlLnN0eWxlW3RyYW5zZm9ybVByb3BdKSkge1xuXHRcdFx0XHRcdGxlZnQgKz0gcGFyc2VJbnQobm9kZS5zdHlsZVt0cmFuc2Zvcm1Qcm9wXS5yZXBsYWNlKHhyZWdleCwgJyQxJyksIDEwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b3AgKz0gbm9kZS5vZmZzZXRUb3AgLSAobm9kZS5vZmZzZXRQYXJlbnQgPyBub2RlLm9mZnNldFBhcmVudC5zY3JvbGxUb3AgOiAwKSAtIG9mZnNldEFkanVzdFRvcDtcblx0XHRcdFx0aWYgKHRyYW5zZm9ybVByb3AgJiYgeXJlZ2V4LnRlc3Qobm9kZS5zdHlsZVt0cmFuc2Zvcm1Qcm9wXSkpIHtcblx0XHRcdFx0XHR0b3AgKz0gcGFyc2VJbnQobm9kZS5zdHlsZVt0cmFuc2Zvcm1Qcm9wXS5yZXBsYWNlKHlyZWdleCwgJyQxJyksIDEwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBOZWVkIHRvIGNvcnJlY3QgZm9yIGJvcmRlcnMgaWYgYW55IGV4aXN0IG9uIHBhcmVudCBlbGVtZW50c1xuXHRcdFx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0Tm9kZSkge1xuXHRcdFx0XHRcdGlmIChub2RlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdFx0Ly8gT2ggSUUsIHdlIGRvIHNvIGxvdmUgd29ya2luZyBhcm91bmQgeW91ciBpbmNvbXBhdGliaWxpdGllc1xuXHRcdFx0XHRcdFx0Ym9yZGVyTGVmdCA9IHBhcnNlSW50KG5vZGUuY3VycmVudFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApO1xuXHRcdFx0XHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VJbnQobm9kZS5jdXJyZW50U3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRib3JkZXJMZWZ0ID0gcGFyc2VJbnQoZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUobm9kZSwgJycpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksIDEwKTtcblx0XHRcdFx0XHRcdGJvcmRlclRvcCA9IHBhcnNlSW50KGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKG5vZGUsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksIDEwKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTm8gY29tcHV0ZWQgc3R5bGUgb3B0aW9ucywgc28gdHJ5IHRoZSBub3JtYWwgc3R5bGUgb2JqZWN0IChtdWNoIGxlc3Mgcm9idXN0KVxuXHRcdFx0XHRcdFx0Ym9yZGVyTGVmdCA9IHBhcnNlSW50KG5vZGUuc3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cdFx0XHRcdFx0XHRib3JkZXJUb3AgPSBwYXJzZUludChub2RlLnN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChib3JkZXJMZWZ0KSB7XG5cdFx0XHRcdFx0XHRsZWZ0ICs9IGJvcmRlckxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChib3JkZXJUb3ApIHtcblx0XHRcdFx0XHRcdHRvcCArPSBib3JkZXJUb3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENvbnRpbnVlIGlmIHdlIGhhdmUgYW4gYWRkaXRpb25hbCBvZmZzZXRQYXJlbnQsIGFuZCBlaXRoZXIgZG9uJ3QgaGF2ZSBhIHJlbGF0aXZlVG9Ob2RlIG9yIHRoZSBvZmZzZXRQYXJlbnQgaXMgY29udGFpbmVkIGJ5IHRoZSByZWxhdGl2ZVRvTm9kZSAoaWYgb2Zmc2V0UGFyZW50IGNvbnRhaW5zIHJlbGF0aXZlVG9Ob2RlLCB0aGVuIHdlIGhhdmUgYWxyZWFkeSBjYWxjdWxhdGVkIHVwIHRvIHRoZSBub2RlLCBhbmQgY2FuIHNhZmVseSBleGl0KVxuXHRcdFx0XHQvLyBGb3IgSUUgOCBjb21wYXRpYmlsaXR5LCBoYXZlIHRvIHVzZSBpbnRlZ2VyIDE2IGluc3RlYWQgb2YgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQllcblx0XHRcdH0gd2hpbGUgKChub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQpICYmICghcmVsYXRpdmVUb05vZGUgfHwgdGhpcy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyZWxhdGl2ZVRvTm9kZSwgbm9kZSkgJiAxNikpO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0J3RvcCc6IHRvcCxcblx0XHRcdCdsZWZ0JzogbGVmdCxcblx0XHRcdCdib3R0b20nOiB0b3RhbEhlaWdodCAtIHRvcCAtIGhlaWdodCxcblx0XHRcdCdyaWdodCc6IHRvdGFsV2lkdGggLSBsZWZ0IC0gd2lkdGgsXG5cdFx0XHQnaGVpZ2h0JzogaGVpZ2h0LFxuXHRcdFx0J3dpZHRoJzogd2lkdGhcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIGBpbm5lckhUTUxgIHByb3BlcnR5IG9mIHRoZSBzcGVjaWZpZWQgYG5vZGVgIHRvIGBodG1sYC5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIHNldC5cblx0KiBAcGFyYW0ge1N0cmluZ30gaHRtbCAtIEFuIEhUTUwgc3RyaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0SW5uZXJIdG1sOiBmdW5jdGlvbihub2RlLCBodG1sKSB7XG5cdFx0bm9kZS5pbm5lckhUTUwgPSBodG1sO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENoZWNrcyBhIFtET01de0BnbG9zc2FyeSBOb2RlfSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IGZvciBhIHNwZWNpZmljIENTUyBjbGFzcy5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIHNldC5cblx0KiBAcGFyYW0ge1N0cmluZ30gcyAtIFRoZSBjbGFzcyBuYW1lIHRvIGNoZWNrIGZvci5cblx0KiBAcmV0dXJucyB7KEJvb2xlYW58dW5kZWZpbmVkKX0gYHRydWVgIGlmIGBub2RlYCBoYXMgdGhlIGBzYCBjbGFzczsgYHVuZGVmaW5lZGBcblx0KiBpZiB0aGVyZSBpcyBubyBgbm9kZWAgb3IgaXQgaGFzIG5vIGBjbGFzc05hbWVgIHByb3BlcnR5LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKG5vZGUsIHMpIHtcblx0XHRpZiAoIW5vZGUgfHwgIW5vZGUuY2xhc3NOYW1lKSB7IHJldHVybjsgfVxuXHRcdHJldHVybiAoJyAnICsgbm9kZS5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgcyArICcgJykgPj0gMDtcblx0fSxcblxuXHQvKipcblx0KiBVbmlxdWVseSBhZGRzIGEgQ1NTIGNsYXNzIHRvIGEgRE9NIG5vZGUuXG5cdCpcblx0KiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgW25vZGVde0BnbG9zc2FyeSBOb2RlfSB0byBzZXQuXG5cdCogQHBhcmFtIHtTdHJpbmd9IHMgLSBUaGUgY2xhc3MgbmFtZSB0byBhZGQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhZGRDbGFzczogZnVuY3Rpb24obm9kZSwgcykge1xuXHRcdGlmIChub2RlICYmICF0aGlzLmhhc0NsYXNzKG5vZGUsIHMpKSB7XG5cdFx0XHR2YXIgc3MgPSBub2RlLmNsYXNzTmFtZTtcblx0XHRcdG5vZGUuY2xhc3NOYW1lID0gKHNzICsgKHNzID8gJyAnIDogJycpICsgcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFJlbW92ZXMgYSBDU1MgY2xhc3MgZnJvbSBhIERPTSBub2RlIGlmIGl0IGV4aXN0cy5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBjbGFzcy5cblx0KiBAcGFyYW0ge1N0cmluZ30gcyAtIFRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZSBmcm9tIGBub2RlYC5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbihub2RlLCBzKSB7XG5cdFx0aWYgKG5vZGUgJiYgdGhpcy5oYXNDbGFzcyhub2RlLCBzKSkge1xuXHRcdFx0dmFyIHNzID0gbm9kZS5jbGFzc05hbWU7XG5cdFx0XHRub2RlLmNsYXNzTmFtZSA9ICgnICcgKyBzcyArICcgJykucmVwbGFjZSgnICcgKyBzICsgJyAnLCAnICcpLnNsaWNlKDEsIC0xKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQWRkcyBhIGNsYXNzIHRvIGBkb2N1bWVudC5ib2R5YC4gVGhpcyBkZWZlcnMgdGhlIGFjdHVhbCBjbGFzcyBjaGFuZ2UgaWYgbm90aGluZyBoYXMgYmVlblxuXHQqIHJlbmRlcmVkIGludG8gYGJvZHlgIHlldC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBzIC0gVGhlIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBkb2N1bWVudCdzIGBib2R5YC5cblx0KiBAcHVibGljXG5cdCovXG5cdGFkZEJvZHlDbGFzczogZnVuY3Rpb24ocykge1xuXHRcdGlmICghdXRpbHMuZXhpc3RzKHJvb3RzLnJvb3RzKSB8fCByb290cy5yb290cy5sZW5ndGggPT09IDApIHtcblx0XHRcdGlmIChkb20uX2JvZHlDbGFzc2VzKSB7XG5cdFx0XHRcdGRvbS5fYm9keUNsYXNzZXMucHVzaChzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvbS5fYm9keUNsYXNzZXMgPSBbc107XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZG9tLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIHMpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIGFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLCByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnRcblx0KiBjb3JuZXIgb2YgdGhlIHNjcmVlbi4gVGhpcyBmdW5jdGlvbiB0YWtlcyBpbnRvIGFjY291bnQgYWNjb3VudCBhYnNvbHV0ZS9yZWxhdGl2ZVxuXHQqIGBvZmZzZXRQYXJlbnRgIHBvc2l0aW9uaW5nLCBgc2Nyb2xsYCBwb3NpdGlvbiwgYW5kIENTUyB0cmFuc2Zvcm1zIChjdXJyZW50bHlcblx0KiBgdHJhbnNsYXRlWGAsIGB0cmFuc2xhdGVZYCwgYW5kIGBtYXRyaXgzZGApLlxuXHQqXG5cdCogYGBgamF2YXNjcmlwdFxuXHQqIHt0b3A6IC4uLiwgcmlnaHQ6IC4uLiwgYm90dG9tOiAuLi4sIGxlZnQ6IC4uLiwgaGVpZ2h0OiAuLi4sIHdpZHRoOiAuLi59XG5cdCogYGBgXG5cdCpcblx0KiBWYWx1ZXMgcmV0dXJuZWQgYXJlIG9ubHkgdmFsaWQgaWYgYGhhc05vZGUoKWAgaXMgdHJ1dGh5LiBJZiB0aGVyZSdzIG5vIERPTSBub2RlIGZvciB0aGVcblx0KiBvYmplY3QsIHRoaXMgcmV0dXJucyBhIGJvdW5kcyBzdHJ1Y3R1cmUgd2l0aCBgdW5kZWZpbmVkYCBhcyB0aGUgdmFsdWUgb2YgYWxsIGZpZWxkcy5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gbiAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHRvIG1lYXN1cmUuXG5cdCogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgYHRvcGAsIGByaWdodGAsIGBib3R0b21gLCBgbGVmdGAsXG5cdCpcdGBoZWlnaHRgLCBhbmQgYHdpZHRoYC5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldEFic29sdXRlQm91bmRzOiBmdW5jdGlvbih0YXJnZXROb2RlKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmNsb25lKHRhcmdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZsdXNoQm9keUNsYXNzZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChkb20uX2JvZHlDbGFzc2VzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgYzsgKGM9ZG9tLl9ib2R5Q2xhc3Nlc1tpXSk7ICsraSkge1xuXHRcdFx0XHRkb20uYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgYyk7XG5cdFx0XHR9XG5cdFx0XHRkb20uX2JvZHlDbGFzc2VzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2JvZHlDbGFzc2VzOiBudWxsLFxuXG5cdC8qKlxuXHQqIENvbnZlcnQgdG8gdmFyaW91cyB1bml0IGZvcm1hdHMuIFVzZWZ1bCBmb3IgY29udmVydGluZyBwaXhlbHMgdG8gYSByZXNvbHV0aW9uLWluZGVwZW5kZW50XG5cdCogbWVhc3VyZW1lbnQgbWV0aG9kLCBsaWtlIFwicmVtXCIuIE90aGVyIHVuaXRzIGFyZSBhdmFpbGFibGUgaWYgZGVmaW5lZCBpbiB0aGVcblx0KiBbZW55by5kb20udW5pdFRvUGl4ZWxGYWN0b3JzXXtAbGluayBlbnlvLmRvbS51bml0VG9QaXhlbEZhY3RvcnN9IG9iamVjdC5cblx0KlxuXHQqIGBgYGphdmFzY3JpcHRcblx0KiAvLyBEbyBjYWxjdWxhdGlvbnMgYW5kIGdldCBiYWNrIHRoZSBkZXNpcmVkIENTUyB1bml0LlxuXHQqIHZhciBmcmFtZVdpZHRoID0gMjUwLFxuXHQqICAgICBmcmFtZVdpdGhNYXJnaW5JbmNoZXMgPSBlbnlvLmRvbS51bml0KCAxMCArIGZyYW1lV2lkdGggKyAxMCwgJ2luJyApLFxuXHQqICAgICBmcmFtZVdpdGhNYXJnaW5SZW1zID0gZW55by5kb20udW5pdCggMTAgKyBmcmFtZVdpZHRoICsgMTAsICdyZW0nICk7XG5cdCogLy8gJzIuODEyNWluJyA9PSBmcmFtZVdpdGhNYXJnaW5JbmNoZXNcblx0KiAvLyAnMjIuNXJlbScgPT0gZnJhbWVXaXRoTWFyZ2luUmVtc1xuXHQqIGBgYFxuXHQqXG5cdCogQHBhcmFtIHsoU3RyaW5nfE51bWJlcil9IHBpeGVscyAtIFRoZSB0aGUgcGl4ZWxzIG9yIG1hdGggdG8gY29udmVydCB0byB0aGUgdW5pdC5cblx0Klx0KFwicHhcIiBzdWZmaXggaW4gU3RyaW5nIGZvcm1hdCBpcyBwZXJtaXR0ZWQuIGV4OiBgJzIwcHgnYClcblx0KiBAcGFyYW0geyhTdHJpbmcpfSB0b1VuaXQgLSBUaGUgbmFtZSBvZiB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLlxuXHQqIEByZXR1cm5zIHsoTnVtYmVyfHVuZGVmaW5lZCl9IFJlc3VsdGluZyBjb252ZXJzaW9uLCBpbiBjYXNlIG9mIG1hbGZvcm1lZCBpbnB1dCwgYHVuZGVmaW5lZGBcblx0KiBAcHVibGljXG5cdCovXG5cdHVuaXQ6IGZ1bmN0aW9uIChwaXhlbHMsIHRvVW5pdCkge1xuXHRcdGlmICghdG9Vbml0IHx8ICF0aGlzLnVuaXRUb1BpeGVsRmFjdG9yc1t0b1VuaXRdKSByZXR1cm47XG5cdFx0aWYgKHR5cGVvZiBwaXhlbHMgPT0gJ3N0cmluZycgJiYgcGl4ZWxzLnN1YnN0cigtMikgPT0gJ3B4JykgcGl4ZWxzID0gcGFyc2VJbnQocGl4ZWxzLnN1YnN0cigwLCBwaXhlbHMubGVuZ3RoIC0gMiksIDEwKTtcblx0XHRpZiAodHlwZW9mIHBpeGVscyAhPSAnbnVtYmVyJykgcmV0dXJuO1xuXG5cdFx0cmV0dXJuIChwaXhlbHMgLyB0aGlzLnVuaXRUb1BpeGVsRmFjdG9yc1t0b1VuaXRdKSArICcnICsgdG9Vbml0O1xuXHR9LFxuXG5cdC8qKlxuXHQqIE9iamVjdCB0aGF0IHN0b3JlcyBhbGwgb2YgdGhlIHBpeGVsIGNvbnZlcnNpb24gZmFjdG9ycyB0byBlYWNoIGtleWVkIHVuaXQuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHVuaXRUb1BpeGVsRmFjdG9yczoge1xuXHRcdCdyZW0nOiAxMixcblx0XHQnaW4nOiA5NlxuXHR9XG59O1xuXG4vLyBvdmVycmlkZSBzZXRJbm5lckh0bWwgZm9yIFdpbmRvd3MgOCBIVE1MIGFwcGxpY2F0aW9uc1xuaWYgKHR5cGVvZiBnbG9iYWwuTVNBcHAgIT09ICd1bmRlZmluZWQnKSB7XG5cdGRvbS5zZXRJbm5lckh0bWwgPSBmdW5jdGlvbihub2RlLCBodG1sKSB7XG5cdFx0Z2xvYmFsLk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdH0pO1xuXHR9O1xufVxuXG4vLyB1c2UgZmFzdGVyIGNsYXNzTGlzdCBpbnRlcmZhY2UgaWYgaXQgZXhpc3RzXG5pZiAoZG9jdW1lbnQuaGVhZCAmJiBkb2N1bWVudC5oZWFkLmNsYXNzTGlzdCkge1xuXHRkb20uaGFzQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBzKSB7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhzKTtcblx0XHR9XG5cdH07XG5cdGRvbS5hZGRDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIHMpIHtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0cmV0dXJuIG5vZGUuY2xhc3NMaXN0LmFkZChzKTtcblx0XHR9XG5cdH07XG5cdGRvbS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChub2RlLCBzKSB7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHJldHVybiBub2RlLmNsYXNzTGlzdC5yZW1vdmUocyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiogQWxsb3dzIGJvb3RzdHJhcHBpbmcgaW4gZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBnbG9iYWwgb2JqZWN0IHJpZ2h0IGF3YXkuXG4qXG4qIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gcnVuXG4qIEBwdWJsaWNcbiovXG5kb20ucmVxdWlyZXNXaW5kb3cgPSBmdW5jdGlvbihmdW5jKSB7XG5cdGZ1bmMoKTtcbn07XG5cblxudmFyIGNzc1RyYW5zZm9ybVByb3BzID0gWyd0cmFuc2Zvcm0nLCAnLXdlYmtpdC10cmFuc2Zvcm0nLCAnLW1vei10cmFuc2Zvcm0nLCAnLW1zLXRyYW5zZm9ybScsICctby10cmFuc2Zvcm0nXSxcblx0c3R5bGVUcmFuc2Zvcm1Qcm9wcyA9IFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybSddO1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5kb20uY2FsY0NhbkFjY2VsZXJhdGUgPSBmdW5jdGlvbigpIHtcblx0LyogQW5kcm9pZCAyIGlzIGEgbGlhcjogaXQgZG9lcyBOT1Qgc3VwcG9ydCAzRCB0cmFuc2Zvcm1zLCBldmVuIHRob3VnaCBQZXJzcGVjdGl2ZSBpcyB0aGUgYmVzdCBjaGVjayAqL1xuXHRpZiAocGxhdGZvcm0uYW5kcm9pZCA8PSAyKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHZhciBwJCA9IFsncGVyc3BlY3RpdmUnLCAnV2Via2l0UGVyc3BlY3RpdmUnLCAnTW96UGVyc3BlY3RpdmUnLCAnbXNQZXJzcGVjdGl2ZScsICdPUGVyc3BlY3RpdmUnXTtcblx0Zm9yICh2YXIgaT0wLCBwOyAocD1wJFtpXSk7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVtwXSAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG4vKipcbiogQHByaXZhdGVcbiovXG5kb20uZ2V0Q3NzVHJhbnNmb3JtUHJvcCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fY3NzVHJhbnNmb3JtUHJvcCkge1xuXHRcdHJldHVybiB0aGlzLl9jc3NUcmFuc2Zvcm1Qcm9wO1xuXHR9XG5cdHZhciBpID0gdXRpbHMuaW5kZXhPZih0aGlzLmdldFN0eWxlVHJhbnNmb3JtUHJvcCgpLCBzdHlsZVRyYW5zZm9ybVByb3BzKTtcblx0dGhpcy5fY3NzVHJhbnNmb3JtUHJvcCA9IGNzc1RyYW5zZm9ybVByb3BzW2ldO1xuXHRyZXR1cm4gdGhpcy5fY3NzVHJhbnNmb3JtUHJvcDtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmRvbS5nZXRTdHlsZVRyYW5zZm9ybVByb3AgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX3N0eWxlVHJhbnNmb3JtUHJvcCB8fCAhZG9jdW1lbnQuYm9keSkge1xuXHRcdHJldHVybiB0aGlzLl9zdHlsZVRyYW5zZm9ybVByb3A7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDAsIHA7IChwID0gc3R5bGVUcmFuc2Zvcm1Qcm9wc1tpXSk7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVtwXSAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fc3R5bGVUcmFuc2Zvcm1Qcm9wID0gcDtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZVRyYW5zZm9ybVByb3A7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5kb20uZG9tVHJhbnNmb3Jtc1RvQ3NzID0gZnVuY3Rpb24oaW5UcmFuc2Zvcm1zKSB7XG5cdHZhciBuLCB2LCB0ZXh0ID0gJyc7XG5cdGZvciAobiBpbiBpblRyYW5zZm9ybXMpIHtcblx0XHR2ID0gaW5UcmFuc2Zvcm1zW25dO1xuXHRcdGlmICgodiAhPT0gbnVsbCkgJiYgKHYgIT09IHVuZGVmaW5lZCkgJiYgKHYgIT09ICcnKSkge1xuXHRcdFx0dGV4dCArPSAgbiArICcoJyArIHYgKyAnKSAnO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmRvbS50cmFuc2Zvcm1zVG9Eb20gPSBmdW5jdGlvbihjb250cm9sKSB7XG5cdHZhciBjc3MgPSB0aGlzLmRvbVRyYW5zZm9ybXNUb0Nzcyhjb250cm9sLmRvbVRyYW5zZm9ybXMpLFxuXHRcdHN0eWxlUHJvcDtcblxuXHRpZiAoY29udHJvbC5oYXNOb2RlKCkpIHtcblx0XHRzdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlVHJhbnNmb3JtUHJvcCgpO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlUHJvcCA9IHRoaXMuZ2V0Q3NzVHJhbnNmb3JtUHJvcCgpO1xuXHR9XG5cblx0aWYgKHN0eWxlUHJvcCkgY29udHJvbC5hcHBseVN0eWxlKHN0eWxlUHJvcCwgY3NzKTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgQ1NTMyBUcmFuc2Zvcm1zLlxuKlxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHBsYXRmb3JtIHN1cHBvcnRzIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eTtcbiogb3RoZXJ3aXNlLCBgZmFsc2VgLlxuKiBAcHVibGljXG4qL1xuZG9tLmNhblRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gQm9vbGVhbih0aGlzLmdldFN0eWxlVHJhbnNmb3JtUHJvcCgpKTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIGB0cnVlYCBpZiBwbGF0Zm9ybSBzdXBwb3J0cyBDU1MzIDNEIFRyYW5zZm9ybXMuXG4qXG4qIFR5cGljYWxseSB1c2VkIGxpa2UgdGhpczpcbiogYGBgXG4qIGlmIChkb20uY2FuQWNjZWxlcmF0ZSgpKSB7XG4qIFx0ZG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMuJC5zbGlkaW5nVGhpbmcsICd0cmFuc2xhdGUzZCcsIHggKyAnLCcgKyB5ICsgJywnICsgJzAnKVxuKiB9IGVsc2Uge1xuKiBcdGRvbS50cmFuc2Zvcm1WYWx1ZSh0aGlzLiQuc2xpZGluZ1RoaW5nLCAndHJhbnNsYXRlJywgeCArICcsJyArIHkpO1xuKiB9XG4qIGBgYFxuKlxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHBsYXRmb3JtIHN1cHBvcnRzIENTUzMgM0QgVHJhbnNmb3Jtcztcbiogb3RoZXJ3aXNlLCBgZmFsc2VgLlxuKiBAcHVibGljXG4qL1xuZG9tLmNhbkFjY2VsZXJhdGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICh0aGlzLmFjY2VsZXJhbmRvICE9PSB1bmRlZmluZWQpID8gdGhpcy5hY2NlbGVyYW5kbyA6IGRvY3VtZW50LmJvZHkgJiYgKHRoaXMuYWNjZWxlcmFuZG8gPSB0aGlzLmNhbGNDYW5BY2NlbGVyYXRlKCkpO1xufTtcblxuLyoqXG4qIEFwcGxpZXMgYSBzZXJpZXMgb2YgdHJhbnNmb3JtcyB0byB0aGUgc3BlY2lmaWVkIHtAbGluayBlbnlvLkNvbnRyb2x9LCB1c2luZ1xuKiB0aGUgcGxhdGZvcm0ncyBwcmVmaXhlZCBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbipcbiogKipOb3RlOioqIFRyYW5zZm9ybXMgYXJlIG5vdCBjb21tdXRhdGl2ZSwgc28gb3JkZXIgaXMgaW1wb3J0YW50LlxuKlxuKiBUcmFuc2Zvcm0gdmFsdWVzIGFyZSB1cGRhdGVkIGJ5IHN1Y2Nlc3NpdmUgY2FsbHMsIHNvXG4qIGBgYGphdmFzY3JpcHRcbiogZG9tLnRyYW5zZm9ybShjb250cm9sLCB7dHJhbnNsYXRlOiAnMzBweCwgNDBweCcsIHNjYWxlOiAyLCByb3RhdGU6ICcyMGRlZyd9KTtcbiogZG9tLnRyYW5zZm9ybShjb250cm9sLCB7c2NhbGU6IDMsIHNrZXdYOiAnLTMwZGVnJ30pO1xuKiBgYGBcbipcbiogaXMgZXF1aXZhbGVudCB0bzpcbiogYGBgamF2YXNjcmlwdFxuKiBkb20udHJhbnNmb3JtKGNvbnRyb2wsIHt0cmFuc2xhdGU6ICczMHB4LCA0MHB4Jywgc2NhbGU6IDMsIHJvdGF0ZTogJzIwZGVnJywgc2tld1g6ICctMzBkZWcnfSk7XG4qIGBgYFxuKlxuKiBXaGVuIGFwcGx5aW5nIHRoZXNlIHRyYW5zZm9ybXMgaW4gYSBXZWJLaXQgYnJvd3NlciwgdGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuKiBgYGBqYXZhc2NyaXB0XG4qIGNvbnRyb2wuYXBwbHlTdHlsZSgnLXdlYmtpdC10cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDMwcHgsIDQwcHgpIHNjYWxlKDMpIHJvdGF0ZSgyMGRlZykgc2tld1goLTMwZGVnKScpO1xuKiBgYGBcbipcbiogQW5kIGluIEZpcmVmb3gsIHRoaXMgaXMgZXF1aXZhbGVudCB0bzpcbiogYGBgamF2YXNjcmlwdFxuKiBjb250cm9sLmFwcGx5U3R5bGUoJy1tb3otdHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgzMHB4LCA0MHB4KSBzY2FsZSgzKSByb3RhdGUoMjBkZWcpIHNrZXdYKC0zMGRlZyknKTtcbiogYGBgXG4qXG4qIEBwYXJhbSB7ZW55by5Db250cm9sfSBjb250cm9sIC0gVGhlIHtAbGluayBlbnlvLkNvbnRyb2x9IHRvIHRyYW5zZm9ybS5cbiogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybXMgLSBUaGUgc2V0IG9mIHRyYW5zZm9ybXMgdG8gYXBwbHkgdG8gYGNvbnRyb2xgLlxuKiBAcHVibGljXG4qL1xuZG9tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbnRyb2wsIHRyYW5zZm9ybXMpIHtcblx0dmFyIGQgPSBjb250cm9sLmRvbVRyYW5zZm9ybXMgPSBjb250cm9sLmRvbVRyYW5zZm9ybXMgfHwge307XG5cdHV0aWxzLm1peGluKGQsIHRyYW5zZm9ybXMpO1xuXHR0aGlzLnRyYW5zZm9ybXNUb0RvbShjb250cm9sKTtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIGEgc2luZ2xlIHRyYW5zZm9ybSB0byB0aGUgc3BlY2lmaWVkIHtAbGluayBlbnlvLkNvbnRyb2x9LlxuKlxuKiBFeGFtcGxlOlxuKiBgYGBcbiogdGFwOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuKiBcdHZhciBjID0gaW5FdmVudC5vcmlnaW5hdG9yO1xuKiBcdHZhciByID0gYy5yb3RhdGlvbiB8fCAwO1xuKiBcdHIgPSAociArIDQ1KSAlIDM2MDtcbiogXHRjLnJvdGF0aW9uID0gcjtcbiogXHRkb20udHJhbnNmb3JtVmFsdWUoYywgJ3JvdGF0ZScsIHIpO1xuKiB9XG4qIGBgYFxuKlxuKiBUaGlzIHdpbGwgcm90YXRlIHRoZSB0YXBwZWQgY29udHJvbCBieSA0NSBkZWdyZWVzIGNsb2Nrd2lzZS5cbipcbiogQHBhcmFtIHtlbnlvLkNvbnRyb2x9IGNvbnRyb2wgLSBUaGUge0BsaW5rIGVueW8uQ29udHJvbH0gdG8gdHJhbnNmb3JtLlxuKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtIC0gVGhlIG5hbWUgb2YgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiogQHBhcmFtIHsoU3RyaW5nfE51bWJlcil9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSB0cmFuc2Zvcm0uXG4qIEBwdWJsaWNcbiovXG5kb20udHJhbnNmb3JtVmFsdWUgPSBmdW5jdGlvbihjb250cm9sLCB0cmFuc2Zvcm0sIHZhbHVlKSB7XG5cdHZhciBkID0gY29udHJvbC5kb21UcmFuc2Zvcm1zID0gY29udHJvbC5kb21UcmFuc2Zvcm1zIHx8IHt9O1xuXHRkW3RyYW5zZm9ybV0gPSB2YWx1ZTtcblx0dGhpcy50cmFuc2Zvcm1zVG9Eb20oY29udHJvbCk7XG59O1xuXG4vKipcbiogQXBwbGllcyBhIHRyYW5zZm9ybSB0aGF0IHNob3VsZCB0cmlnZ2VyIEdQVSBjb21wb3NpdGluZyBmb3IgdGhlIHNwZWNpZmllZFxuKiB7QGxpbmsgZW55by5Db250cm9sfS4gQnkgZGVmYXVsdCwgdGhlIGFjY2VsZXJhdGlvbiBpcyBvbmx5IGFwcGxpZWQgaWYgdGhlXG4qIGJyb3dzZXIgc3VwcG9ydHMgaXQuIFlvdSBtYXkgYWxzbyBvcHRpb25hbGx5IGZvcmNlLXNldCBgdmFsdWVgIGRpcmVjdGx5LCB0b1xuKiBiZSBhcHBsaWVkIHRvIGB0cmFuc2xhdGVaKHZhbHVlKWAuXG4qXG4qIEBwYXJhbSB7ZW55by5Db250cm9sfSBjb250cm9sIC0gVGhlIHtAbGluayBlbnlvLkNvbnRyb2x9IHRvIGFjY2VsZXJhdGUuXG4qIEBwYXJhbSB7KFN0cmluZ3xOdW1iZXIpfSBbdmFsdWVdIC0gQW4gb3B0aW9uYWwgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIGFjY2VsZXJhdGlvbiB0cmFuc2Zvcm1cbipcdHByb3BlcnR5LlxuKiBAcHVibGljXG4qL1xuZG9tLmFjY2VsZXJhdGUgPSBmdW5jdGlvbihjb250cm9sLCB2YWx1ZSkge1xuXHR2YXIgdiA9IHZhbHVlID09ICdhdXRvJyA/IHRoaXMuY2FuQWNjZWxlcmF0ZSgpIDogdmFsdWU7XG5cdHRoaXMudHJhbnNmb3JtVmFsdWUoY29udHJvbCwgJ3RyYW5zbGF0ZVonLCB2ID8gMCA6IG51bGwpO1xufTtcblxuXG4vKipcbiAqIFRoZSBDU1MgYHRyYW5zaXRpb25gIHByb3BlcnR5IG5hbWUgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIvcGxhdGZvcm0sIGUuZy46XG4gKlxuICogKiBgLXdlYmtpdC10cmFuc2l0aW9uYFxuICogKiBgLW1vei10cmFuc2l0aW9uYFxuICogKiBgdHJhbnNpdGlvbmBcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZG9tLnRyYW5zaXRpb24gPSAocGxhdGZvcm0uaW9zIHx8IHBsYXRmb3JtLmFuZHJvaWQgfHwgcGxhdGZvcm0uY2hyb21lIHx8IHBsYXRmb3JtLmFuZHJvaWRDaHJvbWUgfHwgcGxhdGZvcm0uc2FmYXJpKVxuXHQ/ICctd2Via2l0LXRyYW5zaXRpb24nXG5cdDogKHBsYXRmb3JtLmZpcmVmb3ggfHwgcGxhdGZvcm0uZmlyZWZveE9TIHx8IHBsYXRmb3JtLmFuZHJvaWRGaXJlZm94KVxuXHRcdD8gJy1tb3otdHJhbnNpdGlvbidcblx0XHQ6ICd0cmFuc2l0aW9uJztcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vcGxhdGZvcm1cIjo3MSxcIi4vcm9vdHNcIjo3NCxcIi4vdXRpbHNcIjo3NX1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGpzb24gPSByZXF1aXJlKCcuL2pzb24nKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi9wbGF0Zm9ybScpO1xuXG4vKipcbiogVGhlc2UgcGxhdGZvcm1zIG9ubHkgYWxsb3cgb25lIGFyZ3VtZW50IGZvciBbY29uc29sZS5sb2coKV17QGdsb3NzYXJ5IGNvbnNvbGUubG9nfTpcbipcbiogKiBhbmRyb2lkXG4qICogaW9zXG4qICogd2Vib3NcbipcbiogQHByaXZhdGVcbiovXG52YXIgZHVtYkNvbnNvbGUgPSBCb29sZWFuKHBsYXRmb3JtLmFuZHJvaWQgfHwgcGxhdGZvcm0uaW9zIHx8IHBsYXRmb3JtLndlYm9zKTtcblxuLyoqXG4qIEludGVybmFsbHkgdXNlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCBsb2dnaW5nLlxuKlxuKiBAbmFtZXNwYWNlIGV4cG9ydHMubG9nZ2luZ1xuKiBAcHVibGljXG4qL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gLyoqIEBsZW5kcyBleHBvcnRzLmxvZ2dpbmcgKi8ge1xuXHRcblx0LyoqXG5cdCogVGhlIGxvZyBsZXZlbCB0byB1c2UuIENhbiBiZSBhIHZhbHVlIGZyb20gLTEgdG8gOTksIHdoZXJlIC0xIGRpc2FibGVzIGFsbFxuXHQqIGxvZ2dpbmcsIDAgaXMgJ2Vycm9yJywgMTAgaXMgJ3dhcm4nLCBhbmQgMjAgaXMgJ2xvZycuIEl0IGlzIHByZWZlcnJlZCB0aGF0XG5cdCogdGhpcyB2YWx1ZSBiZSBzZXQgdXNpbmcgdGhlIFtleHBvcnRzLnNldExvZ0xldmVsKClde0BsaW5rIGVueW9+c2V0TG9nTGV2ZWx9XG5cdCogbWV0aG9kLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCA5OVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bGV2ZWw6IDk5LFxuXHRcblx0LyoqXG5cdCogVGhlIGtub3duIGxldmVscy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGxldmVsczoge2xvZzogMjAsIHdhcm46IDEwLCBlcnJvcjogMH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGRMb2c6IGZ1bmN0aW9uIChmbikge1xuXHRcdHZhciBsbCA9IHBhcnNlSW50KHRoaXMubGV2ZWxzW2ZuXSwgMCk7XG5cdFx0cmV0dXJuIChsbCA8PSB0aGlzLmxldmVsKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZhbGlkYXRlQXJnczogZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHQvLyBncmFjZWZ1bGx5IGhhbmRsZSBhbmQgcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2UgZXJyb3JzIGluIG9iamVjdHNcblx0XHRmb3IgKHZhciBpPTAsIGw9YXJncy5sZW5ndGgsIGl0ZW07IChpdGVtPWFyZ3NbaV0pIHx8IGk8bDsgaSsrKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0YXJnc1tpXSA9IGpzb24uc3RyaW5naWZ5KGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFyZ3NbaV0gPSAnRXJyb3I6ICcgKyBlLm1lc3NhZ2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2xvZzogZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG5cdFx0Ly8gYXZvaWQgdHJ5aW5nIHRvIHVzZSBjb25zb2xlIG9uIElFIGluc3RhbmNlcyB3aGVyZSB0aGUgb2JqZWN0IGhhc24ndCBiZWVuXG5cdFx0Ly8gY3JlYXRlZCBkdWUgdG8gdGhlIGRldmVsb3BlciB0b29scyBiZWluZyB1bm9wZW5lZFxuXHRcdHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG5cdFx0aWYgKHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cdFx0Ly92YXIgYSQgPSB1dGlscy5sb2dnaW5nLmZvcm1hdEFyZ3MoZm4sIGFyZ3MpO1xuXHRcdHZhciBhJCA9IHV0aWxzLmlzQXJyYXkoYXJncykgPyBhcmdzIDogdXRpbHMuY2xvbmVBcnJheShhcmdzKTtcblx0XHRpZiAocGxhdGZvcm0uYW5kcm9pZEZpcmVmb3gpIHtcblx0XHRcdC8vIEZpcmVmb3ggZm9yIEFuZHJvaWQncyBjb25zb2xlIGRvZXMgbm90IGhhbmRsZSBvYmplY3RzIHdpdGggY2lyY3VsYXIgcmVmZXJlbmNlc1xuXHRcdFx0dGhpcy52YWxpZGF0ZUFyZ3MoYSQpO1xuXHRcdH1cblx0XHRpZiAoZHVtYkNvbnNvbGUpIHtcblx0XHRcdC8vIGF0IGxlYXN0IGluIGVhcmx5IHZlcnNpb25zIG9mIHdlYm9zLCBjb25zb2xlLiogb25seSBhY2NlcHQgYSBzaW5nbGUgYXJndW1lbnRcblx0XHRcdGEkID0gW2EkLmpvaW4oJyAnKV07XG5cdFx0fVxuXHRcdHZhciBmbiQgPSBjb25zb2xlW2ZuXTtcblx0XHRpZiAoZm4kICYmIGZuJC5hcHBseSkge1xuXHRcdFx0Ly8gc29tZSBjb25zb2xlcyBzdXBwb3J0ICd3YXJuJywgJ2luZm8nLCBhbmQgc28gb25cblx0XHRcdGZuJC5hcHBseShjb25zb2xlLCBhJCk7XG5cdFx0fSBlbHNlIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuXHRcdFx0Ly8gc29tZSBjb25zb2xlcyBzdXBwb3J0IGNvbnNvbGUubG9nLmFwcGx5XG5cdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhJCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIG90aGVyd2lzZSwgZG8gb3VyIG93biBmb3JtYXR0aW5nXG5cdFx0XHRjb25zb2xlLmxvZyhhJC5qb2luKCcgJykpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIFRoaXMgaXMgZXhwb3NlZCBlbHNld2hlcmUuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRsb2c6IGZ1bmN0aW9uIChmbiwgYXJncykge1xuXG5cdFx0aWYgKGZuICE9ICdsb2cnICYmIGZuICE9ICd3YXJuJyAmJiBmbiAhPSAnZXJyb3InKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGZuID0gJ2xvZyc7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZTtcblx0XHRpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRpZiAodGhpcy5zaG91bGRMb2coZm4pKSB7XG5cdFx0XHRcdHRoaXMuX2xvZyhmbiwgYXJncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiogU2V0cyB0aGUgbG9nIGxldmVsIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhpcyB3aWxsIHJlc3RyaWN0IHRoZSBhbW91bnQgb2Ygb3V0cHV0IGRlcGVuZGluZyBvblxuKiB0aGUgc2V0dGluZ3MuIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBvdXRwdXQgdGhhdCB3aWxsIGJlIGFsbG93ZWQuIFRoZSBkZWZhdWx0IGlzXG4qIDk5LiBUaGUgdmFsdWUsIC0xLCB3b3VsZCBzaWxlbmNlIGFsbCBsb2dnaW5nLCBldmVuICdlcnJvcicgKDApLlxuKiBXaXRob3V0IHRoZSAnc2VlJzoge0BsaW5rIGV4cG9ydHMubG9nfS5cbipcbiogQHNlZSBleHBvcnRzLmxvZ2dpbmcubGV2ZWxcbiogQHNlZSBleHBvcnRzLmxvZ1xuKiBAc2VlIGV4cG9ydHMud2FyblxuKiBAc2VlIGV4cG9ydHMuZXJyb3JcbiogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIC0gVGhlIGxldmVsIHRvIHNldCBsb2dnaW5nIHRvLlxuKi9cbmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcblx0dmFyIGxsID0gcGFyc2VJbnQobGV2ZWwsIDApO1xuXHRpZiAoaXNGaW5pdGUobGwpKSB7XG5cdFx0dGhpcy5sZXZlbCA9IGxsO1xuXHR9XG59O1xuXG4vKipcbiogQSB3cmFwcGVyIGZvciBbY29uc29sZS5sb2coKV17QGdsb3NzYXJ5IGNvbnNvbGUubG9nfSwgY29tcGF0aWJsZVxuKiBhY3Jvc3Mgc3VwcG9ydGVkIHBsYXRmb3Jtcy4gV2lsbCBvdXRwdXQgb25seSBpZiB0aGUgY3VycmVudFxuKiBbbG9nIGxldmVsXXtAbGluayBleHBvcnRzLmxvZ2dpbmcubGV2ZWx9IGFsbG93cyBpdC4gW09iamVjdF17QGdsb3NzYXJ5IE9iamVjdH1cbiogcGFyYW1ldGVycyB3aWxsIGJlIHNlcmlhbGl6ZWQgdmlhIFtKU09OLnN0cmluZ2lmeSgpXXtAZ2xvc3NhcnkgSlNPTi5zdHJpbmdpZnl9XG4qIGF1dG9tYXRpY2FsbHkuXG4qXG4qIEB1dGlsaXR5XG4qIEBzZWUge0BnbG9zc2FyeSBjb25zb2xlLmxvZ31cbiogQHBhcmFtIHsuLi4qfSAtIFRoZSBhcmd1bWVudHMgdG8gYmUgbG9nZ2VkLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogQSB3cmFwcGVyIGZvciBbY29uc29sZS53YXJuKClde0BnbG9zc2FyeSBjb25zb2xlLndhcm59LCBjb21wYXRpYmxlXG4qIGFjcm9zcyBzdXBwb3J0ZWQgcGxhdGZvcm1zLiBXaWxsIG91dHB1dCBvbmx5IGlmIHRoZSBjdXJyZW50XG4qIFtsb2cgbGV2ZWxde0BsaW5rIGV4cG9ydHMubG9nZ2luZy5sZXZlbH0gYWxsb3dzIGl0LiBbT2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fVxuKiBwYXJhbWV0ZXJzIHdpbGwgYmUgc2VyaWFsaXplZCB2aWEgW0pTT04uc3RyaW5naWZ5KClde0BnbG9zc2FyeSBKU09OLnN0cmluZ2lmeX1cbiogYXV0b21hdGljYWxseS5cbipcbiogQHV0aWxpdHlcbiogQHNlZSB7QGdsb3NzYXJ5IGNvbnNvbGUud2Fybn1cbiogQHBhcmFtIHsuLi4qfSAtIFRoZSBhcmd1bWVudHMgdG8gYmUgbG9nZ2VkLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmxvZygnd2FybicsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiogQSB3cmFwcGVyIGZvciBbY29uc29sZS5lcnJvcigpXXtAZ2xvc3NhcnkgY29uc29sZS5lcnJvcn0sIGNvbXBhdGlibGVcbiogYWNyb3NzIHN1cHBvcnRlZCBwbGF0Zm9ybXMuIFdpbGwgb3V0cHV0IG9ubHkgaWYgdGhlIGN1cnJlbnRcbiogW2xvZyBsZXZlbF17QGxpbmsgZXhwb3J0cy5sb2dnaW5nLmxldmVsfSBhbGxvd3MgaXQuIFtPYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9XG4qIHBhcmFtZXRlcnMgd2lsbCBiZSBzZXJpYWxpemVkIHZpYSBbSlNPTi5zdHJpbmdpZnkoKV17QGdsb3NzYXJ5IEpTT04uc3RyaW5naWZ5fVxuKiBhdXRvbWF0aWNhbGx5LlxuKlxuKiBAdXRpbGl0eVxuKiBAc2VlIHtAZ2xvc3NhcnkgY29uc29sZS5lcnJvcn1cbiogQHBhcmFtIHsuLi4qfSAtIFRoZSBhcmd1bWVudHMgdG8gYmUgbG9nZ2VkLlxuKiBAcHVibGljXG4qL1xuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5sb2coJ2Vycm9yJywgYXJndW1lbnRzKTtcbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL2pzb25cIjo2NSxcIi4vcGxhdGZvcm1cIjo3MSxcIi4vdXRpbHNcIjo3NX1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vcGxhdGZvcm0nKSxcblx0cGF0aCA9IHJlcXVpcmUoJy4vcGF0aFJlc29sdmVyJyk7XG5cbi8qKlxuKiBQYXJhbWV0ZXJzIGFuZCBvcHRpb25zIGZvciB0aGUgW2VueW8ueGhyLnJlcXVlc3QoKV17QGxpbmsgZW55by54aHIucmVxdWVzdH0gbWV0aG9kLlxuKlxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLnhoci5yZXF1ZXN0fk9wdGlvbnNcbiogQHByb3BlcnR5IHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gcmVxdWVzdCAocmVxdWlyZWQpLlxuKiBAcHJvcGVydHkge1N0cmluZ30gbWV0aG9kIC0gT25lIG9mIGAnR0VUJ2AsIGAnUE9TVCdgLCBgJ0RFTEVURSdgLCBgJ1VQREFURSdgLCBvclxuKiBjdXN0b20gbWV0aG9kczsgZGVmYXVsdHMgdG8gYCdHRVQnYC5cbiogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayBtZXRob2QgdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuKiBAcHJvcGVydHkge09iamVjdH0gYm9keSAtIE9wdGlvbmFsIHNlcmlhbGl6YWJsZSBib2R5IGZvciBgUE9TVGAgcmVxdWVzdHMuXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIC0gT3B0aW9uYWwgaGVhZGVyIG92ZXJyaWRlczsgZGVmYXVsdHMgdG8gYG51bGxgLlxuKiBAcHJvcGVydHkge1N0cmluZ30gdXNlcm5hbWUgLSBPcHRpb25hbCB1c2VybmFtZSB0byBwcm92aWRlIGZvciBhdXRoZW50aWNhdGlvbiBwdXJwb3Nlcy5cbiogQHByb3BlcnR5IHtTdHJpbmd9IHBhc3N3b3JkIC0gT3B0aW9uYWwgcGFzc3dvcmQgdG8gcHJvdmlkZSBmb3IgYXV0aGVudGljYXRpb24gcHVycG9zZXMuXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSB4aHJGaWVsZHMgLSBPcHRpb25hbCBrZXkvdmFsdWUgcGFpcnMgdG8gYXBwbHkgZGlyZWN0bHkgdG8gdGhlIHJlcXVlc3QuXG4qIEBwcm9wZXJ0eSB7U3RyaW5nfSBtaW1lVHlwZSAtIE9wdGlvbmFsIHNwZWNpZmljYXRpb24gZm9yIHRoZSBgTUlNRS1UeXBlYCBvZiB0aGUgcmVxdWVzdC5cbiogQHByb3BlcnR5IHtCb29sZWFufSBtb3pTeXN0ZW0gLSBPcHRpb25hbCBib29sZWFuIHRvIGNyZWF0ZSBjcm9zcy1kb21haW4gWEhSIChGaXJlZm94IE9TIG9ubHkpLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IG1vekFub24gLSBPcHRpb25hbCBib29sZWFuIHRvIGNyZWF0ZSBhbm9ueW1vdXMgWEhSIHRoYXQgZG9lcyBub3Qgc2VuZFxuKlx0Y29va2llcyBvciBhdXRoZW50aWNhdGlvbiBoZWFkZXJzIChGaXJlZm94IE9TIG9ubHkpLlxuKiBAcHJpdmF0ZVxuKi9cblxuLyoqXG4qIEFuIGludGVybmFsbHktdXNlZCBuYW1lc3BhY2UgZm9yIFhIUi1yZWxhdGVkIG1ldGhvZHMgYW5kIHdyYXBwZXJzLlxuKlxuKiBAbmFtZXNwYWNlIGVueW8ueGhyXG4qIEBwcml2YXRlXG4qL1xubW9kdWxlLmV4cG9ydHMgPSAvKiogQGxlbmRzIGVueW8ueGhyICovIHtcblx0XG5cdC8qKlxuXHQqIEludGVybmFsbHktdXNlZCBtZXRob2QgdG8gZXhlY3V0ZSBYSFIgcmVxdWVzdHMuXG5cdCpcblx0KiBOb3RlIHRoYXQgd2UgZXhwbGljaXRseSBhZGQgYSBgJ2NhY2hlLWNvbnRyb2w6IG5vLWNhY2hlJ2AgaGVhZGVyIGZvciBpT1MgNiBmb3IgYW55XG5cdCogbm9uLWBHRVRgIHJlcXVlc3RzIHRvIHdvcmsgYXJvdW5kIGEgc3lzdGVtIGJ1ZyBjYXVzaW5nIG5vbi1jYWNoYWJsZSByZXF1ZXN0cyB0byBiZVxuXHQqIGNhY2hlZC4gVG8gZGlzYWJsZSB0aGlzLCB1c2UgdGhlIGBoZWFkZXJgIHByb3BlcnR5IHRvIHNwZWNpZnkgYW4gb2JqZWN0IHdoZXJlXG5cdCogYGNhY2hlLWNvbnRyb2xgIGlzIHNldCB0byBgbnVsbGAuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8ueGhyLnJlcXVlc3R+T3B0aW9uc30gcGFyYW1zIC0gVGhlIG9wdGlvbnMgYW5kIHByb3BlcnRpZXMgZm9yIHRoaXMgWEhSIHJlcXVlc3QuXG5cdCogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBUaGUgWEhSIHJlcXVlc3Qgb2JqZWN0LlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlcXVlc3Q6IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0XHR2YXIgeGhyID0gdGhpcy5nZXRYTUxIdHRwUmVxdWVzdChwYXJhbXMpO1xuXHRcdHZhciB1cmwgPSB0aGlzLnNpbXBsaWZ5RmlsZVVSTChwYXRoLnJld3JpdGUocGFyYW1zLnVybCkpO1xuXHRcdC8vXG5cdFx0dmFyIG1ldGhvZCA9IHBhcmFtcy5tZXRob2QgfHwgJ0dFVCc7XG5cdFx0dmFyIGFzeW5jID0gIXBhcmFtcy5zeW5jO1xuXHRcdC8vXG5cdFx0aWYgKHBhcmFtcy51c2VybmFtZSkge1xuXHRcdFx0eGhyLm9wZW4obWV0aG9kLCB1cmwsIGFzeW5jLCBwYXJhbXMudXNlcm5hbWUsIHBhcmFtcy5wYXNzd29yZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhoci5vcGVuKG1ldGhvZCwgdXJsLCBhc3luYyk7XG5cdFx0fVxuXHRcdC8vXG5cdFx0dXRpbHMubWl4aW4oeGhyLCBwYXJhbXMueGhyRmllbGRzKTtcblx0XHQvLyBvbmx5IHNldHVwIGhhbmRsZXIgd2hlbiB3ZSBoYXZlIGEgY2FsbGJhY2tcblx0XHRpZiAocGFyYW1zLmNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm1ha2VSZWFkeVN0YXRlSGFuZGxlcih4aHIsIHBhcmFtcy5jYWxsYmFjayk7XG5cdFx0fVxuXHRcdC8vXG5cdFx0cGFyYW1zLmhlYWRlcnMgPSBwYXJhbXMuaGVhZGVycyB8fCB7fTtcblx0XHQvLyB3b3JrIGFyb3VuZCBpT1MgNi4wIGJ1ZyB3aGVyZSBub24tR0VUIHJlcXVlc3RzIGFyZSBjYWNoZWRcblx0XHQvLyBzZWUgaHR0cDovL3d3dy5laW50ZXJuYWxzLmNvbS9ibG9nL3dlYi1kZXZlbG9wbWVudC9pb3M2LTAtY2FjaGluZy1hamF4LXBvc3QtcmVxdWVzdHNcblx0XHRpZiAobWV0aG9kICE9PSAnR0VUJyAmJiBwbGF0Zm9ybS5pb3MgJiYgcGxhdGZvcm0uaW9zID09IDYpIHtcblx0XHRcdGlmIChwYXJhbXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhcmFtcy5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBwYXJhbXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddIHx8ICduby1jYWNoZSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHVzZXItc2V0IGhlYWRlcnMgb3ZlcnJpZGUgYW55IHBsYXRmb3JtLWRlZmF1bHRcblx0XHRpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBwYXJhbXMuaGVhZGVycykge1xuXHRcdFx0XHRpZiAocGFyYW1zLmhlYWRlcnNba2V5XSkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgcGFyYW1zLmhlYWRlcnNba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9cblx0XHRpZigodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09ICdmdW5jdGlvbicpICYmIHBhcmFtcy5taW1lVHlwZSkge1xuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUocGFyYW1zLm1pbWVUeXBlKTtcblx0XHR9XG5cdFx0Ly9cblx0XHR4aHIuc2VuZChwYXJhbXMuYm9keSB8fCBudWxsKTtcblx0XHRpZiAoIWFzeW5jICYmIHBhcmFtcy5jYWxsYmFjaykge1xuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSh4aHIpO1xuXHRcdH1cblx0XHRyZXR1cm4geGhyO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVtb3ZlcyBhbnkgY2FsbGJhY2tzIHRoYXQgbWlnaHQgYmUgc2V0IGZyb20gRW55byBjb2RlIGZvciBhbiBleGlzdGluZyBYSFJcblx0KiBhbmQgc3RvcHMgdGhlIFhIUiBmcm9tIGNvbXBsZXRpbmcgKGlmIHBvc3NpYmxlKS5cblx0KlxuXHQqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IFRoZSAtIHJlcXVlc3QgdG8gY2FuY2VsLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbmNlbDogZnVuY3Rpb24gKHhocikge1xuXHRcdGlmICh4aHIub25sb2FkKSB7XG5cdFx0XHR4aHIub25sb2FkID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UpIHtcblx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoeGhyLmFib3J0KSB7XG5cdFx0XHR4aHIuYWJvcnQoKTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtYWtlUmVhZHlTdGF0ZUhhbmRsZXI6IGZ1bmN0aW9uIChpblhociwgaW5DYWxsYmFjaykge1xuXHRcdGlmIChnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgaW5YaHIgaW5zdGFuY2VvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QpIHtcblx0XHRcdGluWGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGF0YTtcblx0XHRcdFx0aWYgKGluWGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuXHRcdFx0XHRcdGRhdGEgPSBpblhoci5yZXNwb25zZTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgaW5YaHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdGRhdGEgPSBpblhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5DYWxsYmFjay5hcHBseShudWxsLCBbZGF0YSwgaW5YaHJdKTtcblx0XHRcdFx0aW5YaHIgPSBudWxsO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5YaHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChpblhociAmJiBpblhoci5yZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdFx0XHR2YXIgZGF0YTtcblx0XHRcdFx0XHRpZiAoaW5YaHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG5cdFx0XHRcdFx0XHRkYXRhID0gaW5YaHIucmVzcG9uc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgaW5YaHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IGluWGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5DYWxsYmFjay5hcHBseShudWxsLCBbZGF0YSwgaW5YaHJdKTtcblx0XHRcdFx0XHRpblhociA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5PcmlnaW46IGZ1bmN0aW9uICh1cmwpIHtcblx0XHR2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSwgcmVzdWx0ID0gZmFsc2U7XG5cdFx0YS5ocmVmID0gdXJsO1xuXHRcdC8vIHByb3RvY29sIGlzICc6JyBmb3IgcmVsYXRpdmUgVVJMc1xuXHRcdGlmIChhLnByb3RvY29sID09PSAnOicgfHxcblx0XHRcdFx0KGEucHJvdG9jb2wgPT09IGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbCAmJlxuXHRcdFx0XHRcdGEuaG9zdG5hbWUgPT09IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSAmJlxuXHRcdFx0XHRcdGEucG9ydCA9PT0gKGdsb2JhbC5sb2NhdGlvbi5wb3J0IHx8XG5cdFx0XHRcdFx0XHQoZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICc0NDMnIDogJzgwJykpKSkge1xuXHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNpbXBsaWZ5RmlsZVVSTDogZnVuY3Rpb24gKHVybCkge1xuXHRcdHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGEuaHJlZiA9IHVybDtcblx0XHQvLyBwcm90b2NvbCBpcyAnOicgZm9yIHJlbGF0aXZlIFVSTHNcblx0XHRpZiAoYS5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fFxuXHRcdFx0YS5wcm90b2NvbCA9PT0gJzonICYmIGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuXHRcdFx0Ly8gbGVhdmUgb2ZmIHNlYXJjaCBhbmQgaGFzaCBwYXJ0cyBvZiB0aGUgVVJMXG5cdFx0XHQvLyBhbmQgd29yayBhcm91bmQgYSBidWcgaW4gd2ViT1MgMyB3aGVyZSB0aGUgYXBwJ3MgaG9zdCBoYXMgYSBkb21haW4gc3RyaW5nXG5cdFx0XHQvLyBpbiBpdCB0aGF0IGlzbid0IHJlc29sdmVkIGFzIGEgcGF0aFxuXHRcdFx0dmFyIGhvc3QgPSAocGxhdGZvcm0ud2Vib3MgPCA0KSA/ICcnIDogYS5ob3N0O1xuXHRcdFx0cmV0dXJuIGEucHJvdG9jb2wgKyAnLy8nICsgaG9zdCArIGEucGF0aG5hbWU7XG5cdFx0fSBlbHNlIGlmIChhLnByb3RvY29sID09PSAnOicgJiYgZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sID09PSAneC13bWFwcDA6Jykge1xuXHRcdFx0Ly8gZXhwbGljaXRseSByZXR1cm4gYWJzb2x1dGUgVVJMIGZvciBXaW5kb3dzIFBob25lIDgsIGFzIGFuIGFic29sdXRlIHBhdGggaXMgcmVxdWlyZWQgZm9yIGxvY2FsIGZpbGVzXG5cdFx0XHRyZXR1cm4gZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGdsb2JhbC5sb2NhdGlvbi5wYXRobmFtZS5zcGxpdCgnLycpWzBdICsgJy8nICsgYS5ob3N0ICsgYS5wYXRobmFtZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHVybDtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRYTUxIdHRwUmVxdWVzdDogZnVuY3Rpb24gKHBhcmFtcykge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBvbmx5IHVzZSBYRG9tYWluUmVxdWVzdCB3aGVuIGl0IGV4aXN0cywgbm8gZXh0cmEgaGVhZGVycyB3ZXJlIHNldCwgYW5kIHRoZVxuXHRcdFx0Ly8gdGFyZ2V0IFVSTCBtYXBzIHRvIGEgZG9tYWluIG90aGVyIHRoYW4gdGhlIGRvY3VtZW50IG9yaWdpbi5cblx0XHRcdGlmIChwbGF0Zm9ybS5pZSA8IDEwICYmIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhcGFyYW1zLmhlYWRlcnMgJiZcblx0XHRcdFx0IXRoaXMuaW5PcmlnaW4ocGFyYW1zLnVybCkgJiYgIS9eZmlsZTpcXC9cXC8vLnRlc3QoZ2xvYmFsLmxvY2F0aW9uLmhyZWYpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlKSB7fVxuXHRcdHRyeSB7XG5cblx0XHRcdGlmIChwbGF0Zm9ybS5maXJlZm94T1MpIHtcblx0XHRcdFx0dmFyIHNob3VsZENyZWF0ZU5vblN0YW5kYXJkWEhSID0gZmFsc2U7IC8vIGZsYWcgdG8gZGVjaWRlIGlmIHdlJ3JlIGNyZWF0aW5nIHRoZSB4aHIgb3Igbm90XG5cdFx0XHRcdHZhciB4aHJPcHRpb25zID0ge307XG5cblx0XHRcdFx0Ly8gbW96U3lzdGVtIGFsbG93cyB5b3UgdG8gZG8gY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIG9uIEZpcmVmb3ggT1Ncblx0XHRcdFx0Ly8gQXMgc2VlbiBpbjpcblx0XHRcdFx0Ly8gICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QjTm9uLXN0YW5kYXJkX3Byb3BlcnRpZXNcblx0XHRcdFx0aWYgKHBhcmFtcy5tb3pTeXN0ZW0pIHtcblx0XHRcdFx0XHR4aHJPcHRpb25zLm1velN5c3RlbSA9IHRydWU7XG5cdFx0XHRcdFx0c2hvdWxkQ3JlYXRlTm9uU3RhbmRhcmRYSFIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbW96QW5vbiBhbGxvd3MgeW91IHRvIHNlbmQgYSByZXF1ZXN0IHdpdGhvdXQgY29va2llcyBvciBhdXRoZW50aWNhdGlvbiBoZWFkZXJzXG5cdFx0XHRcdC8vIEFzIHNlZW4gaW46XG5cdFx0XHRcdC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0I05vbi1zdGFuZGFyZF9wcm9wZXJ0aWVzXG5cdFx0XHRcdGlmIChwYXJhbXMubW96QW5vbikge1xuXHRcdFx0XHRcdHhock9wdGlvbnMubW96QW5vbiA9IHRydWU7XG5cdFx0XHRcdFx0c2hvdWxkQ3JlYXRlTm9uU3RhbmRhcmRYSFIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNob3VsZENyZWF0ZU5vblN0YW5kYXJkWEhSKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCh4aHJPcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0fSBjYXRjaChlKSB7fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9wYXRoUmVzb2x2ZXJcIjo3MCxcIi4vcGxhdGZvcm1cIjo3MSxcIi4vdXRpbHNcIjo3NX1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcbiAgICBhbmltYXRpb24gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9hbmltYXRpb24nKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL3V0aWxzJyk7XG5cbi8qKlxuKiBQcm92aWRlcyBzdGF0aWMgbWV0aG9kcyBmb3IgZWFzaW5nIGNhbGN1bGF0aW9ucy5cbipcbiogQHVpXG4qIEBwdWJsaWNcbiogQHRvZG8gdmVyaWZ5IHRoaXMgY29tYmluZXMgd2l0aCBlbnlvLmVhc2luZyBkZWZpbml0aW9uXG4qIEB0b2RvIHZlcmlmeSBhbGwgdGhlc2UgbWV0aG9kcyBuZWVkIHRvIGJlIGRvY3VtZW50ZWRcbiovXG5cbnZhciBlYXNpbmcgPSBtb2R1bGUuZXhwb3J0cyA9IHV0aWxzLm1peGluKGFuaW1hdGlvbi5lYXNpbmcsIC8qKiBAbGVuZHMgIGVueW8uZWFzaW5nLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyoodCAvPSBkKSp0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiAtYyAqKHQgLz0gZCkqKHQtMikgKyBiO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIGlmICgodCAvPSBkLzIpIDwgMSkgeyByZXR1cm4gYy8yKnQqdCArIGI7IH1cbiAgICAgICAgcmV0dXJuIC1jLzIgKiAoKC0tdCkqKHQtMikgLSAxKSArIGI7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjKih0IC89IGQpKnQqdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIGMqKCh0PXQvZC0xKSp0KnQgKyAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICBpZiAoKHQgLz0gZC8yKSA8IDEpIHsgcmV0dXJuIGMvMip0KnQqdCArIGI7IH1cbiAgICAgICAgcmV0dXJuIGMvMiooKHQtPTIpKnQqdCArIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjKih0IC89IGQpKnQqdCp0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gLWMgKiAoKHQ9dC9kLTEpKnQqdCp0IC0gMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKCh0IC89IGQvMikgPCAxKSB7IHJldHVybiBjLzIqdCp0KnQqdCArIGI7IH1cbiAgICAgICAgcmV0dXJuIC1jLzIgKiAoKHQtPTIpKnQqdCp0IC0gMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIGMqKHQgLz0gZCkqdCp0KnQqdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIGMqKCh0PXQvZC0xKSp0KnQqdCp0ICsgMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKCh0IC89IGQvMikgPCAxKSB7IHJldHVybiBjLzIqdCp0KnQqdCp0ICsgYjsgfVxuICAgICAgICByZXR1cm4gYy8yKigodC09MikqdCp0KnQqdCArIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZUluU2luZTogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIC1jICogTWF0aC5jb3ModC9kICogKE1hdGguUEkvMikpICsgYyArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VPdXRTaW5lOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gYyAqIE1hdGguc2luKHQvZCAqIChNYXRoLlBJLzIpKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiAtYy8yICogKE1hdGguY29zKE1hdGguUEkqdC9kKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZUluRXhwbzogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MCkgPyBiIDogYyAqIE1hdGgucG93KDIsIDEwICogKHQvZCAtIDEpKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VPdXRFeHBvOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICByZXR1cm4gKHQ9PT1kKSA/IGIrYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQvZCkgKyAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIGlmICh0PT09MCkgeyByZXR1cm4gYjsgfVxuICAgICAgICBpZiAodD09PWQpIHsgcmV0dXJuIGIrYzsgfVxuICAgICAgICBpZiAoKHQgLz0gZC8yKSA8IDEpIHsgcmV0dXJuIGMvMiAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKyBiOyB9XG4gICAgICAgIHJldHVybiBjLzIgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbkNpcmM6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpKnQpIC0gMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlT3V0Q2lyYzogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0PXQvZC0xKSp0KSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIGlmICgodCAvPSBkLzIpIDwgMSkgeyByZXR1cm4gLWMvMiAqIChNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKSArIGI7IH1cbiAgICAgICAgcmV0dXJuIGMvMiAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICB2YXIgYSA9IGM7XG4gICAgICAgIHZhciBwID0gMDtcbiAgICAgICAgaWYgKHQ9PT0wKSB7IHJldHVybiBiOyB9XG4gICAgICAgIGlmICgodCAvPSBkKT09MSkgeyByZXR1cm4gYitjOyB9XG4gICAgICAgIGlmICghcCkgeyBwPWQqMC4zOyB9XG4gICAgICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHsgYT1jOyBzPXAvNDsgfVxuICAgICAgICBlbHNlIHsgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4gKGMvYSk7IH1cbiAgICAgICAgcmV0dXJuIC0oYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbiggKHQqZC1zKSooMipNYXRoLlBJKS9wICkpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgdmFyIGEgPSBjO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIGlmICh0PT09MCkgeyByZXR1cm4gYjsgfVxuICAgICAgICBpZiAoKHQgLz0gZCk9PTEpIHsgcmV0dXJuIGIrYzsgfVxuICAgICAgICBpZiAoIXApIHsgcD1kKjAuMzsgfVxuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7IGE9Yzsgcz1wLzQ7IH1cbiAgICAgICAgZWxzZSB7IHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luIChjL2EpOyB9XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKnQpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApICsgYyArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgdmFyIGEgPSBjO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIGlmICh0PT09MCkgeyByZXR1cm4gYjsgfVxuICAgICAgICBpZiAoKHQgLz0gZC8yKT09PTIpIHsgcmV0dXJuIGIrYzsgfVxuICAgICAgICBpZiAoIXApIHsgcD1kKigwLjMqMS41KTsgfVxuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7IGE9Yzsgcz1wLzQ7IH1cbiAgICAgICAgZWxzZSB7IHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luIChjL2EpOyB9XG4gICAgICAgIGlmICh0IDwgMSkgeyByZXR1cm4gLTAuNSooYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbiggKHQqZC1zKSooMipNYXRoLlBJKS9wICkpICsgYjsgfVxuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCoodC09MSkpICogTWF0aC5zaW4oICh0KmQtcykqKDIqTWF0aC5QSSkvcCApKjAuNSArIGMgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5CYWNrOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBjKih0IC89IGQpKnQqKChzKzEpKnQgLSBzKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VPdXRCYWNrOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBjKigodD10L2QtMSkqdCooKHMrMSkqdCArIHMpICsgMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIGlmICgodCAvPSBkLzIpIDwgMSkgeyByZXR1cm4gYy8yKih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKSArIGI7IH1cbiAgICAgICAgcmV0dXJuIGMvMiooKHQtPTIpKnQqKCgocyo9KDEuNTI1KSkrMSkqdCArIHMpICsgMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uIChuLCB0LCBiLCBjLCBkKSB7XG4gICAgICAgIHJldHVybiBjIC0gZWFzaW5nLmVhc2VPdXRCb3VuY2UgKGQtdCwgMCwgYywgZCkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbiAobiwgdCwgYiwgYywgZCkge1xuICAgICAgICBpZiAoKHQgLz0gZCkgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuIGMqKDcuNTYyNSp0KnQpICsgYjtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjKig3LjU2MjUqKHQtPSgxLjUvMi43NSkpKnQgKyAwLjc1KSArIGI7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLjUvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjKig3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgMC45Mzc1KSArIGI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYyooNy41NjI1Kih0LT0oMi42MjUvMi43NSkpKnQgKyAwLjk4NDM3NSkgKyBiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24gKG4sIHQsIGIsIGMsIGQpIHtcbiAgICAgICAgaWYgKHQgPCBkLzIpIHsgcmV0dXJuIGVhc2luZy5lYXNlSW5Cb3VuY2UgKG4sIHQqMiwgMCwgYywgZCkgKiAwLjUgKyBiOyB9XG4gICAgICAgIHJldHVybiBlYXNpbmcuZWFzZU91dEJvdW5jZSAobiwgdCoyLWQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XG4gICAgfVxufSk7XG5cbi8qXG5cblRFUk1TIE9GIFVTRSAtIEVBU0lORyBFUVVBVElPTlNcblxuT3BlbiBzb3VyY2UgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLlxuXG5Db3B5cmlnaHQgwqkgMjAwMSBSb2JlcnQgUGVubmVyXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG5SZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxub2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG5SZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxub2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbnByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Vcbm9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTllcbkVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFU1xuT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlRcblNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG5TUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UXG5PRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbkVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbiovXG59LHtcIi4uLy4uL2VueW8vbGliL2FuaW1hdGlvblwiOjU2LFwiLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NX1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdERvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbnZhciBzZWxmQ2xvc2luZyA9IHtpbWc6IDEsIGhyOiAxLCBicjogMSwgYXJlYTogMSwgYmFzZTogMSwgYmFzZWZvbnQ6IDEsIGlucHV0OiAxLCBsaW5rOiAxLFxuXHRtZXRhOiAxLCBjb21tYW5kOiAxLCBlbWJlZDogMSwga2V5Z2VuOiAxLCB3YnI6IDEsIHBhcmFtOiAxLCBzb3VyY2U6IDEsIHRyYWNrOiAxLCBjb2w6IDF9O1xuXG4vKipcbiogVGhpcyBpcyB0aGUgZGVmYXVsdCByZW5kZXIgZGVsZWdhdGUgdXNlZCBieSB7QGxpbmsgZW55by5Db250cm9sfS4gSXRcbiogZ2VuZXJhdGVzIHRoZSBIVE1MIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IGNvbnRlbnQgYW5kIGNvcnJlY3RseSBpbnNlcnRzXG4qIGl0IGludG8gdGhlIERPTS4gQSBzdHJpbmctY29uY2F0ZW5hdGlvbiB0ZWNobmlxdWUgaXMgdXNlZCB0byBwZXJmb3JtIERPTVxuKiBpbnNlcnRpb24gaW4gYmF0Y2hlcy5cbipcbiogQG5hbWUgZW55by5IVE1MU3RyaW5nRGVsZWdhdGVcbiogQHR5cGUgT2JqZWN0XG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGludmFsaWRhdGU6IGZ1bmN0aW9uIChjb250cm9sLCBpdGVtKSB7XG5cdFx0c3dpdGNoIChpdGVtKSB7XG5cdFx0Y2FzZSAnY29udGVudCc6XG5cdFx0XHR0aGlzLnJlbmRlckNvbnRlbnQoY29udHJvbCk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29udHJvbC50YWdzVmFsaWQgPSBmYWxzZTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcjogZnVuY3Rpb24gKGNvbnRyb2wpIHtcblx0XHRpZiAoY29udHJvbC5wYXJlbnQpIHtcblx0XHRcdGNvbnRyb2wucGFyZW50LmJlZm9yZUNoaWxkUmVuZGVyKGNvbnRyb2wpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWNvbnRyb2wucGFyZW50LmdlbmVyYXRlZCkgcmV0dXJuO1xuXHRcdFx0aWYgKGNvbnRyb2wudGFnID09PSBudWxsKSByZXR1cm4gY29udHJvbC5wYXJlbnQucmVuZGVyKCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmICghY29udHJvbC5oYXNOb2RlKCkpIHRoaXMucmVuZGVyTm9kZShjb250cm9sKTtcblx0XHRpZiAoY29udHJvbC5oYXNOb2RlKCkpIHtcblx0XHRcdHRoaXMucmVuZGVyRG9tKGNvbnRyb2wpO1xuXHRcdFx0aWYgKGNvbnRyb2wuZ2VuZXJhdGVkKSBjb250cm9sLnJlbmRlcmVkKCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVySW50bzogZnVuY3Rpb24gKGNvbnRyb2wsIHBhcmVudE5vZGUpIHtcblx0XHRwYXJlbnROb2RlLmlubmVySFRNTCA9IHRoaXMuZ2VuZXJhdGVIdG1sKGNvbnRyb2wpO1xuXHRcdFxuXHRcdGlmIChjb250cm9sLmdlbmVyYXRlZCkgY29udHJvbC5yZW5kZXJlZCgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyTm9kZTogZnVuY3Rpb24gKGNvbnRyb2wpIHtcblx0XHR0aGlzLnRlYXJkb3duUmVuZGVyKGNvbnRyb2wpO1xuXHRcdGNvbnRyb2wubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29udHJvbC50YWcpO1xuXHRcdGNvbnRyb2wuYWRkTm9kZVRvUGFyZW50KCk7XG5cdFx0Y29udHJvbC5zZXQoJ2dlbmVyYXRlZCcsIHRydWUpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyRG9tOiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdHRoaXMucmVuZGVyQXR0cmlidXRlcyhjb250cm9sKTtcblx0XHR0aGlzLnJlbmRlclN0eWxlcyhjb250cm9sKTtcblx0XHR0aGlzLnJlbmRlckNvbnRlbnQoY29udHJvbCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJTdHlsZXM6IGZ1bmN0aW9uIChjb250cm9sKSB7XG5cdFx0dmFyIHN0eWxlID0gY29udHJvbC5zdHlsZTtcblx0XHRcblx0XHQvLyB3ZSBjYW4gc2FmZWx5IGRvIHRoaXMga25vd2luZyBpdCB3aWxsIHN5bmNocm9uaXplIHByb3Blcmx5IHdpdGhvdXQgYSBkb3VibGVcblx0XHQvLyBzZXQgaW4gdGhlIERPTSBiZWNhdXNlIHdlJ3JlIGZsYWdnaW5nIHRoZSBpbnRlcm5hbCBwcm9wZXJ0eVxuXHRcdGlmIChjb250cm9sLmhhc05vZGUoKSkge1xuXHRcdFx0Y29udHJvbC5ub2RlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcblx0XHRcdC8vIHJldHJpZXZlIHRoZSBwYXJzZWQgdmFsdWUgZm9yIHN5bmNocm9uaXphdGlvblxuXHRcdFx0Y29udHJvbC5jc3NUZXh0ID0gc3R5bGUgPSBjb250cm9sLm5vZGUuc3R5bGUuY3NzVGV4dDtcblx0XHRcdC8vIG5vdyB3ZSBzZXQgaXQga25vd2luZyB0aGV5IHdpbGwgYmUgc3luY2hyb25pemVkIGFuZCBldmVyeWJvZHkgdGhhdCBpcyBsaXN0ZW5pbmdcblx0XHRcdC8vIHdpbGwgYWxzbyBiZSB1cGRhdGVkIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZVxuXHRcdFx0Y29udHJvbC5zZXQoJ3N0eWxlJywgc3R5bGUpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlckF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChjb250cm9sKSB7XG5cdFx0dmFyIGF0dHJzID0gY29udHJvbC5hdHRyaWJ1dGVzLFxuXHRcdFx0bm9kZSA9IGNvbnRyb2wuaGFzTm9kZSgpLFxuXHRcdFx0a2V5LFxuXHRcdFx0dmFsO1xuXHRcdFxuXHRcdGlmIChub2RlKSB7XG5cdFx0XHRmb3IgKGtleSBpbiBhdHRycykge1xuXHRcdFx0XHR2YWwgPSBhdHRyc1trZXldO1xuXHRcdFx0XHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJDb250ZW50OiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdGlmIChjb250cm9sLmdlbmVyYXRlZCkgdGhpcy50ZWFyZG93bkNoaWxkcmVuKGNvbnRyb2wpO1xuXHRcdGlmIChjb250cm9sLmhhc05vZGUoKSkgY29udHJvbC5ub2RlLmlubmVySFRNTCA9IHRoaXMuZ2VuZXJhdGVJbm5lckh0bWwoY29udHJvbCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZW5lcmF0ZUh0bWw6IGZ1bmN0aW9uIChjb250cm9sKSB7XG5cdFx0dmFyIGNvbnRlbnQsXG5cdFx0XHRodG1sO1xuXHRcdFxuXHRcdGlmIChjb250cm9sLmNhbkdlbmVyYXRlID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHQvLyBkbyB0aGlzIGZpcnN0IGluIGNhc2UgY29udGVudCBnZW5lcmF0aW9uIGFmZmVjdHMgb3V0ZXIgaHRtbCAoc3R5bGVzIG9yIGF0dHJpYnV0ZXMpXG5cdFx0Y29udGVudCA9IHRoaXMuZ2VuZXJhdGVJbm5lckh0bWwoY29udHJvbCk7XG5cdFx0Ly8gZ2VuZXJhdGUgdGFnLCBzdHlsZXMsIGF0dHJpYnV0ZXNcblx0XHRodG1sID0gdGhpcy5nZW5lcmF0ZU91dGVySHRtbChjb250cm9sLCBjb250ZW50KTtcblx0XHQvLyBOT1RFOiAnZ2VuZXJhdGVkJyBpcyB1c2VkIHRvIGdhdGUgYWNjZXNzIHRvIGZpbmROb2RlQnlJZCBpblxuXHRcdC8vIGhhc05vZGUsIGJlY2F1c2UgZmluZE5vZGVCeUlkIGlzIGV4cGVuc2l2ZS5cblx0XHQvLyBOT1RFOiB3ZSB0eXBpY2FsbHkgdXNlICdnZW5lcmF0ZWQnIHRvIG1lYW4gJ2NyZWF0ZWQgaW4gRE9NJ1xuXHRcdC8vIGJ1dCB0aGF0IGhhcyBub3QgYWN0dWFsbHkgaGFwcGVuZWQgYXQgdGhpcyBwb2ludC5cblx0XHQvLyBXZSBzZXQgJ2dlbmVyYXRlZCA9IHRydWUnIGhlcmUgYW55d2F5IHRvIGF2b2lkIGhhdmluZyB0byB3YWxrIHRoZVxuXHRcdC8vIGNvbnRyb2wgdHJlZSBhIHNlY29uZCB0aW1lICh0byBzZXQgaXQgbGF0ZXIpLlxuXHRcdC8vIFRoZSBjb250cmFjdCBpcyB0aGF0IGluc2VydGlvbiBpbiBET00gd2lsbCBoYXBwZW4gc3luY2hyb25vdXNseVxuXHRcdC8vIHRvIGdlbmVyYXRlSHRtbCgpIGFuZCBiZWZvcmUgYW55Ym9keSBzaG91bGQgYmUgY2FsbGluZyBoYXNOb2RlKCkuXG5cdFx0Y29udHJvbC5zZXQoJ2dlbmVyYXRlZCcsIHRydWUpO1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2VuZXJhdGVPdXRlckh0bWw6IGZ1bmN0aW9uIChjb250cm9sLCBjb250ZW50KSB7XG5cdFx0aWYgKCFjb250cm9sLnRhZykgcmV0dXJuIGNvbnRlbnQ7XG5cdFx0aWYgKCFjb250cm9sLnRhZ3NWYWxpZCkgdGhpcy5wcmVwYXJlVGFncyhjb250cm9sKTtcblx0XHRyZXR1cm4gY29udHJvbC5fb3BlblRhZyArIGNvbnRlbnQgKyBjb250cm9sLl9jbG9zZVRhZztcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdlbmVyYXRlSW5uZXJIdG1sOiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdHZhciBhbGxvd0h0bWwgPSBjb250cm9sLmFsbG93SHRtbCxcblx0XHRcdGNvbnRlbnQ7XG5cdFx0XG5cdFx0Ly8gZmxvdyBjYW4gYWx0ZXIgdGhlIHdheSB0aGF0IGh0bWwgY29udGVudCBpcyByZW5kZXJlZCBpbnNpZGVcblx0XHQvLyB0aGUgY29udGFpbmVyIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVyZSBhcmUgY2hpbGRyZW4uXG5cdFx0Y29udHJvbC5mbG93KCk7XG5cdFx0aWYgKGNvbnRyb2wuY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gdGhpcy5nZW5lcmF0ZUNoaWxkSHRtbChjb250cm9sKTtcblx0XHRlbHNlIHtcblx0XHRcdGNvbnRlbnQgPSBjb250cm9sLmdldCgnY29udGVudCcpO1xuXHRcdFx0cmV0dXJuIGFsbG93SHRtbCA/IGNvbnRlbnQgOiBEb20uZXNjYXBlKGNvbnRlbnQpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdlbmVyYXRlQ2hpbGRIdG1sOiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdHZhciBjaGlsZCxcblx0XHRcdGh0bWwgPSAnJyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGVsZWdhdGU7XG5cdFx0XG5cdFx0Zm9yICg7IChjaGlsZCA9IGNvbnRyb2wuY2hpbGRyZW5baV0pOyArK2kpIHtcblx0XHRcdGRlbGVnYXRlID0gY2hpbGQucmVuZGVyRGVsZWdhdGUgfHwgdGhpcztcblx0XHRcdGh0bWwgKz0gZGVsZWdhdGUuZ2VuZXJhdGVIdG1sKGNoaWxkKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcmVwYXJlVGFnczogZnVuY3Rpb24gKGNvbnRyb2wpIHtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdFxuXHRcdC8vIG9wZW4gdGFnXG5cdFx0aHRtbCArPSAnPCcgKyBjb250cm9sLnRhZyArIChjb250cm9sLnN0eWxlID8gJyBzdHlsZT1cIicgKyBjb250cm9sLnN0eWxlICsgJ1wiJyA6ICcnKTtcblx0XHRodG1sICs9IHRoaXMuYXR0cmlidXRlc1RvSHRtbChjb250cm9sLmF0dHJpYnV0ZXMpO1xuXHRcdGlmIChzZWxmQ2xvc2luZ1tjb250cm9sLnRhZ10pIHtcblx0XHRcdGNvbnRyb2wuX29wZW5UYWcgPSBodG1sICsgJy8+Jztcblx0XHRcdGNvbnRyb2wuX2Nsb3NlVGFnID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRyb2wuX29wZW5UYWcgPSBodG1sICsgJz4nO1xuXHRcdFx0Y29udHJvbC5fY2xvc2VUYWcgPSAnPC8nICsgY29udHJvbC50YWcgKyAnPic7XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnRyb2wudGFnc1ZhbGlkID0gdHJ1ZTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGF0dHJpYnV0ZXNUb0h0bWw6IGZ1bmN0aW9uKGF0dHJzKSB7XG5cdFx0dmFyIGtleSxcblx0XHRcdHZhbCxcblx0XHRcdGh0bWwgPSAnJztcblx0XHRcdFxuXHRcdGZvciAoa2V5IGluIGF0dHJzKSB7XG5cdFx0XHR2YWwgPSBhdHRyc1trZXldO1xuXHRcdFx0aWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gZmFsc2UgJiYgdmFsICE9PSAnJykge1xuXHRcdFx0XHRodG1sICs9ICcgJyArIGtleSArICc9XCInICsgdGhpcy5lc2NhcGVBdHRyaWJ1dGUodmFsKSArICdcIic7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXNjYXBlQXR0cmlidXRlOiBmdW5jdGlvbiAodGV4dCkge1xuXHRcdGlmICh0eXBlb2YgdGV4dCAhPSAnc3RyaW5nJykgcmV0dXJuIHRleHQ7XG5cdFxuXHRcdHJldHVybiBTdHJpbmcodGV4dCkucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRlYXJkb3duUmVuZGVyOiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdGlmIChjb250cm9sLmdlbmVyYXRlZCkgdGhpcy50ZWFyZG93bkNoaWxkcmVuKGNvbnRyb2wpO1xuXHRcdGNvbnRyb2wubm9kZSA9IG51bGw7XG5cdFx0Y29udHJvbC5zZXQoJ2dlbmVyYXRlZCcsIGZhbHNlKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRlYXJkb3duQ2hpbGRyZW46IGZ1bmN0aW9uIChjb250cm9sKSB7XG5cdFx0dmFyIGNoaWxkLFxuXHRcdFx0aSA9IDA7XG5cdFx0XHRcblx0XHRmb3IgKDsgKGNoaWxkID0gY29udHJvbC5jaGlsZHJlbltpXSk7ICsraSkge1xuXHRcdFx0Y2hpbGQudGVhcmRvd25SZW5kZXIoKTtcblx0XHR9XG5cdH1cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9kb21cIjo1OH1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdERvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbnZhciBfYmFzZVNjcmVlblR5cGUgPSAnc3RhbmRhcmQnLFxuXHRfcmlSYXRpbyxcblx0X3NjcmVlblR5cGUsXG5cdF9zY3JlZW5UeXBlcyA9IFsge25hbWU6ICdzdGFuZGFyZCcsIHB4UGVyUmVtOiAxNiwgd2lkdGg6IGdsb2JhbC5pbm5lcldpZHRoLCAgaGVpZ2h0OiBnbG9iYWwuaW5uZXJIZWlnaHQsIGFzcGVjdFJhdGlvTmFtZTogJ3N0YW5kYXJkJ30gXSxcdC8vIEFzc2lnbiBvbmUgc2FuZSB2YWx1ZSBpbiBjYXNlIGRlZmluZVNjcmVlblR5cGVzIGlzIG5ldmVyIHJ1bi5cblx0X3NjcmVlblR5cGVPYmplY3Q7XG5cbnZhciBnZXRTY3JlZW5UeXBlT2JqZWN0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dHlwZSA9IHR5cGUgfHwgX3NjcmVlblR5cGU7XG5cdGlmICh0eXBlID09IF9zY3JlZW5UeXBlICYmIF9zY3JlZW5UeXBlT2JqZWN0KSB7XG5cdFx0cmV0dXJuIF9zY3JlZW5UeXBlT2JqZWN0O1xuXHR9XG5cdHJldHVybiBfc2NyZWVuVHlwZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0cmV0dXJuICh0eXBlID09IGVsZW0ubmFtZSk7XG5cdH0pWzBdO1xufTtcblxuLyoqXG4qIEBuYW1lc3BhY2UgcmlcbiovXG52YXIgcmkgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0LyoqXG5cdCogU2V0dXAgc2NyZWVuIHJlc29sdXRpb24gc2NhbGluZyBjYXBhYmlsaXRpZXMgYnkgZGVmaW5pbmcgYWxsIG9mIHRoZSBzY3JlZW5zIHlvdSdyZSB3b3JraW5nXG5cdCogd2l0aC4gVGhlc2Ugc2hvdWxkIGJlIGluIHRoZSBvcmRlciBvZiBzbWFsbGVzdCB0byBsYXJnZXN0IChhY2NvcmRpbmcgdG8gd2lkdGgpLiBSdW5uaW5nXG5cdCogdGhpcyBhbHNvIGluaXRpYWxpemVzIHRoZSByZXN0IG9mIHRoaXMgcmVzb2x1dGlvbiBjb2RlLlxuXHQqXG5cdCogSW4gdGhlIGFyZ3VtZW50cywgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXF1aXJlZDogJ25hbWUnLCAncHhQZXJSZW0nLCAnd2lkdGgnLFxuXHQqICdhc3BlY3RSYXRpb05hbWUnLiBUaGUgcHJvcGVydHkgJ2Jhc2UnIGRlZmluZXMgdGhlIHByaW1hcnkgb3IgZGVmYXVsdCByZXNvdWx0aW9uIHRoYXRcblx0KiBldmVyeXRoaW5nIGVsc2Ugd2lsbCBiZSBiYXNlZCB1cG9uLlxuXHQqXG5cdCogYGBgXG5cdCogcmkuZGVmaW5lU2NyZWVuVHlwZXMoW1xuXHQqIFx0e25hbWU6ICd2Z2EnLCAgICAgcHhQZXJSZW06IDgsICB3aWR0aDogNjQwLCAgaGVpZ2h0OiA0ODAsICBhc3BlY3RSYXRpb05hbWU6ICdzdGFuZGFyZCd9LFxuXHQqIFx0e25hbWU6ICd4Z2EnLCAgICAgcHhQZXJSZW06IDE2LCB3aWR0aDogMTAyNCwgaGVpZ2h0OiA3NjgsICBhc3BlY3RSYXRpb05hbWU6ICdzdGFuZGFyZCd9LFxuXHQqIFx0e25hbWU6ICdoZCcsICAgICAgcHhQZXJSZW06IDE2LCB3aWR0aDogMTI4MCwgaGVpZ2h0OiA3MjAsICBhc3BlY3RSYXRpb05hbWU6ICdoZHR2J30sXG5cdCogXHR7bmFtZTogJ2ZoZCcsICAgICBweFBlclJlbTogMjQsIHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAsIGFzcGVjdFJhdGlvTmFtZTogJ2hkdHYnLCBiYXNlOiB0cnVlfSxcblx0KiBcdHtuYW1lOiAndXctdXhnYScsIHB4UGVyUmVtOiAyNCwgd2lkdGg6IDI1NjAsIGhlaWdodDogMTA4MCwgYXNwZWN0UmF0aW9OYW1lOiAnY2luZW1hJ30sXG5cdCogXHR7bmFtZTogJ3VoZCcsICAgICBweFBlclJlbTogNDgsIHdpZHRoOiAzODQwLCBoZWlnaHQ6IDIxNjAsIGFzcGVjdFJhdGlvTmFtZTogJ2hkdHYnfVxuXHQqIF0pO1xuXHQqIGBgYFxuXHQqXG5cdCogQHBhcmFtIHtBcnJheX0gdHlwZXMgQW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGFyZ3VtZW50cyBsaWtlIHRoZSBleGFtcGxlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkZWZpbmVTY3JlZW5UeXBlczogZnVuY3Rpb24gKHR5cGVzKSB7XG5cdFx0X3NjcmVlblR5cGVzID0gdHlwZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfc2NyZWVuVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChfc2NyZWVuVHlwZXNbaV1bJ2Jhc2UnXSkgX2Jhc2VTY3JlZW5UeXBlID0gX3NjcmVlblR5cGVzW2ldLm5hbWU7XG5cdFx0fVxuXHRcdHJpLmluaXQoKTtcblx0fSxcblxuXHQvKipcblx0KiBGZXRjaGVzIHRoZSBiZXN0LW1hdGNoaW5nIHNjcmVlbiB0eXBlIG5hbWUgZm9yIHRoZSBjdXJyZW50IHNjcmVlbiBzaXplLiBUaGUgXCJiZXN0XCIgc2NyZWVuIHR5cGVcblx0KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzY3JlZW4gdHlwZSBuYW1lIHRoYXQgaXMgdGhlIGNsb3Nlc3QgdG8gdGhlIHNjcmVlbiByZXNvbHV0aW9uIHdpdGhvdXRcblx0KiBnb2luZyBvdmVyLiAoXCJUaGUgUHJpY2UgaXMgUmlnaHRcIiBzdHlsZS4pXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gW3Jlel0gLSBPcHRpb25hbCBtZWFzdXJlbWVudCBzY2hlbWUuIE11c3QgaGF2ZSBcImhlaWdodFwiIGFuZCBcIndpZHRoXCIgcHJvcGVydGllcy5cblx0KiBAcmV0dXJucyB7U3RyaW5nfSBTY3JlZW4gdHlwZSwgbGlrZSBcImZoZFwiLCBcInVoZFwiLCBldGMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTY3JlZW5UeXBlOiBmdW5jdGlvbiAocmV6KSB7XG5cdFx0cmV6ID0gcmV6IHx8IHtcblx0XHRcdGhlaWdodDogZ2xvYmFsLmlubmVySGVpZ2h0LFxuXHRcdFx0d2lkdGg6IGdsb2JhbC5pbm5lcldpZHRoXG5cdFx0fTtcblx0XHR2YXIgaSxcblx0XHRcdHR5cGVzID0gX3NjcmVlblR5cGVzLFxuXHRcdFx0YmVzdE1hdGNoID0gdHlwZXNbdHlwZXMubGVuZ3RoIC0gMV0ubmFtZTtcblxuXHRcdC8vIGxvb3AgdGhvcnVnaCByZXNvbHV0aW9uc1xuXHRcdGZvciAoaSA9IHR5cGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHQvLyBmaW5kIHRoZSBvbmUgdGhhdCBtYXRjaGVzIG91ciBjdXJyZW50IHNpemUgb3IgaXMgc21hbGxlci4gZGVmYXVsdCB0byB0aGUgZmlyc3QuXG5cdFx0XHRpZiAocmV6LndpZHRoIDw9IHR5cGVzW2ldLndpZHRoKSB7XG5cdFx0XHRcdGJlc3RNYXRjaCA9IHR5cGVzW2ldLm5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgcmVzb2x1dGlvbiBpZiB3ZSBmaW5kIG9uZS5cblx0XHRyZXR1cm4gYmVzdE1hdGNoO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZVNjcmVlbkJvZHlDbGFzc2VzOiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IF9zY3JlZW5UeXBlO1xuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHREb20uYWRkQm9keUNsYXNzKCdlbnlvLXJlcy0nICsgdHlwZS50b0xvd2VyQ2FzZSgpKTtcblx0XHRcdHZhciBzY3JPYmogPSBnZXRTY3JlZW5UeXBlT2JqZWN0KHR5cGUpO1xuXHRcdFx0aWYgKHNjck9iai5hc3BlY3RSYXRpb05hbWUpIHtcblx0XHRcdFx0RG9tLmFkZEJvZHlDbGFzcygnZW55by1hc3BlY3QtcmF0aW8tJyArIHNjck9iai5hc3BlY3RSYXRpb05hbWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0UmlSYXRpbzogZnVuY3Rpb24gKHR5cGUpIHtcblx0XHR0eXBlID0gdHlwZSB8fCBfc2NyZWVuVHlwZTtcblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIHJhdGlvID0gdGhpcy5nZXRVbml0VG9QaXhlbEZhY3RvcnModHlwZSkgLyB0aGlzLmdldFVuaXRUb1BpeGVsRmFjdG9ycyhfYmFzZVNjcmVlblR5cGUpO1xuXHRcdFx0aWYgKHR5cGUgPT0gX3NjcmVlblR5cGUpIHtcblx0XHRcdFx0Ly8gY2FjaGUgdGhpcyBpZiBpdCdzIGZvciBvdXIgY3VycmVudCBzY3JlZW4gdHlwZS5cblx0XHRcdFx0X3JpUmF0aW8gPSByYXRpbztcblx0XHRcdH1cblx0XHRcdHJldHVybiByYXRpbztcblx0XHR9XG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0VW5pdFRvUGl4ZWxGYWN0b3JzOiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IF9zY3JlZW5UeXBlO1xuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHRyZXR1cm4gZ2V0U2NyZWVuVHlwZU9iamVjdCh0eXBlKS5weFBlclJlbTtcblx0XHR9XG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBzY3JlZW4gdHlwZSBwcm92aWRlZC4gSWYgbm9uZSBpcyBwcm92aWRlZCB0aGUgY3VycmVudFxuXHQqIHNjcmVlbiB0eXBlIGlzIHVzZWQuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gdHlwZSBTY3JlZW4gdHlwZSB0byBnZXQgdGhlIGFzcGVjdCByYXRpbyBvZi4gUHJvdmlkaW5nIG5vdGhpbmcgdXNlcyB0aGVcblx0Klx0Y3VycmVudCBzY3JlZW4gdHlwZS5cblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBzY3JlZW4gcmF0aW8gKDEuMzMzLCAxLjc3NywgMi4zMzMsIGV0Yylcblx0KiBAcHVibGljXG5cdCovXG5cdGdldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHZhciBzY3JPYmogPSBnZXRTY3JlZW5UeXBlT2JqZWN0KHR5cGUpO1xuXHRcdGlmIChzY3JPYmoud2lkdGggJiYgc2NyT2JqLmhlaWdodCkge1xuXHRcdFx0cmV0dXJuIChzY3JPYmoud2lkdGggLyBzY3JPYmouaGVpZ2h0KTtcblx0XHR9XG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYXNwZWN0IHJhdGlvbiBnaXZlbiB0aGUgc2NyZWVuIHR5cGUgb3IgdGhlIGRlZmF1bHQgc2NyZWVuIHR5cGUgaWZcblx0KiBub25lIGlzIHByb2lkZWQuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gdHlwZSBTY3JlZW4gdHlwZSB0byBnZXQgdGhlIGFzcGVjdCByYXRpbyBvZi4gUHJvdmlkaW5nIG5vdGhpbmcgdXNlcyB0aGVcblx0Klx0Y3VycmVudCBzY3JlZW4gdHlwZS5cblx0KiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdHlwZSBvZiBzY3JlZW4gcmF0aW9cblx0KiBAcHVibGljXG5cdCovXG5cdGdldEFzcGVjdFJhdGlvTmFtZTogZnVuY3Rpb24gKHR5cGUpIHtcblx0XHR2YXIgc2NyT2JqID0gZ2V0U2NyZWVuVHlwZU9iamVjdCh0eXBlKTtcblx0XHQgcmV0dXJuIHNjck9iai5hc3BlY3RSYXRpb05hbWUgfHwgJ3N0YW5kYXJkJztcblx0fSxcblxuXHQvKipcblx0KiBUYWtlcyBhIHByb3ZpZGVkIHBpeGVsIHZhbHVlIGFuZCBwcmVmb3JtcyBhIHNjYWxpbmcgb3BlcmF0aW9uIG9uIHRoZSBudW1iZXIgYmFzZWQgb24gdGhlXG5cdCogY3VycmVudCBzY3JlZW4gdHlwZS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBweCBUaGUgYW1vdW50IG9mIHN0YW5kYXJkLXJlc29sdXRpb24gcGl4ZWxzIHRvIHNjYWxlIHRvIHRoZSBjdXJyZW50IHNjcmVlblxuXHQqXHRyZXNvbHV0aW9uLlxuXHQqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzY2FsZWQgdmFsdWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2NyZWVuIHNjYWxpbmcgZmFjdG9yLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2NhbGU6IGZ1bmN0aW9uIChweCkge1xuXHRcdHJldHVybiAoX3JpUmF0aW8gfHwgdGhpcy5nZXRSaVJhdGlvKCkpICogcHg7XG5cdH0sXG5cblx0LyoqXG5cdCogVGhlIGRlZmF1bHQgY29uZmlndXJhYmxlIFtvcHRpb25zXXtAbGluayByaS5zZWxlY3RTcmMjb3B0aW9uc30uXG5cdCpcblx0KiBAdHlwZWRlZiB7T2JqZWN0fSByaS5zZWxlY3RTcmN+c3JjXG5cdCogQHByb3BlcnR5IHtTdHJpbmd9IGhkIC0gSEQgLyA3MjBwIFJlc29sdXRpb24gaW1hZ2UgYXNzZXQgc291cmNlIFVSSS9VUkxcblx0KiBAcHJvcGVydHkge1N0cmluZ30gZmhkIC0gRkhEIC8gMTA4MHAgUmVzb2x1dGlvbiBpbWFnZSBhc3NldCBzb3VyY2UgVVJJL1VSTFxuXHQqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1aGQgLSBVSEQgLyA0SyBSZXNvbHV0aW9uIGltYWdlIGFzc2V0IHNvdXJjZSBVUkkvVVJMXG5cdCpcblx0KiBAdHlwZWRlZiB7U3RyaW5nfSByaS5zZWxlY3RTcmN+c3JjIC0gSW1hZ2UgYXNzZXQgc291cmNlIFVSSS9VUkxcblx0Ki9cblxuXHQvKipcblx0KiBJbWFnZSBzcmMgY2hvb3Nlci4gQSBzaW1wbGUgdXRpbGl0eSBtZXRob2QgdG8gc2VsZWN0IHRoZSBpZGVhbCBpbWFnZSBhc3NldCBmcm9tIGEgc2V0IG9mXG5cdCogYXNzZXRzLCBiYXNlZCBvbiB2YXJpb3VzIHNjcmVlbiByZXNvbHV0aW9uczogSEQgKDcyMHApLCBGSEQgKDEwODBwKSwgVUhEICg0aykuIFdoZW4gcHJvdmlkZWRcblx0KiB3aXRoIGEgc3JjIGFyZ3VtZW50LCBtdWx0aVJlc1NyYyB3aWxsIGNob29zZSB0aGUgYmVzdCBpbWFnZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgc2NyZWVuXG5cdCogcmVzb2x1dGlvbi4gYHNyY2AgbWF5IGJlIGVpdGhlciB0aGUgdHJhZGl0aW9uYWwgc3RyaW5nLCB3aGljaCB3aWxsIHBhc3Mgc3RyYWlnaHQgdGhyb3VnaCwgb3IgYVxuXHQqIGhhc2gvb2JqZWN0IG9mIHNjcmVlbiB0eXBlcyBhbmQgdGhlaXIgYXNzZXQgc291cmNlcyAoa2V5czpzY3JlZW4gYW5kIHZhbHVlczpzcmMpLiBUaGUgaW1hZ2Vcblx0KiBzb3VyY2VzIHdpbGwgYmUgdXNlZCBjaG9zZW4gd2hlbiB0aGUgc2NyZWVuIHJlc29sdXRpb24gaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZFxuXHQqIHNjcmVlbiB0eXBlcy5cblx0KlxuXHQqIGBgYFxuXHQqIC8vIFRha2UgYWR2YW50YWdlIG9mIHRoZSBtdWx0aS1yZXogbW9kZVxuXHQqIHtraW5kOiAnbW9vbi5JbWFnZScsIHNyYzoge1xuXHQqIFx0J2hkJzogJ2h0dHA6Ly9sb3JlbXBpeGVsLmNvbS82NC82NC9jaXR5LzEvJyxcblx0KiBcdCdmaGQnOiAnaHR0cDovL2xvcmVtcGl4ZWwuY29tLzEyOC8xMjgvY2l0eS8xLycsXG5cdCogXHQndWhkJzogJ2h0dHA6Ly9sb3JlbXBpeGVsLmNvbS8yNTYvMjU2L2NpdHkvMS8nXG5cdCogfSwgYWx0OiAnTXVsdGktcmV6J30sXG5cdCogLy8gU3RhbmRhcmQgc3RyaW5nIGBzcmNgXG5cdCoge2tpbmQ6ICdtb29uLkltYWdlJywgc3JjOiBodHRwOi8vbG9yZW1waXhlbC5jb20vMTI4LzEyOC9jaXR5LzEvJywgYWx0OiAnTGFyZ2UnfSxcblx0KiBgYGBcblx0KlxuXHQqIEBwYXJhbSB7KFN0cmluZ3xtb29uLnJpLnNlbGVjdFNyY35zcmMpfSBzcmMgQSBzdHJpbmcgY29udGFpbmluZyBhIHNpbmdsZSBpbWFnZSBzcmMgb3IgYVxuXHQqXHRrZXkvdmFsdWUgaGFzaC9vYmplY3QgY29udGFpbmluZyBrZXlzIHJlcHJlc2VudGluZyBzY3JlZW4gdHlwZXMgKGhkLCBmaGQsIHVoZCwgZXRjKSBhbmRcblx0Klx0dmFsdWVzIGNvbnRhaW5pbmcgdGhlIGFzc2V0IHNyYyBmb3IgdGhhdCB0YXJnZXQgc2NyZWVuIHJlc29sdXRpb24uXG5cdCogQHJldHVybnMge1N0cmluZ30gVGhlIGNob29zZW4gc3JjIGdpdmVuIHRoZSBzdHJpbmcgb3IgbGlzdCBwcm92aWRlZC5cblx0KiBAcHVibGljXG5cdCovXG5cdHNlbGVjdFNyYzogZnVuY3Rpb24gKHNyYykge1xuXHRcdGlmICh0eXBlb2Ygc3JjICE9ICdzdHJpbmcnICYmIHNyYykge1xuXHRcdFx0dmFyIGksIHQsXG5cdFx0XHRcdG5ld1NyYyA9IHNyYy5maGQgfHwgc3JjLnVoZCB8fCBzcmMuaGQsXG5cdFx0XHRcdHR5cGVzID0gX3NjcmVlblR5cGVzO1xuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggcmVzb2x1dGlvbnNcblx0XHRcdGZvciAoaSA9IHR5cGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHQgPSB0eXBlc1tpXS5uYW1lO1xuXHRcdFx0XHRpZiAoX3NjcmVlblR5cGUgPT0gdCAmJiBzcmNbdF0pIG5ld1NyYyA9IHNyY1t0XTtcblx0XHRcdH1cblxuXHRcdFx0c3JjID0gbmV3U3JjO1xuXHRcdH1cblx0XHRyZXR1cm4gc3JjO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFRoaXMgd2lsbCBuZWVkIHRvIGJlIHJlLXJ1biBhbnkgdGltZSB0aGUgc2NyZWVuIHNpemUgY2hhbmdlcywgc28gYWxsIHRoZSB2YWx1ZXMgY2FuIGJlXG5cdCogcmUtY2FjaGVkLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHQvLyBMYXRlciB3ZSBjYW4gd2lyZSB0aGlzIHVwIHRvIGEgc2NyZWVuIHJlc2l6ZSBldmVudCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5LlxuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0X3NjcmVlblR5cGUgPSB0aGlzLmdldFNjcmVlblR5cGUoKTtcblx0XHRfc2NyZWVuVHlwZU9iamVjdCA9IGdldFNjcmVlblR5cGVPYmplY3QoKTtcblx0XHR0aGlzLnVwZGF0ZVNjcmVlbkJvZHlDbGFzc2VzKCk7XG5cdFx0RG9tLnVuaXRUb1BpeGVsRmFjdG9ycy5yZW0gPSB0aGlzLmdldFVuaXRUb1BpeGVsRmFjdG9ycygpO1xuXHRcdF9yaVJhdGlvID0gdGhpcy5nZXRSaVJhdGlvKCk7XG5cdH1cbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL2RvbVwiOjU4fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0bG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdG9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKTtcblxudmFyIGRlZmF1bHRDdG9yID0gbnVsbDtcblxuLyoqXG4qIENyZWF0ZXMgYSBKYXZhU2NyaXB0IFtjb25zdHJ1Y3Rvcl17QGdsb3NzYXJ5IGNvbnN0cnVjdG9yfSBmdW5jdGlvbiB3aXRoXG4qIGEgcHJvdG90eXBlIGRlZmluZWQgYnkgYHByb3BzYC4gKipBbGwgY29uc3RydWN0b3JzIG11c3QgaGF2ZSBhIHVuaXF1ZSBuYW1lLioqXG4qXG4qIGBlbnlvLmtpbmQoKWAgbWFrZXMgaXQgZWFzeSB0byBidWlsZCBhIGNvbnN0cnVjdG9yLXdpdGgtcHJvdG90eXBlIChsaWtlIGFcbiogY2xhc3MpIHRoYXQgaGFzIGFkdmFuY2VkIGZlYXR1cmVzIGxpa2UgcHJvdG90eXBlLWNoYWluaW5nXG4qIChbaW5oZXJpdGFuY2Vde0BnbG9zc2FyeSBpbmhlcml0YW5jZX0pLlxuKlxuKiBBIHBsdWctaW4gc3lzdGVtIGlzIGluY2x1ZGVkIGZvciBleHRlbmRpbmcgdGhlIGFiaWxpdGllcyBvZiB0aGVcbiogW2tpbmRde0BnbG9zc2FyeSBraW5kfSBnZW5lcmF0b3IsIGFuZCBjb25zdHJ1Y3RvcnMgYXJlIGFsbG93ZWQgdG9cbiogcGVyZm9ybSBjdXN0b20gb3BlcmF0aW9ucyB3aGVuIHN1YmNsYXNzZWQuXG4qXG4qIElmIHlvdSBtYWtlIGNoYW5nZXMgdG8gYGVueW8ua2luZCgpYCwgYmUgc3VyZSB0byBhZGQgb3IgdXBkYXRlIHRoZSBhcHByb3ByaWF0ZVxuKiBbdW5pdCB0ZXN0c10oQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VueW9qcy9lbnlvL3RyZWUvbWFzdGVyL3Rvb2xzL3Rlc3QvY29yZS90ZXN0cykuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0tpbmRzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUva2V5LWNvbmNlcHRzL2tpbmRzLmh0bWx9IGluIHRoZSBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQG5hbWVzcGFjZSBlbnlvLmtpbmRcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gQSBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gb2YgcHJvcGVydGllcyB1c2VkIHRvIGRlZmluZSBhbmQgY3JlYXRlXG4qXHR0aGUgW2tpbmRde0BnbG9zc2FyeSBraW5kfVxuKiBAcHVibGljXG4qL1xudmFyIGtpbmQgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcblx0Ly8gZXh0cmFjdCAnbmFtZScgcHJvcGVydHlcblx0dmFyIG5hbWUgPSBwcm9wcy5uYW1lIHx8ICcnO1xuXHRkZWxldGUgcHJvcHMubmFtZTtcblx0Ly8gZXh0cmFjdCAna2luZCcgcHJvcGVydHlcblx0dmFyIGhhc0tpbmQgPSAoJ2tpbmQnIGluIHByb3BzKTtcblx0dmFyIGtpbmROYW1lID0gcHJvcHMua2luZDtcblx0ZGVsZXRlIHByb3BzLmtpbmQ7XG5cdC8vIGVzdGFibGlzaCBiYXNlIGNsYXNzIHJlZmVyZW5jZVxuXHR2YXIgYmFzZSA9IGNvbnN0cnVjdG9yRm9yS2luZChraW5kTmFtZSk7XG5cdHZhciBpc2EgPSBiYXNlICYmIGJhc2UucHJvdG90eXBlIHx8IG51bGw7XG5cdC8vIGlmIHdlIGhhdmUgYW4gZXhwbGljaXQga2luZCBwcm9wZXJ0eSB3aXRoIHZhbHVlIHVuZGVmaW5lZCwgd2UgcHJvYmFibHlcblx0Ly8gdHJpZWQgdG8gcmVmZXJlbmNlIGEga2luZCB0aGF0IGlzIG5vdCB5ZXQgaW4gc2NvcGVcblx0aWYgKGhhc0tpbmQgJiYga2luZE5hbWUgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgcHJvYmxlbSA9IGtpbmROYW1lID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkIGtpbmQnIDogJ3Vua25vd24ga2luZCAoJyArIGtpbmROYW1lICsgJyknO1xuXHRcdHRocm93ICdlbnlvLmtpbmQ6IEF0dGVtcHQgdG8gc3ViY2xhc3MgYW4gJyArIHByb2JsZW0gKyAnLiBDaGVjayBkZXBlbmRlbmNpZXMgZm9yIFsnICsgKG5hbWUgfHwgJzx1bm5hbWVkPicpICsgJ10uJztcblx0fVxuXHQvLyBtYWtlIGEgYm9pbGVycGxhdGUgY29uc3RydWN0b3Jcblx0dmFyIGN0b3IgPSBraW5kLm1ha2VDdG9yKCk7XG5cdC8vIHNlbWktcmVzZXJ2ZWQgd29yZCAnY29uc3RydWN0b3InIGNhdXNlcyBwcm9ibGVtcyB3aXRoIFByb3RvdHlwZSBhbmQgSUUsIHNvIHdlIHJlbmFtZSBpdCBoZXJlXG5cdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuXHRcdHByb3BzLl9jb25zdHJ1Y3RvciA9IHByb3BzLmNvbnN0cnVjdG9yO1xuXHRcdGRlbGV0ZSBwcm9wcy5jb25zdHJ1Y3Rvcjtcblx0fVxuXHQvLyBjcmVhdGUgb3VyIHByb3RvdHlwZVxuXHQvL2N0b3IucHJvdG90eXBlID0gaXNhID8gZW55by5kZWxlZ2F0ZShpc2EpIDoge307XG5cdHV0aWxzLnNldFByb3RvdHlwZShjdG9yLCBpc2EgPyB1dGlscy5kZWxlZ2F0ZShpc2EpIDoge30pO1xuXHQvLyB0aGVyZSBhcmUgc3BlY2lhbCBjYXNlcyB3aGVyZSBhIGJhc2UgY2xhc3MgaGFzIGEgcHJvcGVydHlcblx0Ly8gdGhhdCBtYXkgbmVlZCB0byBiZSBjb25jYXRlbmF0ZWQgd2l0aCBhIHN1YmNsYXNzZXMgaW1wbGVtZW50YXRpb25cblx0Ly8gYXMgb3Bwb3NlZCB0byBjb21wbGV0ZWx5IG92ZXJ3cml0aW5nIGl0Li4uXG5cdGtpbmQuY29uY2F0SGFuZGxlcihjdG9yLCBwcm9wcyk7XG5cblx0Ly8gcHV0IGluIG91ciBwcm9wc1xuXHR1dGlscy5taXhpbihjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xuXHQvLyBhbGlhcyBjbGFzcyBuYW1lIGFzICdraW5kJyBpbiB0aGUgcHJvdG90eXBlXG5cdC8vIGJ1dCB3ZSBhY3R1YWxseSBvbmx5IG5lZWQgdG8gc2V0IHRoaXMgaWYgYSBuZXcgbmFtZSB3YXMgdXNlZCxcblx0Ly8gbm90IGlmIGl0IGlzIGluaGVyaXRpbmcgZnJvbSBhIGtpbmQgYW5vbnltb3VzbHlcblx0aWYgKG5hbWUpIHtcblx0XHRjdG9yLnByb3RvdHlwZS5raW5kTmFtZSA9IG5hbWU7XG5cdH1cblx0Ly8gdGhpcyBpcyBmb3IgYW5vbnltb3VzIGNvbnN0cnVjdG9yc1xuXHRlbHNlIHtcblx0XHRjdG9yLnByb3RvdHlwZS5raW5kTmFtZSA9IGJhc2UgJiYgYmFzZS5wcm90b3R5cGU/IGJhc2UucHJvdG90eXBlLmtpbmROYW1lOiAnJztcblx0fVxuXHQvLyBjYWNoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yXG5cdGN0b3IucHJvdG90eXBlLmJhc2UgPSBiYXNlO1xuXHQvLyByZWZlcmVuY2Ugb3VyIHJlYWwgY29uc3RydWN0b3Jcblx0Y3Rvci5wcm90b3R5cGUuY3RvciA9IGN0b3I7XG5cdC8vIHN1cHBvcnQgcGx1Z2dhYmxlICdmZWF0dXJlcydcblx0dXRpbHMuZm9yRWFjaChraW5kLmZlYXR1cmVzLCBmdW5jdGlvbihmbil7IGZuKGN0b3IsIHByb3BzKTsgfSk7XG5cdFxuXHRpZiAobmFtZSkga2luZEN0b3JzW25hbWVdID0gY3Rvcjtcblx0XG5cdHJldHVybiBjdG9yO1xufTtcblxuZXhwb3J0cy5zZXREZWZhdWx0Q3RvciA9IGZ1bmN0aW9uIChjdG9yKSB7XG5cdGRlZmF1bHRDdG9yID0gY3Rvcjtcbn07XG5cbnZhciBnZXREZWZhdWx0Q3RvciA9IGV4cG9ydHMuZ2V0RGVmYXVsdEN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBkZWZhdWx0Q3Rvcjtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBjb25jYXRlbmF0ZWQgPSBleHBvcnRzLmNvbmNhdGVuYXRlZCA9IFtdO1xuXG4vKipcbiogQ3JlYXRlcyBhIHNpbmdsZXRvbiBvZiBhIGdpdmVuIFtraW5kXXtAZ2xvc3Nhcnkga2luZH0gd2l0aCBhIGdpdmVuXG4qIGRlZmluaXRpb24uICoqVGhlIGBuYW1lYCBwcm9wZXJ0eSB3aWxsIGJlIHRoZSBpbnN0YW5jZSBuYW1lIG9mIHRoZSBzaW5nbGV0b25cbiogYW5kIG11c3QgYmUgdW5pcXVlLioqXG4qXG4qIGBgYGphdmFzY3JpcHRcbipcdGVueW8uc2luZ2xldG9uKHtcbipcdFx0a2luZDogJ2VueW8uQ29udHJvbCcsXG4qXHRcdG5hbWU6ICdhcHAuTXlTaW5nbGV0b24nLFxuKlx0XHRwdWJsaXNoZWQ6IHtcbipcdFx0XHR2YWx1ZTogJ2ZvbydcbipcdFx0fSxcbipcdFx0bWFrZVNvbWV0aGluZzogZnVuY3Rpb24oKSB7XG4qXHRcdFx0Ly8uLi5cbipcdFx0fVxuKlx0fSk7XG4qXG4qXHRhcHAuTXlTaW5nbGV0b24ubWFrZVNvbWV0aGluZygpO1xuKlx0YXBwLk15U2luZ2xldG9uLnNldFZhbHVlKCdiYXInKTtcbipgYGBcbipcbiogQHB1YmxpY1xuKi9cbmV4cG9ydHMuc2luZ2xldG9uID0gZnVuY3Rpb24gKGNvbmYsIGNvbnRleHQpIHtcblx0Ly8gZXh0cmFjdCAnbmFtZScgcHJvcGVydHkgKHRoZSBuYW1lIG9mIG91ciBzaW5nbGV0b24pXG5cdHZhciBuYW1lID0gY29uZi5uYW1lO1xuXHRkZWxldGUoY29uZi5uYW1lKTtcblx0Ly8gY3JlYXRlIGFuIHVubmFtZWQga2luZCBhbmQgc2F2ZSBpdHMgY29uc3RydWN0b3IncyBmdW5jdGlvblxuXHR2YXIgS2luZCA9IGtpbmQoY29uZik7XG5cdHZhciBpbnN0O1xuXHQvLyBjcmVhdGUgdGhlIHNpbmdsZXRvbiB3aXRoIHRoZSBwcmV2aW91cyBuYW1lIGFuZCBjb25zdHJ1Y3RvclxuXHR1dGlscy5zZXRQYXRoLmNhbGwoY29udGV4dCB8fCBnbG9iYWwsIG5hbWUsIChpbnN0ID0gbmV3IEtpbmQoKSkpO1xuXHRyZXR1cm4gaW5zdDtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmtpbmQubWFrZUN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBlbnlvQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGVueW9Db25zdHJ1Y3RvcikpIHtcblx0XHRcdHRocm93ICdlbnlvLmtpbmQ6IGNvbnN0cnVjdG9yIGNhbGxlZCBkaXJlY3RseSwgbm90IHVzaW5nIFwibmV3XCInO1xuXHRcdH1cblxuXHRcdC8vIHR3by1wYXNzIGluc3RhbnRpYXRpb25cblx0XHR2YXIgcmVzdWx0O1xuXHRcdGlmICh0aGlzLl9jb25zdHJ1Y3Rvcikge1xuXHRcdFx0Ly8gcHVyZSBjb25zdHJ1Y3Rpb25cblx0XHRcdHJlc3VsdCA9IHRoaXMuX2NvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHRcdC8vIGRlZmVyIGluaXRpYWxpemF0aW9uIHVudGlsIGVudGlyZSBjb25zdHJ1Y3RvciBjaGFpbiBoYXMgZmluaXNoZWRcblx0XHRpZiAodGhpcy5jb25zdHJ1Y3RlZCkge1xuXHRcdFx0Ly8gcG9zdC1jb25zdHJ1Y3RvciBpbml0aWFsaXphdGlvblxuXHRcdFx0dGhpcy5jb25zdHJ1Y3RlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gZW55b0NvbnN0cnVjdG9yO1xufTtcblxuLyoqXG4qIENsYXNzZXMgcmVmZXJlbmNlZCBieSBuYW1lIG1heSBvbWl0IHRoaXMgbmFtZXNwYWNlIChlLmcuLCBcIkJ1dHRvblwiIGluc3RlYWQgb2YgXCJlbnlvLkJ1dHRvblwiKVxuKlxuKiBAcHJpdmF0ZVxuKi9cbmtpbmQuZGVmYXVsdE5hbWVzcGFjZSA9ICdlbnlvJztcblxuLyoqXG4qIEZlYXR1cmUgaG9va3MgZm9yIHRoZSBvb3Agc3lzdGVtXG4qXG4qIEBwcml2YXRlXG4qL1xua2luZC5mZWF0dXJlcyA9IFtdO1xuXG4vKipcbiogVXNlZCBpbnRlcm5hbGx5IGJ5IHNldmVyYWwgbWVjaGFuaXNtcyB0byBhbGxvdyBzYWZlIGFuZCBub3JtYWxpemVkIGhhbmRsaW5nIGZvciBleHRlbmRpbmcgYVxuKiBba2luZCdzXXtAZ2xvc3Nhcnkga2luZH0gc3VwZXItbWV0aG9kcy4gSXQgY2FuIHRha2UgYVxuKiBbY29uc3RydWN0b3Jde0BnbG9zc2FyeSBjb25zdHJ1Y3Rvcn0sIGEgW3Byb3RvdHlwZV17QGdsb3NzYXJ5IE9iamVjdC5wcm90b3R5cGV9LCBvciBhblxuKiBpbnN0YW5jZS5cbipcbiogQHByaXZhdGVcbiovXG5raW5kLmV4dGVuZE1ldGhvZHMgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMsIGFkZCkge1xuXHR2YXIgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSB8fCBjdG9yLFxuXHRcdGIgPSBwcm90by5iYXNlO1xuXHRpZiAoIXByb3RvLmluaGVyaXRlZCAmJiBiKSB7XG5cdFx0cHJvdG8uaW5oZXJpdGVkID0ga2luZC5pbmhlcml0ZWQ7XG5cdH1cblx0Ly8gcmVuYW1lIGNvbnN0cnVjdG9yIHRvIF9jb25zdHJ1Y3RvciB0byB3b3JrIGFyb3VuZCBJRTgvUHJvdG90eXBlIHByb2JsZW1zXG5cdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuXHRcdHByb3BzLl9jb25zdHJ1Y3RvciA9IHByb3BzLmNvbnN0cnVjdG9yO1xuXHRcdGRlbGV0ZSBwcm9wcy5jb25zdHJ1Y3Rvcjtcblx0fVxuXHQvLyBkZWNvcmF0ZSBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIHN1cHBvcnQgaW5oZXJpdGVkIChkbyB0aGlzIGV4IHBvc3QgZmFjdG8gc28gdGhhdFxuXHQvLyBjdG9yLnByb3RvdHlwZSBpcyBrbm93biwgcmVsaWVzIG9uIGVsZW1lbnRzIGluIHByb3BzIGJlaW5nIGNvcGllZCBieSByZWZlcmVuY2UpXG5cdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHR2YXIgcCA9IHByb3BzW25dO1xuXHRcdGlmIChpc0luaGVyaXRlZChwKSkge1xuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXNuJ3QgYWN0dWFsbHkgYSBzdXBlciBtZXRob2QgdG8gY2FsbCwgaXQgd29uJ3Rcblx0XHRcdC8vIGZhaWwgbWlzZXJhYmx5IC0gd2hpbGUgdGhpcyBzaG91bGRuJ3QgaGFwcGVuIG9mdGVuLCBpdCBpcyBhIHNhbml0eVxuXHRcdFx0Ly8gY2hlY2sgZm9yIG1peGluLWV4dGVuc2lvbnMgZm9yIGtpbmRzXG5cdFx0XHRpZiAoYWRkKSB7XG5cdFx0XHRcdHAgPSBwcm90b1tuXSA9IHAuZm4ocHJvdG9bbl0gfHwgdXRpbHMubm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHAgPSBwcm90b1tuXSA9IHAuZm4oYj8gKGIucHJvdG90eXBlW25dIHx8IHV0aWxzLm5vcCk6IHV0aWxzLm5vcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh1dGlscy5pc0Z1bmN0aW9uKHApKSB7XG5cdFx0XHRpZiAoYWRkKSB7XG5cdFx0XHRcdHByb3RvW25dID0gcDtcblx0XHRcdFx0cC5kaXNwbGF5TmFtZSA9IG4gKyAnKCknO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cC5faW5oZXJpdGVkID0gYj8gYi5wcm90b3R5cGVbbl06IG51bGw7XG5cdFx0XHRcdC8vIEZJWE1FOiB3ZSB1c2VkIHRvIG5lZWQgc29tZSBleHRyYSB2YWx1ZXMgZm9yIGluaGVyaXRlZCwgdGhlbiBpbmhlcml0ZWQgZ290IGNsZWFuZXJcblx0XHRcdFx0Ly8gYnV0IGluIHRoZSBtZWFudGltZSB3ZSB1c2VkIHRoZXNlIHZhbHVlcyB0byBzdXBwb3J0IGxvZ2dpbmcgaW4gT2JqZWN0LlxuXHRcdFx0XHQvLyBGb3Igbm93IHdlIHN1cHBvcnQgdGhpcyBsZWdhY3kgc2l0dWF0aW9uLCBieSBzdXBwbGluZyBsb2dnaW5nIGluZm9ybWF0aW9uIGhlcmUuXG5cdFx0XHRcdHAuZGlzcGxheU5hbWUgPSBwcm90by5raW5kTmFtZSArICcuJyArIG4gKyAnKCknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbmtpbmQuZmVhdHVyZXMucHVzaChraW5kLmV4dGVuZE1ldGhvZHMpO1xuXG4vKipcbiogQ2FsbGVkIGJ5IHtAbGluayBlbnlvLk9iamVjdH0gaW5zdGFuY2VzIGF0dGVtcHRpbmcgdG8gYWNjZXNzIHN1cGVyLW1ldGhvZHNcbiogb2YgYSBwYXJlbnQgY2xhc3MgKFtraW5kXXtAZ2xvc3Nhcnkga2luZH0pIGJ5IGNhbGxpbmdcbiogYHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cylgIGZyb20gd2l0aGluIGEga2luZCBtZXRob2QuIFRoaXMgY2FuIG9ubHkgYmUgZG9uZVxuKiBzYWZlbHkgd2hlbiB0aGVyZSBpcyBrbm93biB0byBiZSBhIHN1cGVyIGNsYXNzIHdpdGggdGhlIHNhbWUgbWV0aG9kLlxuKlxuKiBAcHJpdmF0ZVxuKi9cbmtpbmQuaW5oZXJpdGVkID0gZnVuY3Rpb24gKG9yaWdpbmFscywgcmVwbGFjZW1lbnRzKSB7XG5cdC8vIG9uZS1vZmYgbWV0aG9kcyBhcmUgdGhlIGZhc3QgdHJhY2tcblx0dmFyIHRhcmdldCA9IG9yaWdpbmFscy5jYWxsZWU7XG5cdHZhciBmbiA9IHRhcmdldC5faW5oZXJpdGVkO1xuXG5cdC8vIHJlZ2FyZGxlc3Mgb2YgaG93IHdlIGdvdCBoZXJlLCBqdXN0IGVuc3VyZSB3ZSBhY3R1YWxseVxuXHQvLyBoYXZlIGEgZnVuY3Rpb24gdG8gY2FsbCBvciBlbHNlIHdlIHRocm93IGEgY29uc29sZVxuXHQvLyB3YXJuaW5nIHRvIG5vdGlmeSBkZXZlbG9wZXJzIHRoZXkgYXJlIGNhbGxpbmcgYVxuXHQvLyBzdXBlciBtZXRob2QgdGhhdCBkb2Vzbid0IGV4aXN0XG5cdGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm4pIHtcblx0XHR2YXIgYXJncyA9IG9yaWdpbmFscztcblx0XHRpZiAocmVwbGFjZW1lbnRzKSB7XG5cdFx0XHQvLyBjb21iaW5lIHRoZSB0d28gYXJyYXlzLCB3aXRoIHRoZSByZXBsYWNlbWVudHMgdGFraW5nIHRoZSBmaXJzdFxuXHRcdFx0Ly8gc2V0IG9mIGFyZ3VtZW50cywgYW5kIG9yaWdpbmFscyBmaWxsaW5nIHVwIHRoZSByZXN0LlxuXHRcdFx0YXJncyA9IFtdO1xuXHRcdFx0dmFyIGkgPSAwLCBsID0gcmVwbGFjZW1lbnRzLmxlbmd0aDtcblx0XHRcdGZvciAoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdGFyZ3NbaV0gPSByZXBsYWNlbWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRsID0gb3JpZ2luYWxzLmxlbmd0aDtcblx0XHRcdGZvciAoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdGFyZ3NbaV0gPSBvcmlnaW5hbHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSBlbHNlIHtcblx0XHRsb2dnZXIud2FybignZW55by5raW5kLmluaGVyaXRlZDogdW5hYmxlIHRvIGZpbmQgcmVxdWVzdGVkICcgK1xuXHRcdFx0J3N1cGVyLW1ldGhvZCBmcm9tIC0+ICcgKyBvcmlnaW5hbHMuY2FsbGVlLmRpc3BsYXlOYW1lICsgJyBpbiAnICsgdGhpcy5raW5kTmFtZSk7XG5cdH1cbn07XG5cbi8vIGRjbCBpbnNwaXJlZCBzdXBlci1pbmhlcml0YW5jZVxuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgSW5oZXJpdGVkID0gZnVuY3Rpb24gKGZuKSB7XG5cdHRoaXMuZm4gPSBmbjtcbn07XG5cbi8qKlxuKiBXaGVuIGRlZmluaW5nIGEgbWV0aG9kIHRoYXQgb3ZlcnJpZGVzIGFuIGV4aXN0aW5nIG1ldGhvZCBpbiBhIFtraW5kXXtAZ2xvc3Nhcnkga2luZH0sIHlvdVxuKiBjYW4gd3JhcCB0aGUgZGVmaW5pdGlvbiBpbiB0aGlzIGZ1bmN0aW9uIGFuZCBpdCB3aWxsIGRlY29yYXRlIGl0IGFwcHJvcHJpYXRlbHkgZm9yIGluaGVyaXRhbmNlXG4qIHRvIHdvcmsuXG4qXG4qIFRoZSBvbGRlciBgdGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKWAgbWV0aG9kIHN0aWxsIHdvcmtzLCBidXQgdGhpcyB2ZXJzaW9uIHJlc3VsdHMgaW4gbXVjaFxuKiBmYXN0ZXIgY29kZSBhbmQgaXMgdGhlIG9ubHkgb25lIHN1cHBvcnRlZCBmb3Iga2luZCBbbWl4aW5zXXtAZ2xvc3NhcnkgbWl4aW59LlxuKlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIEEgW2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IHRoYXQgdGFrZXMgYSBzaW5nbGVcbiogICBhcmd1bWVudCAodXN1YWxseSBuYW1lZCBgc3VwYCkgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB3aGVyZVxuKiAgIGBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKWAgaXMgdXNlZCBhcyBhIG1lY2hhbmlzbSB0byBtYWtlIHRoZVxuKiAgIHN1cGVyLWNhbGwuXG4qIEBwdWJsaWNcbiovXG52YXIgaW5oZXJpdCA9IGV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gbmV3IEluaGVyaXRlZChmbik7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgaXNJbmhlcml0ZWQgPSBleHBvcnRzLmlzSW5oZXJpdGVkID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiBmbiAmJiAoZm4gaW5zdGFuY2VvZiBJbmhlcml0ZWQpO1xufTtcblxuXG4vL1xuLy8gJ3N0YXRpY3MnIGZlYXR1cmVcbi8vXG5raW5kLmZlYXR1cmVzLnB1c2goZnVuY3Rpb24oY3RvciwgcHJvcHMpIHtcblx0Ly8gaW5zdGFsbCBjb21tb24gc3RhdGljc1xuXHRpZiAoIWN0b3Iuc3ViY2xhc3MpIHtcblx0XHRjdG9yLnN1YmNsYXNzID0ga2luZC5zdGF0aWNzLnN1YmNsYXNzO1xuXHR9XG5cdGlmICghY3Rvci5leHRlbmQpIHtcblx0XHRjdG9yLmV4dGVuZCA9IGtpbmQuc3RhdGljcy5leHRlbmQ7XG5cdH1cblx0Ly8gbW92ZSBwcm9wcyBzdGF0aWNzIHRvIGNvbnN0cnVjdG9yXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XG5cdFx0dXRpbHMubWl4aW4oY3RvciwgcHJvcHMuc3RhdGljcyk7XG5cdFx0ZGVsZXRlIGN0b3IucHJvdG90eXBlLnN0YXRpY3M7XG5cdH1cblx0Ly8gYWxzbyBzdXBwb3J0IHByb3RlY3RlZFN0YXRpY3Mgd2hpY2ggd29uJ3QgaW50ZXJmZXJlIHdpdGggZGVmZXJcblx0aWYgKHByb3BzLnByb3RlY3RlZFN0YXRpY3MpIHtcblx0XHR1dGlscy5taXhpbihjdG9yLCBwcm9wcy5wcm90ZWN0ZWRTdGF0aWNzKTtcblx0XHRkZWxldGUgY3Rvci5wcm90b3R5cGUucHJvdGVjdGVkU3RhdGljcztcblx0fVxuXHQvLyBhbGxvdyBzdXBlcmNsYXNzIGN1c3RvbWl6YXRpb25cblx0dmFyIGJhc2UgPSBjdG9yLnByb3RvdHlwZS5iYXNlO1xuXHR3aGlsZSAoYmFzZSkge1xuXHRcdGJhc2Uuc3ViY2xhc3MoY3RvciwgcHJvcHMpO1xuXHRcdGJhc2UgPSBiYXNlLnByb3RvdHlwZS5iYXNlO1xuXHR9XG59KTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xua2luZC5zdGF0aWNzID0ge1xuXG5cdC8qKlxuXHQqIEEgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBtYXkgc2V0IGl0cyBvd24gYHN1YmNsYXNzKClgIG1ldGhvZCBhcyBhXG5cdCogc3RhdGljIG1ldGhvZCBmb3IgaXRzIFtjb25zdHJ1Y3Rvcl17QGdsb3NzYXJ5IGNvbnN0cnVjdG9yfS4gV2hlbmV2ZXJcblx0KiBpdCBpcyBzdWJjbGFzc2VkLCB0aGUgY29uc3RydWN0b3IgYW5kIHByb3BlcnRpZXMgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaFxuXHQqIHRoaXMgbWV0aG9kIGZvciBzcGVjaWFsIGhhbmRsaW5nIG9mIGltcG9ydGFudCBmZWF0dXJlcy5cblx0KlxuXHQqIEBwYXJhbSB7RnVuY3Rpb259IGN0b3IgLSBUaGUgW2NvbnN0cnVjdG9yXXtAZ2xvc3NhcnkgY29uc3RydWN0b3J9IG9mIHRoZVxuXHQqXHRba2luZF17QGdsb3NzYXJ5IGtpbmR9IGJlaW5nIHN1YmNsYXNzZWQuXG5cdCogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGtpbmQgYmVpbmcgc3ViY2xhc3NlZC5cblx0KiBAbWVtYmVyb2YgZW55by5raW5kXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdWJjbGFzczogZnVuY3Rpb24gKGN0b3IsIHByb3BzKSB7fSxcblxuXHQvKipcblx0KiBBbGxvd3MgZm9yIGV4dGVuc2lvbiBvZiB0aGUgY3VycmVudCBba2luZF17QGdsb3NzYXJ5IGtpbmR9IHdpdGhvdXRcblx0KiBjcmVhdGluZyBhIG5ldyBraW5kLiBUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb24gYWxsXG5cdCogW2NvbnN0cnVjdG9yc117QGdsb3NzYXJ5IGNvbnN0cnVjdG9yfSwgYWx0aG91Z2ggY2FsbGluZyBpdCBvbiBhXG5cdCogW2RlZmVycmVkXXtAZ2xvc3NhcnkgZGVmZXJyZWR9IGNvbnN0cnVjdG9yIHdpbGwgZm9yY2UgaXQgdG8gYmVcblx0KiByZXNvbHZlZCBhdCB0aGF0IHRpbWUuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHJlLXJ1biB0aGVcblx0KiB7QGxpbmsgZW55by5raW5kLmZlYXR1cmVzfSBhZ2FpbnN0IHRoZSBjb25zdHJ1Y3RvciBvciBpbnN0YW5jZS5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBwcm9wcyBBIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSBvciBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX1cblx0Klx0b2YgW2hhc2hlc117QGdsb3NzYXJ5IE9iamVjdH0uIFByb3BlcnRpZXMgd2lsbCBvdmVycmlkZVxuXHQqXHRbcHJvdG90eXBlXXtAZ2xvc3NhcnkgT2JqZWN0LnByb3RvdHlwZX0gcHJvcGVydGllcy4gSWYgYVxuXHQqXHRtZXRob2QgdGhhdCBpcyBiZWluZyBhZGRlZCBhbHJlYWR5IGV4aXN0cywgdGhlIG5ldyBtZXRob2Qgd2lsbFxuXHQqXHRzdXBlcnNlZGUgdGhlIGV4aXN0aW5nIG9uZS4gVGhlIG1ldGhvZCBtYXkgY2FsbFxuXHQqXHRgdGhpcy5pbmhlcml0ZWQoKWAgb3IgYmUgd3JhcHBlZCB3aXRoIGBraW5kLmluaGVyaXQoKWAgdG8gY2FsbFxuXHQqXHR0aGUgb3JpZ2luYWwgbWV0aG9kICh0aGlzIGNoYWlucyBtdWx0aXBsZSBtZXRob2RzIHRpZWQgdG8gYVxuXHQqXHRzaW5nbGUgW2tpbmRde0BnbG9zc2FyeSBraW5kfSkuXG5cdCogQHBhcmFtIHtPYmplY3R9IFt0YXJnZXRdIC0gVGhlIGluc3RhbmNlIHRvIGJlIGV4dGVuZGVkLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlXG5cdCpcdFtjb25zdHJ1Y3Rvcl17QGdsb3NzYXJ5IGNvbnN0cnVjdG9yfSBvZiB0aGVcblx0Klx0W29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIG9uIHdpbGxcblx0Klx0YmUgZXh0ZW5kZWQuXG5cdCogQHJldHVybnMge09iamVjdH0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjbGFzcywgb3Igc3BlY2lmaWNcblx0Klx0aW5zdGFuY2UsIHRoYXQgaGFzIGJlZW4gZXh0ZW5kZWQuXG5cdCogQG1lbWJlcm9mIGVueW8ua2luZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZXh0ZW5kOiBmdW5jdGlvbiAocHJvcHMsIHRhcmdldCkge1xuXHRcdHZhciBjdG9yID0gdGhpc1xuXHRcdFx0LCBleHRzID0gdXRpbHMuaXNBcnJheShwcm9wcyk/IHByb3BzOiBbcHJvcHNdXG5cdFx0XHQsIHByb3RvLCBmbjtcblxuXHRcdGZuID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdHJldHVybiAhKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGlzSW5oZXJpdGVkKHZhbHVlKSkgJiYgY29uY2F0ZW5hdGVkLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG5cdFx0fTtcblxuXHRcdHByb3RvID0gdGFyZ2V0IHx8IGN0b3IucHJvdG90eXBlO1xuXHRcdGZvciAodmFyIGk9MCwgZXh0OyAoZXh0PWV4dHNbaV0pOyArK2kpIHtcblx0XHRcdGNvbmNhdEhhbmRsZXIocHJvdG8sIGV4dCwgdHJ1ZSk7XG5cdFx0XHRraW5kLmV4dGVuZE1ldGhvZHMocHJvdG8sIGV4dCwgdHJ1ZSk7XG5cdFx0XHR1dGlscy5taXhpbihwcm90bywgZXh0LCB7ZmlsdGVyOiBmbn0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQgfHwgY3Rvcjtcblx0fVxufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xudmFyIGNvbmNhdEhhbmRsZXIgPSBleHBvcnRzLmNvbmNhdEhhbmRsZXIgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMsIGluc3RhbmNlKSB7XG5cdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3Jcblx0XHQsIGJhc2UgPSBwcm90by5jdG9yO1xuXG5cdHdoaWxlIChiYXNlKSB7XG5cdFx0aWYgKGJhc2UuY29uY2F0KSBiYXNlLmNvbmNhdChjdG9yLCBwcm9wcywgaW5zdGFuY2UpO1xuXHRcdGJhc2UgPSBiYXNlLnByb3RvdHlwZS5iYXNlO1xuXHR9XG59O1xuXG4vKipcbiogRmFjdG9yeSBmb3IgW2tpbmRzXXtAZ2xvc3Nhcnkga2luZH0gaWRlbnRpZmllZCBieSBbc3RyaW5nc117QGdsb3NzYXJ5IFN0cmluZ30uXG4qXG4qIEBwcml2YXRlXG4qL1xudmFyIGtpbmRDdG9ycyA9IGV4cG9ydHMuX2tpbmRDdG9ycyA9IHt9O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgY29uc3RydWN0b3JGb3JLaW5kID0gZXhwb3J0cy5jb25zdHJ1Y3RvckZvcktpbmQgPSBmdW5jdGlvbiAoa2luZCkge1xuXHRpZiAoa2luZCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBraW5kO1xuXHR9IGVsc2UgaWYgKGtpbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBnZXREZWZhdWx0Q3RvcigpO1xuXHR9XG5cdGVsc2UgaWYgKHV0aWxzLmlzRnVuY3Rpb24oa2luZCkpIHtcblx0XHRyZXR1cm4ga2luZDtcblx0fVxuXG5cdC8vIHVzZSBtZW1vaXplZCBjb25zdHJ1Y3RvciBpZiBhdmFpbGFibGUuLi5cblx0dmFyIGN0b3IgPSBraW5kQ3RvcnNba2luZF07XG5cdGlmIChjdG9yKSB7XG5cdFx0cmV0dXJuIGN0b3I7XG5cdH1cblx0Ly8gb3RoZXJ3aXNlIGxvb2sgaXQgdXAgYW5kIG1lbW9pemUgd2hhdCB3ZSBmaW5kXG5cdC8vXG5cdC8vIGlmIGtpbmQgaXMgYW4gb2JqZWN0IGluIGVueW8sIHNheSBcIkNvbnRyb2xcIiwgdGhlbiBjdG9yID0gZW55b1tcIkNvbnRyb2xcIl1cblx0Ly8gaWYga2luZCBpcyBhIHBhdGggdW5kZXIgZW55bywgc2F5IFwiSGVyaXRhZ2UuQnV0dG9uXCIsIHRoZW4gY3RvciA9IGVueW9bXCJIZXJpdGFnZS5CdXR0b25cIl0gfHwgZW55by5IZXJpdGFnZS5CdXR0b25cblx0Ly8gaWYga2luZCBpcyBhIGZ1bGx5IHF1YWxpZmllZCBwYXRoLCBzYXkgXCJlbnlvLkhlcml0YWdlLkJ1dHRvblwiLCB0aGVuIGN0b3IgPSBlbnlvW1wiZW55by5IZXJpdGFnZS5CdXR0b25cIl0gfHwgZW55by5lbnlvLkhlcml0YWdlLkJ1dHRvbiB8fCBlbnlvLkhlcml0YWdlLkJ1dHRvblxuXHQvL1xuXHQvLyBOb3RlIHRoYXQga2luZCBcIkZvb1wiIHdpbGwgcmVzb2x2ZSB0byBlbnlvLkZvbyBiZWZvcmUgcmVzb2x2aW5nIHRvIGdsb2JhbCBcIkZvb1wiLlxuXHQvLyBUaGlzIGlzIGltcG9ydGFudCBzbyBcIkltYWdlXCIgd2lsbCBtYXAgdG8gYnVpbHQtaW4gSW1hZ2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIGVueW8uSW1hZ2UgY29udHJvbC5cblx0Y3RvciA9IFRoZW1lW2tpbmRdIHx8IChnbG9iYWwuZW55byAmJiBnb2JhbC5lbnlvW2tpbmRdKSB8fCB1dGlscy5nZXRQYXRoLmNhbGwoZ2xvYmFsLCAnZW55by4nICsga2luZCkgfHwgZ2xvYmFsW2tpbmRdIHx8IHV0aWxzLmdldFBhdGguY2FsbChnbG9iYWwsIGtpbmQpO1xuXG5cdC8vIElmIHdoYXQgd2UgZm91bmQgYXQgdGhpcyBuYW1lc3BhY2UgaXNuJ3QgYSBmdW5jdGlvbiwgaXQncyBkZWZpbml0ZWx5IG5vdCBhIGtpbmQgY29uc3RydWN0b3Jcblx0aWYgKCF1dGlscy5pc0Z1bmN0aW9uKGN0b3IpKSB7XG5cdFx0dGhyb3cgJ1snICsga2luZCArICddIGlzIG5vdCB0aGUgbmFtZSBvZiBhIHZhbGlkIGtpbmQuJztcblx0fVxuXHRraW5kQ3RvcnNba2luZF0gPSBjdG9yO1xuXHRyZXR1cm4gY3Rvcjtcbn07XG5cbi8qKlxuKiBOYW1lc3BhY2UgZm9yIGN1cnJlbnQgdGhlbWUgKGBlbnlvLlRoZW1lLkJ1dHRvbmAgcmVmZXJlbmNlcyB0aGUgQnV0dG9uIHNwZWNpYWxpemF0aW9uIGZvciB0aGVcbiogY3VycmVudCB0aGVtZSkuXG4qXG4qIEBwcml2YXRlXG4qL1xudmFyIFRoZW1lID0gZXhwb3J0cy5UaGVtZSA9IHt9O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5leHBvcnRzLnJlZ2lzdGVyVGhlbWUgPSBmdW5jdGlvbiAobnMpIHtcblx0dXRpbHMubWl4aW4oVGhlbWUsIG5zKTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmV4cG9ydHMuY3JlYXRlRnJvbUtpbmQgPSBmdW5jdGlvbiAobm9tLCBwYXJhbSkge1xuXHR2YXIgQ3RvciA9IG5vbSAmJiBjb25zdHJ1Y3RvckZvcktpbmQobm9tKTtcblx0aWYgKEN0b3IpIHtcblx0XHRyZXR1cm4gbmV3IEN0b3IocGFyYW0pO1xuXHR9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9sb2dnZXJcIjo2NyxcIi4vb3B0aW9uc1wiOjY5LFwiLi91dGlsc1wiOjc1fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhciBraW5kID0gcmVxdWlyZSgnLi9raW5kJyk7XG5cbi8qKlxuKiBBbiBpbnRlcm5hbGx5LXVzZWQgc3VwcG9ydCB7QGdsb3NzYXJ5IG1peGlufSB0aGF0IGlzIGFwcGxpZWQgdG8gYWxsXG4qIFtjb21wb25lbnRzXXtAbGluayBlbnlvLkNvbXBvbmVudH0gb2YgYW4ge0BsaW5rIGVueW8uQXBwbGljYXRpb259IGluc3RhbmNlXG4qIChhbmQgdG8gdGhlaXIgY29tcG9uZW50cywgcmVjdXJzaXZlbHkpLiBUaGlzIG1peGluIGFkZHMgYW4gYGFwcGAgcHJvcGVydHkgdG9cbiogZWFjaCBjb21wb25lbnQtLWEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSBgZW55by5BcHBsaWNhdGlvbmAgaW5zdGFuY2UgdGhhdFxuKiB0aGUgY29tcG9uZW50IGJlbG9uZ3MgdG8uXG4qIFxuKiBAbWl4aW4gZW55by5BcHBsaWNhdGlvblN1cHBvcnRcbiogQHByb3RlY3RlZFxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdBcHBsaWNhdGlvblN1cHBvcnQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFkanVzdENvbXBvbmVudFByb3BzOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdHByb3BzLmFwcCA9IHByb3BzLmFwcCB8fCB0aGlzLmFwcDtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIHJlbGVhc2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgYXBwbGljYXRpb25cblx0XHRcdHRoaXMuYXBwID0gbnVsbDtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG5cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9raW5kXCI6NjZ9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuKiBBbGwge0BsaW5rIGVueW8uQmluZGluZ30gaW5zdGFuY2VzIGFyZSBzdG9yZWQgaW4gdGhpcyBsaXN0IGFuZCBtYXkgYmUgcmV0cmlldmVkIHZpYSB0aGVcbioge0BsaW5rIGVueW8uQmluZGluZy5maW5kfSBtZXRob2QgdXNpbmcgYW4ge0BsaW5rIGVueW8uQmluZGluZyNpZH0gaWRlbnRpZmllci5cbipcbiogQG5hbWUgZW55by5iaW5kaW5nc1xuKiBAcHVibGljXG4qL1xudmFyIGJpbmRpbmdzID0gW107XG5cbnZhciBESVJUWV9GUk9NID0gMHgwMVxuXHQsIERJUlRZX1RPID0gMHgwMjtcblxuLyoqXG4qIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIHtAbGluayBlbnlvLkJpbmRpbmd9IGlzIGFjdHVhbGx5IHJlYWR5LlxuKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIHJlYWR5IChiaW5kaW5nKSB7XG5cdHZhciByZHkgPSBiaW5kaW5nLnJlYWR5O1xuXHRcblx0aWYgKCFyZHkpIHtcblx0XHRcblx0XHR2YXIgZnJvbSA9IGJpbmRpbmcuZnJvbSB8fCAnJyxcblx0XHRcdHRvID0gYmluZGluZy50byB8fCAnJyxcblx0XHRcdHNvdXJjZSA9IGJpbmRpbmcuc291cmNlLFxuXHRcdFx0dGFyZ2V0ID0gYmluZGluZy50YXJnZXQsXG5cdFx0XHRvd25lciA9IGJpbmRpbmcub3duZXIsXG5cdFx0XHR0d29XYXkgPSAhYmluZGluZy5vbmVXYXksXG5cdFx0XHR0b1RhcmdldDtcblx0XHRcblx0XHRpZiAodHlwZW9mIGZyb20gIT0gJ3N0cmluZycpIGZyb20gPSAnJztcblx0XHRpZiAodHlwZW9mIHRvICE9ICdzdHJpbmcnKSB0byA9ICcnO1xuXHRcdFxuXHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcblx0XHRcdC8vIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGhlcmUgaXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcHVycG9zZXNcblx0XHRcdC8vIHdlIGhhdmUgdG8gYXQgbGVhc3QgYmUgYWJsZSB0byBkZXJpdmUgdGhlIHNvdXJjZSB2aWEgdGhlIGZyb20gc3RyaW5nXG5cdFx0XHRpZiAoZnJvbVswXSA9PSAnXicpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHRoaXMgbWVhbnMgd2UncmUgcmVhY2hpbmcgZm9yIGEgZ2xvYmFsXG5cdFx0XHRcdHZhciBmcm9tUGFydHMgPSBmcm9tLnNwbGl0KCcuJyk7XG5cdFx0XHRcdGZyb20gPSBmcm9tUGFydHMucG9wKCk7XG5cdFx0XHRcdHNvdXJjZSA9IHV0aWxzLmdldFBhdGgoZnJvbVBhcnRzLmpvaW4oJy4nKS5zbGljZSgxKSk7XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c291cmNlID0gb3duZXI7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFxuXHRcdFx0Ly8gc2FtZSB3b3JzdCBjYXNlIGFzIGFib3ZlLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHVycG9zZXNcblx0XHRcdC8vIHdlIGhhdmUgdG8gYXQgbGVhc3QgYmUgYWJsZSB0byBkZXJpdmUgdGhlIHRhcmdldCB2aWEgdGhlIHRvIHN0cmluZ1xuXHRcdFx0aWYgKHRvWzBdID09ICdeJykge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdGhpcyBtZWFucyB3ZSdyZSByZWFjaGluZyBmb3IgYSBnbG9iYWxcblx0XHRcdFx0dmFyIHRvUGFydHMgPSB0by5zcGxpdCgnLicpO1xuXHRcdFx0XHR0byA9IHRvUGFydHMucG9wKCk7XG5cdFx0XHRcdHRhcmdldCA9IHV0aWxzLmdldFBhdGgodG9QYXJ0cy5qb2luKCcuJykuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0ID0gb3duZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHdlIGRvIHRoaXMgc28gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBvcmlnaW5hbHMgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlc2V0IGxhdGVyXG5cdFx0YmluZGluZy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdGJpbmRpbmcuX3NvdXJjZSA9IHNvdXJjZTtcblx0XHRiaW5kaW5nLl9mcm9tID0gZnJvbVswXSA9PSAnLic/IGZyb20uc2xpY2UoMSk6IGZyb207XG5cdFx0YmluZGluZy5fdG8gPSB0b1swXSA9PSAnLic/IHRvLnNsaWNlKDEpOiB0bztcblx0XHRcblx0XHRpZiAoIXR3b1dheSkge1xuXHRcdFx0dG9UYXJnZXQgPSBiaW5kaW5nLl90by5zcGxpdCgnLicpO1xuXHRcdFx0aWYgKHRvVGFyZ2V0Lmxlbmd0aCA+IDIpIHtcblx0XHRcdFx0dG9UYXJnZXQucG9wKCk7XG5cdFx0XHRcdGJpbmRpbmcuX3RvVGFyZ2V0ID0gdG9UYXJnZXQuam9pbignLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBub3cgb3VyIHNhbml0aXphdGlvblxuXHRcdHJkeSA9ICEhIChcblx0XHRcdChzb3VyY2UgJiYgKHR5cGVvZiBzb3VyY2UgPT0gJ29iamVjdCcpKSAmJlxuXHRcdFx0KHRhcmdldCAmJiAodHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0JykpICYmXG5cdFx0XHQoZnJvbSkgJiZcblx0XHRcdCh0bylcblx0XHQpO1xuXHR9XG5cdFxuXHQvKmpzaGludCAtVzA5MyAqL1xuXHRyZXR1cm4gKGJpbmRpbmcucmVhZHkgPSByZHkpO1xuXHQvKmpzaGludCArVzA5MyAqL1xufVxuXG4vKipcbiogVGhlIGRldGFpbHMgZm9yIGFuIHtAbGluayBlbnlvLkJpbmRpbmcjdHJhbnNmb3JtfSBbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn0sIFxuKiBpbmNsdWRpbmcgdGhlIGF2YWlsYWJsZSBwYXJhbWV0ZXJzIGFuZCBob3cgdGhleSBjYW4gYmUgdXNlZC5cbiogXG4qIEBjYWxsYmFjayBlbnlvLkJpbmRpbmd+VHJhbnNmb3JtXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgc3luY2hyb25pemVkLlxuKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBvZiBzeW5jaHJvbml6YXRpb247IHdpbGwgYmUgZWl0aGVyXG4qIFx0MSAoc291cmNlIHZhbHVlIGhhcyBjaGFuZ2VkIGFuZCB3aWxsIGJlIHdyaXR0ZW4gdG8gdGFyZ2V0KSBvciAyICh0YXJnZXRcbiogXHR2YWx1ZSBoYXMgY2hhbmdlZCBhbmQgd2lsbCBiZSB3cml0dGVuIHRvIHNvdXJjZSkuXG4qIEBwYXJhbSB7T2JqZWN0fSBiaW5kaW5nIC0gQSByZWZlcmVuY2UgdG8gdGhlIGFzc29jaWF0ZWQgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30uIEluIGNhc2VzIFxuKiBcdHdoZXJlIHRoZSBiaW5kaW5nIHNob3VsZCBiZSBpbnRlcnJ1cHRlZCBhbmQgbm90IHByb3BhZ2F0ZSB0aGUgc3luY2hyb25pemF0aW9uIGF0IGFsbCwgY2FsbFxuKiBcdHRoZSBbc3RvcCgpXXtAbGluayBlbnlvLkJpbmRpbmcjc3RvcH0gbWV0aG9kIG9uIHRoZSBwYXNzZWQtaW4gYmluZGluZyByZWZlcmVuY2UuXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uQmluZGluZ30gaXMgYSBtZWNoYW5pc20gdXNlZCB0byBrZWVwIHByb3BlcnRpZXMgc3luY2hyb25pemVkLiBBIFxuKiBiaW5kaW5nIG1heSBiZSB1c2VkIHRvIGxpbmsgdHdvIHByb3BlcnRpZXMgb24gZGlmZmVyZW50XG4qIFtvYmplY3RzXXtAZ2xvc3NhcnkgT2JqZWN0fSwgb3IgZXZlbiB0d28gcHJvcGVydGllcyBvbiB0aGUgc2FtZSBvYmplY3QuXG4qIE9uY2UgYSBiaW5kaW5nIGhhcyBiZWVuIGVzdGFibGlzaGVkLCBpdCB3aWxsIHdhaXQgZm9yIGNoYW5nZSBub3RpZmljYXRpb25zO1xuKiB3aGVuIGEgbm90aWZpY2F0aW9uIGFycml2ZXMsIHRoZSBiaW5kaW5nIHdpbGwgc3luY2hyb25pemUgdGhlIHZhbHVlIGJldHdlZW5cbiogdGhlIHR3byBlbmRzLiBOb3RlIHRoYXQgYmluZGluZ3MgbWF5IGJlIGVpdGhlclxuKiBbb25lLXdheV17QGxpbmsgZW55by5CaW5kaW5nI29uZVdheX0gKHRoZSBkZWZhdWx0KSBvclxuKiBbdHdvLXdheV17QGxpbmsgZW55by5CaW5kaW5nI29uZVdheX0uXG4qIFxuKiBVc3VhbGx5LCB5b3Ugd2lsbCBub3QgbmVlZCB0byBjcmVhdGUgQmluZGluZyBvYmplY3RzIGFyYml0cmFyaWx5LCBidXQgd2lsbFxuKiBpbnN0ZWFkIHJlbHkgb24gdGhlIHB1YmxpYyBbQmluZGluZ1N1cHBvcnQgQVBJXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSxcbiogd2hpY2ggaXMgYXBwbGllZCB0byBbZW55by5PYmplY3Rde0BsaW5rIGVueW8uT2JqZWN0fSBhbmQgc28gaXMgYXZhaWxhYmxlIG9uXG4qIGFsbCBvZiBpdHMgW3N1YmtpbmRzXXtAZ2xvc3Nhcnkgc3Via2luZH0uXG4qIFxuKiBAY2xhc3MgZW55by5CaW5kaW5nXG4qIEBwdWJsaWNcbiovXG52YXIgQmluZGluZyA9IG1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkJpbmRpbmcucHJvdG90eXBlICovIHtcblx0XG5cdG5hbWU6ICdlbnlvLkJpbmRpbmcnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogbnVsbCxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblx0XG5cdC8qKlxuXHQqIElmIGEgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gaXMgb25lLXdheSwgdGhpcyBmbGFnIHNob3VsZCBiZSBgdHJ1ZWAgKHRoZSBkZWZhdWx0KS4gXG5cdCogSWYgdGhpcyBmbGFnIGlzIHNldCB0byBgZmFsc2VgLCB0aGUgYmluZGluZyB3aWxsIGJlIHR3by13YXkuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCB0cnVlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRvbmVXYXk6IHRydWUsXG5cdFxuXHQvKipcblx0KiBJZiB0aGUgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gd2FzIGFibGUgdG8gcmVzb2x2ZSBib3RoIGVuZHMgKGkuZS4sIGl0cyBcblx0KiBbc291cmNlXXtAbGluayBlbnlvLkJpbmRpbmcjc291cmNlfSBhbmQgW3RhcmdldF17QGxpbmsgZW55by5CaW5kaW5nI3RhcmdldH0gXG5cdCogW29iamVjdHNde0BnbG9zc2FyeSBPYmplY3R9KSwgdGhpcyB2YWx1ZSB3aWxsIGJlIGB0cnVlYC4gU2V0dGluZyB0aGlzIG1hbnVhbGx5IHdpbGxcblx0KiBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29ubmVjdGVkOiBmYWxzZSxcblx0XG5cdC8qKlxuXHQqIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBleHRlbnNpdmVseSBmb3IgdmFyaW91cyBwdXJwb3NlcyB3aXRoaW4gYVxuXHQqIFtiaW5kaW5nXXtAbGluayBlbnlvLkJpbmRpbmd9LiBPbmUgcHJpbWFyeSBwdXJwb3NlIGlzIHRvIHNlcnZlIGFzIGEgcm9vdFxuXHQqIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGZyb20gd2hpY2ggdG9cdHNlYXJjaCBmb3IgdGhlIGJpbmRpbmcncyBlbmRzICh0aGVcblx0KiBbc291cmNlXXtAbGluayBlbnlvLkJpbmRpbmcjc291cmNlfSBhbmQvb3IgW3RhcmdldF17QGxpbmsgZW55by5CaW5kaW5nI3RhcmdldH0pLlxuXHQqIElmIHRoZSBvd25lciBjcmVhdGVkIHRoZSBiaW5kaW5nLCBpdCB3aWxsIGFsc28gYmUgcmVzcG9uc2libGUgZm9yIGRlc3Ryb3lpbmcgXG5cdCogaXQgKGF1dG9tYXRpY2FsbHkpLlxuXHQqXG5cdCogQHR5cGUge2VueW8uT2JqZWN0fVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdG93bmVyOiBudWxsLFxuXHRcblx0LyoqXG5cdCogQnkgZGVmYXVsdCwgYSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfSB3aWxsIGF0dGVtcHQgdG8gY29ubmVjdCB0byBib3RoIGVuZHMgXG5cdCogKFtzb3VyY2Vde0BsaW5rIGVueW8uQmluZGluZyNzb3VyY2V9IGFuZCBbdGFyZ2V0XXtAbGluayBlbnlvLkJpbmRpbmcjdGFyZ2V0fSkuIElmIHRoaXMgXG5cdCogcHJvY2VzcyBzaG91bGQgYmUgZGVmZXJyZWQsIHNldCB0aGlzIGZsYWcgdG8gYGZhbHNlYC5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHRydWVcblx0KiBAcHVibGljXG5cdCovXG5cdGF1dG9Db25uZWN0OiB0cnVlLFxuXHRcblx0LyoqXG5cdCogQnkgZGVmYXVsdCwgYSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfSB3aWxsIGF0dGVtcHQgdG8gc3luY2hyb25pemUgaXRzIHZhbHVlcyBmcm9tIFxuXHQqIGl0cyBbc291cmNlXXtAbGluayBlbnlvLkJpbmRpbmcjc291cmNlfSB0byBpdHMgW3RhcmdldF17QGxpbmsgZW55by5CaW5kaW5nI3RhcmdldH0uIElmIFxuXHQqIHRoaXMgcHJvY2VzcyBzaG91bGQgYmUgZGVmZXJyZWQsIHNldCB0aGlzIGZsYWcgdG8gYGZhbHNlYC5cblx0KiBcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCB0cnVlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhdXRvU3luYzogdHJ1ZSxcblx0XG5cdC8qKlxuXHQqIFNldCB0aGlzIG9ubHkgdG8gYSByZWZlcmVuY2UgZm9yIGFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHRvIHVzZVxuXHQqIGFzIHRoZSBzb3VyY2UgZm9yIHRoZSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfS4gSWYgdGhpcyBpcyBub3QgYVxuXHQqIFtiaW5kYWJsZV17QGxpbmsgZW55by5CaW5kaW5nU3VwcG9ydH0gb2JqZWN0LCB0aGUgc291cmNlIHdpbGwgYmUgZGVyaXZlZFxuXHQqIGZyb20gdGhlIFtmcm9tXXtAbGluayBlbnlvLkJpbmRpbmcjZnJvbX0gcHJvcGVydHkgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuXHQqIFxuXHQqIEB0eXBlIHtPYmplY3R9XG5cdCogQGRlZmF1bHQgbnVsbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c291cmNlOiBudWxsLFxuXHRcblx0LyoqXG5cdCogU2V0IHRoaXMgb25seSB0byBhIHJlZmVyZW5jZSBmb3IgYW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdG8gdXNlXG5cdCogYXMgdGhlIHRhcmdldCBmb3IgdGhlIFtiaW5kaW5nXXtAbGluayBlbnlvLkJpbmRpbmd9LiBJZiB0aGlzIGlzIG5vdCBhXG5cdCogW2JpbmRhYmxlXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSBvYmplY3QsIHRoZSB0YXJnZXQgd2lsbCB3aWxsIGJlXG5cdCogZGVyaXZlZCBmcm9tIHRoZSBbdG9de0BsaW5rIGVueW8uQmluZGluZyN0b30gcHJvcGVydHkgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuXHQqIFxuXHQqIEB0eXBlIHtPYmplY3R9XG5cdCogQGRlZmF1bHQgbnVsbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dGFyZ2V0OiBudWxsLFxuXHRcblx0LyoqXG5cdCogQSBwYXRoIGluIHdoaWNoIHRoZSBwcm9wZXJ0eSBvZiB0aGUgW3NvdXJjZV17QGxpbmsgZW55by5CaW5kaW5nI3NvdXJjZX0gdG9cblx0KiBiaW5kIGZyb20gbWF5IGJlIGZvdW5kLiBJZiB0aGUgc291cmNlIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgYW5kIHRoZSBwYXRoXG5cdCogaXMgcmVsYXRpdmUgKGkuZS4sIGl0IGJlZ2lucyB3aXRoIGEgYFwiLlwiYCksIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2U7XG5cdCogb3RoZXJ3aXNlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgW293bmVyXXtAbGluayBlbnlvLkJpbmRpbmcjb3duZXJ9IG9mIHRoZVxuXHQqIFtiaW5kaW5nXXtAbGluayBlbnlvLkJpbmRpbmd9LiBUbyBoYXZlIGEgYmluZGluZyBiZSBldmFsdWF0ZWQgZnJvbSB0aGVcblx0KiBnbG9iYWwgc2NvcGUsIHByZWZpeCB0aGUgcGF0aCB3aXRoIGEgYFwiXlwiYC4gSWYgdGhlIHNvdXJjZSBhbmQgdGhlIGBcIl5cImBcblx0KiBhcmUgdXNlZCBpbiB0YW5kZW0sIHRoZSBgXCJeXCJgIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIHBhdGggd2lsbCBiZSBhc3N1bWVkXG5cdCogdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHByb3ZpZGVkIHNvdXJjZS5cblx0KiBcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdGZyb206IG51bGwsXG5cdFxuXHQvKipcblx0KiBUaGUgYGRpcnR5YCBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSBjaGFuZ2VkIHZhbHVlIHN0YXRlIG9mIGJvdGggdGhlIHByb3BlcnR5IGRlc2lnbmF0ZWQgYnlcblx0KiB0aGUgW2Zyb21de0BsaW5rIGVueW8uQmluZGluZyNmcm9tfSBwYXRoIGFuZCB0aGUgcHJvcGVydHkgZGVzaWduYXRlZCBieSB0aGUgXG5cdCogW3RvXXtAbGluayBlbnlvLkJpbmRpbmcjdG99IHBhdGguXG5cdCpcblx0KiBAdHlwZSB7TnVtYmVyfVxuXHQqIEBkZWZhdWx0IGVueW8uQmluZGluZy5ESVJUWV9GUk9NXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkaXJ0eTogRElSVFlfRlJPTSxcblx0XG5cdC8qKlxuXHQqIEEgcGF0aCBpbiB3aGljaCB0aGUgcHJvcGVydHkgb2YgdGhlIFt0YXJnZXRde0BsaW5rIGVueW8uQmluZGluZyN0YXJnZXR9IHRvXG5cdCogYmluZCBmcm9tIG1heSBiZSBmb3VuZC4gSWYgdGhlIHRhcmdldCBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGFuZCB0aGUgcGF0aFxuXHQqIGlzIHJlbGF0aXZlIChpLmUuLCBpdCBiZWdpbnMgd2l0aCBhIGBcIi5cImApLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0O1xuXHQqIG90aGVyd2lzZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIG93bmVyIG9mIHRoZSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfS5cblx0KiBUbyBoYXZlIGEgYmluZGluZyBiZSBldmFsdWF0ZWQgZnJvbSB0aGUgZ2xvYmFsIHNjb3BlLCBwcmVmaXggdGhlIHBhdGggd2l0aFxuXHQqIGEgYFwiXlwiYC4gSWYgdGhlIHRhcmdldCBhbmQgdGhlIGBcIl5cImAgYXJlIHVzZWQgaW4gdGFuZGVtLCB0aGUgYFwiXlwiYCB3aWxsIGJlXG5cdCogaWdub3JlZCBhbmQgdGhlIHBhdGggd2lsbCBiZSBhc3N1bWVkIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBwcm92aWRlZCB0YXJnZXQuXG5cdCogXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0bzogbnVsbCxcblxuXHQvKipcblx0KiBTZXQgdGhpcyB0byBhIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSBvciB0aGUgbmFtZSBvZiBhIG1ldGhvZCBvblxuXHQqIHRoZSBbb3duZXJde0BsaW5rIGVueW8uQmluZGluZyNvd25lcn0gb2YgdGhpcyBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfS5cblx0KiBUaGUgdHJhbnNmb3JtIGlzIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBtb2RpZnkgdGhlIHZhbHVlIGJlaW5nIHN5bmNocm9uaXplZC5cblx0KiBTZWUge0BsaW5rIGVueW8uQmluZGluZ35UcmFuc2Zvcm19IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB0aGUgcGFyYW1ldGVyc1xuXHQqIHRoYXQgYXJlIGF2YWlsYWJsZSB0byBgdHJhbnNmb3JtYC5cblx0KiBcblx0KiBAdHlwZSB7ZW55by5CaW5kaW5nflRyYW5zZm9ybX1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0cmFuc2Zvcm06IG51bGwsXG5cdFxuXHQvKipcblx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gaXMgY3VycmVudGx5IGNvbm5lY3RlZC5cblx0KlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29ubmVjdGVkOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc0Nvbm5lY3RlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBmcm9tID0gdGhpcy5fZnJvbSxcblx0XHRcdHRvID0gdGhpcy5vbmVXYXkgPyAodGhpcy5fdG9UYXJnZXQgfHwgdGhpcy5fdG8pIDogdGhpcy5fdG8sXG5cdFx0XHRzb3VyY2UgPSB0aGlzLl9zb3VyY2UsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHR0b0NoYWluLFxuXHRcdFx0ZnJvbUNoYWluO1xuXHRcdFx0XG5cdFx0aWYgKGZyb20gJiYgdG8gJiYgc291cmNlICYmIHRhcmdldCkge1xuXHRcdFx0aWYgKCF0aGlzLm9uZVdheSB8fCB0aGlzLl90b1RhcmdldCkgdG9DaGFpbiA9IHRhcmdldC5nZXRDaGFpbnMoKVt0b107XG5cdFx0XHRmcm9tQ2hhaW4gPSBzb3VyY2UuZ2V0Q2hhaW5zKClbZnJvbV07XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLmNvbm5lY3RlZFxuXHRcdFx0XHQmJiAoZnJvbUNoYWluID8gZnJvbUNoYWluLmlzQ29ubmVjdGVkKCkgOiB0cnVlKVxuXHRcdFx0XHQmJiAodG9DaGFpbiA/IHRvQ2hhaW4uaXNDb25uZWN0ZWQoKSA6IHRydWUpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBDYXVzZXMgYSBzaW5nbGUgcHJvcGFnYXRpb24gYXR0ZW1wdCB0byBmYWlsLiBUeXBpY2FsbHkgbm90IGNhbGxlZCBvdXRzaWRlXG5cdCogdGhlIHNjb3BlIG9mIGEgW3RyYW5zZm9ybV17QGxpbmsgZW55by5CaW5kaW5nI3RyYW5zZm9ybX0uXG5cdCogXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fc3RvcCA9IHRydWU7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gaXMgYWN0dWFsbHkgcmVhZHkuXG5cdCogXG5cdCogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiByZWFkeTsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNSZWFkeTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWR5IHx8IHJlYWR5KHRoaXMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVzZXRzIGFsbCBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuXHQqIFxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5yZWFkeSA9IG51bGw7XG5cdFx0dGhpcy5fc291cmNlID0gdGhpcy5fdGFyZ2V0ID0gdGhpcy5fdG8gPSB0aGlzLl9mcm9tID0gdGhpcy5fdG9UYXJnZXQgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVidWlsZHMgdGhlIGVudGlyZSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfS4gV2lsbCBzeW5jaHJvbml6ZSBpZiBpdCBpcyBhYmxlIHRvIFxuXHQqIGNvbm5lY3QgYW5kIHRoZSBbYXV0b1N5bmNde0BsaW5rIGVueW8uQmluZGluZyNhdXRvU3luY30gZmxhZyBpcyBgdHJ1ZWAuXG5cdCogXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVidWlsZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlc2V0KCkuY29ubmVjdCgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQ29ubmVjdHMgdGhlIGVuZHMgKGkuZS4sIHRoZSBbc291cmNlXXtAbGluayBlbnlvLkJpbmRpbmcjc291cmNlfSBhbmRcblx0KiBbdGFyZ2V0XXtAbGluayBlbnlvLkJpbmRpbmcjdGFyZ2V0fSkgb2YgdGhlIFtiaW5kaW5nXXtAbGluayBlbnlvLkJpbmRpbmd9LiBXaGlsZSB5b3Vcblx0KiB0eXBpY2FsbHkgd29uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kLCBpdCBpcyBzYWZlIHRvIGNhbGwgZXZlbiB3aGVuIHRoZSBlbmRzIGFyZVxuXHQqIGFscmVhZHkgZXN0YWJsaXNoZWQuIE5vdGUgdGhhdCBpZiBvbmUgb3IgYm90aCBvZiB0aGUgZW5kcyBkb2VzIGJlY29tZSBjb25uZWN0ZWQgYW5kIHRoZVxuXHQqIFthdXRvU3luY117QGxpbmsgZW55by5CaW5kaW5nI2F1dG9TeW5jfSBmbGFnIGlzIGB0cnVlYCwgdGhlIGVuZHMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG5cdCogc3luY2hyb25pemVkLlxuXHQqIFxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuXHRcdFx0aWYgKHRoaXMuaXNSZWFkeSgpKSB7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vYnNlcnZlKHRoaXMuX2Zyb20sIHRoaXMuX3NvdXJjZUNoYW5nZWQsIHRoaXMsIHtwcmlvcml0eTogdHJ1ZX0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZm9yIHR3by13YXkgYmluZGluZ3Mgd2UgcmVnaXN0ZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzXG5cdFx0XHRcdC8vIGZyb20gdGhlIHRhcmdldFxuXHRcdFx0XHRpZiAoIXRoaXMub25lV2F5KSB0aGlzLl90YXJnZXQub2JzZXJ2ZSh0aGlzLl90bywgdGhpcy5fdGFyZ2V0Q2hhbmdlZCwgdGhpcyk7XG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuX3RvVGFyZ2V0KSB7XG5cdFx0XHRcdFx0dGhpcy5fdGFyZ2V0Lm9ic2VydmUodGhpcy5fdG9UYXJnZXQsIHRoaXMuX3RvVGFyZ2V0Q2hhbmdlZCwgdGhpcywge3ByaW9yaXR5OiB0cnVlfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIHdlIGZsYWcgaXQgYXMgaGF2aW5nIGJlZW4gY29ubmVjdGVkXG5cdFx0XHRcdHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLmF1dG9TeW5jKSB0aGlzLnN5bmModHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogRGlzY29ubmVjdHMgZnJvbSB0aGUgZW5kcyAoaS5lLiwgdGhlIFtzb3VyY2Vde0BsaW5rIGVueW8uQmluZGluZyNzb3VyY2V9IGFuZCBcblx0KiBbdGFyZ2V0XXtAbGluayBlbnlvLkJpbmRpbmcjdGFyZ2V0fSkgaWYgYSBjb25uZWN0aW9uIGV4aXN0cyBhdCBlaXRoZXIgZW5kLiBUaGlzIG1ldGhvZCBcblx0KiB3aWxsIG1vc3QgbGlrZWx5IG5vdCBuZWVkIHRvIGJlIGNhbGxlZCBkaXJlY3RseS5cblx0KiBcblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuXHRcdFx0dGhpcy5fc291cmNlLnVub2JzZXJ2ZSh0aGlzLl9mcm9tLCB0aGlzLl9zb3VyY2VDaGFuZ2VkLCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0Ly8gZm9yIHR3by13YXkgYmluZGluZ3Mgd2UgdW5yZWdpc3RlciB0aGUgb2JzZXJ2ZXIgZnJvbVxuXHRcdFx0Ly8gdGhlIHRhcmdldCBhcyB3ZWxsXG5cdFx0XHRpZiAoIXRoaXMub25lV2F5KSB0aGlzLl90YXJnZXQudW5vYnNlcnZlKHRoaXMuX3RvLCB0aGlzLl90YXJnZXRDaGFuZ2VkLCB0aGlzKTtcblx0XHRcdGVsc2UgaWYgKHRoaXMuX3RvVGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuX3RhcmdldC51bm9ic2VydmUodGhpcy5fdG9UYXJnZXQsIHRoaXMuX3RvVGFyZ2V0Q2hhbmdlZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogU3luY2hyb25pemVzIHZhbHVlcyBmcm9tIHRoZSBbc291cmNlXXtAbGluayBlbnlvLkJpbmRpbmcjc291cmNlfSB0byB0aGVcblx0KiBbdGFyZ2V0XXtAbGluayBlbnlvLkJpbmRpbmcjdGFyZ2V0fS4gVGhpcyB1c3VhbGx5IHdpbGwgbm90IG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5LlxuXHQqIFtUd28td2F5IGJpbmRpbmdzXXtAbGluayBlbnlvLkJpbmRpbmcjb25lV2F5fSB3aWxsIGF1dG9tYXRpY2FsbHkgc3luY2hyb25pemUgZnJvbSB0aGVcblx0KiB0YXJnZXQgZW5kIG9uY2UgdGhleSBhcmUgY29ubmVjdGVkLlxuXHQqIFxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHN5bmM6IGZ1bmN0aW9uIChmb3JjZSkge1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2UsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRmcm9tID0gdGhpcy5fZnJvbSxcblx0XHRcdHRvID0gdGhpcy5fdG8sXG5cdFx0XHR4Zm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCksXG5cdFx0XHR2YWw7XG5cdFx0XG5cdFx0aWYgKHRoaXMuaXNSZWFkeSgpICYmIHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuXHRcdFx0XHRcblx0XHRcdHN3aXRjaCAodGhpcy5kaXJ0eSB8fCAoZm9yY2UgJiYgRElSVFlfRlJPTSkpIHtcblx0XHRcdGNhc2UgRElSVFlfVE86XG5cdFx0XHRcdHZhbCA9IHRhcmdldC5nZXQodG8pO1xuXHRcdFx0XHRpZiAoeGZvcm0pIHZhbCA9IHhmb3JtLmNhbGwodGhpcy5vd25lciB8fCB0aGlzLCB2YWwsIERJUlRZX1RPLCB0aGlzKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9zdG9wKSBzb3VyY2Uuc2V0KGZyb20sIHZhbCwge2NyZWF0ZTogZmFsc2V9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIERJUlRZX0ZST006XG5cdFx0XHRcdFxuXHRcdFx0Ly8gQFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIG5lZWQgdG8gaGFwcGVuIGJ1dCBpcyBoZXJlIGp1c3QgaW4gY2FzZVxuXHRcdFx0Ly8gaXQgaXMgZXZlciBhcmJpdHJhcmlseSBjYWxsZWQgbm90IGhhdmluZyBiZWVuIGRpcnR5P1xuXHRcdFx0Ly8gZGVmYXVsdDpcblx0XHRcdFx0dmFsID0gc291cmNlLmdldChmcm9tKTtcblx0XHRcdFx0aWYgKHhmb3JtKSB2YWwgPSB4Zm9ybS5jYWxsKHRoaXMub3duZXIgfHwgdGhpcywgdmFsLCBESVJUWV9GUk9NLCB0aGlzKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9zdG9wKSB0YXJnZXQuc2V0KHRvLCB2YWwsIHtjcmVhdGU6IGZhbHNlfSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kaXJ0eSA9IG51bGw7XG5cdFx0XHR0aGlzLl9zdG9wID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBSZWxlYXNlcyBhbGwgb2YgdGhlIFtiaW5kaW5nJ3Nde0BsaW5rIGVueW8uQmluZGluZ30gcGFydHMgYW5kIHVucmVnaXN0ZXJzIGl0cyBcblx0KiBbb2JzZXJ2ZXJzXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH0uIFR5cGljYWxseSwgdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQgXG5cdCogZGlyZWN0bHkgdW5sZXNzIHRoZSBiaW5kaW5nIHdhcyBjcmVhdGVkIHdpdGhvdXQgYW4gW293bmVyXXtAbGluayBlbnlvLkJpbmRpbmcjb3duZXJ9LlxuXHQqIFxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLm93bmVyLFxuXHRcdFx0aWR4O1xuXHRcdFxuXHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdHRoaXMub3duZXIgPSBudWxsO1xuXHRcdHRoaXMuc291cmNlID0gdGhpcy5fc291cmNlID0gbnVsbDtcblx0XHR0aGlzLnRhcmdldCA9IHRoaXMuX3RhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5yZWFkeSA9IG51bGw7XG5cdFx0dGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdFxuXHRcdC8vIEB0b2RvOiByZW1vdmUgbWUgb3IgcG9zdHBvbmUgb3BlcmF0aW9uP1xuXHRcdGlkeCA9IGJpbmRpbmdzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGlkeCA+IC0xKSBiaW5kaW5ncy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcblx0XHRpZiAob3duZXIgJiYgIW93bmVyLmRlc3Ryb3llZCkgb3duZXIucmVtb3ZlQmluZGluZyh0aGlzKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaWRJbml0VHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0gOiAoZnVuY3Rpb24gKGJuZCkge1xuXHRcdFx0Ym5kLl9kaWRJbml0VHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFxuXHRcdFx0dmFyIHhmb3JtID0gYm5kLnRyYW5zZm9ybSxcblx0XHRcdFx0b3duZXIgPSBibmQub3duZXIsXG5cdFx0XHRcdHhmb3JtT3duZXIgPSBvd25lciAmJiBvd25lci5iaW5kaW5nVHJhbnNmb3JtT3duZXI7XG5cdFx0XHRcblx0XHRcdGlmICh4Zm9ybSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHhmb3JtID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0aWYgKHhmb3JtT3duZXIgJiYgeGZvcm1Pd25lclt4Zm9ybV0pIHtcblx0XHRcdFx0XHRcdHhmb3JtID0geGZvcm1Pd25lclt4Zm9ybV07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChvd25lciAmJiBvd25lclt4Zm9ybV0pIHtcblx0XHRcdFx0XHRcdHhmb3JtID0gb3duZXJbeGZvcm1dO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4Zm9ybSA9IHV0aWxzLmdldFBhdGgoeGZvcm0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Lypqc2hpbnQgLVcwOTMgKi9cblx0XHRcdFx0cmV0dXJuIChibmQudHJhbnNmb3JtID0gKHR5cGVvZiB4Zm9ybSA9PSAnZnVuY3Rpb24nID8geGZvcm0gOiBudWxsKSk7XG5cdFx0XHRcdC8qanNoaW50ICtXMDkzICovXG5cdFx0XHR9XG5cdFx0fSkodGhpcyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0YmluZGluZ3MucHVzaCh0aGlzKTtcblx0XHRcblx0XHRpZiAocHJvcHMpIHV0aWxzLm1peGluKHRoaXMsIHByb3BzKTtcblx0XHRcblx0XHRpZiAoIXRoaXMuZXVpZCkgdGhpcy5ldWlkID0gdXRpbHMudWlkKCdiJyk7XG5cdFx0aWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMuY29ubmVjdCgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X3NvdXJjZUNoYW5nZWQ6IGZ1bmN0aW9uICh3YXMsIGlzLCBwYXRoKSB7XG5cdFx0Ly8gQFRPRE86IFNob3VsZCBpdC4uLndvdWxkIGl0IGJlbmVmaXQgZnJvbSB1c2luZyB0aGVzZSBwYXNzZWQgaW4gdmFsdWVzP1xuXHRcdHRoaXMuZGlydHkgPSB0aGlzLmRpcnR5ID09IERJUlRZX1RPID8gbnVsbCA6IERJUlRZX0ZST007XG5cdFx0cmV0dXJuIHRoaXMuZGlydHkgPT0gRElSVFlfRlJPTSAmJiB0aGlzLnN5bmMoKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF90YXJnZXRDaGFuZ2VkOiBmdW5jdGlvbiAod2FzLCBpcywgcGF0aCkge1xuXHRcdC8vIEBUT0RPOiBTYW1lIHF1ZXN0aW9uIGFzIGFib3ZlLCBpdCBzZWVtcyB1c2VmdWwgYnV0IHdvdWxkIGl0IGFmZmVjdCBjb21wdXRlZFxuXHRcdC8vIHByb3BlcnRpZXMgb3Igc3RhbGUgdmFsdWVzP1xuXHRcdHRoaXMuZGlydHkgPSB0aGlzLmRpcnR5ID09IERJUlRZX0ZST00gPyBudWxsIDogRElSVFlfVE87XG5cdFx0cmV0dXJuIHRoaXMuZGlydHkgPT0gRElSVFlfVE8gJiYgdGhpcy5zeW5jKCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfdG9UYXJnZXRDaGFuZ2VkOiBmdW5jdGlvbiAod2FzLCBpcywgcGF0aCkge1xuXHRcdHRoaXMuZGlydHkgPSBESVJUWV9GUk9NO1xuXHRcdHRoaXMucmVzZXQoKS5jb25uZWN0KCk7XG5cdH1cbn0pO1xuXG4vKipcbiogUmV0cmlldmVzIGEgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gYnkgaXRzIGdsb2JhbCBpZC5cbipcbiogQHBhcmFtIHtTdHJpbmd9IGV1aWQgLSBUaGUgW0VueW8gZ2xvYmFsIGlkXXtAZ2xvc3NhcnkgRVVJRH0gYnkgd2hpY2ggdG8gcmV0cmlldmUgYSBcbipcdFtiaW5kaW5nXXtAbGluayBlbnlvLkJpbmRpbmd9LlxuKiBAcmV0dXJucyB7ZW55by5CaW5kaW5nfHVuZGVmaW5lZH0gQSByZWZlcmVuY2UgdG8gdGhlIGJpbmRpbmcgaWYgdGhlIGlkIFxuKlx0aXMgZm91bmQ7IG90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gW3VuZGVmaW5lZF17QGdsb3NzYXJ5IHVuZGVmaW5lZH0uXG4qIFxuKiBAc3RhdGljXG4qIEBwdWJsaWNcbiovXG5CaW5kaW5nLmZpbmQgPSBmdW5jdGlvbiAoZXVpZCkge1xuXHRyZXR1cm4gYmluZGluZ3MuZmluZChmdW5jdGlvbiAobG4pIHtcblx0XHRyZXR1cm4gbG4uZXVpZCA9PSBldWlkO1xuXHR9KTtcbn07XG5cbkJpbmRpbmcuYmluZGluZ3MgPSBiaW5kaW5ncztcblxuLyoqXG4qIFBvc3NpYmxlIHZhbHVlIG9mIHRoZSBbZGlydHlde0BsaW5rIGVueW8uQmluZGluZyNkaXJ0eX0gcHJvcGVydHksIGluZGljYXRpbmcgdGhhdCB0aGUgdmFsdWUgXG4qIG9mIHRoZSBbYmluZGluZyBzb3VyY2Vde0BsaW5rIGVueW8uQmluZGluZyNzb3VyY2V9IGhhcyBjaGFuZ2VkLlxuKiBcbiogQHN0YXRpY1xuKiBAcHVibGljXG5CaW5kaW5nQi5EaW5kaW5nSVJUWV9GUk9NID0gRElSVFlfRlJPTTtcblxuLyoqXG4qIFBvc3NpYmxlIHZhbHVlIG9mIHRoZSBbZGlydHlde0BsaW5rIGVueW8uQmluZGluZyNkaXJ0eX0gcHJvcGVydHksIGluZGljYXRpbmcgdGhhdCB0aGUgdmFsdWVcbiogb2YgdGhlIFtiaW5kaW5nIHRhcmdldF17QGxpbmsgZW55by5CaW5kaW5nI3RhcmdldH0gaGFzIGNoYW5nZWQuXG4qIFxuKiBAc3RhdGljXG4qIEBwdWJsaWNcbiovXG5CaW5kaW5nLkRJUlRZX1RPID0gRElSVFlfVE87XG5cbi8qKlxuKiBUaGUgZGVmYXVsdCBba2luZF17QGdsb3NzYXJ5IGtpbmR9IHRoYXQgcHJvdmlkZXMgW2JpbmRpbmdde0BsaW5rIGVueW8uQmluZGluZ30gXG4qIGZ1bmN0aW9uYWxpdHkuXG4qIFxuKiBzdGF0aWNcbiogcHVibGljXG4qL1xuQmluZGluZy5kZWZhdWx0QmluZGluZ0tpbmQgPSBCaW5kaW5nO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpO1xuXG4vKipcbiogQW4gaW50ZXJuYWxseS11c2VkIHtAZ2xvc3NhcnkgbWl4aW59IGFwcGxpZWQgdG8ge0BsaW5rIGVueW8uQ29tcG9uZW50fVxuKiBpbnN0YW5jZXMgdG8gYmV0dGVyIHN1cHBvcnQgW2JpbmRpbmdzXXtAbGluayBlbnlvLkJpbmRpbmd9LlxuKlxuKiBAbWl4aW4gZW55by5Db21wb25lbnRCaW5kaW5nU3VwcG9ydFxuKiBAcHJvdGVjdGVkXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnQ29tcG9uZW50QmluZGluZ1N1cHBvcnQnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YWRqdXN0Q29tcG9uZW50UHJvcHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRwcm9wcy5iaW5kaW5nVHJhbnNmb3JtT3duZXIgfHwgKHByb3BzLmJpbmRpbmdUcmFuc2Zvcm1Pd25lciA9IHRoaXMuZ2V0SW5zdGFuY2VPd25lcigpKTtcblx0XHR9O1xuXHR9KVxufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL2tpbmRcIjo2Nn1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBleHRlbmQgPSBraW5kLnN0YXRpY3MuZXh0ZW5kO1xuXHRcbmtpbmQuY29uY2F0ZW5hdGVkLnB1c2goJ2NvbXB1dGVkJyk7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGdldENvbXB1dGVkVmFsdWUgKG9iaiwgcGF0aCkge1xuXHR2YXIgY2FjaGUgPSBvYmouX2dldENvbXB1dGVkQ2FjaGUocGF0aClcblx0XHQsIGlzQ2FjaGVkID0gb2JqLl9pc0NvbXB1dGVkQ2FjaGVkKHBhdGgpO1xuXHRcblx0Ly8gaW4gdGhlIGVuZCwgZm9yIGVmZmljaWVuY3kgYW5kIGNvbXBsZXRlbmVzcyBpbiBvdGhlciBzaXR1YXRpb25zXG5cdC8vIGl0IGlzIGJldHRlciB0byBrbm93IHRoZSByZXR1cm5lZCB2YWx1ZSBvZiBhbGwgY29tcHV0ZWQgcHJvcGVydGllc1xuXHQvLyBidXQgaW4gY2FzZXMgd2hlcmUgdGhleSBhcmUgc2V0IGFzIGNhY2hlZCB3ZSB3aWxsIHNvbWV0aW1lcyB1c2Vcblx0Ly8gdGhhdCB2YWx1ZVxuXHRpZiAoY2FjaGUuZGlydHkgfHwgY2FjaGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlzQ2FjaGVkICYmIChjYWNoZS5kaXJ0eSA9IGZhbHNlKTtcblx0XHRjYWNoZS5wcmV2aW91cyA9IGNhY2hlLnZhbHVlO1xuXHRcdGNhY2hlLnZhbHVlID0gb2JqW3BhdGhdKCk7XG5cdH1cblx0XG5cdHJldHVybiBjYWNoZS52YWx1ZTtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gcXVldWVDb21wdXRlZCAob2JqLCBwYXRoKSB7XG5cdHZhciBxdWV1ZSA9IG9iai5fY29tcHV0ZWRRdWV1ZSB8fCAob2JqLl9jb21wdXRlZFF1ZXVlID0gW10pXG5cdFx0LCBkZXBzID0gb2JqLl9jb21wdXRlZERlcGVuZGVuY2llc1twYXRoXTtcblx0XHRcblx0aWYgKGRlcHMpIHtcblx0XHRmb3IgKHZhciBpPTAsIGRlcDsgKGRlcD1kZXBzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoIXF1ZXVlLmxlbmd0aCB8fCAtMSA9PSBxdWV1ZS5pbmRleE9mKGRlcCkpIHF1ZXVlLnB1c2goZGVwKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZmx1c2hDb21wdXRlZCAob2JqKSB7XG5cdHZhciBxdWV1ZSA9IG9iai5fY29tcHV0ZWRRdWV1ZTtcblx0b2JqLl9jb21wdXRlZFF1ZXVlID0gbnVsbDtcblx0aWYgKHF1ZXVlICYmIG9iai5pc09ic2VydmluZygpKSB7XG5cdFx0Zm9yICh2YXIgaT0wLCBsbjsgKGxuPXF1ZXVlW2ldKTsgKytpKSB7XG5cdFx0XHRvYmoubm90aWZ5KGxuLCBvYmouX2dldENvbXB1dGVkQ2FjaGUobG4pLnZhbHVlLCBnZXRDb21wdXRlZFZhbHVlKG9iaiwgbG4pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4qIEEge0BnbG9zc2FyeSBtaXhpbn0gdGhhdCBhZGRzIEFQSSBtZXRob2RzIHRvIHN1cHBvcnRcbiogW2NvbXB1dGVkIHByb3BlcnRpZXNde0BnbG9zc2FyeSBcImNvbXB1dGVkIHByb3BlcnR5XCJ9LiBVbmxpa2Ugb3RoZXIgc3VwcG9ydCBtaXhpbnMsXG4qIHRoaXMgbWl4aW4gZG9lcyBub3QgbmVlZCB0byBiZSBleHBsaWNpdGx5IGluY2x1ZGVkIGJ5IGEgW2tpbmRde0BnbG9zc2FyeSBraW5kfS4gSWYgdGhlXG4qIGBjb21wdXRlZGAgW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IGlzIGZvdW5kIGluIGEga2luZCBkZWZpbml0aW9uLCB0aGlzIG1peGluIHdpbGxcbiogYXV0b21hdGljYWxseSBiZSBpbmNsdWRlZC5cbipcbiogQG1peGluIGVueW8uQ29tcHV0ZWRTdXBwb3J0XG4qIEBwdWJsaWNcbiovXG52YXIgQ29tcHV0ZWRTdXBwb3J0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnQ29tcHV0ZWRTdXBwb3J0Jyxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9jb21wdXRlZFJlY3Vyc2lvbjogMCxcblx0XG5cdC8qKlxuXHQqIFByaW1hcmlseSBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlLCB0aGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlXG5cdCogZ2l2ZW4gcGF0aCBpcyBhIGtub3duIFtjb21wdXRlZCBwcm9wZXJ0eV17QGdsb3NzYXJ5IFwiY29tcHV0ZWQgcHJvcGVydHlcIn0uXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFRoZSBwcm9wZXJ0eSBvciBwYXRoIHRvIHRlc3QuXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBgcGF0aGAgaXMgYVxuXHQqXHRbY29tcHV0ZWQgcHJvcGVydHlde0BnbG9zc2FyeSBcImNvbXB1dGVkIHByb3BlcnR5XCJ9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNDb21wdXRlZDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHQvLyBpZiBpdCBleGlzdHMgaXQgd2lsbCBiZSBleHBsaWNpdGx5IG9uZSBvZiB0aGVzZSBjYXNlcyBhbmQgaXQgaXMgY2hlYXBlciB0aGFuIGhhc093blByb3BlcnR5XG5cdFx0cmV0dXJuIHRoaXMuX2NvbXB1dGVkICYmICh0aGlzLl9jb21wdXRlZFtwYXRoXSA9PT0gdHJ1ZSB8fCB0aGlzLl9jb21wdXRlZFtwYXRoXSA9PT0gZmFsc2UpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUHJpbWFyaWx5IGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2UsIHRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciB0aGVcblx0KiBnaXZlbiBwYXRoIGlzIGEga25vd24gZGVwZW5kZW5jeSBvZiBhXG5cdCogW2NvbXB1dGVkIHByb3BlcnR5XXtAZ2xvc3NhcnkgXCJjb21wdXRlZCBwcm9wZXJ0eVwifS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gVGhlIHByb3BlcnR5IG9yIHBhdGggdG8gdGVzdC5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGBwYXRoYCBpcyBhIGRlcGVuZGVuY3kgb2YgYVxuXHQqXHRbY29tcHV0ZWQgcHJvcGVydHlde0BnbG9zc2FyeSBcImNvbXB1dGVkIHByb3BlcnR5XCJ9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNDb21wdXRlZERlcGVuZGVuY3k6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0cmV0dXJuICEhICh0aGlzLl9jb21wdXRlZERlcGVuZGVuY2llcz8gdGhpcy5fY29tcHV0ZWREZXBlbmRlbmNpZXNbcGF0aF06IGZhbHNlKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzQ29tcHV0ZWQocGF0aCk/IGdldENvbXB1dGVkVmFsdWUodGhpcywgcGF0aCk6IHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0Ly8gd2UgZG8gbm90IGFjY2VwdCBwYXJhbWV0ZXJzIGZvciBjb21wdXRlZCBwcm9wZXJ0aWVzXG5cdFx0XHRyZXR1cm4gdGhpcy5pc0NvbXB1dGVkKHBhdGgpPyB0aGlzOiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5vdGlmeU9ic2VydmVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm5vdGlmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bm90aWZ5OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocGF0aCwgd2FzLCBpcykge1xuXHRcdFx0dGhpcy5pc0NvbXB1dGVkRGVwZW5kZW5jeShwYXRoKSAmJiBxdWV1ZUNvbXB1dGVkKHRoaXMsIHBhdGgpO1xuXHRcdFx0dGhpcy5fY29tcHV0ZWRSZWN1cnNpb24rKztcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5fY29tcHV0ZWRSZWN1cnNpb24tLTtcblx0XHRcdHRoaXMuX2NvbXB1dGVkUXVldWUgJiYgdGhpcy5fY29tcHV0ZWRSZWN1cnNpb24gPT09IDAgJiYgZmx1c2hDb21wdXRlZCh0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2lzQ29tcHV0ZWRDYWNoZWQ6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbXB1dGVkW3BhdGhdO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2dldENvbXB1dGVkQ2FjaGU6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGNhY2hlID0gdGhpcy5fY29tcHV0ZWRDYWNoZSB8fCAodGhpcy5fY29tcHV0ZWRDYWNoZSA9IHt9KTtcblx0XHRyZXR1cm4gY2FjaGVbcGF0aF0gfHwgKGNhY2hlW3BhdGhdID0ge30pO1xuXHR9XG59O1xuXG5cbi8qKlxuKiBIaWphY2sgdGhlIG9yaWdpbmFsIHNvIHdlIGNhbiBhZGQgYWRkaXRpb25hbCBkZWZhdWx0IGJlaGF2aW9yLlxuKi9cbnZhciBzdXAgPSBraW5kLmNvbmNhdEhhbmRsZXI7XG5cbi8vIEBOT1RFOiBJdCBzZWVtcyBsaWtlIGEgbG90IG9mIHdvcmsgYnV0IGl0IHJlYWxseSB3b24ndCBoYXBwZW4gdGhhdCBtdWNoIGFuZCB0aGUgbW9yZVxuLy8gd2UgcHVzaCB0byBraW5kLXRpbWUgdGhlIGJldHRlciBmb3IgaW5pdGlhbGl6YXRpb24gdGltZVxuXG4vKipcbiogQHByaXZhdGVcbiovXG5raW5kLmNvbmNhdEhhbmRsZXIgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMsIGluc3RhbmNlKSB7XG5cblx0c3VwLmNhbGwodGhpcywgY3RvciwgcHJvcHMsIGluc3RhbmNlKTtcblxuXHQvLyBvbmx5IG1hdHRlcnMgaWYgdGhlcmUgYXJlIGNvbXB1dGVkIHByb3BlcnRpZXMgdG8gbWFuYWdlXG5cdGlmIChwcm9wcy5jb21wdXRlZCkge1xuXHRcdFxuXHRcdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3Jcblx0XHRcdCwgY29tcHV0ZWQgPSBwcm90by5fY29tcHV0ZWQ/IE9iamVjdC5jcmVhdGUocHJvdG8uX2NvbXB1dGVkKToge31cblx0XHRcdCwgZGVwZW5kZW5jaWVzID0gcHJvdG8uX2NvbXB1dGVkRGVwZW5kZW5jaWVzPyBPYmplY3QuY3JlYXRlKHByb3RvLl9jb21wdXRlZERlcGVuZGVuY2llcyk6IHt9O1xuXHRcdFxuXHRcdC8vIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gYXBwbGllZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBwcm90b3R5cGUgd2lsbFxuXHRcdC8vIGFjdHVhbGx5IGhhdmUgdGhlIGNvbXB1dGVkIHN1cHBvcnQgbWl4aW4gcHJlc2VudCwgaXQgd2lsbCBub3QgYXBwbHkgaXQgbW9yZVxuXHRcdC8vIHRoYW4gb25jZSB0byB0aGUgcHJvdG90eXBlXG5cdFx0ZXh0ZW5kKENvbXB1dGVkU3VwcG9ydCwgcHJvdG8pO1xuXHRcblx0XHQvLyBATk9URTogVGhpcyBpcyB0aGUgaGFuZGxpbmcgb2YgdGhlIG9yaWdpbmFsIHN5bnRheCBwcm92aWRlZCBmb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbiAyLjMuaXNoLi4uXG5cdFx0Ly8gQWxsIHdlIGRvIGhlcmUgaXMgY29udmVydCBpdCB0byBhIHN0cnVjdHVyZSB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgb3RoZXIgc2NlbmFyaW8gYW5kIHByZWZlcnJlZFxuXHRcdC8vIGNvbXB1dGVkIGRlY2xhcmF0aW9ucyBmb3JtYXRcblx0XHRpZiAoIXByb3BzLmNvbXB1dGVkIHx8ICEocHJvcHMuY29tcHV0ZWQgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciB0bXAgPSBbXSwgZGVwcywgbmFtZSwgY29uZjtcblx0XHRcdFx0Ly8gaGVyZSBpcyB0aGUgc2xvdyBpdGVyYXRpb24gb3ZlciB0aGUgcHJvcGVydGllcy4uLlxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gcHJvcHMuY29tcHV0ZWQpIHtcblx0XHRcdFx0XHQvLyBwb2ludHMgdG8gdGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgY29tcHV0ZWQgbWV0aG9kXG5cdFx0XHRcdFx0ZGVwcyA9IHByb3BzLmNvbXB1dGVkW25hbWVdO1xuXHRcdFx0XHRcdC8qanNoaW50IC1XMDgzICovXG5cdFx0XHRcdFx0Y29uZiA9IGRlcHMgJiYgZGVwcy5maW5kKGZ1bmN0aW9uIChsbikge1xuXHRcdFx0XHRcdFx0Ly8gd2UgZGVsaWJlcmF0ZWx5IHJlbW92ZSB0aGUgZW50cnkgaGVyZSBhbmQgZm9yY2libHkgcmV0dXJuIHRydWUgdG8gYnJlYWtcblx0XHRcdFx0XHRcdHJldHVybiB0eXBlb2YgbG4gPT0gJ29iamVjdCc/ICh1dGlscy5yZW1vdmUoZGVwcywgbG4pIHx8IHRydWUpOiBmYWxzZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHQvKmpzaGludCArVzA4MyAqL1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhIHNpbmdsZSBlbnRyeSBub3cgZm9yIHRoZSBtZXRob2QvY29tcHV0ZWQgd2l0aCBhbGwgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdFx0dG1wLnB1c2goe21ldGhvZDogbmFtZSwgcGF0aDogZGVwcywgY2FjaGVkOiBjb25mPyBjb25mLmNhY2hlZDogbnVsbH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBub3RlIHRoYXQgd2Ugb25seSBkbyB0aGlzIG9uZSBzbyBldmVuIGZvciBhIG1peGluIHRoYXQgaXMgZXZhbHVhdGVkIHNldmVyYWxcblx0XHRcdFx0Ly8gdGltZXMgdGhpcyB3b3VsZCBvbmx5IGhhcHBlbiBvbmNlXG5cdFx0XHRcdHByb3BzLmNvbXB1dGVkID0gdG1wO1xuXHRcdFx0fSgpKTtcblx0XHR9XG5cdFx0XG5cdFx0dmFyIGFkZERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocGF0aCwgZGVwKSB7XG5cdFx0XHQvLyBpdHMgcmVhbGx5IGFuIGludmVyc2UgbG9vayBhdCB0aGUgb3JpZ2luYWxcblx0XHRcdHZhciBkZXBzO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGVwZW5kZW5jaWVzW3BhdGhdICYmICFkZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocGF0aCkpIGRlcGVuZGVuY2llc1twYXRoXSA9IGRlcGVuZGVuY2llc1twYXRoXS5zbGljZSgpO1xuXHRcdFx0ZGVwcyA9IGRlcGVuZGVuY2llc1twYXRoXSB8fCAoZGVwZW5kZW5jaWVzW3BhdGhdID0gW10pO1xuXHRcdFx0ZGVwcy5wdXNoKGRlcCk7XG5cdFx0fTtcblx0XHRcblx0XHQvLyBub3cgd2UgaGFuZGxlIHRoZSBuZXcgY29tcHV0ZWQgcHJvcGVydGllcyB0aGUgd2F5IHdlIGludGVuZGVkIHRvXG5cdFx0Zm9yICh2YXIgaT0wLCBsbjsgKGxuPXByb3BzLmNvbXB1dGVkW2ldKTsgKytpKSB7XG5cdFx0XHQvLyBpZiB0aGUgZW50cnkgYWxyZWFkeSBleGlzdHMgd2UgYXJlIG1lcmVseSB1cGRhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCBpc1xuXHRcdFx0Ly8gbm93IGNhY2hlZFxuXHRcdFx0Y29tcHV0ZWRbbG4ubWV0aG9kXSA9ICEhIGxuLmNhY2hlZDtcblx0XHRcdC8vIHdlIG11c3Qgbm93IGxvb2sgdG8gYWRkIGFuIGVudHJ5IGZvciBhbnkgZ2l2ZW4gZGVwZW5kZW5jaWVzIGFuZCBtYXAgdGhlbVxuXHRcdFx0Ly8gYmFjayB0byB0aGUgY29tcHV0ZWQgcHJvcGVydHkgdGhleSB3aWxsIHRyaWdnZXJcblx0XHRcdC8qanNoaW50IC1XMDgzICovXG5cdFx0XHRpZiAobG4ucGF0aCAmJiBsbi5wYXRoIGluc3RhbmNlb2YgQXJyYXkpIGxuLnBhdGguZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7IGFkZERlcGVuZGVuY3koZGVwLCBsbi5tZXRob2QpOyB9KTtcblx0XHRcdC8qanNoaW50ICtXMDgzICovXG5cdFx0XHRlbHNlIGlmIChsbi5wYXRoKSBhZGREZXBlbmRlbmN5KGxuLnBhdGgsIGxuLm1ldGhvZCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGFyZywgZnJlZSB0aGUga2V5IGZyb20gdGhlIHByb3BlcnRpZXMgc28gaXQgd29uJ3QgYmUgYXBwbGllZCBsYXRlci4uLlxuXHRcdC8vIGRlbGV0ZSBwcm9wcy5jb21wdXRlZDtcblx0XHQvLyBtYWtlIHN1cmUgdG8gcmVhc3NpZ24gdGhlIGNvcnJlY3QgaXRlbXMgdG8gdGhlIHByb3RvdHlwZVxuXHRcdHByb3RvLl9jb21wdXRlZCA9IGNvbXB1dGVkO1xuXHRcdHByb3RvLl9jb21wdXRlZERlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcblx0fVxufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL2tpbmRcIjo2NixcIi4vdXRpbHNcIjo3NX1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkxheW91dH0gaXMgdGhlIGJhc2UgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBmb3IgbGF5b3V0XG4qIGtpbmRzLiBMYXlvdXQga2luZHMgYXJlIHVzZWQgYnkge0BsaW5rIGVueW8uVWlDb21wb25lbnR9LWJhc2VkXG4qIFtjb250cm9sc117QGxpbmsgZW55by5Db250cm9sfSB0byBhbGxvdyBmb3IgYXJyYW5naW5nIG9mIGNoaWxkIGNvbnRyb2xzIGJ5XG4qIHNldHRpbmcgdGhlIFtsYXlvdXRLaW5kXXtAbGluayBlbnlvLlVpQ29tcG9uZW50I2xheW91dEtpbmR9IHByb3BlcnR5LlxuKiBcbiogRGVyaXZlZCBraW5kcyB3aWxsIHVzdWFsbHkgcHJvdmlkZSB0aGVpciBvd25cbiogW2xheW91dENsYXNzXXtAbGluayBlbnlvLkxheW91dCNsYXlvdXRDbGFzc30gcHJvcGVydHkgdG8gYWZmZWN0IHRoZSBDU1NcbiogcnVsZXMgdXNlZCwgYW5kIG1heSBhbHNvIGltcGxlbWVudCB0aGUgW2Zsb3coKV17QGxpbmsgZW55by5MYXlvdXQjZmxvd31cbiogYW5kIFtyZWZsb3coKV17QGxpbmsgZW55by5MYXlvdXQjcmVmbG93fSBtZXRob2RzLiBgZmxvdygpYCBpcyBjYWxsZWRcbiogZHVyaW5nIGNvbnRyb2wgcmVuZGVyaW5nLCB3aGlsZSBgcmVmbG93KClgIGlzIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkXG4qIGNvbnRyb2wgaXMgcmVzaXplZC5cbipcbiogQGNsYXNzIGVueW8uTGF5b3V0XG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5MYXlvdXQucHJvdG90eXBlICovIHtcblxuXHRuYW1lOiAnZW55by5MYXlvdXQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IG51bGwsXG5cblx0LyoqIFxuXHQqIENTUyBjbGFzcyB0aGF0J3MgYWRkZWQgdG8gdGhlIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHVzaW5nIHRoaXMgXG5cdCogW2xheW91dF17QGxpbmsgZW55by5MYXlvdXR9IFtraW5kXXtAZ2xvc3Nhcnkga2luZH0uXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICcnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRsYXlvdXRDbGFzczogJycsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmxheW91dENsYXNzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmNvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5sYXlvdXRDbGFzcyk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQ2FsbGVkIGR1cmluZyBzdGF0aWMgcHJvcGVydHkgbGF5b3V0IChpLmUuLCBkdXJpbmcgcmVuZGVyaW5nKS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmxvdzogZnVuY3Rpb24gKCkge1xuXHR9LFxuXG5cdC8qKiBcblx0KiBDYWxsZWQgZHVyaW5nIGR5bmFtaWMgbWVhc3VyaW5nIGxheW91dCAoaS5lLiwgZHVyaW5nIGEgcmVzaXplKS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVmbG93OiBmdW5jdGlvbiAoKSB7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4va2luZFwiOjY2fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4qIEFuIGFic3RyYWN0IGxpbmtlZC1saXN0IG5vZGUuXG4qXG4qIEBjbGFzcyBlbnlvLkxpbmtlZExpc3ROb2RlXG4qIEBwcml2YXRlXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uTGlua2VkTGlzdE5vZGUucHJvdG90eXBlICovIHtcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IG51bGwsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcmV2OiBudWxsLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmV4dDogbnVsbCxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvcHk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3B5ID0gbmV3IHRoaXMuY3RvcigpO1xuXHRcdGNweS5wcmV2ID0gdGhpcy5wcmV2O1xuXHRcdGNweS5uZXh0ID0gdGhpcy5uZXh0O1xuXHRcdHJldHVybiBjcHk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0cHJvcHMgJiYgdXRpbHMubWl4aW4odGhpcywgcHJvcHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGNsZWFyIHJlZmVyZW5jZSB0byBwcmV2aW91cyBub2RlXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcblx0XHRcblx0XHQvLyBpZiB3ZSBoYXZlIGEgcmVmZXJlbmNlIHRvIG91ciBuZXh0IG5vZGVcblx0XHQvLyB3ZSBjb250aW51ZSBkb3duIHRoZSBjaGFpblxuXHRcdHRoaXMubmV4dCAmJiB0aGlzLm5leHQuZGVzdHJveSgpO1xuXHRcdFxuXHRcdC8vIGNsZWFyIG91ciByZWZlcmVuY2UgdG8gdGhlIG5leHQgbm9kZVxuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG5cbnZhclxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHRsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG5raW5kLmNvbmNhdGVuYXRlZC5wdXNoKCdtaXhpbnMnKTtcblxudmFyIHN1cCA9IGtpbmQuc3RhdGljcy5leHRlbmQ7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBleHRlbmQgPSBraW5kLnN0YXRpY3MuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChhcmdzLCB0YXJnZXQpIHtcblx0aWYgKHV0aWxzLmlzQXJyYXkoYXJncykpIHJldHVybiB1dGlscy5mb3JFYWNoKGFyZ3MsIGZ1bmN0aW9uIChsbikgeyBleHRlbmQuY2FsbCh0aGlzLCBsbiwgdGFyZ2V0KTsgfSwgdGhpcyk7XG5cdGlmICh0eXBlb2YgYXJncyA9PSAnc3RyaW5nJykgYXBwbHkodGFyZ2V0IHx8IHRoaXMucHJvdG90eXBlLCBhcmdzKTtcblx0ZWxzZSB7XG5cdFx0aWYgKGFyZ3MubWl4aW5zKSBmZWF0dXJlKHRhcmdldCB8fCB0aGlzLCBhcmdzKTtcblx0XG5cdFx0Ly8gdGhpcyBhbGxvd3MgZm9yIG1peGlucyB0byBhcHBseSBtaXhpbnMgd2hpY2guLi5pcyBsZXNzIHRoYW4gaWRlYWwgYnV0IHBvc3NpYmxlXG5cdFx0aWYgKGFyZ3MubmFtZSkgYXBwbHkodGFyZ2V0IHx8IHRoaXMucHJvdG90eXBlLCBhcmdzKTtcblx0XHRlbHNlIHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG59O1xuXG4vKipcbiogQXBwbGllcywgd2l0aCBzYWZlZ3VhcmRzLCBhIGdpdmVuIG1peGluIHRvIGFuIG9iamVjdC5cbipcbiogQHByaXZhdGVcbiovXG5mdW5jdGlvbiBhcHBseSAocHJvdG8sIHByb3BzKSB7XG5cdHZhciBhcHBsaWVkID0gcHJvdG8uX21peGlucz8gKHByb3RvLl9taXhpbnMgPSBwcm90by5fbWl4aW5zLnNsaWNlKCkpOiAocHJvdG8uX21peGlucyA9IFtdKVxuXHRcdCwgbmFtZSA9IHV0aWxzLmlzU3RyaW5nKHByb3BzKT8gcHJvcHM6IHByb3BzLm5hbWVcblx0XHQsIGlkeCA9IHV0aWxzLmluZGV4T2YobmFtZSwgYXBwbGllZCk7XG5cdGlmIChpZHggPCAwKSB7XG5cdFx0bmFtZSA9PSBwcm9wcyAmJiAocHJvcHMgPSB1dGlscy5nZXRQYXRoKG5hbWUpKTtcblx0XHQvLyBpZiB3ZSBjb3VsZCBub3QgcmVzb2x2ZSB0aGUgcmVxdWVzdGVkIG1peGluIChzaG91bGQgbmV2ZXIgaGFwcGVuKVxuXHRcdC8vIHdlIHRocm93IGEgc2ltcGxlIGxpdHRsZSBlcnJvclxuXHRcdC8vIEBUT0RPOiBOb3JtYWxpemUgZXJyb3IgZm9ybWF0XG5cdFx0IXByb3BzICYmIGxvZ2dlci5lcnJvcignQ291bGQgbm90IGZpbmQgdGhlIG1peGluICcgKyBuYW1lKTtcblx0XHRcblx0XHQvLyBpdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGlzIGVuc3VyZXMgaXQgd29uJ3QgcmVjdXJzaXZlbHkgcmUtYWRkIHRoZSBzYW1lIG1peGluIGJ1dFxuXHRcdC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIGZvciBtaXhpbnMgdG8gYXBwbHkgbWl4aW5zIHRoZSBuYW1lcyB3aWxsIGJlIG91dCBvZiBvcmRlclxuXHRcdC8vIHRoaXMgbmFtZSBpcyBwdXNoZWQgb24gYnV0IHRoZSBuZXN0ZWQgbWl4aW5zIGFyZSBhcHBsaWVkIGJlZm9yZSB0aGlzIG9uZVxuXHRcdG5hbWUgJiYgYXBwbGllZC5wdXNoKG5hbWUpO1xuXHRcdFxuXHRcdHByb3BzID0gdXRpbHMuY2xvbmUocHJvcHMpO1xuXHRcdFxuXHRcdC8vIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgbW92ZSB0aGUgY29uc3RydWN0b3IgaWYgaXQgaGFzIG9uZSBzbyBpdFxuXHRcdC8vIHdpbGwgb3ZlcnJpZGUgdGhlIGNvcnJlY3QgbWV0aG9kIC0gdGhpcyBpcyBhIG9uZS10aW1lIHBlcm1hbmVudFxuXHRcdC8vIHJ1bnRpbWUgb3BlcmF0aW9uIHNvIHN1YnNlcXVlbnQgYWRkaXRpb25zIG9mIHRoZSBtaXhpbiBkb24ndCByZXF1aXJlXG5cdFx0Ly8gaXQgYWdhaW5cblx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcblx0XHRcdHByb3BzLl9jb25zdHJ1Y3RvciA9IHByb3BzLmNvbnN0cnVjdG9yO1xuXHRcdFx0ZGVsZXRlIHByb3BzLmNvbnN0cnVjdG9yO1xuXHRcdH1cblx0XHRcblx0XHRkZWxldGUgcHJvcHMubmFtZTtcblx0XHRleHRlbmQocHJvcHMsIHByb3RvKTtcblx0XHRcblx0XHQvLyBub3cgcHV0IGl0IGFsbCBiYWNrIHRoZSB3YXkgaXQgd2FzXG5cdFx0cHJvcHMubmFtZSA9IG5hbWU7XG5cdH1cbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZmVhdHVyZSAoY3RvciwgcHJvcHMpIHtcblx0aWYgKHByb3BzLm1peGlucykge1xuXHRcdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3Jcblx0XHRcdCwgbWl4aW5zID0gcHJvcHMubWl4aW5zO1xuXHRcdFxuXHRcdC8vIGRlbGV0ZSBwcm9wcy5taXhpbnM7XG5cdFx0Ly8gZGVsZXRlIHByb3RvLm1peGlucztcblx0XHRcblx0XHRwcm90by5fbWl4aW5zICYmIChwcm90by5fbWl4aW5zID0gcHJvdG8uX21peGlucy5zbGljZSgpKTtcblx0XHR1dGlscy5mb3JFYWNoKG1peGlucywgZnVuY3Rpb24gKGxuKSB7IGFwcGx5KHByb3RvLCBsbik7IH0pO1xuXHR9XG59XG5cbmtpbmQuZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcblxuLyoqXG4qIEFuIGludGVybmFsbHktdXNlZCBzdXBwb3J0IHtAZ2xvc3NhcnkgbWl4aW59IHRoYXQgYWRkcyBBUEkgbWV0aG9kcyB0byBhaWQgaW5cbiogdXNpbmcgYW5kIGFwcGx5aW5nIG1peGlucyB0byBba2luZHNde0BnbG9zc2FyeSBraW5kfS5cbipcbiogQG1peGluIGVueW8uTWl4aW5TdXBwb3J0XG4qIEBwcm90ZWN0ZWRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdNaXhpblN1cHBvcnQnLFxuXHRcblx0LyoqXG5cdCogRXh0ZW5kcyB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFRoZSBwcm9wZXJ0eSBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gZnJvbSB3aGljaCB0byBleHRlbmRcblx0Klx0dGhlIGNhbGxlZS5cblx0Ki9cblx0ZXh0ZW5kOiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRwcm9wcyAmJiBhcHBseSh0aGlzLCBwcm9wcyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbXBvcnRQcm9wczoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0XHRwcm9wcyAmJiBwcm9wcy5taXhpbnMgJiYgZmVhdHVyZSh0aGlzLCBwcm9wcyk7XG5cdFx0XHRcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG59O1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4va2luZFwiOjY2LFwiLi9sb2dnZXJcIjo2NyxcIi4vdXRpbHNcIjo3NX1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbi8qKlxuKiBBbGwgb2YgdGhlIGtub3duLCBpbnN0YW5jZWQgW3NvdXJjZXNde0BsaW5rIGVueW8uU291cmNlfSwgYnkgbmFtZS5cbipcbiogQG5hbWUgZW55b35zb3VyY2VzXG4qIEB0eXBlIHtPYmplY3R9XG4qIEByZWFkb25seVxuKi9cbnZhciBzb3VyY2VzID0ge307XG5cbi8qKlxuKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MuIEEgW3NvdXJjZV17QGxpbmsgZW55by5Tb3VyY2V9IGlzIGEgY29tbXVuaWNhdGlvblxuKiBsYXllciB1c2VkIGJ5IGRhdGEgbGF5ZXIgW2tpbmRzXXtAZ2xvc3Nhcnkga2luZH0gdG8gcmV0cmlldmUgYW5kIHBlcnNpc3QgZGF0YSBhbmRcbiogYXBwbGljYXRpb24gc3RhdGUgdmlhIGl0cyBhYnN0cmFjdCBBUEkgbWV0aG9kcy5cbipcbiogQGNsYXNzIGVueW8uU291cmNlXG4qIEBwdWJsaWNcbiovXG52YXIgU291cmNlID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uU291cmNlLnByb3RvdHlwZSAqLyB7XG5cdFxuXHRuYW1lOiAnZW55by5Tb3VyY2UnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogbnVsbCxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblx0XG5cdC8qKlxuXHQqIFdoZW4gaW5pdGlhbGl6ZWQsIHRoZSBzb3VyY2Ugc2hvdWxkIGJlIHBhc3NlZCBwcm9wZXJ0aWVzIHRvIHNldCBvbiBpdHNlbGYuXG5cdCogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgaW5jbHVkZSB0aGUgbmFtZSBieSB3aGljaCBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgaW5cblx0KiB0aGUgYXBwbGljYXRpb24uXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSAtIFRoZSBwcm9wZXJ0aWVzIHRvIHNldCBvbiBpdHNlbGYuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0aWYgKHByb3BzKSB0aGlzLmltcG9ydFByb3BzKHByb3BzKTtcblx0XHQvLyBhdXRvbWF0aWMgY29lcnNpb24gb2YgbmFtZSByZW1vdmluZyBwcmVmaXhcblx0XHR0aGlzLm5hbWUgfHwgKHRoaXMubmFtZSA9IHRoaXMua2luZE5hbWUucmVwbGFjZSgvXiguKilcXC4vLCBcIlwiKSk7XG5cdFx0Ly8gbm93IGFkZCB0byB0aGUgZ2xvYmFsIHJlZ2lzdHJ5IG9mIHNvdXJjZXNcblx0XHRzb3VyY2VzW3RoaXMubmFtZV0gPSB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gaGFuZGxlIHJldHJpZXZhbCBvZiBkYXRhLiBUaGlzIG1ldGhvZCBzaG91bGQgYWNjZXB0IGFuIG9wdGlvbnNcblx0KiBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gd2l0aCBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcywgaW5jbHVkaW5nIGBzdWNjZXNzYFxuXHQqIGFuZCBgZXJyb3JgIGNhbGxiYWNrcyB0byBoYW5kbGUgdGhlIHJlc3VsdC5cblx0KlxuXHQqIEB2aXJ0dWFsXG5cdCogQHBhcmFtIHsoZW55by5Nb2RlbHxlbnlvLkNvbGxlY3Rpb24pfSBtb2RlbCBUaGUgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBvclxuXHQqXHRbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSB0byBiZSByZXRyaWV2ZWQuXG5cdCogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSwgaW5jbHVkaW5nXG5cdCpcdGBzdWNjZXNzYCBhbmQgYGVycm9yYCBjYWxsYmFja3MuXG5cdCovXG5cdGZldGNoOiBmdW5jdGlvbiAobW9kZWwsIG9wdHMpIHtcblx0XHQvL1xuXHR9LFxuXHRcblx0LyoqXG5cdCogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gaGFuZGxlIHBlcnNpc3Rpbmcgb2YgZGF0YS4gVGhpcyBtZXRob2Qgc2hvdWxkIGFjY2VwdCBhbiBvcHRpb25zXG5cdCogW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMsIGluY2x1ZGluZyBgc3VjY2Vzc2Bcblx0KiBhbmQgYGVycm9yYCBjYWxsYmFja3MgdG8gaGFuZGxlIHRoZSByZXN1bHQuXG5cdCpcblx0KiBAdmlydHVhbFxuXHQqIEBwYXJhbSB7KGVueW8uTW9kZWx8ZW55by5Db2xsZWN0aW9uKX0gbW9kZWwgVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gb3Jcblx0Klx0W2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdG8gYmUgcGVyc2lzdGVkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0sIGluY2x1ZGluZ1xuXHQqXHRgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgY2FsbGJhY2suXG5cdCovXG5cdGNvbW1pdDogZnVuY3Rpb24gKG1vZGVsLCBvcHRzKSB7XG5cdFx0Ly9cblx0fSxcblx0XG5cdC8qKlxuXHQqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSBkZWxldGlvbiBvZiBkYXRhLiBUaGlzIG1ldGhvZCBzaG91bGQgYWNjZXB0IGFuIG9wdGlvbnNcblx0KiBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gd2l0aCBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcywgaW5jbHVkaW5nIGBzdWNjZXNzYFxuXHQqIGFuZCBgZXJyb3JgIGNhbGxiYWNrcyB0byBoYW5kbGUgdGhlIHJlc3VsdC4gSWYgY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycywgaXQgd2lsbFxuXHQqIGluc3RlYWQgZGVzdHJveSBpdHNlbGYgYW5kIGJlIHJlbW92ZWQgZnJvbSBbZW55by5zb3VyY2VzXXtAbGluayBlbnlvfnNvdXJjZXN9LCByZW5kZXJpbmdcblx0KiBpdHNlbGYgdW5hdmFpbGFibGUgZm9yIGZ1cnRoZXIgb3BlcmF0aW9ucy5cblx0KlxuXHQqIEBwYXJhbSB7KGVueW8uTW9kZWx8ZW55by5Db2xsZWN0aW9uKX0gbW9kZWwgVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gb3Jcblx0Klx0W2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdG8gYmUgZGVsZXRlZC5cblx0KiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9LCBpbmNsdWRpbmdcblx0Klx0YHN1Y2Nlc3NgIGFuZCBgZXJyb3JgIGNhbGxiYWNrcy5cblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKG1vZGVsLCBvcHRzKSB7XG5cdFx0XG5cdFx0Ly8gaWYgY2FsbGVkIHdpdGggbm8gcGFyYW1ldGVycyB3ZSBhY3R1YWxseSBqdXN0IGJyZWFrZG93biB0aGUgc291cmNlIGFuZCByZW1vdmVcblx0XHQvLyBpdCBhcyBiZWluZyBhdmFpbGFibGVcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHNvdXJjZXNbdGhpcy5uYW1lXSA9IG51bGw7XG5cdFx0XHR0aGlzLm5hbWUgPSBudWxsO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSBxdWVyeWluZyBvZiBkYXRhIGJhc2VkIG9uIHRoZSBwYXNzZWQtaW4gY29uc3RydWN0b3IuIFRoaXNcblx0KiBtZXRob2Qgc2hvdWxkIGFjY2VwdCBhbiBvcHRpb25zIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSB3aXRoIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxuXHQqIHByb3BlcnRpZXMsIGluY2x1ZGluZyBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgY2FsbGJhY2tzIHRvIGhhbmRsZSB0aGUgcmVzdWx0LlxuXHQqXG5cdCogQHZpcnR1YWxcblx0KiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBvZlxuXHQqXHR7QGxpbmsgZW55by5Nb2RlbH0gb3Ige0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdG8gYmUgcXVlcmllZC5cblx0KiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9LCBpbmNsdWRpbmdcblx0Klx0YHN1Y2Nlc3NgIGFuZCBgZXJyb3JgIGNhbGxiYWNrcy5cblx0Ki9cblx0ZmluZDogZnVuY3Rpb24gKGN0b3IsIG9wdHMpIHtcblx0XHQvL1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1wb3J0UHJvcHM6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdHByb3BzICYmIHV0aWxzLm1peGluKHRoaXMsIHByb3BzKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBzZWUgZW55by5nZXRQYXRoXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0OiB1dGlscy5nZXRQYXRoLFxuXHRcblx0LyoqXG5cdCogQHNlZSBlbnlvLnNldFBhdGhcblx0KiBAbWV0aG9kXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXQ6IHV0aWxzLnNldFBhdGhcbn0pO1xuXG4vKipcbiogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgZW55by5Tb3VyY2V9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXMuIFRoZXNlXG4qIHByb3BlcnRpZXMgc2hvdWxkIGluY2x1ZGUgYSBga2luZGAgcHJvcGVydHkgd2l0aCB0aGUgbmFtZSBvZiB0aGVcbiogW2tpbmRde0BnbG9zc2FyeSBraW5kfSBvZiBzb3VyY2UgYW5kIGEgYG5hbWVgIGZvciB0aGUgaW5zdGFuY2UuIFRoaXMgc3RhdGljXG4qIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBvbiBhbGwgW3N1YmtpbmRzXXtAZ2xvc3Nhcnkgc3Via2luZH0gb2ZcbiogYGVueW8uU291cmNlYC4gVGhlIGluc3RhbmNlIHdpbGwgYXV0b21hdGljYWxseSBiZSBhZGRlZCB0byB0aGVcbiogW2VueW8uc291cmNlc117QGxpbmsgZW55b35zb3VyY2VzfSBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBhbmQgbWF5IGJlXG4qIHJlZmVyZW5jZWQgYnkgaXRzIGBuYW1lYC5cbipcbiogQG5hbWUgZW55by5Tb3VyY2UuY3JlYXRlXG4qIEBzdGF0aWNcbiogQG1ldGhvZFxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHJlcXVlc3RlZFxuKlx0W2tpbmRde0BnbG9zc2FyeSBraW5kfSBvZiBbc291cmNlXXtAbGluayBlbnlvLlNvdXJjZX0uXG4qIEByZXR1cm5zIHtlbnlvLlNvdXJjZX0gQW4gaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZCBraW5kIG9mIHNvdXJjZS5cbiogQHB1YmxpY1xuKi9cblNvdXJjZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcblx0dmFyIEN0b3IgPSAocHJvcHMgJiYgcHJvcHMua2luZCkgfHwgdGhpcztcblx0XG5cdGlmICh0eXBlb2YgQ3RvciA9PSAnc3RyaW5nJykgQ3RvciA9IGtpbmQuY29uc3RydWN0b3JGb3JLaW5kKEN0b3IpO1xuXHRcblx0cmV0dXJuIG5ldyBDdG9yKHByb3BzKTtcbn07XG5cbi8qKlxuKiBAc3RhdGljXG4qIEBwcml2YXRlXG4qL1xuU291cmNlLmNvbmNhdCA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcykge1xuXHRcblx0Ly8gZm9yY2Ugbm9EZWZlciBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBzZXQgdGhpcyBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yXG5cdGlmIChwcm9wcykgcHJvcHMubm9EZWZlciA9IHRydWU7XG5cdFxuXHRjdG9yLmNyZWF0ZSA9IFNvdXJjZS5jcmVhdGU7XG59O1xuXG4vKipcbiogQHN0YXRpY1xuKiBAcHJpdmF0ZVxuKi9cblNvdXJjZS5leGVjdXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgbW9kZWwsIG9wdHMpIHtcblx0dmFyIHNvdXJjZSA9IG9wdHMuc291cmNlIHx8IG1vZGVsLnNvdXJjZSxcblx0XG5cdFx0Ly8gd2UgbmVlZCB0byBiZSBhYmxlIHRvIGJpbmQgdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyBmb3IgZWFjaCBvZiB0aGVcblx0XHQvLyBzb3VyY2VzIHdlJ2xsIGJlIHVzaW5nXG5cdFx0b3B0aW9ucyA9IHV0aWxzLmNsb25lKG9wdHMsIHRydWUpLFxuXHRcdG5vbSA9IHNvdXJjZSxcblx0XHRtc2c7XG5cdFxuXHRpZiAoc291cmNlKSB7XG5cdFx0XG5cdFx0Ly8gaWYgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZSB0aGVuIHdlIG5lZWQgdG8gdXNlIGFsbCBhdmFpbGFibGUgc291cmNlcyBpbiB0aGVcblx0XHQvLyBhcHBsaWNhdGlvblxuXHRcdGlmIChzb3VyY2UgPT09IHRydWUpIHtcblx0XHRcdFxuXHRcdFx0Zm9yIChub20gaW4gc291cmNlcykge1xuXHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzW25vbV07XG5cdFx0XHRcdGlmIChzb3VyY2VbYWN0aW9uXSkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGJpbmQgdGhlIHNvdXJjZSBuYW1lIHRvIHRoZSBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3Ncblx0XHRcdFx0XHRvcHRpb25zLnN1Y2Nlc3MgPSBvcHRzLnN1Y2Nlc3MuYmluZChudWxsLCBub20pO1xuXHRcdFx0XHRcdG9wdGlvbnMuZXJyb3IgPSBvcHRzLmVycm9yLmJpbmQobnVsbCwgbm9tKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzb3VyY2VbYWN0aW9uXShtb2RlbCwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgb2Ygc3BlY2lmaWMgc291cmNlcyB0byB1c2Ugd2UsIHdlbGwsIHdpbGwgb25seSB1c2UgdGhvc2UhXG5cdFx0ZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChub20pIHtcblx0XHRcdFx0dmFyIHNyYyA9IHR5cGVvZiBub20gPT0gJ3N0cmluZycgPyBzb3VyY2VzW25vbV0gOiBub207XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc3JjICYmIHNyY1thY3Rpb25dKSB7XG5cdFx0XHRcdFx0Ly8gYmluZCB0aGUgc291cmNlIG5hbWUgdG8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrc1xuXHRcdFx0XHRcdG9wdGlvbnMuc3VjY2VzcyA9IG9wdHMuc3VjY2Vzcy5iaW5kKG51bGwsIHNyYy5uYW1lKTtcblx0XHRcdFx0XHRvcHRpb25zLmVycm9yID0gb3B0cy5lcnJvci5iaW5kKG51bGwsIHNyYy5uYW1lKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzcmNbYWN0aW9uXShtb2RlbCwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvLyBpZiBpdCBpcyBhbiBpbnN0YW5jZSBvZiBhIHNvdXJjZVxuXHRcdGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFNvdXJjZSAmJiBzb3VyY2VbYWN0aW9uXSkge1xuXHRcdFx0XG5cdFx0XHQvLyBiaW5kIHRoZSBzb3VyY2UgbmFtZSB0byB0aGUgc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzXG5cdFx0XHRvcHRpb25zLnN1Y2Nlc3MgPSBvcHRzLnN1Y2Nlc3MuYmluZChudWxsLCBzb3VyY2UubmFtZSk7XG5cdFx0XHRvcHRpb25zLmVycm9yID0gb3B0cy5lcnJvci5iaW5kKG51bGwsIHNvdXJjZS5uYW1lKTtcblx0XHRcdFxuXHRcdFx0c291cmNlW2FjdGlvbl0obW9kZWwsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBvdGhlcndpc2Ugb25seSBvbmUgd2FzIHNwZWNpZmllZCBhbmQgd2UgYXR0ZW1wdCB0byB1c2UgdGhhdFxuXHRcdGVsc2UgaWYgKChzb3VyY2UgPSBlbnlvLnNvdXJjZXNbbm9tXSkgJiYgc291cmNlW2FjdGlvbl0pIHtcblx0XHRcdFxuXHRcdFx0Ly8gYmluZCB0aGUgc291cmNlIG5hbWUgdG8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrc1xuXHRcdFx0b3B0aW9ucy5zdWNjZXNzID0gb3B0cy5zdWNjZXNzLmJpbmQobnVsbCwgbm9tKTtcblx0XHRcdG9wdGlvbnMuZXJyb3IgPSBvcHRzLmVycm9yLmJpbmQobnVsbCwgbm9tKTtcblx0XHRcdFxuXHRcdFx0c291cmNlW2FjdGlvbl0obW9kZWwsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRcblx0XHQvLyB3ZSBjb3VsZCBub3QgcmVzb2x2ZSB0aGUgcmVxdWVzdGVkIHNvdXJjZVxuXHRcdGVsc2Uge1xuXHRcdFx0bXNnID0gJ2VueW8uU291cmNlLmV4ZWN1dGUoKTogcmVxdWVzdGVkIHNvdXJjZShzKSBjb3VsZCBub3QgYmUgZm91bmQgZm9yICcgK1xuXHRcdFx0XHRtb2RlbC5raW5kTmFtZSArICcuJyArIGFjdGlvbiArICcoKSc7XG5cdFx0XHRcblx0XHRcdGxvZ2dlci53YXJuKG1zZyk7XG5cdFx0XHRcblx0XHRcdC8vIHdlIG5lZWQgdG8gZmFpbCB0aGUgYXR0ZW1wdCBhbmQgbGV0IGl0IGJlIGhhbmRsZWRcblx0XHRcdG9wdHMuZXJyb3Iobm9tID8gdHlwZW9mIG5vbSA9PSAnc3RyaW5nJyA/IG5vbSA6IG5vbS5uYW1lIDogJ1VOS05PV04nLCBtc2cpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRtc2cgPSAnZW55by5Tb3VyY2UuZXhlY3V0ZSgpOiBubyBzb3VyY2UocykgcHJvdmlkZWQgZm9yICcgKyBtb2RlbC5raW5kTmFtZSArICcuJyArXG5cdFx0XHRhY3Rpb24gKyAnKCknO1xuXHRcdFx0XG5cdFx0bG9nZ2VyLndhcm4obXNnKTtcblx0XHRcblx0XHQvLyB3ZSBuZWVkIHRvIGZhaWwgdGhlIGF0dGVtcHQgYW5kIGxldCBpdCBiZSBoYW5kbGVkXG5cdFx0b3B0cy5lcnJvcihub20gPyB0eXBlb2Ygbm9tID09ICdzdHJpbmcnID8gbm9tIDogbm9tLm5hbWUgOiAnVU5LTk9XTicsIG1zZyk7XG5cdH1cbn07XG5cblNvdXJjZS5zb3VyY2VzID0gc291cmNlcztcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL2tpbmRcIjo2NixcIi4vbG9nZ2VyXCI6NjcsXCIuL3V0aWxzXCI6NzV9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vcGxhdGZvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29udHJvbCkge1xuXHQvKipcblx0KiB7QGxpbmsgZW55by5GbG9hdGluZ0xheWVyfSBpcyBhIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHRoYXQgcHJvdmlkZXMgYSBsYXllciBmb3Jcblx0KiBjb250cm9scyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgYWJvdmUgYW4gW2FwcGxpY2F0aW9uXXtAbGluayBlbnlvLkFwcGxpY2F0aW9ufS4gVGhlXG5cdCogYGZsb2F0aW5nTGF5ZXJgIHNpbmdsZXRvbiBjYW4gYmUgc2V0IGFzIGEgY29udHJvbCdzIHBhcmVudCB0byBoYXZlIHRoZSBjb250cm9sIGZsb2F0XG5cdCogYWJvdmUgdGhlIGFwcGxpY2F0aW9uLCBlLmcuOlxuXHQqXG5cdCogYGBgXG5cdCogY3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHQqXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCpcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCpcdFx0dGhpcy5zZXRQYXJlbnQoZW55by5mbG9hdGluZ0xheWVyKTtcblx0Klx0fVxuXHQqIH0pO1xuXHQqIGBgYFxuXHQqXG5cdCogTm90ZTogYGVueW8uRmxvYXRpbmdMYXllcmAgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCBieSB1c2Vycy5cblx0KlxuXHQqIEBjbGFzcyBlbnlvLkZsb2F0aW5nTGF5ZXJcblx0KiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcblx0KiBAdWlcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHJldHVybiBraW5kKFxuXHRcdC8qKiBAbGVuZHMgZW55by5GbG9hdGluZ0xheWVyLnByb3RvdHlwZSAqLyB7XG5cblx0XHQvKipcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRraW5kOiBDb250cm9sLFxuXG5cdFx0LyoqXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0Y2xhc3NlczogJ2VueW8tZml0IGVueW8tY2xpcCBlbnlvLXVudG91Y2hhYmxlJyxcblxuXHRcdC8qKlxuXHRcdCogQG1ldGhvZFxuXHRcdCogQHByaXZhdGVcblx0XHQqL1xuXHRcdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuc2V0UGFyZW50KG51bGwpO1xuXG5cdFx0XHRcdGlmIChwbGF0Zm9ybS5pZSA8IDExKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVDbGFzcygnZW55by1maXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8qKlxuXHRcdCogRGV0ZWN0cyB3aGVuIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gaXMgZGV0YXRjaGVkIGR1ZSB0byBgZG9jdW1lbnQuYm9keWAgYmVpbmcgc3RvbXBlZC5cblx0XHQqXG5cdFx0KiBAbWV0aG9kXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0aGFzTm9kZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmICh0aGlzLm5vZGUgJiYgIXRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0dGhpcy50ZWFyZG93blJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0LyoqXG5cdFx0KiBAbWV0aG9kXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0cmVuZGVyOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUgPSBkb2N1bWVudC5ib2R5O1xuXHRcdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0LyoqXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0Z2VuZXJhdGVJbm5lckh0bWw6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0YmVmb3JlQ2hpbGRSZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0dGVhcmRvd25DaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuXHRcdH1cblx0fSk7XG59O1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4va2luZFwiOjY2LFwiLi9wbGF0Zm9ybVwiOjcxLFwiLi91dGlsc1wiOjc1fV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2FuaW1hdGlvbicpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9kb20nKSxcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0bG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvbG9nZ2VyJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvcGxhdGZvcm0nKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi91dGlscycpO1xuXG4vKipcbiogZW55by5MaXN0IHdhcyB0b28gbGFyZ2UgZm9yIHRoZSBwYXJzZXIgc28gd2UgaGF2ZSB0byBzcGxpdCBpdCB1cC4gRm9yIG5vdywgd2UncmUgYXJiaXRyYXJpbHlcbiogc3BsaXR0aW5nIHRoZSBtZXRob2RzIGludG8gYW5vdGhlciBmaWxlLiBBIG1vcmUgYXBwcm9wcmlhdGUgcmVmYWN0b3JpbmcgaXMgcmVxdWlyZWQuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8qKiBAbGVuZHMgZW55by5MaXN0LnByb3RvdHlwZSAqLyB7XG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbXBvcnRQcm9wczoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0XHQvLyBmb3JjZSB0b3VjaCBvbiBkZXNrdG9wIHdoZW4gd2UgaGF2ZSByZW9yZGVyYWJsZSBpdGVtcyB0byB3b3JrIGFyb3VuZFxuXHRcdFx0Ly8gcHJvYmxlbXMgd2l0aCBuYXRpdmUgc2Nyb2xsZXJcblx0XHRcdGlmIChwcm9wcyAmJiBwcm9wcy5yZW9yZGVyYWJsZSkge1xuXHRcdFx0XHR0aGlzLnRvdWNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMucGFnZVNpemVzID0gW107XG5cdFx0XHR0aGlzLm9yaWVudFYgPSB0aGlzLm9yaWVudCA9PSAndic7XG5cdFx0XHR0aGlzLnZlcnRpY2FsID0gdGhpcy5vcmllbnRWID8gJ2RlZmF1bHQnIDogJ2hpZGRlbic7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuJC5nZW5lcmF0b3Iub3JpZW50ID0gdGhpcy5vcmllbnQ7XG5cdFx0XHR0aGlzLmdldFN0cmF0ZWd5KCkudHJhbnNsYXRlT3B0aW1pemVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuJC5wb3J0LmFkZFJlbW92ZUNsYXNzKCdob3Jpem9udGFsJywhdGhpcy5vcmllbnRWKTtcblx0XHRcdHRoaXMuJC5wb3J0LmFkZFJlbW92ZUNsYXNzKCd2ZXJ0aWNhbCcsdGhpcy5vcmllbnRWKTtcblx0XHRcdHRoaXMuJC5wYWdlMC5hZGRSZW1vdmVDbGFzcygndmVydGljYWwnLHRoaXMub3JpZW50Vik7XG5cdFx0XHR0aGlzLiQucGFnZTEuYWRkUmVtb3ZlQ2xhc3MoJ3ZlcnRpY2FsJyx0aGlzLm9yaWVudFYpO1xuXHRcdFx0dGhpcy5ib3R0b21VcENoYW5nZWQoKTsgIC8vIEluaXRpYWxpemVzIHBhZ2VCb3VuZCBhbHNvXG5cdFx0XHR0aGlzLm5vU2VsZWN0Q2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5tdWx0aVNlbGVjdENoYW5nZWQoKTtcblx0XHRcdHRoaXMudG9nZ2xlU2VsZWN0ZWRDaGFuZ2VkKCk7XG5cdFx0XHQvLyBzZXR1cCBnZW5lcmF0b3IgdG8gZGVmYXVsdCB0byAnZnVsbC1saXN0JyB2YWx1ZXNcblx0XHRcdHRoaXMuJC5nZW5lcmF0b3Iuc2V0Um93T2Zmc2V0KDApO1xuXHRcdFx0dGhpcy4kLmdlbmVyYXRvci5zZXRDb3VudCh0aGlzLmNvdW50KTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdENvbXBvbmVudHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY3JlYXRlUmVvcmRlclRvb2xzKCk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuY3JlYXRlU3dpcGVhYmxlQ29tcG9uZW50cygpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZVJlb3JkZXJUb29sczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50KHtcblx0XHRcdG5hbWU6ICdyZW9yZGVyQ29udGFpbmVyJyxcblx0XHRcdGNsYXNzZXM6ICdlbnlvLWxpc3QtcmVvcmRlci1jb250YWluZXInLFxuXHRcdFx0b25kb3duOiAnc2VuZFRvU3RyYXRlZ3knLFxuXHRcdFx0b25kcmFnOiAnc2VuZFRvU3RyYXRlZ3knLFxuXHRcdFx0b25kcmFnc3RhcnQ6ICdzZW5kVG9TdHJhdGVneScsXG5cdFx0XHRvbmRyYWdmaW5pc2g6ICdzZW5kVG9TdHJhdGVneScsXG5cdFx0XHRvbmZsaWNrOiAnc2VuZFRvU3RyYXRlZ3knXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQWRqdXN0cyB0aGUgcGFyZW50IGNvbnRyb2wgc28gW2xpc3RUb29sc117QGxpbmsgZW55by5MaXN0I2xpc3RUb29sc30gYXJlXG5cdCogY3JlYXRlZCBpbnNpZGUgdGhlIHN0cmF0ZWd5LiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3Igc3RyYXRlZ2llcyBsaWtlXG5cdCoge0BsaW5rIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneX0sIHdoaWNoIHdyYXAgdGhlaXIgY29udGVudHMgd2l0aFxuXHQqIGFkZGl0aW9uYWwgRE9NIG5vZGVzLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5TY3JvbGxlci5jcmVhdGVTdHJhdGVneX1cblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlU3RyYXRlZ3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY29udHJvbFBhcmVudE5hbWUgPSAnc3RyYXRlZ3knO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmNyZWF0ZUNocm9tZSh0aGlzLmxpc3RUb29scyk7XG5cdFx0XHR0aGlzLmNvbnRyb2xQYXJlbnROYW1lID0gJ2NsaWVudCc7XG5cdFx0XHR0aGlzLmRpc2NvdmVyQ29udHJvbFBhcmVudCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZVN3aXBlYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpPTA7aTx0aGlzLnN3aXBlYWJsZUNvbXBvbmVudHMubGVuZ3RoO2krKykge1xuXHRcdFx0dGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuY3JlYXRlQ29tcG9uZW50KHRoaXMuc3dpcGVhYmxlQ29tcG9uZW50c1tpXSwge293bmVyOiB0aGlzLm93bmVyfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLiQuZ2VuZXJhdG9yLm5vZGUgPSB0aGlzLiQucG9ydC5oYXNOb2RlKCk7XG5cdFx0XHR0aGlzLiQuZ2VuZXJhdG9yLmdlbmVyYXRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZVJlc2l6ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRib3R0b21VcENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuZ2VuZXJhdG9yLmJvdHRvbVVwID0gdGhpcy5ib3R0b21VcDtcblx0XHR0aGlzLiQucGFnZTAuYXBwbHlTdHlsZSh0aGlzLnBhZ2VCb3VuZCwgbnVsbCk7XG5cdFx0dGhpcy4kLnBhZ2UxLmFwcGx5U3R5bGUodGhpcy5wYWdlQm91bmQsIG51bGwpO1xuXG5cdFx0aWYgKHRoaXMub3JpZW50Vikge1xuXHRcdFx0dGhpcy5wYWdlQm91bmQgPSB0aGlzLmJvdHRvbVVwID8gJ2JvdHRvbScgOiAndG9wJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMucnRsKSB7XG5cdFx0XHRcdHRoaXMucGFnZUJvdW5kID0gdGhpcy5ib3R0b21VcCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhZ2VCb3VuZCA9IHRoaXMuYm90dG9tVXAgPyAncmlnaHQnIDogJ2xlZnQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcmllbnRWICYmIHRoaXMuYm90dG9tVXApe1xuXHRcdFx0dGhpcy4kLnBhZ2UwLmFwcGx5U3R5bGUoJ2xlZnQnLCAnYXV0bycpO1xuXHRcdFx0dGhpcy4kLnBhZ2UxLmFwcGx5U3R5bGUoJ2xlZnQnLCAnYXV0bycpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRub1NlbGVjdENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuZ2VuZXJhdG9yLnNldE5vU2VsZWN0KHRoaXMubm9TZWxlY3QpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG11bHRpU2VsZWN0Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5nZW5lcmF0b3Iuc2V0TXVsdGlTZWxlY3QodGhpcy5tdWx0aVNlbGVjdCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dG9nZ2xlU2VsZWN0ZWRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLmdlbmVyYXRvci5zZXRUb2dnbGVTZWxlY3RlZCh0aGlzLnRvZ2dsZVNlbGVjdGVkKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb3VudENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdHRoaXMudXBkYXRlTWV0cmljcygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBSZS1kaXNwYXRjaGVzIGV2ZW50cyBmcm9tIHRoZSByZW9yZGVyIHRvb2xzIHRvIHRoZSBzY3JvbGwgc3RyYXRlZ3kuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZW5kVG9TdHJhdGVneTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLiQuc3RyYXRlZ3kuZGlzcGF0Y2hFdmVudCgnb24nICsgZXZlbnQudHlwZSwgZXZlbnQsIHNlbmRlcik7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyBwYWdlIG1ldHJpY3MgKHNpemUsIG51bWJlciBvZiBwYWdlcykgYW5kIHJlc2l6ZXMgdGhlIHBvcnQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR1cGRhdGVNZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5kZWZhdWx0UGFnZVNpemUgPSB0aGlzLnJvd3NQZXJQYWdlICogKHRoaXMucm93U2l6ZSB8fCAxMDApO1xuXHRcdHRoaXMucGFnZUNvdW50ID0gTWF0aC5jZWlsKHRoaXMuY291bnQgLyB0aGlzLnJvd3NQZXJQYWdlKTtcblx0XHR0aGlzLnBvcnRTaXplID0gMDtcblx0XHRmb3IgKHZhciBpPTA7IGkgPCB0aGlzLnBhZ2VDb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnBvcnRTaXplICs9IHRoaXMuZ2V0UGFnZVNpemUoaSk7XG5cdFx0fVxuXHRcdHRoaXMuYWRqdXN0UG9ydFNpemUoKTtcblx0fSxcblxuXHQvKipcblx0KiBIYW5kbGVzIGhvbGQgcHVsc2UgZXZlbnRzLiBVc2VkIHRvIGRlbGF5IGJlZm9yZSBydW5uaW5nIGhvbGQgbG9naWMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRob2xkcHVsc2U6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gZG9uJ3QgYWN0aXZhdGUgaWYgd2UncmUgbm90IHN1cHBvcnRpbmcgcmVvcmRlcmluZyBvciBpZiB3ZSd2ZSBhbHJlYWR5XG5cdFx0Ly8gYWN0aXZhdGVkIHRoZSByZW9yZGVyIGxvZ2ljXG5cdFx0aWYgKCF0aGlzLmdldFJlb3JkZXJhYmxlKCkgfHwgdGhpcy5pc1Jlb3JkZXJpbmcoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBmaXJzdCBwdWxzZSBldmVudCB0aGF0IGV4Y2VlZHMgb3VyIG1pbmltdW0gaG9sZCB0aW1lIGFjdGl2YXRlc1xuXHRcdGlmIChldmVudC5ob2xkVGltZSA+PSB0aGlzLnJlb3JkZXJIb2xkVGltZU1TKSB7XG5cdFx0XHQvLyBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGhhbmRsZSB0aGUgaG9sZCBldmVudFxuXHRcdFx0aWYgKHRoaXMuc2hvdWxkU3RhcnRSZW9yZGVyaW5nKHNlbmRlciwgZXZlbnQpKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRSZW9yZGVyaW5nKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBIYW5kbGVzIERyYWdTdGFydCBldmVudHMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnc3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gc3RvcCBkcmFnc3RhcnQgZnJvbSBwcm9wYWdhdGluZyBpZiB3ZSdyZSBpbiByZW9yZGVyIG1vZGVcblx0XHRpZiAodGhpcy5pc1Jlb3JkZXJpbmcoKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmlzU3dpcGVhYmxlKCkpIHtcblx0XHRcdHJldHVybiB0aGlzLnN3aXBlRHJhZ1N0YXJ0KHNlbmRlciwgZXZlbnQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGhhbmRsZSB0aGUgZHJhZyBldmVudC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWc6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuc2hvdWxkRG9SZW9yZGVyRHJhZyhldmVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnJlb3JkZXJEcmFnKGV2ZW50KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5pc1N3aXBlYWJsZSgpKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5zd2lwZURyYWcoc2VuZGVyLCBldmVudCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogSGFuZGxlcyBEcmFnRmluaXNoIGV2ZW50cy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdmaW5pc2g6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuaXNSZW9yZGVyaW5nKCkpIHtcblx0XHRcdHRoaXMuZmluaXNoUmVvcmRlcmluZyhzZW5kZXIsIGV2ZW50KTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTd2lwZWFibGUoKSkge1xuXHRcdFx0dGhpcy5zd2lwZURyYWdGaW5pc2goc2VuZGVyLCBldmVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgdXAgZXZlbnRzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dXA6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuaXNSZW9yZGVyaW5nKCkpIHtcblx0XHRcdHRoaXMuZmluaXNoUmVvcmRlcmluZyhzZW5kZXIsIGV2ZW50KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgcmVjb3JkIGluZGljZXMgZm9yIGBwYWdlTnVtYmVyYCBhbmQgZ2VuZXJhdGVzIHRoZSBtYXJrdXBcblx0KiBmb3IgdGhhdCBwYWdlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2VuZXJhdGVQYWdlOiBmdW5jdGlvbiAocGFnZU51bWJlciwgdGFyZ2V0KSB7XG5cdFx0dGhpcy5wYWdlID0gcGFnZU51bWJlcjtcblx0XHR2YXIgciA9IHRoaXMucm93c1BlclBhZ2UgKiB0aGlzLnBhZ2U7XG5cdFx0dGhpcy4kLmdlbmVyYXRvci5zZXRSb3dPZmZzZXQocik7XG5cdFx0dmFyIHJwcCA9IE1hdGgubWluKHRoaXMuY291bnQgLSByLCB0aGlzLnJvd3NQZXJQYWdlKTtcblx0XHR0aGlzLiQuZ2VuZXJhdG9yLnNldENvdW50KHJwcCk7XG5cdFx0dmFyIGh0bWwgPSB0aGlzLiQuZ2VuZXJhdG9yLmdlbmVyYXRlQ2hpbGRIdG1sKCk7XG5cdFx0dGFyZ2V0LnNldENvbnRlbnQoaHRtbCk7XG5cdFx0Ly8gcHJldmVudCByZW9yZGVyaW5nIHJvdyBmcm9tIGJlaW5nIGRyYXcgdHdpY2Vcblx0XHRpZiAodGhpcy5nZXRSZW9yZGVyYWJsZSgpICYmIHRoaXMuZHJhZ2dpbmdSb3dJbmRleCA+IC0xKSB7XG5cdFx0XHR0aGlzLmhpZGVSZW9yZGVyaW5nUm93KCk7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0YXJnZXQuZ2V0Qm91bmRzKCk7XG5cdFx0dmFyIHBhZ2VTaXplID0gdGhpcy5vcmllbnRWID8gYm91bmRzLmhlaWdodCA6IGJvdW5kcy53aWR0aDtcblx0XHQvLyBpZiByb3dTaXplIGlzIG5vdCBzZXQsIHVzZSB0aGUgaGVpZ2h0IG9yIHdpZHRoIGZyb20gdGhlIGZpcnN0IGdlbmVyYXRlZCBwYWdlXG5cdFx0aWYgKCF0aGlzLnJvd1NpemUgJiYgcGFnZVNpemUgPiAwKSB7XG5cdFx0XHR0aGlzLnJvd1NpemUgPSBNYXRoLmZsb29yKHBhZ2VTaXplIC8gcnBwKTtcblx0XHRcdHRoaXMudXBkYXRlTWV0cmljcygpO1xuXHRcdH1cblx0XHQvLyB1cGRhdGUga25vd24gcGFnZSBzaXplc1xuXHRcdGlmICghdGhpcy5maXhlZFNpemUpIHtcblx0XHRcdHZhciBzMCA9IHRoaXMuZ2V0UGFnZVNpemUocGFnZU51bWJlcik7XG5cdFx0XHRpZiAoczAgIT0gcGFnZVNpemUgJiYgcGFnZVNpemUgPiAwKSB7XG5cdFx0XHRcdHRoaXMucGFnZVNpemVzW3BhZ2VOdW1iZXJdID0gcGFnZVNpemU7XG5cdFx0XHRcdHRoaXMucG9ydFNpemUgKz0gcGFnZVNpemUgLSBzMDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogTWFwcyBhIHJvdyBpbmRleCBudW1iZXIgdG8gdGhlIHBhZ2UgbnVtYmVyIHdoZXJlIGl0IHdvdWxkIGJlIGZvdW5kLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cGFnZUZvclJvdzogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnJvd3NQZXJQYWdlKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgbGlzdCBwYWdlcyB0byBzaG93IHRoZSBjb3JyZWN0IHJvd3MgZm9yIHRoZSByZXF1ZXN0ZWQgYHRvcGAgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdG9wIC0gUG9zaXRpb24gaW4gcGl4ZWxzIGZyb20gdGhlIHRvcC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKHRvcCkge1xuXHRcdHZhciB1cGRhdGVkID0gZmFsc2U7XG5cdFx0Ly8gZ2V0IHBhZ2UgaW5mbyBmb3IgcG9zaXRpb25cblx0XHR2YXIgcGkgPSB0aGlzLnBvc2l0aW9uVG9QYWdlSW5mbyh0b3ApO1xuXHRcdC8vIHpvbmUgbGluZSBwb3NpdGlvblxuXHRcdHZhciBwb3MgPSBwaS5wb3MgKyB0aGlzLnNjcm9sbGVyU2l6ZS8yO1xuXHRcdC8vIGxlYXAtZnJvZyB6b25lIHBvc2l0aW9uXG5cdFx0dmFyIGsgPSBNYXRoLmZsb29yKHBvcy9NYXRoLm1heChwaS5zaXplLCB0aGlzLnNjcm9sbGVyU2l6ZSkgKyAxLzIpICsgcGkubm87XG5cdFx0Ly8gd2hpY2ggcGFnZSBudW1iZXIgZm9yIHBhZ2UwIChldmVuIG51bWJlciBwYWdlcyk/XG5cdFx0dmFyIHAgPSAoayAlIDIgPT09IDApID8gayA6IGstMTtcblx0XHRpZiAodGhpcy5wMCAhPSBwICYmIHRoaXMuaXNQYWdlSW5SYW5nZShwKSkge1xuXHRcdFx0dGhpcy5yZW1vdmVkSW5pdGlhbFBhZ2UgPSB0aGlzLnJlbW92ZWRJbml0aWFsUGFnZSB8fCAodGhpcy5kcmFnZ2luZ1Jvd1BhZ2UgPT0gdGhpcy5wMCk7XG5cdFx0XHR0aGlzLmdlbmVyYXRlUGFnZShwLCB0aGlzLiQucGFnZTApO1xuXHRcdFx0dGhpcy5wb3NpdGlvblBhZ2UocCwgdGhpcy4kLnBhZ2UwKTtcblx0XHRcdHRoaXMucDAgPSBwO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnAwUm93Qm91bmRzID0gdGhpcy5nZXRQYWdlUm93U2l6ZXModGhpcy4kLnBhZ2UwKTtcblx0XHR9XG5cdFx0Ly8gd2hpY2ggcGFnZSBudW1iZXIgZm9yIHBhZ2UxIChvZGQgbnVtYmVyIHBhZ2VzKT9cblx0XHRwID0gKGsgJSAyID09PSAwKSA/IE1hdGgubWF4KDEsIGstMSkgOiBrO1xuXHRcdC8vIHBvc2l0aW9uIGRhdGEgcGFnZSAxXG5cdFx0aWYgKHRoaXMucDEgIT0gcCAmJiB0aGlzLmlzUGFnZUluUmFuZ2UocCkpIHtcblx0XHRcdHRoaXMucmVtb3ZlZEluaXRpYWxQYWdlID0gdGhpcy5yZW1vdmVkSW5pdGlhbFBhZ2UgfHwgKHRoaXMuZHJhZ2dpbmdSb3dQYWdlID09IHRoaXMucDEpO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZVBhZ2UocCwgdGhpcy4kLnBhZ2UxKTtcblx0XHRcdHRoaXMucG9zaXRpb25QYWdlKHAsIHRoaXMuJC5wYWdlMSk7XG5cdFx0XHR0aGlzLnAxID0gcDtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5wMVJvd0JvdW5kcyA9IHRoaXMuZ2V0UGFnZVJvd1NpemVzKHRoaXMuJC5wYWdlMSk7XG5cdFx0fVxuXHRcdGlmICh1cGRhdGVkKSB7XG5cdFx0XHQvLyByZXNldCBnZW5lcmF0b3IgYmFjayB0byAnZnVsbC1saXN0JyB2YWx1ZXNcblx0XHRcdHRoaXMuJC5nZW5lcmF0b3Iuc2V0Um93T2Zmc2V0KDApO1xuXHRcdFx0dGhpcy4kLmdlbmVyYXRvci5zZXRDb3VudCh0aGlzLmNvdW50KTtcblx0XHRcdGlmICghdGhpcy5maXhlZFNpemUpIHtcblx0XHRcdFx0dGhpcy5hZGp1c3RCb3R0b21QYWdlKCk7XG5cdFx0XHRcdHRoaXMuYWRqdXN0UG9ydFNpemUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiBlYWNoIHJvdyBmb3IgYSBwYWdlLlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLkNvbnRyb2x9IHBhZ2UgLSBQYWdlIGNvbnRyb2wuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0UGFnZVJvd1NpemVzOiBmdW5jdGlvbiAocGFnZSkge1xuXHRcdHZhciByb3dzID0ge307XG5cdFx0dmFyIGFsbERpdnMgPSBwYWdlLmhhc05vZGUoKS5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbZGF0YS1lbnlvLWluZGV4XScpO1xuXHRcdGZvciAodmFyIGk9MCwgaW5kZXgsIGJvdW5kczsgaSA8IGFsbERpdnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGluZGV4ID0gYWxsRGl2c1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW55by1pbmRleCcpO1xuXHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdGJvdW5kcyA9IGRvbS5nZXRCb3VuZHMoYWxsRGl2c1tpXSk7XG5cdFx0XHRcdHJvd3NbcGFyc2VJbnQoaW5kZXgsIDEwKV0gPSB7aGVpZ2h0OiBib3VuZHMuaGVpZ2h0LCB3aWR0aDogYm91bmRzLndpZHRofTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJvd3M7XG5cdH0sXG5cblx0LyoqXG5cdCogVXBkYXRlcyByb3cgYm91bmRzIHdoZW4gcm93cyBhcmUgcmUtcmVuZGVyZWQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR1cGRhdGVSb3dCb3VuZHM6IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdGlmICh0aGlzLnAwUm93Qm91bmRzW2luZGV4XSkge1xuXHRcdFx0dGhpcy51cGRhdGVSb3dCb3VuZHNBdEluZGV4KGluZGV4LCB0aGlzLnAwUm93Qm91bmRzLCB0aGlzLiQucGFnZTApO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wMVJvd0JvdW5kc1tpbmRleF0pIHtcblx0XHRcdHRoaXMudXBkYXRlUm93Qm91bmRzQXRJbmRleChpbmRleCwgdGhpcy5wMVJvd0JvdW5kcywgdGhpcy4kLnBhZ2UxKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dXBkYXRlUm93Qm91bmRzQXRJbmRleDogZnVuY3Rpb24gKGluZGV4LCByb3dzLCBwYWdlKSB7XG5cdFx0dmFyIHJvd0RpdiA9IHBhZ2UuaGFzTm9kZSgpLnF1ZXJ5U2VsZWN0b3IoJ2RpdltkYXRhLWVueW8taW5kZXg9XCInICsgaW5kZXggKyAnXCJdJyk7XG5cdFx0dmFyIGJvdW5kcyA9IGRvbS5nZXRCb3VuZHMocm93RGl2KTtcblx0XHRyb3dzW2luZGV4XS5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuXHRcdHJvd3NbaW5kZXhdLndpZHRoID0gYm91bmRzLndpZHRoO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgdGhlIGxpc3QgZm9yIHRoZSBnaXZlbiBgcG9zaXRpb25gLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gUG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZUZvclBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHR0aGlzLnVwZGF0ZSh0aGlzLmNhbGNQb3MocG9zaXRpb24pKTtcblx0fSxcblxuXHQvKipcblx0KiBBZGp1c3RzIHRoZSBwb3NpdGlvbiBpZiB0aGUgbGlzdCBpcyBbYm90dG9tVXBde0BsaW5rIGVueW8uTGlzdCNib3R0b21VcH0uXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBQb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY1BvczogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuICh0aGlzLmJvdHRvbVVwID8gKHRoaXMucG9ydFNpemUgLSB0aGlzLnNjcm9sbGVyU2l6ZSAtIHBvc2l0aW9uKSA6IHBvc2l0aW9uKTtcblx0fSxcblxuXHQvKipcblx0KiBEZXRlcm1pbmVzIHdoaWNoIHBhZ2UgaXMgb24gdGhlIGJvdHRvbSBhbmQgcG9zaXRpb25zIGl0IGFwcHJvcHJpYXRlbHkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhZGp1c3RCb3R0b21QYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJwID0gdGhpcy5wMCA+PSB0aGlzLnAxID8gdGhpcy4kLnBhZ2UwIDogdGhpcy4kLnBhZ2UxO1xuXHRcdHRoaXMucG9zaXRpb25QYWdlKGJwLnBhZ2VObywgYnApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIHBvcnQgdG8gYmUgdGhlIGdyZWF0ZXIgb2YgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGVyIG9yXG5cdCogdGhlIGBwb3J0U2l6ZWAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhZGp1c3RQb3J0U2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2Nyb2xsZXJTaXplID0gdGhpcy5vcmllbnRWID8gdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQgOiB0aGlzLmdldEJvdW5kcygpLndpZHRoO1xuXHRcdHZhciBzID0gTWF0aC5tYXgodGhpcy5zY3JvbGxlclNpemUsIHRoaXMucG9ydFNpemUpO1xuXHRcdHRoaXMuJC5wb3J0LmFwcGx5U3R5bGUoKHRoaXMub3JpZW50ViA/ICdoZWlnaHQnIDogJ3dpZHRoJyksIHMgKyAncHgnKTtcblx0XHRpZiAoIXRoaXMub3JpZW50Vikge1xuXHRcdFx0dGhpcy4kLnBvcnQuYXBwbHlTdHlsZSgnaGVpZ2h0JywgdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQgKyAncHgnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cG9zaXRpb25QYWdlOiBmdW5jdGlvbiAocGFnZU51bWJlciwgdGFyZ2V0KSB7XG5cdFx0dGFyZ2V0LnBhZ2VObyA9IHBhZ2VOdW1iZXI7XG5cdFx0dmFyIHAgPSB0aGlzLnBhZ2VUb1Bvc2l0aW9uKHBhZ2VOdW1iZXIpO1xuXHRcdHRhcmdldC5hcHBseVN0eWxlKHRoaXMucGFnZUJvdW5kLCBwICsgJ3B4Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gb2YgYHBhZ2VgLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgLSBQYWdlIG51bWJlci5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwYWdlVG9Qb3NpdGlvbjogZnVuY3Rpb24gKHBhZ2UpIHtcblx0XHR2YXIgcCA9IDA7XG5cdFx0d2hpbGUgKHBhZ2UgPiAwKSB7XG5cdFx0XHRwYWdlLS07XG5cdFx0XHRwICs9IHRoaXMuZ2V0UGFnZVNpemUocGFnZSk7XG5cdFx0fVxuXHRcdHJldHVybiBwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIG1ldHJpY3MgZm9yIGEgcGFnZSBjb3ZlcmluZyBgcG9zaXRpb25gLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc2l0aW9uIC0gUG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHtlbnlvLkxpc3R+UGFnZUluZm99XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwb3NpdGlvblRvUGFnZUluZm86IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuXHRcdHZhciBwYWdlID0gLTE7XG5cdFx0dmFyIHAgPSB0aGlzLmNhbGNQb3MocG9zaXRpb24pO1xuXHRcdHZhciBzID0gdGhpcy5kZWZhdWx0UGFnZVNpemU7XG5cdFx0d2hpbGUgKHAgPj0gMCkge1xuXHRcdFx0cGFnZSsrO1xuXHRcdFx0cyA9IHRoaXMuZ2V0UGFnZVNpemUocGFnZSk7XG5cdFx0XHRwIC09IHM7XG5cdFx0fVxuXHRcdHBhZ2UgPSBNYXRoLm1heChwYWdlLCAwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bm86IHBhZ2UsXG5cdFx0XHRzaXplOiBzLFxuXHRcdFx0cG9zOiBwICsgcyxcblx0XHRcdHN0YXJ0Um93OiAocGFnZSAqIHRoaXMucm93c1BlclBhZ2UpLFxuXHRcdFx0ZW5kUm93OiBNYXRoLm1pbigocGFnZSArIDEpICogdGhpcy5yb3dzUGVyUGFnZSAtIDEsIHRoaXMuY291bnQgLSAxKVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyBpZiBgcGFnZWAgaXMgYSB2YWxpZCBwYWdlIG51bWJlci5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBwYWdlIC0gUGFnZSBudW1iZXIuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNQYWdlSW5SYW5nZTogZnVuY3Rpb24gKHBhZ2UpIHtcblx0XHRyZXR1cm4gcGFnZSA9PSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnBhZ2VDb3VudC0xLCBwYWdlKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgc2l6ZSBvZiBhIHBhZ2UuIFRoZSBzaXplIGlzIGVzdGltYXRlZCBpZiB0aGUgcGFnZSBoYXMgbm90XG5cdCogeWV0IGJlZW4gcmVuZGVyZWQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRQYWdlU2l6ZTogZnVuY3Rpb24gKHBhZ2VOdW1iZXIpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMucGFnZVNpemVzW3BhZ2VOdW1iZXJdO1xuXHRcdC8vIGVzdGltYXRlIHRoZSBzaXplIGJhc2VkIG9uIGhvdyBtYW55IHJvd3MgYXJlIGluIHRoaXMgcGFnZVxuXHRcdGlmICghc2l6ZSkge1xuXHRcdFx0dmFyIGZpcnN0Um93ID0gdGhpcy5yb3dzUGVyUGFnZSAqIHBhZ2VOdW1iZXI7XG5cdFx0XHR2YXIgbnVtUm93cyA9IE1hdGgubWluKHRoaXMuY291bnQgLSBmaXJzdFJvdywgdGhpcy5yb3dzUGVyUGFnZSk7XG5cdFx0XHRzaXplID0gdGhpcy5kZWZhdWx0UGFnZVNpemUgKiAobnVtUm93cyAvIHRoaXMucm93c1BlclBhZ2UpO1xuXHRcdH1cblx0XHQvLyBjYW4gbmV2ZXIgcmV0dXJuIHNpemUgb2YgMCwgYXMgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3BzXG5cdFx0cmV0dXJuIE1hdGgubWF4KDEsIHNpemUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyBwYWdlcyBhbmQgcmVtb3ZlcyBhbGwgcmVuZGVyZWQgcm93cy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGludmFsaWRhdGVQYWdlczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucDAgPSB0aGlzLnAxID0gbnVsbDtcblx0XHR0aGlzLnAwUm93Qm91bmRzID0ge307XG5cdFx0dGhpcy5wMVJvd0JvdW5kcyA9IHt9O1xuXHRcdC8vIGNsZWFyIHRoZSBodG1sIGluIG91ciByZW5kZXIgdGFyZ2V0c1xuXHRcdHRoaXMuJC5wYWdlMC5zZXRDb250ZW50KCcnKTtcblx0XHR0aGlzLiQucGFnZTEuc2V0Q29udGVudCgnJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzZXRzIHBhZ2UgYW5kIHJvdyBzaXplcy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGludmFsaWRhdGVNZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5wYWdlU2l6ZXMgPSBbXTtcblx0XHR0aGlzLnJvd1NpemUgPSAwO1xuXHRcdHRoaXMudXBkYXRlTWV0cmljcygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFdoZW4gdGhlIGxpc3QgaXMgc2Nyb2xsZWQsIGVuc3VyZXMgdGhhdCB0aGUgY29ycmVjdCByb3dzIGFyZSByZW5kZXJlZCBhbmRcblx0KiB0aGF0IHRoZSByZW9yZGVyaW5nIGNvbnRyb2xzIGFyZSBwb3NpdGlvbmVkIGNvcnJlY3RseS5cblx0KlxuXHQqIEBzZWUge0BsaW5rIGVueW8uU2Nyb2xsZXIuc2Nyb2xsfVxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGw6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0XHR2YXIgciA9IHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHBvcyA9IHRoaXMub3JpZW50ViA/IHRoaXMuZ2V0U2Nyb2xsVG9wKCkgOiB0aGlzLmdldFNjcm9sbExlZnQoKTtcblx0XHRcdGlmICh0aGlzLmxhc3RQb3MgPT09IHBvcykge1xuXHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdH1cblx0XHRcdHRoaXMubGFzdFBvcyA9IHBvcztcblx0XHRcdHRoaXMudXBkYXRlKHBvcyk7XG5cdFx0XHRpZiAodGhpcy5waW5uZWRSZW9yZGVyTW9kZSkge1xuXHRcdFx0XHR0aGlzLnJlb3JkZXJTY3JvbGwoc2VuZGVyLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBVcGRhdGVzIHRoZSBsaXN0IHJvd3Mgd2hlbiB0aGUgc2Nyb2xsIHRvcCBpcyBzZXQgZXhwbGljaXRseS5cblx0KlxuXHQqIEBzZWUge0BsaW5rIGVueW8uU2Nyb2xsZXIuc2V0U2Nyb2xsVG9wfVxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNjcm9sbFRvcDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuXHRcdFx0dGhpcy51cGRhdGUoc2Nyb2xsVG9wKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy50d2lkZGxlKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0U2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWxjUG9zKHRoaXNbKHRoaXMub3JpZW50ViA/ICdnZXRTY3JvbGxUb3AnIDogJ2dldFNjcm9sbExlZnQnKV0oKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0U2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuXHRcdHRoaXNbKHRoaXMub3JpZW50ViA/ICdzZXRTY3JvbGxUb3AnIDogJ3NldFNjcm9sbExlZnQnKV0odGhpcy5jYWxjUG9zKHBvc2l0aW9uKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2Nyb2xscyB0aGUgbGlzdCBzbyB0aGF0IHRoZSBsYXN0IGl0ZW0gaXMgdmlzaWJsZS5cblx0KlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvQm90dG9tOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSh0aGlzLmdldFNjcm9sbEJvdW5kcygpLm1heFRvcCk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgcm93LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHJvdyAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIHNjcm9sbCB0by5cblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvUm93OiBmdW5jdGlvbiAocm93KSB7XG5cdFx0dmFyIHBhZ2UgPSB0aGlzLnBhZ2VGb3JSb3cocm93KTtcblx0XHR2YXIgaCA9IHRoaXMucGFnZVRvUG9zaXRpb24ocGFnZSk7XG5cdFx0Ly8gdXBkYXRlIHRoZSBwYWdlXG5cdFx0dGhpcy51cGRhdGVGb3JQb3NpdGlvbihoKTtcblx0XHQvLyBjYWxsIHBhZ2VUb1Bvc2l0aW9uIGFnYWluIGFuZCB0aGlzIHRpbWUgc2hvdWxkIHJldHVybiB0aGUgcmlnaHQgcG9zIHNpbmNlIHRoZSBwYWdlIGluZm8gaXMgcG9wdWxhdGVkXG5cdFx0aCA9IHRoaXMucGFnZVRvUG9zaXRpb24ocGFnZSk7XG5cdFx0dGhpcy5zZXRTY3JvbGxQb3NpdGlvbihoKTtcblx0XHRpZiAocGFnZSA9PSB0aGlzLnAwIHx8IHBhZ2UgPT0gdGhpcy5wMSkge1xuXHRcdFx0dmFyIHJvd05vZGUgPSB0aGlzLiQuZ2VuZXJhdG9yLmZldGNoUm93Tm9kZShyb3cpO1xuXHRcdFx0aWYgKHJvd05vZGUpIHtcblx0XHRcdFx0Ly8gY2FsYyByb3cgb2Zmc2V0XG5cdFx0XHRcdHZhciBvZmZzZXQgPSAodGhpcy5vcmllbnRWID8gcm93Tm9kZS5vZmZzZXRUb3AgOiByb3dOb2RlLm9mZnNldExlZnQpO1xuXHRcdFx0XHRpZiAodGhpcy5ib3R0b21VcCkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRoaXMuZ2V0UGFnZVNpemUocGFnZSkgLSAodGhpcy5vcmllbnRWID8gcm93Tm9kZS5vZmZzZXRIZWlnaHQgOiByb3dOb2RlLm9mZnNldFdpZHRoKSAtIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcCA9IHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKSArIG9mZnNldDtcblx0XHRcdFx0dGhpcy5zZXRTY3JvbGxQb3NpdGlvbihwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU2Nyb2xscyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzY3JvbGxUb1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpc1t0aGlzLmJvdHRvbVVwID8gKHRoaXMub3JpZW50ViA/ICdzY3JvbGxUb0JvdHRvbScgOiAnc2Nyb2xsVG9SaWdodCcpIDogJ3Njcm9sbFRvVG9wJ10oKTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpc1t0aGlzLmJvdHRvbVVwID8gKHRoaXMub3JpZW50ViA/ICdzY3JvbGxUb1RvcCcgOiAnc2Nyb2xsVG9MZWZ0JykgOiAodGhpcy5vcmllbnRWID8gJ3Njcm9sbFRvQm90dG9tJyA6ICdzY3JvbGxUb1JpZ2h0JyldKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmUtcmVuZGVycyB0aGUgbGlzdCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW52YWxpZGF0ZVBhZ2VzKCk7XG5cdFx0dGhpcy51cGRhdGUodGhpc1sodGhpcy5vcmllbnRWID8gJ2dldFNjcm9sbFRvcCcgOiAnZ2V0U2Nyb2xsTGVmdCcpXSgpKTtcblx0XHR0aGlzLnN0YWJpbGl6ZSgpO1xuXG5cdFx0Ly9GSVhNRTogTmVjZXNzYXJ5IGV2aWwgZm9yIEFuZHJvaWQgNC4wLjQgcmVmcmVzaCBidWdcblx0XHRpZiAocGxhdGZvcm0uYW5kcm9pZCA9PT0gNCkge1xuXHRcdFx0dGhpcy50d2lkZGxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFJlLXJlbmRlcnMgdGhlIGxpc3QgZnJvbSB0aGUgYmVnaW5uaW5nLiAgVGhpcyBpcyB1c2VkIHdoZW4gY2hhbmdpbmcgdGhlXG5cdCogZGF0YSBtb2RlbCBmb3IgdGhlIGxpc3QuICBUaGlzIGFsc28gY2xlYXJzIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5nZXRTZWxlY3Rpb24oKS5jbGVhcigpO1xuXHRcdHRoaXMuaW52YWxpZGF0ZU1ldHJpY3MoKTtcblx0XHR0aGlzLmludmFsaWRhdGVQYWdlcygpO1xuXHRcdHRoaXMuc3RhYmlsaXplKCk7XG5cdFx0dGhpcy5zY3JvbGxUb1N0YXJ0KCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUge0BsaW5rIGVueW8uU2VsZWN0aW9ufSBjb21wb25lbnQgdGhhdFxuXHQqIG1hbmFnZXMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBmb3IgdGhpcyBsaXN0LlxuXHQqXG5cdCogQHJldHVybiB7ZW55by5TZWxlY3Rpb259IC0gVGhlIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgc2VsZWN0aW9uIHN0YXRlIGZvciB0aGlzIGxpc3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy4kLmdlbmVyYXRvci5nZXRTZWxlY3Rpb24oKTtcblx0fSxcblxuXHQvKipcblx0KiBTZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIHRoZSBnaXZlbiByb3cgaW5kZXguXG5cdCpcblx0KiBNb2RpZnlpbmcgc2VsZWN0aW9uIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcmUtcmVuZGVyIHRoZSByb3csIHNvIGNhbGxcblx0KiBbcmVuZGVyUm93KClde0BsaW5rIGVueW8uTGlzdCNyZW5kZXJSb3d9IG9yIFtyZWZyZXNoKClde0BsaW5rIGVueW8uTGlzdCNyZWZyZXNofVxuXHQqIHRvIHVwZGF0ZSB0aGUgdmlldy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHdob3NlIHNlbGVjdGlvbiBzdGF0ZSBpcyB0byBiZSBzZXQuXG5cdCogQHBhcmFtIHsqfSBbZGF0YV0gICAgIC0gRGF0YSB2YWx1ZSBzdG9yZWQgaW4gdGhlIHNlbGVjdGlvbiBvYmplY3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZWxlY3Q6IGZ1bmN0aW9uIChpbmRleCwgZGF0YSkge1xuXHRcdHJldHVybiB0aGlzLmdldFNlbGVjdGlvbigpLnNlbGVjdChpbmRleCwgZGF0YSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2xlYXJzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIHRoZSBnaXZlbiByb3cgaW5kZXguXG5cdCpcblx0KiBNb2RpZnlpbmcgc2VsZWN0aW9uIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcmUtcmVuZGVyIHRoZSByb3csIHNvIGNhbGxcblx0KiBbcmVuZGVyUm93KClde0BsaW5rIGVueW8uTGlzdCNyZW5kZXJSb3d9IG9yIFtyZWZyZXNoKClde0BsaW5rIGVueW8uTGlzdCNyZWZyZXNofVxuXHQqIHRvIHVwZGF0ZSB0aGUgdmlldy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHdob3NlIHNlbGVjdGlvbiBzdGF0ZSBpcyB0byBiZSBjbGVhcmVkLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzZWxlY3Q6IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNlbGVjdGlvbigpLmRlc2VsZWN0KGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBHZXRzIHRoZSBzZWxlY3Rpb24gc3RhdGUgZm9yIHRoZSBnaXZlbiByb3cgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB3aG9zZSBzZWxlY3Rpb24gc3RhdGUgaXNcblx0KiB0byBiZSByZXRyaWV2ZWQuXG5cdCogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiByb3cgaXMgY3VycmVudGx5IHNlbGVjdGVkOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy4kLmdlbmVyYXRvci5pc1NlbGVjdGVkKGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBSZS1yZW5kZXJzIHRoZSBzcGVjaWZpZWQgcm93LiBDYWxsIHRoaXMgbWV0aG9kIGFmdGVyIG1ha2luZ1xuXHQqIG1vZGlmaWNhdGlvbnMgdG8gYSByb3csIHRvIGZvcmNlIGl0IHRvIHJlbmRlci5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIGJlIHJlLXJlbmRlcmVkLlxuXHQqIEBwdWJsaWNcbiAgICAqL1xuICAgIHJlbmRlclJvdzogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dGhpcy4kLmdlbmVyYXRvci5yZW5kZXJSb3coaW5kZXgpO1xuICAgIH0sXG5cblx0LyoqXG4gXHQqIEhhbmRsZXIgZm9yIGBvblJlbmRlclJvd2AgZXZlbnRzLiBVcGRhdGVzIHJvdyBib3VuZHMgd2hlbiByb3dzIGFyZSByZS1yZW5kZXJlZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJvd1JlbmRlcmVkOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMudXBkYXRlUm93Qm91bmRzKGV2ZW50LnJvd0luZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBQcmVwYXJlcyBhIHJvdyB0byBiZWNvbWUgaW50ZXJhY3RpdmUuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0byBiZSBwcmVwYXJlZC5cblx0KiBAcHVibGljXG5cdCovXG5cdHByZXBhcmVSb3c6IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdHRoaXMuJC5nZW5lcmF0b3IucHJlcGFyZVJvdyhpbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzdG9yZXMgdGhlIHJvdyB0byBiZWluZyBub24taW50ZXJhY3RpdmUuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGxvY2tSb3c6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuZ2VuZXJhdG9yLmxvY2tSb3coKTtcblx0fSxcblxuXHQvKipcblx0KiBQZXJmb3JtcyBhIHNldCBvZiB0YXNrcyBieSBydW5uaW5nIHRoZSBmdW5jdGlvbiBgZnVuY2Agb24gYSByb3cgKHdoaWNoXG5cdCogbXVzdCBiZSBpbnRlcmFjdGl2ZSBhdCB0aGUgdGltZSB0aGUgdGFza3MgYXJlIHBlcmZvcm1lZCkuIExvY2tzIHRoZVx0cm93XG5cdCogd2hlbiBkb25lLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0byBiZSBhY3RlZCB1cG9uLlxuXHQqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgIC0gVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0uXG5cdCogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB3aGljaCB0aGUgZnVuY3Rpb24gaXMgYm91bmQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRwZXJmb3JtT25Sb3c6IGZ1bmN0aW9uIChpbmRleCwgZnVuYywgY29udGV4dCkge1xuXHRcdHRoaXMuJC5nZW5lcmF0b3IucGVyZm9ybU9uUm93KGluZGV4LCBmdW5jLCBjb250ZXh0KTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhbmltYXRlRmluaXNoOiBmdW5jdGlvbiAoc2VuZGVyKSB7XG5cdFx0dGhpcy50d2lkZGxlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdC8qKlxuXHQqIEZJWE1FOiBBbmRyb2lkIDQuMDQgaGFzIGlzc3VlcyB3aXRoIG5lc3RlZCBjb21wb3NpdGVkIGVsZW1lbnRzOyBmb3IgZXhhbXBsZSwgYVxuXHQqIFN3aXBlYWJsZUl0ZW0sIGNhbiBpbmNvcnJlY3RseSBnZW5lcmF0ZSB0YXBzIG9uIGl0cyBjb250ZW50IHdoZW4gaXQgaGFzIHNsaWQgb2ZmIHRoZVxuXHQqIHNjcmVlbjsgd2UgYWRkcmVzcyB0aGlzIEJVRyBoZXJlIGJ5IGZvcmNpbmcgdGhlIFNjcm9sbGVyIHRvICd0d2lkZGxlJyB3aGljaCBjb3JyZWN0cyB0aGVcblx0KiBidWcgYnkgcHJvdm9raW5nIGEgZG9tIHVwZGF0ZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHR3aWRkbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMuZ2V0U3RyYXRlZ3koKTtcblx0XHR1dGlscy5jYWxsKHMsICd0d2lkZGxlJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyBwYWdlMCBvciBwYWdlMSBjb250cm9sIGRlcGVuZGluZyBvbiBwYWdlTnVtYmVyIG9kZC9ldmVuIHN0YXR1c1xuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VOdW1iZXIgIC0gSW5kZXggb2YgcGFnZS5cblx0KiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrUmFuZ2UgLSBXaGV0aGVyIHRvIGZvcmNlIGNoZWNraW5nIGBwYWdlTnVtYmVyYCBhZ2FpbnN0XG5cdCogY3VycmVudGx5IGFjdGl2ZSBwYWdlcy5cblx0KiBAcmV0dXJuIHtlbnlvLkNvbnRyb2x9ICAgICAgLSBQYWdlIGNvbnRyb2wgZm9yIGBwYWdlTnVtYmVyYC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwYWdlRm9yUGFnZU51bWJlcjogZnVuY3Rpb24gKHBhZ2VOdW1iZXIsIGNoZWNrUmFuZ2UpIHtcblx0XHRpZiAocGFnZU51bWJlciAlIDIgPT09IDApIHtcblx0XHRcdHJldHVybiAoIWNoZWNrUmFuZ2UgfHwgKHBhZ2VOdW1iZXIgPT09IHRoaXMucDApKSA/IHRoaXMuJC5wYWdlMCA6IG51bGw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICghY2hlY2tSYW5nZSB8fCAocGFnZU51bWJlciA9PT0gdGhpcy5wMSkpID8gdGhpcy4kLnBhZ2UxIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cdC8qKlxuXHRcdC0tLS0gUmVvcmRlciBmdW5jdGlvbmFsaXR5IC0tLS0tLS0tLS0tLVxuXHQqL1xuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB0aGUgaG9sZCBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBhcyBhIHJlb3JkZXIgaG9sZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNob3VsZFN0YXJ0UmVvcmRlcmluZzogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuZ2V0UmVvcmRlcmFibGUoKSB8fFxuXHRcdFx0ZXZlbnQucm93SW5kZXggPT0gbnVsbCB8fFxuXHRcdFx0ZXZlbnQucm93SW5kZXggPCAwIHx8XG5cdFx0XHR0aGlzLnBpbm5lZFJlb3JkZXJNb2RlIHx8XG5cdFx0XHRldmVudC5pbmRleCA9PSBudWxsIHx8XG5cdFx0XHRldmVudC5pbmRleCA8IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogUHJvY2Vzc2VzIGhvbGQgZXZlbnQgYW5kIHByZXBhcmVzIGZvciByZW9yZGVyaW5nLlxuXHQqXG5cdCogQGZpcmVzIGVueW8uTGlzdCNvblNldHVwUmVvcmRlckNvbXBvbmVudHNcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGFydFJlb3JkZXJpbmc6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIGRpc2FibGUgZHJhZyB0byBzY3JvbGwgb24gc3RyYXRlZ3lcblx0XHR0aGlzLiQuc3RyYXRlZ3kubGlzdFJlb3JkZXJpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5idWlsZFJlb3JkZXJDb250YWluZXIoKTtcblx0XHR0aGlzLmRvU2V0dXBSZW9yZGVyQ29tcG9uZW50cyh7aW5kZXg6IGV2ZW50LmluZGV4fSk7XG5cdFx0dGhpcy5zdHlsZVJlb3JkZXJDb250YWluZXIoZXZlbnQpO1xuXG5cdFx0dGhpcy5kcmFnZ2luZ1Jvd0luZGV4ID0gdGhpcy5wbGFjZWhvbGRlclJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG5cdFx0dGhpcy5kcmFnZ2luZ1Jvd1BhZ2UgPSB0aGlzLnBhZ2VGb3JSb3codGhpcy5kcmFnZ2luZ1Jvd0luZGV4KTtcblx0XHR0aGlzLnJlbW92ZURyYWdnaW5nUm93Tm9kZSA9IGV2ZW50LmRpc3BhdGNoVGFyZ2V0LnJldGFpbk5vZGUoZXZlbnQudGFyZ2V0KTtcblx0XHR0aGlzLnJlbW92ZWRJbml0aWFsUGFnZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXRlbU1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5pbml0aWFsUGFnZU51bWJlciA9IHRoaXMuY3VycmVudFBhZ2VOdW1iZXIgPSB0aGlzLnBhZ2VGb3JSb3coZXZlbnQucm93SW5kZXgpO1xuXHRcdHRoaXMucHJldlNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG5cblx0XHQvLyBmaWxsIHJvdyBiZWluZyByZW9yZGVyZWQgd2l0aCBwbGFjZWhvbGRlclxuXHRcdHRoaXMucmVwbGFjZU5vZGVXaXRoUGxhY2Vob2xkZXIoZXZlbnQucm93SW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEZpbGxzIHJlb3JkZXIgY29udGFpbmVyIHdpdGggZHJhZ2dhYmxlIHJlb3JkZXIgY29tcG9uZW50cyBkZWZpbmVkIGJ5IHRoZVxuXHQqIGFwcGxpY2F0aW9uLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YnVpbGRSZW9yZGVyQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIuZGVzdHJveUNsaWVudENvbnRyb2xzKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8dGhpcy5yZW9yZGVyQ29tcG9uZW50cy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR0aGlzLiQucmVvcmRlckNvbnRhaW5lci5jcmVhdGVDb21wb25lbnQodGhpcy5yZW9yZGVyQ29tcG9uZW50c1tpXSwge293bmVyOnRoaXMub3duZXJ9KTtcblx0XHR9XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIucmVuZGVyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUHJlcGFyZXMgZmxvYXRpbmcgcmVvcmRlciBjb250YWluZXIuXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdHlsZVJlb3JkZXJDb250YWluZXI6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5zZXRJdGVtUG9zaXRpb24odGhpcy4kLnJlb3JkZXJDb250YWluZXIsIGUucm93SW5kZXgpO1xuXHRcdHRoaXMuc2V0SXRlbUJvdW5kcyh0aGlzLiQucmVvcmRlckNvbnRhaW5lciwgZS5yb3dJbmRleCk7XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIuc2V0U2hvd2luZyh0cnVlKTtcblx0XHRpZiAodGhpcy5jZW50ZXJSZW9yZGVyQ29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLmNlbnRlclJlb3JkZXJDb250YWluZXJPblBvaW50ZXIoZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENvcGllcyB0aGUgaW5uZXJIVE1MIG9mIGBub2RlYCBpbnRvIGEgbmV3IGNvbXBvbmVudCBpbnNpZGUgb2Zcblx0KiBgcmVvcmRlckNvbnRhaW5lcmAuXG5cdCpcblx0KiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgc291cmNlIG5vZGUuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YXBwZW5kTm9kZVRvUmVvcmRlckNvbnRhaW5lcjogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHR0aGlzLiQucmVvcmRlckNvbnRhaW5lci5jcmVhdGVDb21wb25lbnQoe2FsbG93SHRtbDogdHJ1ZSwgY29udGVudDogbm9kZS5pbm5lckhUTUx9KS5yZW5kZXIoKTtcblx0fSxcblxuXHQvKipcblx0KiBDZW50ZXJzIHRoZSBmbG9hdGluZyByZW9yZGVyIGNvbnRhaW5lciBvbiB0aGUgdXNlcidzIHBvaW50ZXIuXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjZW50ZXJSZW9yZGVyQ29udGFpbmVyT25Qb2ludGVyOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjb250YWluZXJQb3NpdGlvbiA9IGRvbS5jYWxjTm9kZVBvc2l0aW9uKHRoaXMuaGFzTm9kZSgpKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy4kLnJlb3JkZXJDb250YWluZXIuZ2V0Qm91bmRzKCk7XG5cdFx0dmFyIHggPSBlLnBhZ2VYIC0gY29udGFpbmVyUG9zaXRpb24ubGVmdCAtIHBhcnNlSW50KGJvdW5kcy53aWR0aCwgMTApLzI7XG5cdFx0dmFyIHkgPSBlLnBhZ2VZIC0gY29udGFpbmVyUG9zaXRpb24udG9wICsgdGhpcy5nZXRTY3JvbGxUb3AoKSAtIHBhcnNlSW50KGJvdW5kcy5oZWlnaHQsIDEwKS8yO1xuXHRcdGlmICh0aGlzLmdldFN0cmF0ZWd5S2luZCgpICE9ICdTY3JvbGxTdHJhdGVneScpIHtcblx0XHRcdHggLT0gdGhpcy5nZXRTY3JvbGxMZWZ0KCk7XG5cdFx0XHR5IC09IHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG5cdFx0fVxuXHRcdHRoaXMucG9zaXRpb25SZW9yZGVyQ29udGFpbmVyKHgsIHkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE1vdmVzIHRoZSByZW9yZGVyIGNvbnRhaW5lciB0byB0aGUgc3BlY2lmaWVkIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLlxuXHQqIEFuaW1hdGVzIGFuZCBraWNrcyBvZmYgdGltZXIgdG8gdHVybiBvZmYgYW5pbWF0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgYGxlZnRgIHBvc2l0aW9uLlxuXHQqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIGB0b3BgIHBvc2l0aW9uLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHBvc2l0aW9uUmVvcmRlckNvbnRhaW5lcjogZnVuY3Rpb24gKHgseSkge1xuXHRcdHRoaXMuJC5yZW9yZGVyQ29udGFpbmVyLmFkZENsYXNzKCdlbnlvLWFuaW1hdGVkVG9wQW5kTGVmdCcpO1xuXHRcdHRoaXMuJC5yZW9yZGVyQ29udGFpbmVyLmFkZFN0eWxlcygnbGVmdDonK3grJ3B4O3RvcDonK3krJ3B4OycpO1xuXHRcdHRoaXMuc2V0UG9zaXRpb25SZW9yZGVyQ29udGFpbmVyVGltZW91dCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgYSB0aW1lb3V0IHRvIHJlbW92ZSBhbmltYXRpb24gY2xhc3MgZnJvbSByZW9yZGVyIGNvbnRhaW5lci5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldFBvc2l0aW9uUmVvcmRlckNvbnRhaW5lclRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNsZWFyUG9zaXRpb25SZW9yZGVyQ29udGFpbmVyVGltZW91dCgpO1xuXHRcdHRoaXMucG9zaXRpb25SZW9yZGVyQ29udGFpbmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5iaW5kU2FmZWx5KFxuXHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLiQucmVvcmRlckNvbnRhaW5lci5yZW1vdmVDbGFzcygnZW55by1hbmltYXRlZFRvcEFuZExlZnQnKTtcblx0XHRcdFx0dGhpcy5jbGVhclBvc2l0aW9uUmVvcmRlckNvbnRhaW5lclRpbWVvdXQoKTtcblx0XHRcdH0pLCAxMDApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsZWFyUG9zaXRpb25SZW9yZGVyQ29udGFpbmVyVGltZW91dDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnBvc2l0aW9uUmVvcmRlckNvbnRhaW5lclRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnBvc2l0aW9uUmVvcmRlckNvbnRhaW5lclRpbWVvdXQpO1xuXHRcdFx0dGhpcy5wb3NpdGlvblJlb3JkZXJDb250YWluZXJUaW1lb3V0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBoYW5kbGUgdGhlIGRyYWcgZXZlbnQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGREb1Jlb3JkZXJEcmFnOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmdldFJlb3JkZXJhYmxlKCkgfHwgdGhpcy5kcmFnZ2luZ1Jvd0luZGV4IDwgMCB8fCB0aGlzLnBpbm5lZFJlb3JkZXJNb2RlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgdGhlIGRyYWcgZXZlbnQgYXMgYSByZW9yZGVyIGRyYWcuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW9yZGVyRHJhZzogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gcG9zaXRpb24gcmVvcmRlciBub2RlIHVuZGVyIG1vdXNlL3BvaW50ZXJcblx0XHR0aGlzLnBvc2l0aW9uUmVvcmRlck5vZGUoZXZlbnQpO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gYXV0by1zY3JvbGwgdGhlIGxpc3Rcblx0XHR0aGlzLmNoZWNrRm9yQXV0b1Njcm9sbChldmVudCk7XG5cblx0XHQvLyBpZiB0aGUgY3VycmVudCBpbmRleCB0aGUgdXNlciBpcyBkcmFnZ2luZyBvdmVyIGhhcyBjaGFuZ2VkLCBtb3ZlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoaXMudXBkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihldmVudC5wYWdlWSk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB0aGUgcm93IGluZGV4IGF0IGBwYWdlWWAgKGlmIGl0IGV4aXN0cykgYW5kIG1vdmVzIHRoZSBwbGFjZWhvbGRlclxuXHQqIHRvIHRoYXQgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gcGFnZVkgLSBQb3NpdGlvbiBmcm9tIHRvcCBpbiBwaXhlbHMuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dXBkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbjogZnVuY3Rpb24gKHBhZ2VZKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRSb3dJbmRleEZyb21Db29yZGluYXRlKHBhZ2VZKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHQvLyBjdXJzb3IgbW92ZWQgb3ZlciBhIG5ldyByb3csIHNvIGRldGVybWluZSBkaXJlY3Rpb24gb2YgbW92ZW1lbnRcblx0XHRcdGlmIChpbmRleCA+PSB0aGlzLnBsYWNlaG9sZGVyUm93SW5kZXgpIHtcblx0XHRcdFx0dGhpcy5tb3ZlUGxhY2Vob2xkZXJUb0luZGV4KE1hdGgubWluKHRoaXMuY291bnQsIGluZGV4ICsgMSkpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMubW92ZVBsYWNlaG9sZGVyVG9JbmRleChpbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFBvc2l0aW9ucyB0aGUgcmVvcmRlciBub2RlIGJhc2VkIG9uIHRoZSBgZHhgIGFuZCBgZHlgIG9mIHRoZSBkcmFnIGV2ZW50LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cG9zaXRpb25SZW9yZGVyTm9kZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcmVvcmRlck5vZGVCb3VuZHMgPSB0aGlzLiQucmVvcmRlckNvbnRhaW5lci5nZXRCb3VuZHMoKTtcblx0XHR2YXIgbGVmdCA9IHJlb3JkZXJOb2RlQm91bmRzLmxlZnQgKyBlLmRkeDtcblx0XHR2YXIgdG9wID0gcmVvcmRlck5vZGVCb3VuZHMudG9wICsgZS5kZHk7XG5cdFx0dG9wID0gKHRoaXMuZ2V0U3RyYXRlZ3lLaW5kKCkgPT0gJ1Njcm9sbFN0cmF0ZWd5JykgPyB0b3AgKyAodGhpcy5nZXRTY3JvbGxUb3AoKSAtIHRoaXMucHJldlNjcm9sbFRvcCkgOiB0b3A7XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIuYWRkU3R5bGVzKCd0b3A6ICcrdG9wKydweCA7IGxlZnQ6ICcrbGVmdCsncHgnKTtcblx0XHR0aGlzLnByZXZTY3JvbGxUb3AgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IHNob3VsZCBzY3JvbGwgd2hlbiBkcmFnZ2luZyBhbmQsIGlmIHNvLCBzdGFydHMgdGhlXG5cdCogc2Nyb2xsIHRpbWVvdXQgdGltZXIuIEF1dG8tc2Nyb2xsaW5nIGhhcHBlbnMgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpdGVtXG5cdCogd2l0aGluIHRoZSB0b3AvYm90dG9tIGJvdW5kYXJ5IHBlcmNlbnRhZ2UgZGVmaW5lZCBpblxuXHQqIFtkcmFnVG9TY3JvbGxUaHJlc2hvbGRde0BsaW5rIGVueW8uTGlzdCNkcmFnVG9TY3JvbGxUaHJlc2hvbGR9LlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRHJhZyBldmVudC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjaGVja0ZvckF1dG9TY3JvbGw6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBwb3NpdGlvbiA9IGRvbS5jYWxjTm9kZVBvc2l0aW9uKHRoaXMuaGFzTm9kZSgpKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR2YXIgcGVyYztcblx0XHR0aGlzLmF1dG9zY3JvbGxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXHRcdGlmIChldmVudC5wYWdlWSAtIHBvc2l0aW9uLnRvcCA8IGJvdW5kcy5oZWlnaHQgKiB0aGlzLmRyYWdUb1Njcm9sbFRocmVzaG9sZCkge1xuXHRcdFx0cGVyYyA9IDEwMCooMSAtICgoZXZlbnQucGFnZVkgLSBwb3NpdGlvbi50b3ApIC8gKGJvdW5kcy5oZWlnaHQgKiB0aGlzLmRyYWdUb1Njcm9sbFRocmVzaG9sZCkpKTtcblx0XHRcdHRoaXMuc2Nyb2xsRGlzdGFuY2UgPSAtMSpwZXJjO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnQucGFnZVkgLSBwb3NpdGlvbi50b3AgPiBib3VuZHMuaGVpZ2h0ICogKDEgLSB0aGlzLmRyYWdUb1Njcm9sbFRocmVzaG9sZCkpIHtcblx0XHRcdHBlcmMgPSAxMDAqKChldmVudC5wYWdlWSAtIHBvc2l0aW9uLnRvcCAtIGJvdW5kcy5oZWlnaHQqKDEgLSB0aGlzLmRyYWdUb1Njcm9sbFRocmVzaG9sZCkpIC8gKGJvdW5kcy5oZWlnaHQgLSAoYm91bmRzLmhlaWdodCAqICgxIC0gdGhpcy5kcmFnVG9TY3JvbGxUaHJlc2hvbGQpKSkpO1xuXHRcdFx0dGhpcy5zY3JvbGxEaXN0YW5jZSA9IDEqcGVyYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zY3JvbGxEaXN0YW5jZSA9IDA7XG5cdFx0fVxuXHRcdC8vIHN0b3Agc2Nyb2xsaW5nIGlmIGRpc3RhbmNlIGlzIHplcm8gKGkuZS4sIHVzZXIgaXNuJ3Qgc2Nyb2xsaW5nIHRvIHRoZSBlZGdlcyBvZlxuXHRcdC8vIHRoZSBsaXN0KTsgb3RoZXJ3aXNlLCBzdGFydCBpdCBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG5cdFx0aWYgKHRoaXMuc2Nyb2xsRGlzdGFuY2UgPT09IDApIHtcblx0XHRcdHRoaXMuc3RvcEF1dG9TY3JvbGxpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLmF1dG9TY3JvbGxUaW1lb3V0KSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRBdXRvU2Nyb2xsaW5nKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFN0b3BzIGF1dG8tc2Nyb2xsaW5nLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RvcEF1dG9TY3JvbGxpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5hdXRvU2Nyb2xsVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuYXV0b1Njcm9sbFRpbWVvdXQpO1xuXHRcdFx0dGhpcy5hdXRvU2Nyb2xsVGltZW91dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFN0YXJ0cyBhdXRvLXNjcm9sbGluZy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0YXJ0QXV0b1Njcm9sbGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuYXV0b1Njcm9sbFRpbWVvdXQgPSBzZXRJbnRlcnZhbCh0aGlzLmJpbmRTYWZlbHkodGhpcy5hdXRvU2Nyb2xsKSwgdGhpcy5hdXRvU2Nyb2xsVGltZW91dE1TKTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRoZSBsaXN0IGJ5IHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgaW5cblx0KiBbc2Nyb2xsRGlzdGFuY2Vde0BsaW5rIGVueW8uTGlzdCNzY3JvbGxEaXN0YW5jZX0uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhdXRvU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsRGlzdGFuY2UgPT09IDApIHtcblx0XHRcdHRoaXMuc3RvcEF1dG9TY3JvbGxpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLmF1dG9TY3JvbGxUaW1lb3V0KSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRBdXRvU2Nyb2xsaW5nKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2Nyb2xsUG9zaXRpb24odGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpICsgdGhpcy5zY3JvbGxEaXN0YW5jZSk7XG5cdFx0dGhpcy5wb3NpdGlvblJlb3JkZXJOb2RlKHtkZHg6IDAsIGRkeTogMH0pO1xuXG5cdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaW5kZXggdGhlIHVzZXIgaXMgZHJhZ2dpbmcgb3ZlciBoYXMgY2hhbmdlZCwgbW92ZSB0aGUgcGxhY2Vob2xkZXJcblx0XHR0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24odGhpcy5hdXRvc2Nyb2xsUGFnZVkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE1vdmVzIHRoZSBwbGFjZWhvbGRlciAoaS5lLiwgdGhlIGdhcCBiZXR3ZWVuIHJvd3MpIHRvIHRoZSByb3cgY3VycmVudGx5XG5cdCogdW5kZXIgdGhlIHVzZXIncyBwb2ludGVyLiBUaGlzIHByb3ZpZGVzIGEgdmlzdWFsIGN1ZSwgc2hvd2luZyB0aGUgdXNlclxuXHQqIHdoZXJlIHRoZSBpdGVtIGJlaW5nIGRyYWdnZWQgd2lsbCBnbyBpZiBpdCBpcyBkcm9wcGVkLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHJvdyBpbmRleC5cblx0Ki9cblx0bW92ZVBsYWNlaG9sZGVyVG9JbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dmFyIG5vZGUsIG5vZGVQYXJlbnQ7XG5cdFx0aWYgKGluZGV4IDwgMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KSB7XG5cdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdG5vZGVQYXJlbnQgPSB0aGlzLnBhZ2VGb3JQYWdlTnVtYmVyKHRoaXMucGFnZUZvclJvdyh0aGlzLmNvdW50IC0gMSkpLmhhc05vZGUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy4kLmdlbmVyYXRvci5mZXRjaFJvd05vZGUoaW5kZXgpO1xuXHRcdFx0bm9kZVBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0Ly8gZmlndXJlIG5leHQgcGFnZSBmb3IgcGxhY2Vob2xkZXJcblx0XHR2YXIgbmV4dFBhZ2VOdW1iZXIgPSB0aGlzLnBhZ2VGb3JSb3coaW5kZXgpO1xuXG5cdFx0Ly8gZG9uJ3QgYWRkIHBhZ2VzIGJleW9uZCB0aGUgb3JpZ2luYWwgcGFnZSBjb3VudFxuXHRcdGlmIChuZXh0UGFnZU51bWJlciA+PSB0aGlzLnBhZ2VDb3VudCkge1xuXHRcdFx0bmV4dFBhZ2VOdW1iZXIgPSB0aGlzLmN1cnJlbnRQYWdlTnVtYmVyO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgdGhlIHBsYWNlaG9sZGVyIHRvIGp1c3QgYWZ0ZXIgb3VyICdpbmRleCcgbm9kZVxuXHRcdG5vZGVQYXJlbnQuaW5zZXJ0QmVmb3JlKFxuXHRcdFx0dGhpcy5wbGFjZWhvbGRlck5vZGUsXG5cdFx0XHRub2RlKTtcblxuXHRcdGlmICh0aGlzLmN1cnJlbnRQYWdlTnVtYmVyICE9PSBuZXh0UGFnZU51bWJlcikge1xuXHRcdFx0Ly8gaWYgbW92aW5nIHRvIGRpZmZlcmVudCBwYWdlLCByZWNhbGN1bGF0ZSBwYWdlIHNpemVzIGFuZCByZXBvc2l0aW9uIHBhZ2VzXG5cdFx0XHR0aGlzLnVwZGF0ZVBhZ2VTaXplKHRoaXMuY3VycmVudFBhZ2VOdW1iZXIpO1xuXHRcdFx0dGhpcy51cGRhdGVQYWdlU2l6ZShuZXh0UGFnZU51bWJlcik7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhZ2VQb3NpdGlvbnMobmV4dFBhZ2VOdW1iZXIpO1xuXHRcdH1cblxuXHRcdC8vIHNhdmUgdXBkYXRlZCBzdGF0ZVxuXHRcdHRoaXMucGxhY2Vob2xkZXJSb3dJbmRleCA9IGluZGV4O1xuXHRcdHRoaXMuY3VycmVudFBhZ2VOdW1iZXIgPSBuZXh0UGFnZU51bWJlcjtcblxuXHRcdC8vIHJlbWVtYmVyIHRoYXQgd2UgbW92ZWQgYW4gaXRlbSAodG8gcHJldmVudCBwaW5uaW5nIGF0IHRoZSB3cm9uZyB0aW1lKVxuXHRcdHRoaXMuaXRlbU1vdmVkID0gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBUdXJucyBvZmYgcmVvcmRlcmluZy4gSWYgdGhlIHVzZXIgZGlkbid0IGRyYWcgdGhlIGl0ZW0gYmVpbmcgcmVvcmRlcmVkXG5cdCogb3V0c2lkZSBvZiBpdHMgb3JpZ2luYWwgcG9zaXRpb24sIGVudGVycyBwaW5uZWQgcmVvcmRlciBtb2RlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZmluaXNoUmVvcmRlcmluZzogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuaXNSZW9yZGVyaW5nKCkgfHwgdGhpcy5waW5uZWRSZW9yZGVyTW9kZSB8fCB0aGlzLmNvbXBsZXRlUmVvcmRlclRpbWVvdXQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5zdG9wQXV0b1Njcm9sbGluZygpO1xuXHRcdC8vIGVuYWJsZSBkcmFnLXNjcm9sbGluZyBvbiBzdHJhdGVneVxuXHRcdHRoaXMuJC5zdHJhdGVneS5saXN0UmVvcmRlcmluZyA9IGZhbHNlO1xuXHRcdC8vIGFuaW1hdGUgcmVvcmRlciBjb250YWluZXIgdG8gcHJvcGVyIHBvc2l0aW9uIGFuZCB0aGVuIGNvbXBsZXRlXG5cdFx0Ly8gcmVvcmRlcmluZyBhY3Rpb25zXG5cdFx0dGhpcy5tb3ZlUmVvcmRlcmVkQ29udGFpbmVyVG9Ecm9wcGVkUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMuY29tcGxldGVSZW9yZGVyVGltZW91dCA9IHNldFRpbWVvdXQoXG5cdFx0XHR0aGlzLmJpbmRTYWZlbHkodGhpcy5jb21wbGV0ZUZpbmlzaFJlb3JkZXJpbmcsIGV2ZW50KSwgMTAwKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bW92ZVJlb3JkZXJlZENvbnRhaW5lclRvRHJvcHBlZFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0UmVsYXRpdmVPZmZzZXQodGhpcy5wbGFjZWhvbGRlck5vZGUsIHRoaXMuaGFzTm9kZSgpKTtcblx0XHR2YXIgdG9wID0gKHRoaXMuZ2V0U3RyYXRlZ3lLaW5kKCkgPT0gJ1Njcm9sbFN0cmF0ZWd5JykgPyBvZmZzZXQudG9wIDogb2Zmc2V0LnRvcCAtIHRoaXMuZ2V0U2Nyb2xsVG9wKCk7XG5cdFx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCAtIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpO1xuXHRcdHRoaXMucG9zaXRpb25SZW9yZGVyQ29udGFpbmVyKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQWZ0ZXIgdGhlIHJlb3JkZXJlZCBpdGVtIGhhcyBiZWVuIGFuaW1hdGVkIHRvIGl0cyBwb3NpdGlvbiwgY29tcGxldGVzXG5cdCogdGhlIHJlb3JkZXJpbmcgbG9naWMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZUZpbmlzaFJlb3JkZXJpbmc6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuY29tcGxldGVSZW9yZGVyVGltZW91dCA9IG51bGw7XG5cdFx0Ly8gYWRqdXN0IHBsYWNlaG9sZGVyUm93SW5kZXggdG8gbm93IGJlIHRoZSBmaW5hbCByZXN0aW5nIHBsYWNlXG5cdFx0aWYgKHRoaXMucGxhY2Vob2xkZXJSb3dJbmRleCA+IHRoaXMuZHJhZ2dpbmdSb3dJbmRleCkge1xuXHRcdFx0dGhpcy5wbGFjZWhvbGRlclJvd0luZGV4ID0gTWF0aC5tYXgoMCwgdGhpcy5wbGFjZWhvbGRlclJvd0luZGV4IC0gMSk7XG5cdFx0fVxuXHRcdC8vIGlmIHRoZSB1c2VyIGRyb3BwZWQgdGhlIGl0ZW0gaW4gdGhlIHNhbWUgbG9jYXRpb24gd2hlcmUgaXQgd2FzIHBpY2tlZCB1cCwgYW5kIHRoZXlcblx0XHQvLyBkaWRuJ3QgbW92ZSBhbnkgb3RoZXIgaXRlbXMgaW4gdGhlIHByb2Nlc3MsIHBpbiB0aGUgaXRlbSBhbmQgZ28gaW50byBwaW5uZWQgcmVvcmRlciBtb2RlXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmdSb3dJbmRleCA9PSB0aGlzLnBsYWNlaG9sZGVyUm93SW5kZXggJiZcblx0XHRcdHRoaXMucGlubmVkUmVvcmRlckNvbXBvbmVudHMubGVuZ3RoICYmICF0aGlzLnBpbm5lZFJlb3JkZXJNb2RlICYmICF0aGlzLml0ZW1Nb3ZlZCkge1xuXHRcdFx0dGhpcy5iZWdpblBpbm5lZFJlb3JkZXIoZXZlbnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnJlbW92ZURyYWdnaW5nUm93Tm9kZSgpO1xuXHRcdHRoaXMucmVtb3ZlUGxhY2Vob2xkZXJOb2RlKCk7XG5cdFx0dGhpcy5lbXB0eUFuZEhpZGVSZW9yZGVyQ29udGFpbmVyKCk7XG5cdFx0Ly8gY2xlYXIgdGhpcyBlYXJseSB0byBwcmV2ZW50IHNjcm9sbGVyIGNvZGUgZnJvbSB1c2luZyBkaXNhcHBlYXJlZCBwbGFjZWhvbGRlclxuXHRcdHRoaXMucGlubmVkUmVvcmRlck1vZGUgPSBmYWxzZTtcblx0XHR0aGlzLnJlb3JkZXJSb3dzKGV2ZW50KTtcblx0XHR0aGlzLmRyYWdnaW5nUm93SW5kZXggPSB0aGlzLnBsYWNlaG9sZGVyUm93SW5kZXggPSAtMTtcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0fSxcblxuXHQvKipcblx0KiBFbnRlcnMgcGlubmVkIHJlb3JkZXIgbW9kZS5cblx0KlxuXHQqIEBmaXJlcyBlbnlvLkxpc3Qjb25TZXR1cFBpbm5lZFJlb3JkZXJDb21wb25lbnRzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YmVnaW5QaW5uZWRSZW9yZGVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLmJ1aWxkUGlubmVkUmVvcmRlckNvbnRhaW5lcigpO1xuXHRcdHRoaXMuZG9TZXR1cFBpbm5lZFJlb3JkZXJDb21wb25lbnRzKHV0aWxzLm1peGluKGV2ZW50LCB7aW5kZXg6IHRoaXMuZHJhZ2dpbmdSb3dJbmRleH0pKTtcblx0XHR0aGlzLnBpbm5lZFJlb3JkZXJNb2RlID0gdHJ1ZTtcblx0XHR0aGlzLmluaXRpYWxQaW5Qb3NpdGlvbiA9IGV2ZW50LnBhZ2VZO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENsZWFycyBjb250ZW50cyBvZiByZW9yZGVyIGNvbnRhaW5lciwgdGhlbiBoaWRlcy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGVtcHR5QW5kSGlkZVJlb3JkZXJDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQucmVvcmRlckNvbnRhaW5lci5kZXN0cm95Q29tcG9uZW50cygpO1xuXHRcdHRoaXMuJC5yZW9yZGVyQ29udGFpbmVyLnNldFNob3dpbmcoZmFsc2UpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEZpbGxzIHJlb3JkZXIgY29udGFpbmVyIHdpdGggcGlubmVkIGNvbnRyb2xzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YnVpbGRQaW5uZWRSZW9yZGVyQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIuZGVzdHJveUNsaWVudENvbnRyb2xzKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8dGhpcy5waW5uZWRSZW9yZGVyQ29tcG9uZW50cy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR0aGlzLiQucmVvcmRlckNvbnRhaW5lci5jcmVhdGVDb21wb25lbnQodGhpcy5waW5uZWRSZW9yZGVyQ29tcG9uZW50c1tpXSwge293bmVyOnRoaXMub3duZXJ9KTtcblx0XHR9XG5cdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIucmVuZGVyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogU3dhcHMgdGhlIHJvd3MgdGhhdCB3ZXJlIHJlb3JkZXJlZCwgYW5kIHNlbmRzIHVwIHJlb3JkZXIgZXZlbnQuXG5cdCpcblx0KiBAZmlyZXMgZW55by5MaXN0I29uUmVvcmRlclxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlb3JkZXJSb3dzOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBzZW5kIHJlb3JkZXIgZXZlbnRcblx0XHR0aGlzLmRvUmVvcmRlcih0aGlzLm1ha2VSZW9yZGVyRXZlbnQoZXZlbnQpKTtcblx0XHQvLyB1cGRhdGUgZGlzcGxheVxuXHRcdHRoaXMucG9zaXRpb25SZW9yZGVyZWROb2RlKCk7XG5cdFx0Ly8gZml4IGluZGljZXMgZm9yIHJlb3JkZXJlZCByb3dzXG5cdFx0dGhpcy51cGRhdGVMaXN0SW5kaWNlcygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFkZHMgYHJlb3JkZXJUb2AgYW5kIGByZW9yZGVyRnJvbWAgcHJvcGVydGllcyB0byB0aGUgcmVvcmRlciBldmVudC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1ha2VSZW9yZGVyRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnJlb3JkZXJGcm9tID0gdGhpcy5kcmFnZ2luZ1Jvd0luZGV4O1xuXHRcdGV2ZW50LnJlb3JkZXJUbyA9IHRoaXMucGxhY2Vob2xkZXJSb3dJbmRleDtcblx0XHRyZXR1cm4gZXZlbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCogTW92ZXMgdGhlIG5vZGUgYmVpbmcgcmVvcmRlcmVkIHRvIGl0cyBuZXcgcG9zaXRpb24gYW5kIHNob3dzIGl0LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cG9zaXRpb25SZW9yZGVyZWROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gb25seSBkbyB0aGlzIGlmIHRoZSBwYWdlIHdpdGggdGhlIGluaXRpYWwgaXRlbSBpcyBzdGlsbCByZW5kZXJlZFxuXHRcdGlmICghdGhpcy5yZW1vdmVkSW5pdGlhbFBhZ2UpIHtcblx0XHRcdHZhciBpbnNlcnROb2RlID0gdGhpcy4kLmdlbmVyYXRvci5mZXRjaFJvd05vZGUodGhpcy5wbGFjZWhvbGRlclJvd0luZGV4KTtcblx0XHRcdGlmIChpbnNlcnROb2RlKSB7XG5cdFx0XHRcdGluc2VydE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5oaWRkZW5Ob2RlLCBpbnNlcnROb2RlKTtcblx0XHRcdFx0dGhpcy5zaG93Tm9kZSh0aGlzLmhpZGRlbk5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oaWRkZW5Ob2RlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRQYWdlTnVtYmVyICE9IHRoaXMuaW5pdGlhbFBhZ2VOdW1iZXIpIHtcblx0XHRcdFx0dmFyIG1vdmVyLCBtb3ZlZTtcblx0XHRcdFx0dmFyIGN1cnJlbnRQYWdlID0gdGhpcy5wYWdlRm9yUGFnZU51bWJlcih0aGlzLmN1cnJlbnRQYWdlTnVtYmVyKTtcblx0XHRcdFx0dmFyIG90aGVyUGFnZSA9IHRoaXMucGFnZUZvclBhZ2VOdW1iZXIodGhpcy5jdXJyZW50UGFnZU51bWJlciArIDEpO1xuXHRcdFx0XHQvLyBpZiBtb3ZlZCBkb3duLCBtb3ZlIGN1cnJlbnQgcGFnZSdzIGZpcnN0Q2hpbGQgdG8gdGhlIGVuZCBvZiBwcmV2aW91cyBwYWdlXG5cdFx0XHRcdGlmICh0aGlzLmluaXRpYWxQYWdlTnVtYmVyIDwgdGhpcy5jdXJyZW50UGFnZU51bWJlcikge1xuXHRcdFx0XHRcdG1vdmVyID0gY3VycmVudFBhZ2UuaGFzTm9kZSgpLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0b3RoZXJQYWdlLmhhc05vZGUoKS5hcHBlbmRDaGlsZChtb3Zlcik7XG5cdFx0XHRcdC8vIGlmIG1vdmVkIHVwLCBtb3ZlIGN1cnJlbnQgcGFnZSdzIGxhc3RDaGlsZCBiZWZvcmUgcHJldmlvdXMgcGFnZSdzIGZpcnN0Q2hpbGRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtb3ZlciA9IGN1cnJlbnRQYWdlLmhhc05vZGUoKS5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0bW92ZWUgPSBvdGhlclBhZ2UuaGFzTm9kZSgpLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0b3RoZXJQYWdlLmhhc05vZGUoKS5pbnNlcnRCZWZvcmUobW92ZXIsIG1vdmVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNvcnJlY3RQYWdlU2l6ZXMoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVQYWdlUG9zaXRpb25zKHRoaXMuaW5pdGlhbFBhZ2VOdW1iZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBVcGRhdGVzIGluZGljZXMgb2YgbGlzdCBpdGVtcyBhcyBuZWVkZWQgdG8gcHJlc2VydmUgcmVvcmRlcmluZy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZUxpc3RJbmRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZG9uJ3QgZG8gdXBkYXRlIGlmIHdlJ3ZlIG1vdmVkIGZ1cnRoZXIgdGhhbiBvbmUgcGFnZSwgcmVmcmVzaCBpbnN0ZWFkXG5cdFx0aWYgKHRoaXMuc2hvdWxkRG9SZWZyZXNoKCkpIHtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0dGhpcy5jb3JyZWN0UGFnZVNpemVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZyb20gPSBNYXRoLm1pbih0aGlzLmRyYWdnaW5nUm93SW5kZXgsIHRoaXMucGxhY2Vob2xkZXJSb3dJbmRleCk7XG5cdFx0dmFyIHRvID0gTWF0aC5tYXgodGhpcy5kcmFnZ2luZ1Jvd0luZGV4LCB0aGlzLnBsYWNlaG9sZGVyUm93SW5kZXgpO1xuXHRcdHZhciBkaXJlY3Rpb24gPSAodGhpcy5kcmFnZ2luZ1Jvd0luZGV4IC0gdGhpcy5wbGFjZWhvbGRlclJvd0luZGV4ID4gMCkgPyAxIDogLTE7XG5cdFx0dmFyIG5vZGUsIGksIG5ld0luZGV4LCBjdXJyZW50SW5kZXg7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAxKSB7XG5cdFx0XHRub2RlID0gdGhpcy4kLmdlbmVyYXRvci5mZXRjaFJvd05vZGUodGhpcy5kcmFnZ2luZ1Jvd0luZGV4KTtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWVueW8taW5kZXgnLCAncmVvcmRlcmVkJyk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGk9KHRvLTEpLG5ld0luZGV4PXRvO2k+PWZyb207aS0tKSB7XG5cdFx0XHRcdG5vZGUgPSB0aGlzLiQuZ2VuZXJhdG9yLmZldGNoUm93Tm9kZShpKTtcblx0XHRcdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VycmVudEluZGV4ID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW55by1pbmRleCcpLCAxMCk7XG5cdFx0XHRcdG5ld0luZGV4ID0gY3VycmVudEluZGV4ICsgMTtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZW55by1pbmRleCcsIG5ld0luZGV4KTtcblx0XHRcdH1cblx0XHRcdG5vZGUgPSB0aGlzLmhhc05vZGUoKS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1lbnlvLWluZGV4PVwicmVvcmRlcmVkXCJdJyk7XG5cdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1lbnlvLWluZGV4JywgdGhpcy5wbGFjZWhvbGRlclJvd0luZGV4KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy4kLmdlbmVyYXRvci5mZXRjaFJvd05vZGUodGhpcy5kcmFnZ2luZ1Jvd0luZGV4KTtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWVueW8taW5kZXgnLCB0aGlzLnBsYWNlaG9sZGVyUm93SW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpPShmcm9tKzEpLCBuZXdJbmRleD1mcm9tO2k8PXRvO2krKykge1xuXHRcdFx0XHRub2RlID0gdGhpcy4kLmdlbmVyYXRvci5mZXRjaFJvd05vZGUoaSk7XG5cdFx0XHRcdGlmICghbm9kZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1cnJlbnRJbmRleCA9IHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWVueW8taW5kZXgnKSwgMTApO1xuXHRcdFx0XHRuZXdJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWVueW8taW5kZXgnLCBuZXdJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciBhbiBpdGVtIHdhcyByZW9yZGVyZWQgZmFyIGVub3VnaCB0aGF0IGl0IHdhcnJhbnRzIGEgcmVmcmVzaC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNob3VsZERvUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAoTWF0aC5hYnModGhpcy5pbml0aWFsUGFnZU51bWJlciAtIHRoaXMuY3VycmVudFBhZ2VOdW1iZXIpID4gMSk7XG5cdH0sXG5cblx0LyoqXG5cdCogR2V0cyBub2RlIGhlaWdodCwgd2lkdGgsIHRvcCwgYW5kIGxlZnQgdmFsdWVzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0Tm9kZVN0eWxlOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuJC5nZW5lcmF0b3IuZmV0Y2hSb3dOb2RlKGluZGV4KTtcblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0UmVsYXRpdmVPZmZzZXQobm9kZSwgdGhpcy5oYXNOb2RlKCkpO1xuXHRcdHZhciBkaW1lbnNpb25zID0gZG9tLmdldEJvdW5kcyhub2RlKTtcblx0XHRyZXR1cm4ge2g6IGRpbWVuc2lvbnMuaGVpZ2h0LCB3OiBkaW1lbnNpb25zLndpZHRoLCBsZWZ0OiBvZmZzZXQubGVmdCwgdG9wOiBvZmZzZXQudG9wfTtcblx0fSxcblxuXHQvKipcblx0KiBHZXRzIG9mZnNldCByZWxhdGl2ZSB0byBhIHBvc2l0aW9uZWQgYW5jZXN0b3Igbm9kZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbiAobiwgcCkge1xuXHRcdHZhciBybyA9IHt0b3A6IDAsIGxlZnQ6IDB9O1xuXHRcdGlmIChuICE9PSBwICYmIG4ucGFyZW50Tm9kZSkge1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRyby50b3AgKz0gbi5vZmZzZXRUb3AgfHwgMDtcblx0XHRcdFx0cm8ubGVmdCArPSBuLm9mZnNldExlZnQgfHwgMDtcblx0XHRcdFx0biA9IG4ub2Zmc2V0UGFyZW50O1xuXHRcdFx0fSB3aGlsZSAobiAmJiBuICE9PSBwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhpZGVzIHRoZSBET00gbm9kZSBmb3IgdGhlIHJvdyBhdCBgaW5kZXhgIGFuZCBpbnNlcnRzIHRoZSBwbGFjZWhvbGRlciBub2RlIGJlZm9yZSBpdC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHdob3NlIERPTSBub2RlIHdpbGwgYmUgaGlkZGVuLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlcGxhY2VOb2RlV2l0aFBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuJC5nZW5lcmF0b3IuZmV0Y2hSb3dOb2RlKGluZGV4KTtcblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdGxvZ2dlci5sb2coJ05vIG5vZGUgLSAnICsgaW5kZXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBjcmVhdGUgYW5kIHN0eWxlIHBsYWNlaG9sZGVyIG5vZGVcblx0XHR0aGlzLnBsYWNlaG9sZGVyTm9kZSA9IHRoaXMuY3JlYXRlUGxhY2Vob2xkZXJOb2RlKG5vZGUpO1xuXHRcdC8vIGhpZGUgZXhpc3Rpbmcgbm9kZVxuXHRcdHRoaXMuaGlkZGVuTm9kZSA9IHRoaXMuaGlkZU5vZGUobm9kZSk7XG5cdFx0Ly8gaW5zZXJ0IHBsYWNlaG9sZGVyIG5vZGUgd2hlcmUgb3JpZ2luYWwgbm9kZSB3YXNcblx0XHR2YXIgY3VycmVudFBhZ2UgPSB0aGlzLnBhZ2VGb3JQYWdlTnVtYmVyKHRoaXMuY3VycmVudFBhZ2VOdW1iZXIpO1xuXHRcdGN1cnJlbnRQYWdlLmhhc05vZGUoKS5pbnNlcnRCZWZvcmUodGhpcy5wbGFjZWhvbGRlck5vZGUsIHRoaXMuaGlkZGVuTm9kZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHBsYWNlaG9sZGVyIG5vZGUgd2l0aCBkaW1lbnNpb25zIG1hdGNoaW5nIHRob3NlIG9mXG5cdCogdGhlIHBhc3NlZC1pbiBub2RlLlxuXHQqXG5cdCogQHBhcmFtIHtOb2RlfSBub2RlIC0gTm9kZSBvbiB3aGljaCB0byBiYXNlIHRoZSBwbGFjZWhvbGRlciBkaW1lbnNpb25zLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZVBsYWNlaG9sZGVyTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHR2YXIgcGxhY2Vob2xkZXJOb2RlID0gdGhpcy4kLnBsYWNlaG9sZGVyLmhhc05vZGUoKS5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0dmFyIG5vZGVEaW1lbnNpb25zID0gZG9tLmdldEJvdW5kcyhub2RlKTtcblx0XHRwbGFjZWhvbGRlck5vZGUuc3R5bGUuaGVpZ2h0ID0gbm9kZURpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRwbGFjZWhvbGRlck5vZGUuc3R5bGUud2lkdGggPSBub2RlRGltZW5zaW9ucy53aWR0aCArICdweCc7XG5cdFx0cmV0dXJuIHBsYWNlaG9sZGVyTm9kZTtcblx0fSxcblxuXHQvKipcblx0KiBSZW1vdmVzIHRoZSBwbGFjZWhvbGRlciBub2RlIGZyb20gdGhlIERPTS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbW92ZVBsYWNlaG9sZGVyTm9kZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlTm9kZSh0aGlzLnBsYWNlaG9sZGVyTm9kZSk7XG5cdFx0dGhpcy5wbGFjZWhvbGRlck5vZGUgPSBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlbW92ZXMgdGhlIHBhc3NlZC1pbiBub2RlIGZyb20gdGhlIERPTS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbW92ZU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0aWYgKCFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgYHRoaXMucGFnZVNpemVzYCB0byBzdXBwb3J0IHRoZSBwbGFjZWhvbGRlciBub2RlJ3MganVtcGluZ1xuXHQqIGZyb20gb25lIHBhZ2UgdG8gdGhlIG5leHQuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gcGFnZU51bWJlclxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZVBhZ2VTaXplOiBmdW5jdGlvbiAocGFnZU51bWJlcikge1xuXHRcdGlmIChwYWdlTnVtYmVyIDwgMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgcGFnZUNvbnRyb2wgPSB0aGlzLnBhZ2VGb3JQYWdlTnVtYmVyKHBhZ2VOdW1iZXIsIHRydWUpO1xuXHRcdGlmIChwYWdlQ29udHJvbCkge1xuXHRcdFx0dmFyIHMwID0gdGhpcy5wYWdlU2l6ZXNbcGFnZU51bWJlcl07XG5cdFx0XHQvLyBGSVhNRTogdXNlIGhlaWdodC93aWR0aCBkZXBlbmRpbmcgb24gb3JpZW50YXRpb25cblx0XHRcdHZhciBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIHBhZ2VDb250cm9sLmdldEJvdW5kcygpLmhlaWdodCk7XG5cdFx0XHR0aGlzLnBhZ2VTaXplc1twYWdlTnVtYmVyXSA9IHBhZ2VTaXplO1xuXHRcdFx0dGhpcy5wb3J0U2l6ZSArPSBwYWdlU2l6ZSAtIHMwO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBSZXBvc2l0aW9ucyBbY3VycmVudFBhZ2VOdW1iZXJde0BsaW5rIGVueW8uTGlzdCNjdXJyZW50UGFnZU51bWJlcn0gYW5kXG5cdCogYG5leHRQYWdlTnVtYmVyYCBwYWdlcyB0byBzdXBwb3J0IHRoZSBwbGFjZWhvbGRlciBub2RlJ3MganVtcGluZyBmcm9tIG9uZVxuXHQqIHBhZ2UgdG8gdGhlIG5leHQuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gbmV4dFBhZ2VOdW1iZXIgW2Rlc2NyaXB0aW9uXVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZVBhZ2VQb3NpdGlvbnM6IGZ1bmN0aW9uIChuZXh0UGFnZU51bWJlcikge1xuXHRcdHRoaXMucG9zaXRpb25QYWdlKHRoaXMuY3VycmVudFBhZ2VOdW1iZXIsIHRoaXMucGFnZUZvclBhZ2VOdW1iZXIodGhpcy5jdXJyZW50UGFnZU51bWJlcikpO1xuXHRcdHRoaXMucG9zaXRpb25QYWdlKG5leHRQYWdlTnVtYmVyLCB0aGlzLnBhZ2VGb3JQYWdlTnVtYmVyKG5leHRQYWdlTnVtYmVyKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ29ycmVjdHMgcGFnZSBzaXplcyBhcnJheSBhZnRlciByZW9yZGVyIGlzIGNvbXBsZXRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29ycmVjdFBhZ2VTaXplczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbml0UGFnZU51bWJlciA9IHRoaXMuaW5pdGlhbFBhZ2VOdW1iZXIlMjtcblx0XHR0aGlzLnVwZGF0ZVBhZ2VTaXplKHRoaXMuY3VycmVudFBhZ2VOdW1iZXIsIHRoaXMuJFsncGFnZScrdGhpcy5jdXJyZW50UGFnZV0pO1xuXHRcdGlmIChpbml0UGFnZU51bWJlciAhPSB0aGlzLmN1cnJlbnRQYWdlTnVtYmVyKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhZ2VTaXplKHRoaXMuaW5pdGlhbFBhZ2VOdW1iZXIsIHRoaXMuJFsncGFnZScraW5pdFBhZ2VOdW1iZXJdKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogSGlkZXMgYSBET00gbm9kZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhpZGVOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdG5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblxuXHQvKipcblx0KiBTaG93cyBhIERPTSBub2RlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd05vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0bm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblxuXHQvKipcblx0KiBDYWxsZWQgYnkgY2xpZW50IGNvZGUgdG8gZmluYWxpemUgYSBwaW5uZWQgbW9kZSByZW9yZGVyaW5nLCBlLmcuLCB3aGVuIHRoZSBcIkRyb3BcIlxuXHQqIGJ1dHRvbiBpcyBwcmVzc2VkIG9uIHRoZSBwaW5uZWQgcGxhY2Vob2xkZXIgcm93LlxuXHQqXG5cdCogQHRvZG8gU2VlbXMgaW5jb3JyZWN0IHRvIGhhdmUgYW4gZXZlbnQgb24gdGhlIHNpZ25hdHVyZSBmb3IgYSBwdWJsaWMgQVBJXG5cdCogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gQSBtb3VzZS90b3VjaCBldmVudC5cblx0KiBAcHVibGljXG5cdCovXG5cdGRyb3BQaW5uZWRSb3c6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIGFuaW1hdGUgcmVvcmRlciBjb250YWluZXIgdG8gcHJvcGVyIHBvc2l0aW9uIGFuZCB0aGVuIGNvbXBsZXRlIHJlb3JkaW5nIGFjdGlvbnNcblx0XHR0aGlzLm1vdmVSZW9yZGVyZWRDb250YWluZXJUb0Ryb3BwZWRQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5jb21wbGV0ZVJlb3JkZXJUaW1lb3V0ID0gc2V0VGltZW91dChcblx0XHRcdHRoaXMuYmluZFNhZmVseSh0aGlzLmNvbXBsZXRlRmluaXNoUmVvcmRlcmluZywgZXZlbnQpLCAxMDApO1xuXHRcdHJldHVybjtcblx0fSxcblxuXHQvKipcblx0KiBDYWxsZWQgYnkgY2xpZW50IGNvZGUgdG8gY2FuY2VsIGEgcGlubmVkIG1vZGUgcmVvcmRlcmluZy5cblx0KlxuXHQqIEB0b2RvIFNlZW1zIGluY29ycmVjdCB0byBoYXZlIGFuIGV2ZW50IG9uIHRoZSBzaWduYXR1cmUgZm9yIGEgcHVibGljIEFQSVxuXHQqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEEgbW91c2UvdG91Y2ggZXZlbnQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjYW5jZWxQaW5uZWRNb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBtYWtlIGl0IGxvb2sgbGlrZSB3ZSdyZSBkcm9wcGluZyBpbiBvcmlnaW5hbCBsb2NhdGlvblxuXHRcdHRoaXMucGxhY2Vob2xkZXJSb3dJbmRleCA9IHRoaXMuZHJhZ2dpbmdSb3dJbmRleDtcblx0XHR0aGlzLmRyb3BQaW5uZWRSb3coZXZlbnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIHJvdyBpbmRleCB0aGF0IGlzIHVuZGVyIHRoZSBnaXZlbiBgeWAtcG9zaXRpb24gb24gdGhlIHBhZ2UuICBJZiB0aGVcblx0KiBwb3NpdGlvbiBpcyBvZmYgdGhlIGVuZCBvZiB0aGUgbGlzdCwgYHRoaXMuY291bnRgIGlzIHJldHVybmVkLiBJZiB0aGUgcG9zaXRpb25cblx0KiBpcyBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBsaXN0LCBgLTFgIGlzIHJldHVybmVkLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHkgLSBgeWAgcG9zaXRpb24gaW4gcGl4ZWxzIGluIHJlbGF0aW9uIHRvIHRoZSBwYWdlLlxuXHQqIEByZXR1cm4ge051bWJlcn0gIC0gVGhlIGluZGV4IG9mIHRoZSByb3cgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRSb3dJbmRleEZyb21Db29yZGluYXRlOiBmdW5jdGlvbiAoeSkge1xuXHRcdC8vIEZJWE1FOiB0aGlzIGNvZGUgb25seSB3b3JrcyB3aXRoIHZlcnRpY2FsIGxpc3RzXG5cdFx0dmFyIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXRTY3JvbGxUb3AoKSArIHkgLSBkb20uY2FsY05vZGVQb3NpdGlvbih0aGlzLmhhc05vZGUoKSkudG9wO1xuXHRcdC8vIGhhcHBlbnMgaWYgd2UgdHJ5IHRvIGRyYWcgcGFzdCB0b3Agb2YgbGlzdFxuXHRcdGlmIChjdXJzb3JQb3NpdGlvbiA8IDApIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0dmFyIHBhZ2VJbmZvID0gdGhpcy5wb3NpdGlvblRvUGFnZUluZm8oY3Vyc29yUG9zaXRpb24pO1xuXHRcdHZhciByb3dzID0gKHBhZ2VJbmZvLm5vID09IHRoaXMucDApID8gdGhpcy5wMFJvd0JvdW5kcyA6IHRoaXMucDFSb3dCb3VuZHM7XG5cdFx0Ly8gbWlnaHQgaGF2ZSBvbmx5IHJlbmRlcmVkIG9uZSBwYWdlLCBzbyBjYXRjaCB0aGF0IGhlcmVcblx0XHRpZiAoIXJvd3MpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvdW50O1xuXHRcdH1cblx0XHR2YXIgcG9zT25QYWdlID0gcGFnZUluZm8ucG9zO1xuXHRcdHZhciBwbGFjZWhvbGRlckhlaWdodCA9IHRoaXMucGxhY2Vob2xkZXJOb2RlID8gZG9tLmdldEJvdW5kcyh0aGlzLnBsYWNlaG9sZGVyTm9kZSkuaGVpZ2h0IDogMDtcblx0XHR2YXIgdG90YWxIZWlnaHQgPSAwO1xuXHRcdGZvciAodmFyIGk9cGFnZUluZm8uc3RhcnRSb3c7IGkgPD0gcGFnZUluZm8uZW5kUm93OyArK2kpIHtcblx0XHRcdC8vIGRvIGV4dHJhIGNoZWNrIGZvciByb3cgdGhhdCBoYXMgcGxhY2Vob2xkZXIgYXMgd2UnbGwgcmV0dXJuIC0xIGhlcmUgZm9yIG5vIG1hdGNoXG5cdFx0XHRpZiAoaSA9PT0gdGhpcy5wbGFjZWhvbGRlclJvd0luZGV4KSB7XG5cdFx0XHRcdC8vIGZvciBwbGFjZWhvbGRlclxuXHRcdFx0XHR0b3RhbEhlaWdodCArPSBwbGFjZWhvbGRlckhlaWdodDtcblx0XHRcdFx0aWYgKHRvdGFsSGVpZ2h0ID49IHBvc09uUGFnZSkge1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gb3JpZ2luYWxseSBkcmFnZ2VkIHJvdyBpcyBoaWRkZW4sIHNvIGRvbid0IGNvdW50IGl0XG5cdFx0XHRpZiAoaSAhPT0gdGhpcy5kcmFnZ2luZ1Jvd0luZGV4KSB7XG5cdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IHJvd3NbaV0uaGVpZ2h0O1xuXHRcdFx0XHRpZiAodG90YWxIZWlnaHQgPj0gcG9zT25QYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGk7XG5cdH0sXG5cblx0LyoqXG5cdCogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSBub2RlIChpZGVudGlmaWVkIHZpYSBpbmRleCkgb24gdGhlIHBhZ2UuXG5cdCpcblx0KiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwb3NpdGlvbiBvZiB0aGUgcm93IG5vZGUuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0SW5kZXhQb3NpdGlvbjogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0cmV0dXJuIGRvbS5jYWxjTm9kZVBvc2l0aW9uKHRoaXMuJC5nZW5lcmF0b3IuZmV0Y2hSb3dOb2RlKGluZGV4KSk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgc3BlY2lmaWVkIGNvbnRyb2wncyBwb3NpdGlvbiB0byBtYXRjaCB0aGF0IG9mIHRoZSBsaXN0IHJvdyBhdCBgaW5kZXhgLlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLkNvbnRyb2x9IGl0ZW0gLSBUaGUgY29udHJvbCB0byByZXBvc2l0aW9uLlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgIC0gVGhlIGluZGV4IG9mIHRoZSByb3cgd2hvc2UgcG9zaXRpb24gaXMgdG8gYmUgbWF0Y2hlZC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZXRJdGVtUG9zaXRpb246IGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuXHRcdHZhciBjbG9uZWROb2RlU3R5bGUgPSB0aGlzLmdldE5vZGVTdHlsZShpbmRleCk7XG5cdFx0dmFyIHRvcCA9ICh0aGlzLmdldFN0cmF0ZWd5S2luZCgpID09ICdTY3JvbGxTdHJhdGVneScpID8gY2xvbmVkTm9kZVN0eWxlLnRvcCA6IGNsb25lZE5vZGVTdHlsZS50b3AgLSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXHRcdHZhciBzdHlsZVN0ciA9ICd0b3A6Jyt0b3ArJ3B4OyBsZWZ0OicrY2xvbmVkTm9kZVN0eWxlLmxlZnQrJ3B4Oyc7XG5cdFx0aXRlbS5hZGRTdHlsZXMoc3R5bGVTdHIpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIHNwZWNpZmllZCBjb250cm9sJ3Mgd2lkdGggYW5kIGhlaWdodCB0byBtYXRjaCB0aG9zZSBvZiB0aGUgbGlzdCByb3cgYXQgYGluZGV4YC5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5Db250cm9sfSBpdGVtIC0gVGhlIGNvbnRyb2wgdG8gcmVwb3NpdGlvbi5cblx0KiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHdob3NlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHRvIGJlIG1hdGNoZWQuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0SXRlbUJvdW5kczogZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG5cdFx0dmFyIGNsb25lZE5vZGVTdHlsZSA9IHRoaXMuZ2V0Tm9kZVN0eWxlKGluZGV4KTtcblx0XHR2YXIgc3R5bGVTdHIgPSAnd2lkdGg6JytjbG9uZWROb2RlU3R5bGUudysncHg7IGhlaWdodDonK2Nsb25lZE5vZGVTdHlsZS5oKydweDsnO1xuXHRcdGl0ZW0uYWRkU3R5bGVzKHN0eWxlU3RyKTtcblx0fSxcblxuXHQvKipcblx0KiBXaGVuIGluIHBpbm5lZCByZW9yZGVyIG1vZGUsIHJlcG9zaXRpb25zIHRoZSBwaW5uZWQgcGxhY2Vob2xkZXIgd2hlbiB0aGVcblx0KiB1c2VyIGhhcyBzY3JvbGxlZCBmYXIgZW5vdWdoLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVvcmRlclNjcm9sbDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIGlmIHdlIGFyZSB1c2luZyB0aGUgc3RhbmRhcmQgc2Nyb2xsIHN0cmF0ZWd5LCB3ZSBoYXZlIHRvIG1vdmUgdGhlIHBpbm5lZCByb3cgd2l0aCB0aGUgc2Nyb2xsaW5nXG5cdFx0aWYgKHRoaXMuZ2V0U3RyYXRlZ3lLaW5kKCkgPT0gJ1Njcm9sbFN0cmF0ZWd5Jykge1xuXHRcdFx0dGhpcy4kLnJlb3JkZXJDb250YWluZXIuYWRkU3R5bGVzKCd0b3A6JysodGhpcy5pbml0aWFsUGluUG9zaXRpb24rdGhpcy5nZXRTY3JvbGxUb3AoKS10aGlzLnJvd1NpemUpKydweDsnKTtcblx0XHR9XG5cdFx0Ly8geSBjb29yZGluYXRlIG9uIHNjcmVlbiBvZiB0aGUgcGlubmVkIGl0ZW0gZG9lc24ndCBjaGFuZ2UgYXMgd2Ugc2Nyb2xsIHRoaW5nc1xuXHRcdHRoaXMudXBkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbih0aGlzLmluaXRpYWxQaW5Qb3NpdGlvbik7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGlkZVJlb3JkZXJpbmdSb3c6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGlkZGVuTm9kZSA9IHRoaXMuaGFzTm9kZSgpLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWVueW8taW5kZXg9XCInICsgdGhpcy5kcmFnZ2luZ1Jvd0luZGV4ICsgJ1wiXScpO1xuXHRcdC8vIGhpZGUgZXhpc3Rpbmcgbm9kZVxuXHRcdGlmIChoaWRkZW5Ob2RlKSB7XG5cdFx0XHR0aGlzLmhpZGRlbk5vZGUgPSB0aGlzLmhpZGVOb2RlKGhpZGRlbk5vZGUpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpc1Jlb3JkZXJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHRoaXMuZHJhZ2dpbmdSb3dJbmRleCA+IC0xKTtcblx0fSxcblxuXHQvKipcblx0XHQtLS0tIFN3aXBlYWJsZSBmdW5jdGlvbmFsaXR5IC0tLS0tLS0tLS0tLVxuXHQqL1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzU3dpcGluZzogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHdlJ3JlIHN3aXBpbmcgd2hlbiB0aGUgaW5kZXggaXMgc2V0IGFuZCB3ZSdyZSBub3QgaW4gdGhlIG1pZGRsZSBvZiBjb21wbGV0aW5nIG9yIGJhY2tpbmcgb3V0IGEgc3dpcGVcblx0XHRyZXR1cm4gKHRoaXMuc3dpcGVJbmRleCAhPSBudWxsICYmICF0aGlzLnN3aXBlQ29tcGxldGUgJiYgdGhpcy5zd2lwZURpcmVjdGlvbiAhPSBudWxsKTtcblx0fSxcblxuXHQvKipcblx0KiBXaGVuIGEgZHJhZyBzdGFydHMsIGdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZHJhZyBhcyB3ZWxsIGFzIHRoZSBpbmRleFxuXHQqIG9mIHRoZSBpdGVtIGJlaW5nIGRyYWdnZWQsIGFuZCByZXNldHMgYW55IHBlcnRpbmVudCB2YWx1ZXMuIFRoZW4ga2lja3Ncblx0KiBvZmYgdGhlIHN3aXBlIHNlcXVlbmNlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3dpcGVEcmFnU3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gaWYgd2UncmUgbm90IG9uIGEgcm93IG9yIHRoZSBzd2lwZSBpcyB2ZXJ0aWNhbCBvciBpZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHJlb3JkZXJpbmcsIGp1c3Qgc2F5IG5vXG5cdFx0aWYgKGV2ZW50LmluZGV4ID09IG51bGwgfHwgZXZlbnQudmVydGljYWwpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIGlmIHdlIGFyZSB3YWl0aW5nIHRvIGNvbXBsZXRlIGEgc3dpcGUsIGNvbXBsZXRlIGl0XG5cdFx0aWYgKHRoaXMuY29tcGxldGVTd2lwZVRpbWVvdXQpIHtcblx0XHRcdHRoaXMuY29tcGxldGVTd2lwZShldmVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgc3dpcGUgY29tcGxldGUgZmxhZ1xuXHRcdHRoaXMuc3dpcGVDb21wbGV0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKHRoaXMuc3dpcGVJbmRleCAhPSBldmVudC5pbmRleCkge1xuXHRcdFx0dGhpcy5jbGVhclN3aXBlYWJsZXMoKTtcblx0XHRcdHRoaXMuc3dpcGVJbmRleCA9IGV2ZW50LmluZGV4O1xuXHRcdH1cblx0XHR0aGlzLnN3aXBlRGlyZWN0aW9uID0gZXZlbnQueERpcmVjdGlvbjtcblxuXHRcdC8vIHN0YXJ0IHN3aXBlIHNlcXVlbmNlIG9ubHkgaWYgd2UgYXJlIG5vdCBjdXJyZW50bHkgc2hvd2luZyBhIHBlcnNpc3RlbnQgaXRlbVxuXHRcdGlmICghdGhpcy5wZXJzaXN0ZW50SXRlbVZpc2libGUpIHtcblx0XHRcdHRoaXMuc3RhcnRTd2lwZShldmVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgZHJhZ2dlZCBkaXN0YW5jZSAoZm9yIGRyYWdmaW5pc2gpXG5cdFx0dGhpcy5kcmFnZ2VkWERpc3RhbmNlID0gMDtcblx0XHR0aGlzLmRyYWdnZWRZRGlzdGFuY2UgPSAwO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogV2hlbiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3MsIHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzd2lwZWFibGVcblx0KiBjb250YWluZXIgYmFzZWQgb24gdGhlIGBkZHhgIG9mIHRoZSBldmVudC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN3aXBlRHJhZzogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHQvLyBpZiBhIHBlcnNpc3RlbnQgc3dpcGVhYmxlSXRlbSBpcyBzdGlsbCBzaG93aW5nLCBoYW5kbGUgaXQgc2VwYXJhdGVseVxuXHRcdGlmICh0aGlzLnBlcnNpc3RlbnRJdGVtVmlzaWJsZSkge1xuXHRcdFx0dGhpcy5kcmFnUGVyc2lzdGVudEl0ZW0oZXZlbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXMucHJldmVudERyYWdQcm9wYWdhdGlvbjtcblx0XHR9XG5cdFx0Ly8gZWFybHkgZXhpdCBpZiB0aGVyZSdzIG5vIG1hdGNoaW5nIGRyYWdTdGFydCB0byBzZXQgaXRlbVxuXHRcdGlmICghdGhpcy5pc1N3aXBpbmcoKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBhcHBseSBuZXcgcG9zaXRpb25cblx0XHR0aGlzLmRyYWdTd2lwZWFibGVDb21wb25lbnRzKHRoaXMuY2FsY05ld0RyYWdQb3NpdGlvbihldmVudC5kZHgpKTtcblx0XHQvLyBzYXZlIGRyYWdnZWQgZGlzdGFuY2UgKGZvciBkcmFnZmluaXNoKVxuXHRcdHRoaXMuZHJhZ2dlZFhEaXN0YW5jZSA9IGV2ZW50LmR4O1xuXHRcdHRoaXMuZHJhZ2dlZFlEaXN0YW5jZSA9IGV2ZW50LmR5O1xuXHRcdC8vIHNhdmUgbGFzdCBtZWFuaW5nZnVsIChub24temVybykgYW5kIG5ldyBkaXJlY3Rpb24gKGZvciBzd2lwZURyYWdGaW5pc2gpXG5cdFx0aWYgKGV2ZW50LnhEaXJlY3Rpb24gIT0gdGhpcy5sYXN0U3dpcGVEaXJlY3Rpb24gJiYgZXZlbnQueERpcmVjdGlvbikge1xuXHRcdFx0dGhpcy5sYXN0U3dpcGVEaXJlY3Rpb24gPSBldmVudC54RGlyZWN0aW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKlxuXHQqIFdoZW4gdGhlIGN1cnJlbnQgZHJhZyBjb21wbGV0ZXMsIGRlY2lkZXMgd2hldGhlciB0byBjb21wbGV0ZSB0aGUgc3dpcGVcblx0KiBiYXNlZCBvbiBob3cgZmFyIHRoZSB1c2VyIHB1bGxlZCB0aGUgc3dpcGVhYmxlIGNvbnRhaW5lci5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN3aXBlRHJhZ0ZpbmlzaDogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHQvLyBpZiBhIHBlcnNpc3RlbnQgc3dpcGVhYmxlSXRlbSBpcyBzdGlsbCBzaG93aW5nLCBjb21wbGV0ZSBkcmFnIGF3YXkgb3IgYm91bmNlXG5cdFx0aWYgKHRoaXMucGVyc2lzdGVudEl0ZW1WaXNpYmxlKSB7XG5cdFx0XHR0aGlzLmRyYWdGaW5pc2hQZXJzaXN0ZW50SXRlbShldmVudCk7XG5cdFx0Ly8gZWFybHkgZXhpdCBpZiB0aGVyZSdzIG5vIG1hdGNoaW5nIGRyYWdTdGFydCB0byBzZXQgaXRlbVxuXHRcdH0gZWxzZSBpZiAoIXRoaXMuaXNTd2lwaW5nKCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHQvLyBvdGhlcndpc2UgaWYgdXNlciBkcmFnZ2VkIG1vcmUgdGhhbiAyMCUgb2YgdGhlIHdpZHRoLCBjb21wbGV0ZSB0aGUgc3dpcGUuIGlmIG5vdCwgYmFjayBvdXQuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwZXJjZW50YWdlRHJhZ2dlZCA9IHRoaXMuY2FsY1BlcmNlbnRhZ2VEcmFnZ2VkKHRoaXMuZHJhZ2dlZFhEaXN0YW5jZSk7XG5cdFx0XHRpZiAoKHBlcmNlbnRhZ2VEcmFnZ2VkID4gdGhpcy5wZXJjZW50YWdlRHJhZ2dlZFRocmVzaG9sZCkgJiYgKHRoaXMubGFzdFN3aXBlRGlyZWN0aW9uID09PSB0aGlzLnN3aXBlRGlyZWN0aW9uKSkge1xuXHRcdFx0XHR0aGlzLnN3aXBlKHRoaXMuZmFzdFN3aXBlU3BlZWRNUyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmJhY2tPdXRTd2lwZShldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHJldmVudERyYWdQcm9wYWdhdGlvbjtcblx0fSxcblxuXHQvKipcblx0KiBSZW9yZGVyIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBzd2lwZXMsIGFuZCBub3QgaGF2aW5nIGl0IHR1cm5lZCBvbiBvciBzd2lwZWFibGUgY29udHJvbHNcblx0KiBkZWZpbmVkIGFsc28gZGlzYWJsZXMgdGhpcy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzU3dpcGVhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW5hYmxlU3dpcGUgJiYgdGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuY29udHJvbHMubGVuZ3RoICE9PSAwICYmXG5cdFx0XHQhdGhpcy5pc1Jlb3JkZXJpbmcoKSAmJiAhdGhpcy5waW5uZWRSZW9yZGVyTW9kZTtcblx0fSxcblxuXHQvKipcblx0KiBQb3NpdGlvbnMgdGhlIHN3aXBlYWJsZSBjb21wb25lbnRzIGJsb2NrIGF0IHRoZSBjdXJyZW50IHJvdy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgIC0gVGhlIHJvdyBpbmRleC5cblx0KiBAcGFyYW0ge051bWJlcn0geERpcmVjdGlvbiAtIFZhbHVlIG9mIGB4RGlyZWN0aW9uYCBmcm9tIGRyYWcgZXZlbnQgKGAxYCA9IHJpZ2h0LFxuXHQqIGAtMWAgPSBsZWZ0KS5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwb3NpdGlvblN3aXBlYWJsZUNvbnRhaW5lcjogZnVuY3Rpb24gKGluZGV4LCB4RGlyZWN0aW9uKSB7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLiQuZ2VuZXJhdG9yLmZldGNoUm93Tm9kZShpbmRleCk7XG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldFJlbGF0aXZlT2Zmc2V0KG5vZGUsIHRoaXMuaGFzTm9kZSgpKTtcblx0XHR2YXIgZGltZW5zaW9ucyA9IGRvbS5nZXRCb3VuZHMobm9kZSk7XG5cdFx0dmFyIHggPSAoeERpcmVjdGlvbiA9PSAxKSA/IC0xKmRpbWVuc2lvbnMud2lkdGggOiBkaW1lbnNpb25zLndpZHRoO1xuXHRcdHRoaXMuJC5zd2lwZWFibGVDb21wb25lbnRzLmFkZFN0eWxlcygndG9wOiAnK29mZnNldC50b3ArJ3B4OyBsZWZ0OiAnK3grJ3B4OyBoZWlnaHQ6ICcrZGltZW5zaW9ucy5oZWlnaHQrJ3B4OyB3aWR0aDogJytkaW1lbnNpb25zLndpZHRoKydweDsnKTtcblx0fSxcblxuXHQvKipcblx0KiBDYWxjdWxhdGVzIG5ldyBwb3NpdGlvbiBmb3IgdGhlIHN3aXBlYWJsZSBjb250YWluZXIgYmFzZWQgb24gdGhlIHVzZXInc1xuXHQqIGRyYWcgYWN0aW9uLiBEb24ndCBhbGxvdyB0aGUgY29udGFpbmVyIHRvIGRyYWcgYmV5b25kIGVpdGhlciBlZGdlLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGR4IC0gQW1vdW50IG9mIGNoYW5nZSBpbiBgeGAgcG9zaXRpb24uXG5cdCogQHJldHVybiB7TnVtYmVyfVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNOZXdEcmFnUG9zaXRpb246IGZ1bmN0aW9uIChkeCkge1xuXHRcdHZhciBwYXJlbnRCb3VuZHMgPSB0aGlzLiQuc3dpcGVhYmxlQ29tcG9uZW50cy5nZXRCb3VuZHMoKTtcblx0XHR2YXIgeFBvcyA9IHBhcmVudEJvdW5kcy5sZWZ0O1xuXHRcdHZhciBkaW1lbnNpb25zID0gdGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuZ2V0Qm91bmRzKCk7XG5cdFx0dmFyIHhsaW1pdCA9ICh0aGlzLnN3aXBlRGlyZWN0aW9uID09IDEpID8gMCA6IC0xKmRpbWVuc2lvbnMud2lkdGg7XG5cdFx0dmFyIHggPSAodGhpcy5zd2lwZURpcmVjdGlvbiA9PSAxKVxuXHRcdFx0PyAoeFBvcyArIGR4ID4geGxpbWl0KVxuXHRcdFx0XHQ/IHhsaW1pdFxuXHRcdFx0XHQ6IHhQb3MgKyBkeFxuXHRcdFx0OiAoeFBvcyArIGR4IDwgeGxpbWl0KVxuXHRcdFx0XHQ/IHhsaW1pdFxuXHRcdFx0XHQ6IHhQb3MgKyBkeDtcblx0XHRyZXR1cm4geDtcblx0fSxcblxuXHQvKipcblx0KiBQb3NpdGlvbnMgdGhlIHN3aXBlYWJsZSBjb21wb25lbnRzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHggLSBOZXcgYGxlZnRgIHBvc2l0aW9uLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdTd2lwZWFibGVDb21wb25lbnRzOiBmdW5jdGlvbiAoeCkge1xuXHRcdHRoaXMuJC5zd2lwZWFibGVDb21wb25lbnRzLmFwcGx5U3R5bGUoJ2xlZnQnLHgrJ3B4Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQmVnaW5zIHN3aXBpbmcgc2VxdWVuY2UgYnkgcG9zaXRpb25pbmcgdGhlIHN3aXBlYWJsZSBjb250YWluZXIgYW5kXG5cdCogYnViYmxpbmcgdGhlIGBzZXR1cFN3aXBlSXRlbWAgZXZlbnQuXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50XG5cdCogQGZpcmVzIGVueW8uTGlzdCNvblNldHVwU3dpcGVJdGVtXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhcnRTd2lwZTogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBtb2RpZnkgZXZlbnQgaW5kZXggdG8gYWx3YXlzIGhhdmUgdGhpcyBzd2lwZUl0ZW0gdmFsdWVcblx0XHRlLmluZGV4ID0gdGhpcy5zd2lwZUluZGV4O1xuXHRcdHRoaXMucG9zaXRpb25Td2lwZWFibGVDb250YWluZXIodGhpcy5zd2lwZUluZGV4LCBlLnhEaXJlY3Rpb24pO1xuXHRcdHRoaXMuJC5zd2lwZWFibGVDb21wb25lbnRzLnNldFNob3dpbmcodHJ1ZSk7XG5cdFx0dGhpcy5zZXRQZXJzaXN0ZW50SXRlbU9yaWdpbihlLnhEaXJlY3Rpb24pO1xuXHRcdHRoaXMuZG9TZXR1cFN3aXBlSXRlbShlKTtcblx0fSxcblxuXHQvKipcblx0KiBJZiBhIHBlcnNpc3RlbnQgc3dpcGVhYmxlSXRlbSBpcyBzdGlsbCBzaG93aW5nLCBkcmFncyBpdCBhd2F5IG9yIGJvdW5jZXMgaXQuXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50XG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ1BlcnNpc3RlbnRJdGVtOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB4UG9zID0gMDtcblx0XHR2YXIgeCA9ICh0aGlzLnBlcnNpc3RlbnRJdGVtT3JpZ2luID09ICdyaWdodCcpXG5cdFx0XHQ/IE1hdGgubWF4KHhQb3MsICh4UG9zICsgZS5keCkpXG5cdFx0XHQ6IE1hdGgubWluKHhQb3MsICh4UG9zICsgZS5keCkpO1xuXHRcdHRoaXMuJC5zd2lwZWFibGVDb21wb25lbnRzLmFwcGx5U3R5bGUoJ2xlZnQnLHgrJ3B4Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCogSWYgYSBwZXJzaXN0ZW50IHN3aXBlYWJsZUl0ZW0gaXMgc3RpbGwgc2hvd2luZywgY29tcGxldGVzIGRyYWcgYXdheSBvciBib3VuY2UuXG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50XG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ0ZpbmlzaFBlcnNpc3RlbnRJdGVtOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBjb21wbGV0ZVN3aXBlID0gKHRoaXMuY2FsY1BlcmNlbnRhZ2VEcmFnZ2VkKGUuZHgpID4gMC4yKTtcblx0XHR2YXIgZGlyID0gKGUuZHggPiAwKSA/ICdyaWdodCcgOiAoZS5keCA8IDApID8gJ2xlZnQnIDogbnVsbDtcblx0XHRpZiAodGhpcy5wZXJzaXN0ZW50SXRlbU9yaWdpbiA9PSBkaXIpIHtcblx0XHRcdGlmIChjb21wbGV0ZVN3aXBlKSB7XG5cdFx0XHRcdHRoaXMuc2xpZGVBd2F5SXRlbSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ib3VuY2VJdGVtKGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmJvdW5jZUl0ZW0oZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldFBlcnNpc3RlbnRJdGVtT3JpZ2luOiBmdW5jdGlvbiAoeERpcmVjdGlvbikge1xuXHRcdHRoaXMucGVyc2lzdGVudEl0ZW1PcmlnaW4gPSB4RGlyZWN0aW9uID09IDEgPyAnbGVmdCcgOiAncmlnaHQnO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNQZXJjZW50YWdlRHJhZ2dlZDogZnVuY3Rpb24gKGR4KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKGR4L3RoaXMuJC5zd2lwZWFibGVDb21wb25lbnRzLmdldEJvdW5kcygpLndpZHRoKTtcblx0fSxcblxuXHQvKipcblx0KiBDb21wbGV0ZXMgYSBzd2lwZSBhbmltYXRpb24gaW4gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkIC0gVGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3dpcGU6IGZ1bmN0aW9uIChzcGVlZCkge1xuXHRcdHRoaXMuc3dpcGVDb21wbGV0ZSA9IHRydWU7XG5cdFx0dGhpcy5hbmltYXRlU3dpcGUoMCwgc3BlZWQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGJhY2tPdXRTd2lwZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkaW1lbnNpb25zID0gdGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuZ2V0Qm91bmRzKCk7XG5cdFx0dmFyIHggPSAodGhpcy5zd2lwZURpcmVjdGlvbiA9PSAxKSA/IC0xKmRpbWVuc2lvbnMud2lkdGggOiBkaW1lbnNpb25zLndpZHRoO1xuXHRcdHRoaXMuYW5pbWF0ZVN3aXBlKHgsIHRoaXMuZmFzdFN3aXBlU3BlZWRNUyk7XG5cdFx0dGhpcy5zd2lwZURpcmVjdGlvbiA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyBwZXJzaXN0ZWQgc3dpcGVhYmxlIGNvbXBvbmVudHMgdG8gYmVpbmcgdmlzaWJsZSBpZiBub3QgZHJhZ2dlZCBiYWNrXG5cdCogYmV5b25kIHRocmVzaG9sZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGJvdW5jZUl0ZW06IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKGJvdW5kcy5sZWZ0ICE9IGJvdW5kcy53aWR0aCkge1xuXHRcdFx0dGhpcy5hbmltYXRlU3dpcGUoMCwgdGhpcy5ub3JtYWxTd2lwZVNwZWVkTVMpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBBbmltYXRlcyB0aGUgc3dpcGVhYmxlIGNvbXBvbmVudHMgYXdheSBzdGFydGluZyBmcm9tIHRoZWlyIGN1cnJlbnQgcG9zaXRpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzbGlkZUF3YXlJdGVtOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyICRpdGVtID0gdGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHM7XG5cdFx0dmFyIHBhcmVudFdpZHRoID0gJGl0ZW0uZ2V0Qm91bmRzKCkud2lkdGg7XG5cdFx0dmFyIHhQb3MgPSAodGhpcy5wZXJzaXN0ZW50SXRlbU9yaWdpbiA9PSAnbGVmdCcpID8gLTEqcGFyZW50V2lkdGggOiBwYXJlbnRXaWR0aDtcblx0XHR0aGlzLmFuaW1hdGVTd2lwZSh4UG9zLCB0aGlzLm5vcm1hbFN3aXBlU3BlZWRNUyk7XG5cdFx0dGhpcy5wZXJzaXN0ZW50SXRlbVZpc2libGUgPSBmYWxzZTtcblx0XHR0aGlzLnNldFBlcnNpc3RTd2lwZWFibGVJdGVtKGZhbHNlKTtcblx0fSxcblxuXHQvKipcblx0KiBIaWRlcyB0aGUgc3dpcGVhYmxlIGNvbXBvbmVudHMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGVhclN3aXBlYWJsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuc3dpcGVhYmxlQ29tcG9uZW50cy5zZXRTaG93aW5nKGZhbHNlKTtcblx0XHR0aGlzLnBlcnNpc3RlbnRJdGVtVmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMuc2V0UGVyc2lzdFN3aXBlYWJsZUl0ZW0oZmFsc2UpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENvbXBsZXRlcyBzd2lwZSBhbmQgaGlkZXMgYWN0aXZlIHN3aXBlYWJsZSBpdGVtLlxuXHQqXG5cdCogQGZpcmVzIGVueW8uTGlzdCNvblN3aXBlQ29tcGxldGVcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZVN3aXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuY29tcGxldGVTd2lwZVRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNvbXBsZXRlU3dpcGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuY29tcGxldGVTd2lwZVRpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0XHQvLyBpZiB0aGlzIHdhc24ndCBhIHBlcnNpc3RlbnQgaXRlbSwgaGlkZSBpdCB1cG9uIGNvbXBsZXRpb24gYW5kIHNlbmQgc3dpcGUgY29tcGxldGUgZXZlbnRcblx0XHRpZiAoIXRoaXMuZ2V0UGVyc2lzdFN3aXBlYWJsZUl0ZW0oKSkge1xuXHRcdFx0dGhpcy4kLnN3aXBlYWJsZUNvbXBvbmVudHMuc2V0U2hvd2luZyhmYWxzZSk7XG5cdFx0XHQvLyBpZiB0aGUgc3dpcGUgd2FzIGNvbXBsZXRlZCwgdXBkYXRlIHRoZSBjdXJyZW50IHJvdyBhbmQgYnViYmxlIHN3aXBlQ29tcGxldGUgZXZlbnRcblx0XHRcdGlmICh0aGlzLnN3aXBlQ29tcGxldGUpIHtcblx0XHRcdFx0dGhpcy5kb1N3aXBlQ29tcGxldGUoe2luZGV4OiB0aGlzLnN3aXBlSW5kZXgsIHhEaXJlY3Rpb246IHRoaXMuc3dpcGVEaXJlY3Rpb259KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGVyc2lzdGVudCBpdGVtIHdpbGwgb25seSBiZSB2aXNpYmxlIGlmIHRoZSBzd2lwZSB3YXMgY29tcGxldGVkXG5cdFx0XHRpZiAodGhpcy5zd2lwZUNvbXBsZXRlKSB7XG5cdFx0XHRcdHRoaXMucGVyc2lzdGVudEl0ZW1WaXNpYmxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5zd2lwZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLnN3aXBlRGlyZWN0aW9uID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0KiBBbmltYXRlcyBhIHN3aXBlIHN0YXJ0aW5nIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHNwZWNpZmllZCBuZXdcblx0KiBwb3NpdGlvbiBgKHRhcmdldFgpYCBvdmVyIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIG9mIHRpbWUgYCh0b3RhbFRpbWVNUylgLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldFggICAgIC0gVGhlIHRhcmdldCBgbGVmdGAgcG9zaXRpb24uXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsVGltZU1TIC0gVGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YW5pbWF0ZVN3aXBlOiBmdW5jdGlvbiAodGFyZ2V0WCwgdG90YWxUaW1lTVMpIHtcblx0XHR2YXIgdDAgPSB1dGlscy5ub3coKTtcblx0XHR2YXIgJGl0ZW0gPSB0aGlzLiQuc3dpcGVhYmxlQ29tcG9uZW50cztcblx0XHR2YXIgb3JpZ1ggPSBwYXJzZUludCgkaXRlbS5nZXRCb3VuZHMoKS5sZWZ0LCAxMCk7XG5cdFx0dmFyIHhEZWx0YSA9IHRhcmdldFggLSBvcmlnWDtcblxuXHRcdHRoaXMuc3RvcEFuaW1hdGVTd2lwZSgpO1xuXG5cdFx0dmFyIGZuID0gdGhpcy5iaW5kU2FmZWx5KGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0ID0gdXRpbHMubm93KCkgLSB0MDtcblx0XHRcdHZhciBwZXJjVGltZUVsYXBzZWQgPSB0L3RvdGFsVGltZU1TO1xuXHRcdFx0dmFyIGN1cnJlbnRYID0gb3JpZ1ggKyAoeERlbHRhKSpNYXRoLm1pbihwZXJjVGltZUVsYXBzZWQsMSk7XG5cblx0XHRcdC8vIHNldCBuZXcgbGVmdFxuXHRcdFx0JGl0ZW0uYXBwbHlTdHlsZSgnbGVmdCcsIGN1cnJlbnRYKydweCcpO1xuXG5cdFx0XHQvLyBzY2hlZHVsZSBuZXh0IGZyYW1lXG5cdFx0XHR0aGlzLmpvYiA9IGFuaW1hdGlvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuXG5cdFx0XHQvLyBwb3RlbnRpYWxseSBvdmVycmlkZSBhbmltYXRpb24gVE9ET1xuXG5cdFx0XHQvLyBnbyB1bnRpbCB3ZSd2ZSBoaXQgb3VyIHRvdGFsIHRpbWVcblx0XHRcdGlmICh0L3RvdGFsVGltZU1TID49IDEpIHtcblx0XHRcdFx0dGhpcy5zdG9wQW5pbWF0ZVN3aXBlKCk7XG5cdFx0XHRcdHRoaXMuY29tcGxldGVTd2lwZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuYmluZFNhZmVseShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5jb21wbGV0ZVN3aXBlKCk7XG5cdFx0XHRcdH0pLCB0aGlzLmNvbXBsZXRlU3dpcGVEZWxheU1TKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuam9iID0gYW5pbWF0aW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FuY2VscyB0aGUgYWN0aXZlIHN3aXBlIGFuaW1hdGlvbi5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0b3BBbmltYXRlU3dpcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5qb2IpIHtcblx0XHRcdHRoaXMuam9iID0gYW5pbWF0aW9uLmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmpvYik7XG5cdFx0fVxuXHR9XG59O1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9hbmltYXRpb25cIjo1NixcIi4uLy4uLy4uL2VueW8vbGliL2RvbVwiOjU4LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvbG9nZ2VyXCI6NjcsXCIuLi8uLi8uLi9lbnlvL2xpYi9wbGF0Zm9ybVwiOjcxLFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdEJpbmRpbmcgPSByZXF1aXJlKCcuL0JpbmRpbmcnKTtcblxua2luZC5jb25jYXRlbmF0ZWQucHVzaCgnYmluZGluZ3MnKTtcblxuLyoqXG4qIEFuIGludGVybmFsbHktdXNlZCB7QGdsb3NzYXJ5IG1peGlufSB0aGF0IGlzIGFkZGVkIHRvIHtAbGluayBlbnlvLk9iamVjdH1cbiogYW5kIGl0cyBbc3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfS4gSXQgaW5jbHVkZXMgcHVibGljIGFuZCBwcm90ZWN0ZWQgQVBJXG4qIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBbYmluZGluZ3Nde0BsaW5rIGVueW8uQmluZGluZ30uXG4qXG4qIEBtaXhpbiBlbnlvLkJpbmRpbmdTdXBwb3J0XG4qIEBwcm90ZWN0ZWRcbiovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnQmluZGluZ1N1cHBvcnQnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2JpbmRpbmdTdXBwb3J0SW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXHRcblx0LyoqXG5cdCogSW1wZXJhdGl2ZWx5IGNyZWF0ZXMgYSBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfS4gTWVyZ2VzIGEgdmFyaWFibGVcblx0KiBudW1iZXIgb2YgW2hhc2hlc117QGdsb3NzYXJ5IE9iamVjdH0gYW5kIGluc3RhbnRpYXRlcyBhIGJpbmRpbmcgdGhhdFxuXHQqIHdpbGwgaGF2ZSBpdHMgW293bmVyXXtAbGluayBlbnlvLkJpbmRpbmcjb3duZXJ9IHByb3BlcnR5IHNldCB0byB0aGUgY2FsbGVlXG5cdCogKHRoZSBjdXJyZW50IHtAbGluayBlbnlvLk9iamVjdH0pLiBCaW5kaW5ncyBjcmVhdGVkIGluIHRoaXMgd2F5IHdpbGwgYmVcblx0KiBbZGVzdHJveWVkXXtAbGluayBlbnlvLkJpbmRpbmcjZGVzdHJveX0gd2hlbiB0aGVpciBgb3duZXJgIGlzXG5cdCogW2Rlc3Ryb3llZF17QGxpbmsgZW55by5PYmplY3QjZGVzdHJveX0uXG5cdCpcblx0KiBAcGFyYW0gey4uLk9iamVjdH0gcHJvcHMgQSB2YXJpYWJsZSBudW1iZXIgb2YgW2hhc2hlc117QGdsb3NzYXJ5IE9iamVjdH0gdGhhdCB3aWxsXG5cdCpcdGJlIG1lcmdlZCBpbnRvIHRoZSBwcm9wZXJ0aWVzIGFwcGxpZWQgdG8gdGhlIHtAbGluayBlbnlvLkJpbmRpbmd9IGluc3RhbmNlLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGJpbmRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXJncyA9IHV0aWxzLnRvQXJyYXkoYXJndW1lbnRzKVxuXHRcdFx0LCBwcm9wcyA9IHV0aWxzLm1peGluKGFyZ3MpXG5cdFx0XHQsIGJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncyB8fCAodGhpcy5iaW5kaW5ncyA9IFtdKVxuXHRcdFx0LCBDdG9yLCBibmQ7XG5cdFx0XHRcblx0XHRwcm9wcy5vd25lciA9IHByb3BzLm93bmVyIHx8IHRoaXM7XG5cdFx0Q3RvciA9IHByb3BzLmtpbmQgPSBwcm9wcy5raW5kIHx8IHRoaXMuZGVmYXVsdEJpbmRpbmdLaW5kIHx8IEJpbmRpbmcuZGVmYXVsdEJpbmRpbmdLaW5kO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9iaW5kaW5nU3VwcG9ydEluaXRpYWxpemVkKSB7XG5cdFx0XHR1dGlscy5pc1N0cmluZyhDdG9yKSAmJiAoQ3RvciA9IHByb3BzLmtpbmQgPSBraW5kLmNvbnN0cnVjdG9yRm9yS2luZChDdG9yKSk7XG5cdFx0XHRibmQgPSBuZXcgQ3Rvcihwcm9wcyk7XG5cdFx0XHRiaW5kaW5ncy5wdXNoKGJuZCk7XG5cdFx0XHRyZXR1cm4gYm5kO1xuXHRcdH0gZWxzZSBiaW5kaW5ncy5wdXNoKHByb3BzKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIFJlbW92ZXMgYW5kIFtkZXN0cm95c117QGxpbmsgZW55by5CaW5kaW5nI2Rlc3Ryb3l9IGFsbCBvZiwgb3IgYSBzdWJzZXQgb2YsXG5cdCogdGhlIFtiaW5kaW5nc117QGxpbmsgZW55by5CaW5kaW5nfSBiZWxvbmdpbmcgdG8gdGhlIGNhbGxlZS5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5CaW5kaW5nW119IFtzdWJzZXRdIC0gVGhlIG9wdGlvbmFsIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZlxuXHQqXHRbYmluZGluZ3Nde0BsaW5rIGVueW8uQmluZGluZ30gdG8gcmVtb3ZlLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGNsZWFyQmluZGluZ3M6IGZ1bmN0aW9uIChzdWJzZXQpIHtcblx0XHR2YXIgYmluZGluZ3MgPSBzdWJzZXQgfHwgKHRoaXMuYmluZGluZ3MgJiYgdGhpcy5iaW5kaW5ncy5zbGljZSgpKTtcblx0XHRiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChibmQpIHtcblx0XHRcdGJuZC5kZXN0cm95KCk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBSZW1vdmVzIGEgc2luZ2xlIHtAbGluayBlbnlvLkJpbmRpbmd9IGZyb20gdGhlIGNhbGxlZS4gKFRoaXMgZG9lcyBub3Rcblx0KiBbZGVzdHJveV17QGxpbmsgZW55by5CaW5kaW5nI2Rlc3Ryb3l9IHRoZSBiaW5kaW5nLikgQWxzbyByZW1vdmVzIHRoZVxuXHQqIFtvd25lcl17QGxpbmsgZW55by5CaW5kaW5nI293bmVyfSByZWZlcmVuY2UgaWYgaXQgaXMgdGhlIGNhbGxlZS5cblx0KlxuXHQqIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHdoZW4gYSBiaW5kaW5nIGlzIGRlc3Ryb3llZCwgaXQgaXMgYXV0b21hdGljYWxseVxuXHQqIHJlbW92ZWQgZnJvbSBpdHMgb3duZXIuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQmluZGluZ30gYmluZGluZyAtIFRoZSB7QGxpbmsgZW55by5CaW5kaW5nfSBpbnN0YW5jZSB0byByZW1vdmUuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVtb3ZlQmluZGluZzogZnVuY3Rpb24gKGJpbmRpbmcpIHtcblx0XHR1dGlscy5yZW1vdmUoYmluZGluZywgdGhpcy5iaW5kaW5ncyk7XG5cdFx0XG5cdFx0aWYgKGJpbmRpbmcub3duZXIgPT09IHRoaXMpIGJpbmRpbmcub3duZXIgPSBudWxsO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0ZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuYmluZGluZ3M7XG5cdFx0XHR0aGlzLl9iaW5kaW5nU3VwcG9ydEluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHRcdGJpbmRpbmdzICYmICh0aGlzLmJpbmRpbmdzID0gW10pICYmIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcoZGVmKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgJiYgdGhpcy5iaW5kaW5ncy5sZW5ndGggJiYgdGhpcy5jbGVhckJpbmRpbmdzKCk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gbnVsbDtcblx0XHR9O1xuXHR9KVxufTtcblxuLyoqXG5cdEhpamFjayB0aGUgb3JpZ2luYWwgc28gd2UgY2FuIGFkZCBhZGRpdGlvbmFsIGRlZmF1bHQgYmVoYXZpb3IuXG4qL1xudmFyIHN1cCA9IGtpbmQuY29uY2F0SGFuZGxlclxuXHQsIGZsYWdzID0ge2lnbm9yZTogdHJ1ZX07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmtpbmQuY29uY2F0SGFuZGxlciA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcywgaW5zdGFuY2UpIHtcblx0dmFyIHByb3RvID0gY3Rvci5wcm90b3R5cGUgfHwgY3RvclxuXHRcdCwga2luZCA9IHByb3BzICYmIChwcm9wcy5kZWZhdWx0QmluZGluZ0tpbmQgfHwgQmluZGluZy5kZWZhdWx0QmluZGluZ0tpbmQpXG5cdFx0LCBkZWZhdWx0cyA9IHByb3BzICYmIHByb3BzLmJpbmRpbmdEZWZhdWx0cztcblx0XG5cdHN1cC5jYWxsKHRoaXMsIGN0b3IsIHByb3BzLCBpbnN0YW5jZSk7XG5cdGlmIChwcm9wcy5iaW5kaW5ncykge1xuXHRcdHByb3BzLmJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJuZCkge1xuXHRcdFx0ZGVmYXVsdHMgJiYgdXRpbHMubWl4aW4oYm5kLCBkZWZhdWx0cywgZmxhZ3MpO1xuXHRcdFx0Ym5kLmtpbmQgfHwgKGJuZC5raW5kID0ga2luZCk7IFxuXHRcdH0pO1xuXHRcdFxuXHRcdHByb3RvLmJpbmRpbmdzID0gcHJvdG8uYmluZGluZ3M/IHByb3RvLmJpbmRpbmdzLmNvbmNhdChwcm9wcy5iaW5kaW5ncyk6IHByb3BzLmJpbmRpbmdzO1xuXHRcdGRlbGV0ZSBwcm9wcy5iaW5kaW5ncztcblx0fVxufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0JpbmRpbmdcIjo4LFwiLi9raW5kXCI6NjYsXCIuL3V0aWxzXCI6NzV9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXJcblx0QmluZGluZyA9IHJlcXVpcmUoJy4vQmluZGluZycpO1xuXG4vKipcbiogVGhlIHtAbGluayBlbnlvLlJlcGVhdGVyQ2hpbGRTdXBwb3J0fSBbbWl4aW5de0BnbG9zc2FyeSBtaXhpbn0gY29udGFpbnMgbWV0aG9kcyBhbmRcbiogcHJvcGVydGllcyB0aGF0IGFyZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gYWxsIGNoaWxkcmVuIG9mIHtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn1cbiogdG8gYXNzaXN0IGluIHNlbGVjdGlvbiBzdXBwb3J0LiAoU2VlIHtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0gZm9yIGRldGFpbHMgb24gaG93IHRvXG4qIHVzZSBzZWxlY3Rpb24gc3VwcG9ydC4pIFRoaXMgbWl4aW4gYWxzbyBbYWRkc117QGxpbmsgZW55by5SZXBlYXRlciNkZWNvcmF0ZUV2ZW50fSB0aGVcbiogYG1vZGVsYCwgYGNoaWxkYCAoW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gaW5zdGFuY2UpLCBhbmQgYGluZGV4YCBwcm9wZXJ0aWVzIHRvXG4qIGFsbCBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IGVtaXR0ZWQgZnJvbSB0aGUgcmVwZWF0ZXIncyBjaGlsZHJlbi5cbipcbiogQG1peGluIGVueW8uUmVwZWF0ZXJDaGlsZFN1cHBvcnRcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8qXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ1JlcGVhdGVyQ2hpbGRTdXBwb3J0JyxcblxuXHQvKipcblx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBzZWxlY3RlZCBpbiB0aGUgW3JlcGVhdGVyXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0uXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIFNldHRpbmcgY2FjaGVQb2ludDogdHJ1ZSBlbnN1cmVzIHRoYXQgZXZlbnRzIGZyb20gdGhlIHJlcGVhdGVyIGNoaWxkJ3Mgc3VidHJlZSB3aWxsXG5cdCogYWx3YXlzIGJ1YmJsZSB1cCB0aHJvdWdoIHRoZSBjaGlsZCwgYWxsb3dpbmcgdGhlIGV2ZW50cyB0byBiZSBkZWNvcmF0ZWQgd2l0aCByZXBlYXRlci1cblx0KiByZWxhdGVkIG1ldGFkYXRhIGFuZCByZWZlcmVuY2VzLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhY2hlUG9pbnQ6IHRydWUsXG5cdFxuXHQvKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZWxlY3RlZENoYW5nZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLnJlcGVhdGVyLnNlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLmFkZFJlbW92ZUNsYXNzKHRoaXMuc2VsZWN0ZWRDbGFzcyB8fCAnc2VsZWN0ZWQnLCB0aGlzLnNlbGVjdGVkKTtcblx0XHRcdFx0Ly8gZm9yIGVmZmljaWVuY3kgcHVycG9zZXMsIHdlIG5vdyBkaXJlY3RseSBjYWxsIHRoaXMgbWV0aG9kIGFzIG9wcG9zZWQgdG9cblx0XHRcdFx0Ly8gZm9yY2luZyBhIHN5bmNocm9ub3VzIGV2ZW50IGRpc3BhdGNoXG5cdFx0XHRcdHZhciBpZHggPSB0aGlzLnJlcGVhdGVyLmNvbGxlY3Rpb24uaW5kZXhPZih0aGlzLm1vZGVsKTtcblx0XHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWQgJiYgIXRoaXMucmVwZWF0ZXIuaXNTZWxlY3RlZCh0aGlzLm1vZGVsKSkge1xuXHRcdFx0XHRcdHRoaXMucmVwZWF0ZXIuc2VsZWN0KGlkeCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5yZXBlYXRlci5pc1NlbGVjdGVkKHRoaXMubW9kZWwpKSB7XG5cdFx0XHRcdFx0dGhpcy5yZXBlYXRlci5kZXNlbGVjdChpZHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZWNvcmF0ZUV2ZW50OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdFx0ZXZlbnQubW9kZWwgPSB0aGlzLm1vZGVsO1xuXHRcdFx0ZXZlbnQuY2hpbGQgPSB0aGlzO1xuXHRcdFx0ZXZlbnQuaW5kZXggPSB0aGlzLnJlcGVhdGVyLmNvbGxlY3Rpb24uaW5kZXhPZih0aGlzLm1vZGVsKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X3NlbGVjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5yZXBlYXRlci5zZWxlY3Rpb24gJiYgIXRoaXMuZ2V0KCdkaXNhYmxlZCcpKSB7XG5cdFx0XHRpZiAodGhpcy5yZXBlYXRlci5zZWxlY3Rpb25UeXBlICE9ICdncm91cCcgfHwgIXRoaXMuc2VsZWN0ZWQpIHtcblx0XHRcdFx0dGhpcy5zZXQoJ3NlbGVjdGVkJywgIXRoaXMuc2VsZWN0ZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0LyoqXG5cdCogRGVsaWJlcmF0ZWx5IHVzZWQgdG8gc3VwZXJzZWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBhbmQgc2V0IFxuXHQqIFtvd25lcl17QGxpbmsgZW55by5Db21wb25lbnQjb3duZXJ9IHRvIHRoaXMgW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gc28gdGhhdCB0aGVyZSBcblx0KiBhcmUgbm8gbmFtZSBjb2xsaXNpb25zIGluIHRoZSBpbnN0YW5jZSBbb3duZXJde0BsaW5rIGVueW8uQ29tcG9uZW50I293bmVyfSwgYW5kIGFsc28gc28gXG5cdCogdGhhdCBbYmluZGluZ3Nde0BsaW5rIGVueW8uQmluZGluZ30gd2lsbCBjb3JyZWN0bHkgbWFwIHRvIG5hbWVzLlxuXHQqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZUNsaWVudENvbXBvbmVudHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUNvbXBvbmVudHMoY29tcG9uZW50cywge293bmVyOiB0aGlzfSk7XG5cdFx0fTtcblx0fSksXG5cdC8qKlxuXHQqIFVzZWQgc28gdGhhdCB3ZSBkb24ndCBzdG9tcCBvbiBhbnkgYnVpbHQtaW4gaGFuZGxlcnMgZm9yIHRoZSBgb250YXBgXG5cdCoge0BnbG9zc2FyeSBldmVudH0uXG5cdCpcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzcGF0Y2hFdmVudDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUsIGV2ZW50LCBzZW5kZXIpIHtcblx0XHRcdHZhciBvd25lcjtcblx0XHRcdFxuXHRcdFx0Ly8gaWYgdGhlIGV2ZW50IGlzIGNvbWluZyBmcm9tIGEgY2hpbGQgb2YgdGhlIHJlcGVhdGVyLWNoaWxkICh0aGlzLi4uKSBhbmQgaGFzIGFcblx0XHRcdC8vIGRlbGVnYXRlIGFzc2lnbmVkIHRvIGl0IHRoZXJlIGlzIGEgZGlzdGluY3QgcG9zc2liaWxpdHkgaXQgaXMgc3VwcG9zZWQgdG8gYmVcblx0XHRcdC8vIHRhcmdldGluZyB0aGUgaW5zdGFuY2VPd25lciBvZiByZXBlYXRlci1jaGlsZCBub3QgdGhlIHJlcGVhdGVyLWNoaWxkIGl0c2VsZlxuXHRcdFx0Ly8gc28gd2UgaGF2ZSB0byBjaGVjayB0aGlzIGNhc2UgYW5kIHRyZWF0IGl0IGFzIGV4cGVjdGVkIC0gaWYgdGhlcmUgaXMgYSBoYW5kbGVyXG5cdFx0XHQvLyBhbmQgaXQgcmV0dXJucyB0cnVlIHRoZW4gd2UgbXVzdCBza2lwIHRoZSBub3JtYWwgZmxvd1xuXHRcdFx0aWYgKGV2ZW50Lm9yaWdpbmF0b3IgIT09IHRoaXMgJiYgZXZlbnQuZGVsZWdhdGUgJiYgZXZlbnQuZGVsZWdhdGUub3duZXIgPT09IHRoaXMpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzW25hbWVdICE9ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHQvLyBvayB3ZSBkb24ndCBoYXZlIHRoZSBoYW5kbGVyIGhlcmUgbGV0J3Mgc2VlIGlmIG91ciBvd25lciBkb2VzXG5cdFx0XHRcdFx0b3duZXIgPSB0aGlzLmdldEluc3RhbmNlT3duZXIoKTtcblx0XHRcdFx0XHRpZiAob3duZXIgJiYgb3duZXIgIT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2Ygb3duZXJbbmFtZV0gPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHQvLyBhbHJpZ2h0IGl0IGFwcGVhcnMgdGhhdCB3ZSdyZSBzdXBwb3NlZCB0byBmb3J3YXJkIHRoaXMgdG8gdGhlXG5cdFx0XHRcdFx0XHRcdC8vIG5leHQgb3duZXIgaW5zdGVhZFxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb3duZXIuZGlzcGF0Y2gobmFtZSwgZXZlbnQsIHNlbmRlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghZXZlbnQuX2Zyb21SZXBlYXRlckNoaWxkKSB7XG5cdFx0XHRcdGlmICghIX51dGlscy5pbmRleE9mKG5hbWUsIHRoaXMucmVwZWF0ZXIuc2VsZWN0aW9uRXZlbnRzKSkge1xuXHRcdFx0XHRcdHRoaXMuX3NlbGVjdGlvbkhhbmRsZXIoKTtcblx0XHRcdFx0XHRldmVudC5fZnJvbVJlcGVhdGVyQ2hpbGQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0Lypcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0ZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHIgPSB0aGlzLnJlcGVhdGVyLFxuXHRcdFx0XHRzID0gci5zZWxlY3Rpb25Qcm9wZXJ0eTtcblx0XHRcdC8vIHRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHNldCBpZiB0aGUgaW5zdGFuY2Ugb2YgdGhlIHJlcGVhdGVyIG5lZWRzXG5cdFx0XHQvLyB0byB0cmFjayB0aGUgc2VsZWN0ZWQgc3RhdGUgZnJvbSB0aGUgdmlldyBhbmQgbW9kZWwgYW5kIGtlZXAgdGhlbSBpbiBzeW5jXG5cdFx0XHRpZiAocykge1xuXHRcdFx0XHR2YXIgYm5kID0gdGhpcy5iaW5kaW5nKHtcblx0XHRcdFx0XHRmcm9tOiAnbW9kZWwuJyArIHMsXG5cdFx0XHRcdFx0dG86ICdzZWxlY3RlZCcsXG5cdFx0XHRcdFx0b25lV2F5OiBmYWxzZS8qLFxuXHRcdFx0XHRcdGtpbmQ6IGVueW8uQm9vbGVhbkJpbmRpbmcqL1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fc2VsZWN0aW9uQmluZGluZ0lkID0gYm5kLmV1aWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0Lypcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX3NlbGVjdGlvbkJpbmRpbmdJZCkge1xuXHRcdFx0XHR2YXIgYiQgPSBCaW5kaW5nLmZpbmQodGhpcy5fc2VsZWN0aW9uQmluZGluZ0lkKTtcblx0XHRcdFx0aWYgKGIkKSB7XG5cdFx0XHRcdFx0YiQuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9zZWxlY3Rpb25CaW5kaW5nSWQ6IG51bGxcbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9CaW5kaW5nXCI6OCxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvdXRpbHMnKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9wbGF0Zm9ybScpO1xuXG52YXJcblx0TGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvTGF5b3V0JyksXG5cdERvbSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2RvbScpO1xuXG4vKipcbioge0BsaW5rIGVueW8uQXJyYW5nZXJ9IGlzIGFuIHtAbGluayBlbnlvLkxheW91dH0gdGhhdCBjb25zaWRlcnMgb25lIG9mIHRoZVxuKiBjb250cm9scyBpdCBsYXlzIG91dCBhcyBhY3RpdmUuIFRoZSBvdGhlciBjb250cm9scyBhcmUgcGxhY2VkIHJlbGF0aXZlIHRvXG4qIHRoZSBhY3RpdmUgY29udHJvbCBhcyBtYWtlcyBzZW5zZSBmb3IgdGhlIGxheW91dC5cbipcbiogYGVueW8uQXJyYW5nZXJgIHN1cHBvcnRzIGR5bmFtaWMgbGF5b3V0cywgbWVhbmluZyBpdCdzIHBvc3NpYmxlIHRvIHRyYW5zaXRpb25cbiogYmV0d2VlbiBhbiBhcnJhbmdlcidzIGxheW91dHNcdHZpYSBhbmltYXRpb24uIFR5cGljYWxseSwgYXJyYW5nZXJzIHNob3VsZCBsYXkgb3V0XG4qIGNvbnRyb2xzIHVzaW5nIENTUyB0cmFuc2Zvcm1zLCBzaW5jZSB0aGVzZSBhcmUgb3B0aW1pemVkIGZvciBhbmltYXRpb24uIFRvXG4qIHN1cHBvcnQgdGhpcywgdGhlIGNvbnRyb2xzIGluIGFuIGFycmFuZ2VyIGFyZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQsIGFuZFxuKiB0aGUgQXJyYW5nZXIga2luZCBoYXMgYW4gW2FjY2VsZXJhdGVkXXtAbGluayBlbnlvLkFycmFuZ2VyI2FjY2VsZXJhdGVkfSBwcm9wZXJ0eSxcbiogd2hpY2ggbWFya3MgY29udHJvbHMgZm9yIENTUyBjb21wb3NpdGluZy4gVGhlIGRlZmF1bHQgc2V0dGluZyBvZiBgJ2F1dG8nYCBlbnN1cmVzXG4qIHRoYXQgdGhpcyB3aWxsIG9jY3VyIGlmIGVuYWJsZWQgYnkgdGhlIHBsYXRmb3JtLlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uQXJyYW5nZXJcbiogQGV4dGVuZHMgZW55by5MYXlvdXRcbiogQHB1YmxpY1xuKi9cbnZhciBBcnJhbmdlciA9IG1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyAgZW55by5BcnJhbmdlci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLkFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBMYXlvdXQsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGF5b3V0Q2xhc3M6ICdlbnlvLWFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgQXJyYW5nZXIgc2hvdWxkIGxheSBvdXQgY29udHJvbHMgdXNpbmcgQ1NTXG5cdCogY29tcG9zaXRpbmcuIFRoZSBkZWZhdWx0IHNldHRpbmcgYCgnYXV0bycpYCB3aWxsIG1hcmsgY29udHJvbHMgZm9yIGNvbXBvc2l0aW5nXG5cdCogaWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIGl0LlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ3xCb29sZWFufVxuXHQqIEBkZWZhdWx0ICdhdXRvJ1xuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0YWNjZWxlcmF0ZWQ6ICdhdXRvJyxcblxuXHQvKipcblx0KiBBIHByb3BlcnR5IG9mIHRoZSBkcmFnIGV2ZW50LCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYW1vdW50IHRoYXQgYSBkcmFnIHdpbGxcblx0KiBtb3ZlIHRoZSBsYXlvdXQuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICdkZHgnXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ1Byb3A6ICdkZHgnLFxuXG5cdC8qKlxuXHQqIEEgcHJvcGVydHkgb2YgdGhlIGRyYWcgZXZlbnQsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGRyYWcuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICd4RGlyZWN0aW9uJ1xuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdEaXJlY3Rpb25Qcm9wOiAneERpcmVjdGlvbicsXG5cblx0LyoqXG5cdCogQSBwcm9wZXJ0eSBvZiB0aGUgZHJhZyBldmVudCwgdXNlZCB0byBjYWxjdWxhdGUgd2hldGhlciBhIGRyYWcgc2hvdWxkIG9jY3VyLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnaG9yaXpvbnRhbCdcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYW5EcmFnUHJvcDogJ2hvcml6b250YWwnLFxuXG5cdC8qKlxuXHQqIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zaXRpb25zIGJldHdlZW4gbm9uLWFkamFjZW50IGFycmFuZ2VtZW50cyB3aWxsIGdvXG5cdCogdGhyb3VnaCB0aGUgaW50ZXJtZWRpYXRlIGFycmFuZ2VtZW50cy4gVGhpcyBpcyB1c2VmdWwgd2hlbiBkaXJlY3Rcblx0KiB0cmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyB3b3VsZCBiZSB2aXN1YWxseSBqYXJyaW5nLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGluY3JlbWVudGFsUG9pbnRzOiBmYWxzZSxcblxuXHQvKipcblx0KiBDYWxsZWQgd2hlbiByZW1vdmluZyBhbiBhcnJhbmdlciAoZS5nLiwgd2hlbiBzd2l0Y2hpbmcgYSBQYW5lbHMgY29udHJvbCB0byBhXG5cdCogZGlmZmVyZW50IGBhcnJhbmdlcktpbmRgKS4gU3Via2luZHMgc2hvdWxkIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uIHRvIHJlc2V0XG5cdCogd2hhdGV2ZXIgcHJvcGVydGllcyB0aGV5J3ZlIGNoYW5nZWQgb24gY2hpbGQgY29udHJvbHMuIE5vdGUgdGhhdCB5b3UgKiptdXN0Kipcblx0KiBjYWxsIHRoZSBzdXBlcmtpbmQgaW1wbGVtZW50YXRpb24gaW4geW91ciBzdWJraW5kJ3MgYGRlc3Ryb3koKWAgZnVuY3Rpb24uXG5cdCpcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGM7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGMuX2FycmFuZ2VyID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEFycmFuZ2VzIHRoZSBnaXZlbiBhcnJheSBvZiBgY29udHJvbHNgIGluIHRoZSBsYXlvdXQgc3BlY2lmaWVkIGJ5IGBpbmRleGAuIFdoZW5cblx0KiBpbXBsZW1lbnRpbmcgdGhpcyBtZXRob2QsIHJhdGhlciB0aGFuIGFwcGx5aW5nIHN0eWxpbmcgZGlyZWN0bHkgdG8gY29udHJvbHMsIGNhbGxcblx0KiBbYXJyYW5nZUNvbnRyb2woKV17QGxpbmsgZW55by5BcnJhbmdlciNhcnJhbmdlQ29udHJvbH0gYW5kIHBhc3MgaW4gYW4gYXJyYW5nZW1lbnRcblx0KiBvYmplY3Qgd2l0aCBzdHlsaW5nIHNldHRpbmdzLiBUaGUgc3R5bGVzIHdpbGwgdGhlbiBiZSBhcHBsaWVkIHZpYVxuXHQqIFtmbG93Q29udHJvbCgpXXtAbGluayBlbnlvLkFycmFuZ2VyI2Zsb3dDb250cm9sfS5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5Db250cm9sW119IGNvbnRyb2xzXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCogQHZpcnR1YWxcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGFycmFuZ2U6IGZ1bmN0aW9uIChjb250cm9scywgaW5kZXgpIHtcblx0fSxcblxuXHQvKipcblx0KiBTaXplcyB0aGUgY29udHJvbHMgaW4gdGhlIGxheW91dC4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIG9ubHkgYXQgcmVmbG93IHRpbWUuXG5cdCogTm90ZSB0aGF0IHRoZSBzaXppbmcgb3BlcmF0aW9uIGhhcyBiZWVuIHNlcGFyYXRlZCBmcm9tIHRoZSBsYXlvdXQgZG9uZSBpblxuXHQqIFthcnJhbmdlKClde0BsaW5rIGVueW8uQXJyYW5nZXIjYXJyYW5nZX0gYmVjYXVzZSBpdCBpcyBleHBlbnNpdmUgYW5kIG5vdCBzdWl0YWJsZVxuXHQqIGZvciBkeW5hbWljIGxheW91dC5cblx0KlxuXHQqIEB2aXJ0dWFsXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRzaXplOiBmdW5jdGlvbiAoKSB7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsbGVkIHdoZW4gYSBsYXlvdXQgdHJhbnNpdGlvbiBiZWdpbnMuIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBwZXJmb3JtXG5cdCogdGFza3MgdGhhdCBzaG91bGQgb25seSBvY2N1ciB3aGVuIGEgdHJhbnNpdGlvbiBzdGFydHM7IGZvciBleGFtcGxlLCBzb21lXG5cdCogY29udHJvbHMgbWlnaHQgYmUgc2hvd24gb3IgaGlkZGVuLiBJbiBhZGRpdGlvbiwgdGhlIGB0cmFuc2l0aW9uUG9pbnRzYFxuXHQqIGFycmF5IG1heSBiZSBzZXQgb24gdGhlIGNvbnRhaW5lciB0byBkaWN0YXRlIHRoZSBuYW1lZCBhcnJhbmdlbWVudHNcblx0KiBiZXR3ZWVuIHdoaWNoIHRoZSB0cmFuc2l0aW9uIG9jY3Vycy5cblx0KlxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZiA9IHRoaXMuY29udGFpbmVyLmZyb21JbmRleCwgdCA9IHRoaXMuY29udGFpbmVyLnRvSW5kZXg7XG5cdFx0dmFyIHAkID0gdGhpcy5jb250YWluZXIudHJhbnNpdGlvblBvaW50cyA9IFtmXTtcblx0XHQvLyBvcHRpb25hbGx5IGFkZCBhIHRyYW5zaXRpb24gcG9pbnQgZm9yIGVhY2ggaW5kZXggYmV0d2VlbiBmcm9tIGFuZCB0by5cblx0XHRpZiAodGhpcy5pbmNyZW1lbnRhbFBvaW50cykge1xuXHRcdFx0dmFyIGQgPSBNYXRoLmFicyh0IC0gZikgLSAyO1xuXHRcdFx0dmFyIGkgPSBmO1xuXHRcdFx0d2hpbGUgKGQgPj0gMCkge1xuXHRcdFx0XHRpID0gaSArICh0IDwgZiA/IC0xIDogMSk7XG5cdFx0XHRcdHAkLnB1c2goaSk7XG5cdFx0XHRcdGQtLTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cCQucHVzaCh0aGlzLmNvbnRhaW5lci50b0luZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBDYWxsZWQgd2hlbiBhIGxheW91dCB0cmFuc2l0aW9uIGNvbXBsZXRlcy4gSW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvXG5cdCogcGVyZm9ybSB0YXNrcyB0aGF0IHNob3VsZCBvbmx5IG9jY3VyIHdoZW4gYSB0cmFuc2l0aW9uIGVuZHM7IGZvclxuXHQqIGV4YW1wbGUsIHNvbWUgY29udHJvbHMgbWlnaHQgYmUgc2hvd24gb3IgaGlkZGVuLlxuXHQqXG5cdCogQHZpcnR1YWxcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHRoZSBsYXlvdXQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRpZmZlcmVuY2UgaW5cblx0KiBwaXhlbHMgYmV0d2VlbiB0aGUgYXJyYW5nZW1lbnQgYGEwYCBmb3IgbGF5b3V0IHNldHRpbmcgYGkwYFx0YW5kXG5cdCogYXJyYW5nZW1lbnQgYGExYCBmb3IgbGF5b3V0IHNldHRpbmcgYGkxYC4gVGhpcyBkYXRhIGlzIHVzZWQgdG8gY2FsY3VsYXRlXG5cdCogdGhlIHBlcmNlbnRhZ2UgdGhhdCBhIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGxheW91dCBiZXR3ZWVuIHR3byBhY3RpdmUgc3RhdGVzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGkwIC0gVGhlIGluaXRpYWwgbGF5b3V0IHNldHRpbmcuXG5cdCogQHBhcmFtIHtPYmplY3R9IGEwIC0gVGhlIGluaXRpYWwgYXJyYW5nZW1lbnQuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGkxIC0gVGhlIHRhcmdldCBsYXlvdXQgc2V0dGluZy5cblx0KiBAcGFyYW0ge09iamVjdH0gYTEgLSBUaGUgdGFyZ2V0IGFycmFuZ2VtZW50LlxuXHQqIEB2aXJ0dWFsXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRjYWxjQXJyYW5nZW1lbnREaWZmZXJlbmNlOiBmdW5jdGlvbiAoaTAsIGEwLCBpMSwgYTEpIHtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYW5EcmFnRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHJldHVybiBldmVudFt0aGlzLmNhbkRyYWdQcm9wXTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYWxjRHJhZ0RpcmVjdGlvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50W3RoaXMuZHJhZ0RpcmVjdGlvblByb3BdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNEcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnRbdGhpcy5kcmFnUHJvcF07XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZzogZnVuY3Rpb24gKGRwLCBhbiwgYSwgYm4sIGIpIHtcblx0XHR2YXIgZiA9IHRoaXMubWVhc3VyZUFycmFuZ2VtZW50RGVsdGEoLWRwLCBhbiwgYSwgYm4sIGIpO1xuXHRcdHJldHVybiBmO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1lYXN1cmVBcnJhbmdlbWVudERlbHRhOiBmdW5jdGlvbiAoeCwgaTAsIGEwLCBpMSwgYTEpIHtcblx0XHR2YXIgZCA9IHRoaXMuY2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZShpMCwgYTAsIGkxLCBhMSk7XG5cdFx0dmFyIHMgPSBkID8geCAvIE1hdGguYWJzKGQpIDogMDtcblx0XHRzID0gcyAqICh0aGlzLmNvbnRhaW5lci5mcm9tSW5kZXggPiB0aGlzLmNvbnRhaW5lci50b0luZGV4ID8gLTEgOiAxKTtcblx0XHRyZXR1cm4gcztcblx0fSxcblxuXHQvKipcblx0KiBBcnJhbmdlcyB0aGUgcGFuZWxzLCB3aXRoIHRoZSBwYW5lbCBhdCBgaW5kZXhgIGJlaW5nIGRlc2lnbmF0ZWQgYXMgYWN0aXZlLlxuXHQqXG5cdCogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHBhbmVsLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9hcnJhbmdlOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHQvLyBndWFyZCBhZ2FpbnN0IGJlaW5nIGNhbGxlZCBiZWZvcmUgd2UndmUgYmVlbiByZW5kZXJlZFxuXHRcdGlmICghdGhpcy5jb250YWluZXJCb3VuZHMpIHtcblx0XHRcdHRoaXMucmVmbG93KCk7XG5cdFx0fVxuXHRcdHZhciBjJCA9IHRoaXMuZ2V0T3JkZXJlZENvbnRyb2xzKGluZGV4KTtcblx0XHR0aGlzLmFycmFuZ2UoYyQsIGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBBcnJhbmdlcyBgY29udHJvbGAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgYGFycmFuZ2VtZW50YC5cblx0KlxuXHQqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2Vzbid0IGFjdHVhbGx5IG1vZGlmeSBgY29udHJvbGAgYnV0IHJhdGhlciBzZXRzIHRoZVxuXHQqIGFycmFuZ2VtZW50IG9uIGEgcHJpdmF0ZSBtZW1iZXIgb2YgdGhlIGNvbnRyb2wgdG8gYmUgcmV0cmlldmVkIGJ5XG5cdCoge0BsaW5rIGVueW8uUGFuZWxzfS5cblx0KlxuXHQqIEBwYXJhbSAge2VueW8uQ29udHJvbH0gY29udHJvbFxuXHQqIEBwYXJhbSAge09iamVjdH0gYXJyYW5nZW1lbnRcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhcnJhbmdlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wsIGFycmFuZ2VtZW50KSB7XG5cdFx0Y29udHJvbC5fYXJyYW5nZXIgPSB1dGlscy5taXhpbihjb250cm9sLl9hcnJhbmdlciB8fCB7fSwgYXJyYW5nZW1lbnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGxlZCBiZWZvcmUgSFRNTCBpcyByZW5kZXJlZC4gQXBwbGllcyBDU1MgdG8gcGFuZWxzIHRvIGVuc3VyZSBHUFUgYWNjZWxlcmF0aW9uIGlmXG5cdCogW2FjY2VsZXJhdGVkXXtAbGluayBlbnlvLkFycmFuZ2VyI2FjY2VsZXJhdGVkfSBpcyBgdHJ1ZWAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmbG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jJCA9IFtdLmNvbmNhdCh0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKSk7XG5cdFx0dGhpcy5jb250cm9sc0luZGV4ID0gMDtcblx0XHRmb3IgKHZhciBpPTAsIGMkPXRoaXMuY29udGFpbmVyLmdldFBhbmVscygpLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0RG9tLmFjY2VsZXJhdGUoYywgIWMucHJldmVudEFjY2VsZXJhdGUgJiYgdGhpcy5hY2NlbGVyYXRlZCk7XG5cdFx0XHRpZiAocGxhdGZvcm0uc2FmYXJpKSB7XG5cdFx0XHRcdC8vIE9uIFNhZmFyaS1kZXNrdG9wLCBzb21ldGltZXMgaGF2aW5nIHRoZSBwYW5lbCdzIGRpcmVjdCBjaGlsZCBzZXQgdG8gYWNjZWxlcmF0ZSBpc24ndCBzdWZmaWNpZW50XG5cdFx0XHRcdC8vIHRoaXMgaXMgbW9zdCBvZnRlbiB0aGUgY2FzZSB3aXRoIExpc3RzIGNvbnRhaW5lZCBpbnNpZGUgYW5vdGhlciBjb250cm9sLCBpbnNpZGUgYSBQYW5lbHNcblx0XHRcdFx0dmFyIGdyYW5kcz1jLmNoaWxkcmVuO1xuXHRcdFx0XHRmb3IgKHZhciBqPTAsIGtpZDsgKGtpZD1ncmFuZHNbal0pOyBqKyspIHtcblx0XHRcdFx0XHREb20uYWNjZWxlcmF0ZShraWQsIHRoaXMuYWNjZWxlcmF0ZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGxlZCBkdXJpbmcgXCJyZW5kZXJlZFwiIHBoYXNlIHRvIFtzaXplXXtAbGluayBlbnlvLkFycmFuZ2VyI3NpemV9IHRoZSBjb250cm9scy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlZmxvdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjbiA9IHRoaXMuY29udGFpbmVyLmhhc05vZGUoKTtcblx0XHR0aGlzLmNvbnRhaW5lckJvdW5kcyA9IGNuID8ge3dpZHRoOiBjbi5jbGllbnRXaWR0aCwgaGVpZ2h0OiBjbi5jbGllbnRIZWlnaHR9IDoge307XG5cdFx0dGhpcy5zaXplKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogSWYgdGhlIHtAbGluayBlbnlvLlBhbmVsc30gaGFzIGFuIGFycmFuZ2VtZW50LCBmbG93cyBlYWNoIGNvbnRyb2wgYWNjb3JkaW5nIHRvIHRoYXRcblx0KiBhcnJhbmdlbWVudC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZsb3dBcnJhbmdlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhID0gdGhpcy5jb250YWluZXIuYXJyYW5nZW1lbnQ7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAodmFyIGk9MCwgYyQ9dGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCksIGM7IChjPWMkW2ldKSAmJiAoYVtpXSk7IGkrKykge1xuXHRcdFx0XHR0aGlzLmZsb3dDb250cm9sKGMsIGFbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0LyoqXG5cdCogTGF5cyBvdXQgdGhlIGdpdmVuIGBjb250cm9sYCBhY2NvcmRpbmcgdG8gdGhlIHNldHRpbmdzIHN0b3JlZCBpbiB0aGVcblx0KiBgYXJyYW5nZW1lbnRgIG9iamVjdC4gQnkgZGVmYXVsdCwgYGZsb3dDb250cm9sKClgIHdpbGwgYXBwbHkgc2V0dGluZ3MgZm9yXG5cdCogYGxlZnRgLCBgdG9wYCwgYW5kIGBvcGFjaXR5YC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgaW1wbGVtZW50ZWQgdG8gYXBwbHlcblx0KiBvdGhlciBzZXR0aW5ncyBtYWRlIHZpYSBbYXJyYW5nZUNvbnRyb2woKV17QGxpbmsgZW55by5BcnJhbmdlciNhcnJhbmdlQ29udHJvbH0uXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29udHJvbH0gY29udHJvbCAtIFRoZSBjb250cm9sIHRvIGJlIGxhaWQgb3V0LlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBhcnJhbmdlbWVudCAtIEFuIG9iamVjdCB3aG9zZSBtZW1iZXJzIHNwZWNpZnkgdGhlIGxheW91dCBzZXR0aW5ncy5cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGZsb3dDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCwgYXJyYW5nZW1lbnQpIHtcblx0XHRBcnJhbmdlci5wb3NpdGlvbkNvbnRyb2woY29udHJvbCwgYXJyYW5nZW1lbnQpO1xuXHRcdHZhciBvID0gYXJyYW5nZW1lbnQub3BhY2l0eTtcblx0XHRpZiAobyAhPSBudWxsKSB7XG5cdFx0XHRBcnJhbmdlci5vcGFjaWZ5Q29udHJvbChjb250cm9sLCBvKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogR2V0cyBhbiBhcnJheSBvZiBjb250cm9scyBhcnJhbmdlZCBpbiBzdGF0ZSBvcmRlci5cblx0KiBub3RlOiBvcHRpbWl6YXRpb24sIGRpYWwgYXJvdW5kIGEgc2luZ2xlIGFycmF5LlxuXHQqXG5cdCogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAgICAgLSBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBwYW5lbC5cblx0KiBAcmV0dXJuIHtlbnlvLkNvbnRyb2xbXX0gICAtIE9yZGVyZWQgYXJyYXkgb2YgY29udHJvbHMuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0T3JkZXJlZENvbnRyb2xzOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHR2YXIgd2hvbGUgPSBNYXRoLmZsb29yKGluZGV4KTtcblx0XHR2YXIgYSA9IHdob2xlIC0gdGhpcy5jb250cm9sc0luZGV4O1xuXHRcdHZhciBzaWduID0gYSA+IDA7XG5cdFx0dmFyIGMkID0gdGhpcy5jJCB8fCBbXTtcblx0XHRmb3IgKHZhciBpPTA7IGk8TWF0aC5hYnMoYSk7IGkrKykge1xuXHRcdFx0aWYgKHNpZ24pIHtcblx0XHRcdFx0YyQucHVzaChjJC5zaGlmdCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGMkLnVuc2hpZnQoYyQucG9wKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmNvbnRyb2xzSW5kZXggPSB3aG9sZTtcblx0XHRyZXR1cm4gYyQ7XG5cdH1cbn0pO1xuXG4vKipcbiogUG9zaXRpb25zIGEgY29udHJvbCB2aWEgdHJhbnNmb3JtLS1gdHJhbnNsYXRlWC90cmFuc2xhdGVZYCBpZiBzdXBwb3J0ZWQsXG4qIGZhbGxpbmcgYmFjayB0byBgbGVmdC90b3BgIGlmIG5vdC5cbipcbiogQGxlbmRzIGVueW8uQXJyYW5nZXJcbiogQHBhcmFtICB7ZW55by5Db250cm9sfSBjb250cm9sIC0gVGhlIGNvbnRyb2wgdG8gcG9zaXRpb24uXG4qIEBwYXJhbSAge09iamVjdH0gYm91bmRzICAgICAgICAtIFRoZSBuZXcgYm91bmRzIGZvciBgY29udHJvbGAuXG4qIEBwYXJhbSAge1N0cmluZ30gdW5pdCAgICAgICAgICAtIFRoZSB1bml0IGZvciBgYm91bmRzYCBtZW1iZXJzLlxuKiBAcHVibGljXG4qL1xuQXJyYW5nZXIucG9zaXRpb25Db250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wsIGJvdW5kcywgdW5pdCkge1xuXHR1bml0ID0gdW5pdCB8fCAncHgnO1xuXHRpZiAoIXRoaXMudXBkYXRpbmcpIHtcblx0XHQvLyBJRTEwIHVzZXMgc2V0Qm91bmRzIGJlY2F1c2Ugb2YgY29udHJvbCBoaXQgY2FjaGluZyBwcm9ibGVtcyBzZWVtIGluIHNvbWUgYXBwc1xuXHRcdGlmIChEb20uY2FuVHJhbnNmb3JtKCkgJiYgIWNvbnRyb2wucHJldmVudFRyYW5zZm9ybSAmJiAhcGxhdGZvcm0uYW5kcm9pZCAmJiBwbGF0Zm9ybS5pZSAhPT0gMTApIHtcblx0XHRcdHZhciBsID0gYm91bmRzLmxlZnQsIHQgPSBib3VuZHMudG9wO1xuXHRcdFx0bCA9IHV0aWxzLmlzU3RyaW5nKGwpID8gbCA6IGwgJiYgKGwgKyB1bml0KTtcblx0XHRcdHQgPSB1dGlscy5pc1N0cmluZyh0KSA/IHQgOiB0ICYmICh0ICsgdW5pdCk7XG5cdFx0XHREb20udHJhbnNmb3JtKGNvbnRyb2wsIHt0cmFuc2xhdGVYOiBsIHx8IG51bGwsIHRyYW5zbGF0ZVk6IHQgfHwgbnVsbH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIHByZXZpb3VzbHkgcG9zaXRpb25lZCBjb250cm9sIGhhcyBzdWJzZXF1ZW50bHkgYmVlbiBtYXJrZWQgd2l0aFxuXHRcdFx0Ly8gcHJldmVudFRyYW5zZm9ybSwgd2UgbmVlZCB0byBjbGVhciBvdXQgYW55IG9sZCB0cmFuc2xhdGlvbiB2YWx1ZXMuXG5cdFx0XHRpZiAoRG9tLmNhblRyYW5zZm9ybSgpICYmIGNvbnRyb2wucHJldmVudFRyYW5zZm9ybSkge1xuXHRcdFx0XHREb20udHJhbnNmb3JtKGNvbnRyb2wsIHt0cmFuc2xhdGVYOiBudWxsLCB0cmFuc2xhdGVZOiBudWxsfSk7XG5cdFx0XHR9XG5cdFx0XHRjb250cm9sLnNldEJvdW5kcyhib3VuZHMsIHVuaXQpO1xuXHRcdH1cblx0fVxufSxcblxuLyoqXG4qIFNldHMgdGhlIG9wYWNpdHkgdmFsdWUgZm9yIGEgZ2l2ZW4gY29udHJvbC5cbipcbiogQGxlbmRzIGVueW8uQXJyYW5nZXJcbiogQHBhcmFtICB7ZW55by5Db250cm9sfSBpbkNvbnRyb2wgLSBUaGUgY29udHJvbCB3aG9zZSBvcGFjaXR5IGlzIHRvIGJlIHNldC5cbiogQHBhcmFtICB7TnVtYmVyfSBpbk9wYWNpdHkgLSBUaGUgbmV3IG9wYWNpdHkgdmFsdWUgZm9yIHRoZSBjb250cm9sLlxuKiBAcHVibGljXG4qL1xuQXJyYW5nZXIub3BhY2lmeUNvbnRyb2wgPSBmdW5jdGlvbiAoaW5Db250cm9sLCBpbk9wYWNpdHkpIHtcblx0dmFyIG8gPSBpbk9wYWNpdHk7XG5cdC8vIEZJWE1FOiB2ZXJ5IGhpZ2gvbG93IHNldHRpbmdzIG9mIG9wYWNpdHkgY2FuIGNhdXNlIGEgY29udHJvbCB0b1xuXHQvLyBibGluayBzbyBjYXAgdGhpcyBoZXJlLlxuXHRvID0gbyA+IDAuOTkgPyAxIDogKG8gPCAwLjAxID8gMCA6IG8pO1xuXHQvLyBub3RlOiB3ZSBvbmx5IGNhcmUgYWJvdXQgaWU4XG5cdGlmIChwbGF0Zm9ybS5pZSA8IDkpIHtcblx0XHRpbkNvbnRyb2wuYXBwbHlTdHlsZSgnZmlsdGVyJywgJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PScgKyAobyAqIDEwMCkgKyAnKScpO1xuXHR9IGVsc2Uge1xuXHRcdGluQ29udHJvbC5hcHBseVN0eWxlKCdvcGFjaXR5Jywgbyk7XG5cdH1cbn1cbn0se1wiLi4vLi4vLi4vZW55by9saWIvTGF5b3V0XCI6MjYsXCIuLi8uLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2VueW8vbGliL3BsYXRmb3JtXCI6NzEsXCIuLi8uLi8uLi9lbnlvL2xpYi91dGlsc1wiOjc1fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG4gICAga2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcbiAgICBMYXlvdXQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9MYXlvdXQnKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkNvbnRleHR1YWxMYXlvdXR9IHByb3ZpZGVzIHRoZSBiYXNlIHBvc2l0aW9uaW5nIGxvZ2ljIGZvciBhIGNvbnRleHR1YWxcbiogbGF5b3V0IHN0cmF0ZWd5LiBUaGlzIGxheW91dCBzdHJhdGVneSBpcyBpbnRlbmRlZCBmb3IgdXNlIHdpdGggYSBwb3B1cCBpbiBhXG4qIGRlY29yYXRvci9hY3RpdmF0b3Igc2NlbmFyaW8sIGluIHdoaWNoIHRoZSBwb3B1cCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvXG4qIHRoZSBhY3RpdmF0b3IsIGUuZy46XG4qXG4qIGBgYFxuKiB7a2luZDogJ29ueXguQ29udGV4dHVhbFBvcHVwRGVjb3JhdG9yJywgY29tcG9uZW50czogW1xuKiAgIHtjb250ZW50OiAnU2hvdyBQb3B1cCd9LFxuKiAgIHtraW5kOiAnb255eC5Db250ZXh0dWFsUG9wdXAnLFxuKiAgICAgICB0aXRsZTogJ1NhbXBsZSBQb3B1cCcsXG4qICAgICAgIGFjdGlvbkJ1dHRvbnM6IFtcbiogICAgICAgICAgIHtjb250ZW50OiAnQnV0dG9uIDEnLCBjbGFzc2VzOiAnb255eC1idXR0b24td2FybmluZyd9LFxuKiAgICAgICAgICAge2NvbnRlbnQ6ICdCdXR0b24gMid9XG4qICAgICAgIF0sXG4qICAgICAgIGNvbXBvbmVudHM6IFtcbiogICAgICAgICAgIHtjb250ZW50OiAnU2FtcGxlIGNvbXBvbmVudCBpbiBwb3B1cCd9XG4qICAgICAgIF1cbiogICB9XG4qIF19XG4qIGBgYFxuKlxuKiBUaGUgZGVjb3JhdG9yIGNvbnRhaW5zIHRoZSBwb3B1cCBhbmQgYWN0aXZhdG9yLCB3aXRoIHRoZSBhY3RpdmF0b3IgYmVpbmcgdGhlXG4qIGZpcnN0IGNoaWxkIGNvbXBvbmVudCAoaS5lLiwgdGhlIFwiU2hvdyBQb3B1cFwiIGJ1dHRvbikuIFRoZSBjb250ZXh0dWFsIGxheW91dFxuKiBzdHJhdGVneSBpcyBhcHBsaWVkIGJlY2F1c2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBvbnl4LkNvbnRleHR1YWxQb3B1cGAsXG4qIGl0cyBgbGF5b3V0S2luZGAgcHJvcGVydHkgaXMgc2V0IHRvIGBlbnlvLkNvbnRleHR1YWxMYXlvdXRgLlxuKlxuKiBOb3RlIHRoYXQgYSBwb3B1cCB1c2luZyBDb250ZXh0dWFsTGF5b3V0IGFzIGl0cyBgbGF5b3V0S2luZGAgaXMgZXhwZWN0ZWQgdG9cbiogZGVjbGFyZSBzZXZlcmFsIHNwZWNpZmljIHByb3BlcnRpZXM6XG4qXG4qIC0gYHZlcnRGbHVzaE1hcmdpbmAgLSBUaGUgdmVydGljYWwgZmx1c2ggbGF5b3V0IG1hcmdpbiwgaS5lLiwgaG93IGNsb3NlIHRoZVxuKiBwb3B1cCdzIGVkZ2UgbWF5IGNvbWUgdG8gdGhlIHZlcnRpY2FsIHNjcmVlbiBlZGdlIChpbiBwaXhlbHMpIGJlZm9yZVxuKiBiZWluZyBsYWlkIG91dCBcImZsdXNoXCIgc3R5bGUuXG4qIC0gYGhvcml6Rmx1c2hNYXJnaW5gIC0gVGhlIGhvcml6b250YWwgZmx1c2ggbGF5b3V0IG1hcmdpbiwgaS5lLiwgaG93IGNsb3NlXG4qIHRoZSBwb3B1cCdzIGVkZ2UgbWF5IGNvbWUgdG8gdGhlIGhvcml6b250YWwgc2NyZWVuIGVkZ2UgKGluIHBpeGVscylcbiogYmVmb3JlIGJlaW5nIGxhaWQgb3V0IFwiZmx1c2hcIiBzdHlsZS5cbiogLSBgd2lkZVBvcHVwYCAtIEEgcG9wdXAgd2lkZXIgdGhhbiB0aGlzIHZhbHVlIChpbiBwaXhlbHMpIGlzIGNvbnNpZGVyZWQgd2lkZVxuKiBmb3IgbGF5b3V0IGNhbGN1bGF0aW9uIHB1cnBvc2VzLlxuKiAtIGBsb25nUG9wdXBgIC0gQSBwb3B1cCBsb25nZXIgdGhhbiB0aGlzIHZhbHVlIChpbiBwaXhlbHMpIGlzIGNvbnNpZGVyZWQgbG9uZ1xuKiBmb3IgbGF5b3V0IGNhbGN1bGF0aW9uIHB1cnBvc2VzLlxuKiAtIGBob3JpekJ1ZmZlcmAgLSBIb3Jpem9udGFsIGZsdXNoIHBvcHVwcyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIHRoaXMgYnVmZmVyXG4qIGFyZWEgKGluIHBpeGVscykgb24gdGhlIGxlZnQgb3IgcmlnaHQgc2NyZWVuIGVkZ2UuXG4qIC0gYGFjdGl2YXRvck9mZnNldGAgLSBUaGUgcG9wdXAgYWN0aXZhdG9yJ3Mgb2Zmc2V0IG9uIHRoZSBwYWdlIChpbiBwaXhlbHMpO1xuKiB0aGlzIHNob3VsZCBiZSBjYWxjdWxhdGVkIHdoZW5ldmVyIHRoZSBwb3B1cCBpcyB0byBiZSBzaG93bi5cbipcbiogQHR5cGVkZWYge09iamVjdH0gZW55by5Db250ZXh0dWFsTGF5b3V0XG4qXG4qIEBjbGFzcyBlbnlvLkNvbnRleHR1YWxMYXlvdXRcbiogQGV4dGVuZHMgZW55by5MYXlvdXRcbiogQHB1YmxpY1xuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuICAgIC8qKiBAbGVuZHMgIGVueW8uQ29udGV4dHVhbExheW91dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgbmFtZTogJ2VueW8uQ29udGV4dHVhbExheW91dCcsXG5cbiAgICAvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuICAgIGtpbmQ6IExheW91dCxcblxuICAgIC8qKlxuICAgICogQWRqdXN0cyB0aGUgcG9wdXAncyBwb3NpdGlvbiwgYXMgd2VsbCBhcyB0aGUgbnViIGxvY2F0aW9uIGFuZCBkaXJlY3Rpb24uXG4gICAgKlxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnNob3dpbmcgJiYgdGhpcy5jb250YWluZXIuaGFzTm9kZSgpKSB7XG4gICAgICAgICAgICAvKioqKkNvbnRleHR1YWxQb3B1cCBwb3NpdGlvbmluZyBydWxlczpcbiAgICAgICAgICAgICAgICAxLiBBY3RpdmF0b3IgTG9jYXRpb246XG4gICAgICAgICAgICAgICAgICAgIGEuIElmIGFjdGl2YXRvciBpcyBsb2NhdGVkIGluIGEgY29ybmVyIHRoZW4gcG9zaXRpb24gdXNpbmcgYSBmbHVzaCBzdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGkuICBBdHRlbXB0IHZlcnRpY2FsIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWkuIEhvcml6b250YWwgaWYgdmVydGljYWwgZG9lc24ndCBmaXQuXG4gICAgICAgICAgICAgICAgICAgIGIuIElmIG5vdCBpbiBhIGNvcm5lciB0aGVuIGNoZWNrIGlmIHRoZSBhY3RpdmF0b3IgaXMgbG9jYXRlZCBpbiBvbmUgb2YgdGhlIDQgXCJlZGdlc1wiIG9mIHRoZSB2aWV3ICYgcG9zaXRpb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dpbmcgd2F5IGlmIHNvOlxuICAgICAgICAgICAgICAgICAgICAgICAgaS4gICBBY3RpdmF0b3IgaXMgaW4gdG9wIGVkZ2UsIHBvc2l0aW9uIHBvcHVwIGJlbG93IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWkuICBBY3RpdmF0b3IgaXMgaW4gYm90dG9tIGVkZ2UsIHBvc2l0aW9uIHBvcHVwIGFib3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWlpLiBBY3RpdmF0b3IgaXMgaW4gbGVmdCBlZGdlLCBwb3NpdGlvbiBwb3B1cCB0byB0aGUgcmlnaHQgb2YgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdi4gIEFjdGl2YXRvciBpcyBpbiByaWdodCBlZGdlLCBwb3NpdGlvbiBwb3B1cCB0byB0aGUgbGVmdCBvZiBpdC5cblxuICAgICAgICAgICAgICAgIDIuIFNjcmVlbiBTaXplIC0gdGhlIHBvcC11cCBzaG91bGQgZ2VuZXJhbGx5IGV4dGVuZCBpbiB0aGUgZGlyZWN0aW9uIHdoZXJlIHRoZXJl4oCZcyByb29tIGZvciBpdC5cbiAgICAgICAgICAgICAgICAgICAgTm90ZTogbm8gc3BlY2lmaWMgbG9naWMgYmVsb3cgZm9yIHRoaXMgcnVsZSBzaW5jZSBpdCBpcyBidWlsdCBpbnRvIHRoZSBwb3NpdGlvbmluZyBmdW5jdGlvbnMsIGllIHdlIGF0dGVtcHQgdG8gbmV2ZXJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gYSBwb3B1cCB3aGVyZSB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgaXQuXG5cbiAgICAgICAgICAgICAgICAzLiBQb3B1cCBTaXplOlxuICAgICAgICAgICAgICAgICAgICBpLiAgSWYgcG9wdXAgY29udGVudCBpcyB3aWRlLCB1c2UgdG9wIG9yIGJvdHRvbSBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWkuIElmIHBvcHVwIGNvbnRlbnQgaXMgbG9uZywgdXNlIGhvcml6b250YWwgcG9zaXRpb25pbmcuXG5cbiAgICAgICAgICAgICAgICA0LiBGYXZvciB0b3Agb3IgYm90dG9tOlxuICAgICAgICAgICAgICAgICAgICBJZiBhbGwgdGhlIGFib3ZlIHJ1bGVzIGhhdmUgYmVlbiBmb2xsb3dlZCBhbmQgbG9jYXRpb24gY2FuIHN0aWxsIHZhcnkgdGhlbiBmYXZvciB0b3Agb3IgYm90dG9tIHBvc2l0aW9uaW5nLlxuXG4gICAgICAgICAgICAgICAgNS4gSWYgdG9wIG9yIGJvdHRvbSB3aWxsIHdvcmssIGZhdm9yIGJvdHRvbS5cbiAgICAgICAgICAgICAgICAgICAgTm90ZTogbm8gc3BlY2lmaWMgbG9naWMgYmVsb3cgZm9yIHRoaXMgcnVsZSBzaW5jZSBpdCBpcyBidWlsdCBpbnRvIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBmdW5jdGlvbnMsIGllIHdlIGF0dGVtcHQgdG9cbiAgICAgICAgICAgICAgICAgICAgdXNlIGEgYm90dG9tIHBvc2l0aW9uIGZvciB0aGUgcG9wdXAgYXMgbXVjaCBwb3NzaWJsZS4gQWRkaXRpb25hbGx5IHdpdGhpbiB0aGUgdmV0aWNhbCBwb3NpdGlvbiBmdW5jdGlvbiB3ZSBjZW50ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgIHBvcHVwIGlmIHRoZSBhY3RpdmF0b3IgaXMgYXQgdGhlIHZlcnRpY2FsIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgICoqKiovXG4gICAgICAgICAgICB0aGlzLnJlc2V0UG9zaXRpb25pbmcoKTtcbiAgICAgICAgICAgIHZhciBpbm5lcldpZHRoID0gdGhpcy5nZXRWaWV3V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBpbm5lckhlaWdodCA9IHRoaXMuZ2V0Vmlld0hlaWdodCgpO1xuXG4gICAgICAgICAgICAvL1RoZXNlIGFyZSB0aGUgdmlldyBcImZsdXNoIGJvdW5kYXJpZXNcIlxuICAgICAgICAgICAgdmFyIHRvcEZsdXNoUHQgPSB0aGlzLmNvbnRhaW5lci52ZXJ0Rmx1c2hNYXJnaW47XG4gICAgICAgICAgICB2YXIgYm90dG9tRmx1c2hQdCA9IGlubmVySGVpZ2h0IC0gdGhpcy5jb250YWluZXIudmVydEZsdXNoTWFyZ2luO1xuICAgICAgICAgICAgdmFyIGxlZnRGbHVzaFB0ID0gdGhpcy5jb250YWluZXIuaG9yaXpGbHVzaE1hcmdpbjtcbiAgICAgICAgICAgIHZhciByaWdodEZsdXNoUHQgPSBpbm5lcldpZHRoIC0gdGhpcy5jb250YWluZXIuaG9yaXpGbHVzaE1hcmdpbjtcblxuICAgICAgICAgICAgLy9SdWxlIDEgLSBBY3RpdmF0b3IgTG9jYXRpb24gYmFzZWQgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIC8vaWYgdGhlIGFjdGl2YXRvciBpcyBpbiB0aGUgdG9wIG9yIGJvdHRvbSBlZGdlcyBvZiB0aGUgdmlldywgY2hlY2sgaWYgdGhlIHBvcHVwIG5lZWRzIGZsdXNoIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICBpZiAoKHRoaXMub2Zmc2V0LnRvcCArIHRoaXMub2Zmc2V0LmhlaWdodCkgPCB0b3BGbHVzaFB0IHx8IHRoaXMub2Zmc2V0LnRvcCA+IGJvdHRvbUZsdXNoUHQpIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrL3RyeSB2ZXJ0aWNhbCBmbHVzaCBwb3NpdGlvbmluZ1x0KHJ1bGUgMS5hLmkpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlWZXJ0aWNhbEZsdXNoUG9zaXRpb25pbmcobGVmdEZsdXNoUHQsIHJpZ2h0Rmx1c2hQdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vaWYgdmVydGljYWwgZG9lc24ndCBmaXQgdGhlbiBjaGVjay90cnkgaG9yaXpvbnRhbCBmbHVzaCAocnVsZSAxLmEuaWkpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlIb3Jpem9udGFsRmx1c2hQb3NpdGlvbmluZyhsZWZ0Rmx1c2hQdCwgcmlnaHRGbHVzaFB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBmbHVzaCBwb3NpdGlvbmluZyBkaWRuJ3Qgd29yayB0aGVuIHRyeSBqdXN0IHBvc2l0aW9uaW5nIHZlcnRpY2FsbHkgKHJ1bGUgMS5iLmkgJiBydWxlIDEuYi5paSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBseVZlcnRpY2FsUG9zaXRpb25pbmcoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvL290aGVyd2lzZSBjaGVjayBpZiB0aGUgYWN0aXZhdG9yIGlzIGluIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzIG9mIHRoZSB2aWV3ICYgaWYgc28gdHJ5IGhvcml6b250YWwgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHRoaXMub2Zmc2V0LmxlZnQgKyB0aGlzLm9mZnNldC53aWR0aCkgPCBsZWZ0Rmx1c2hQdCB8fCB0aGlzLm9mZnNldC5sZWZ0ID4gcmlnaHRGbHVzaFB0KSB7XG4gICAgICAgICAgICAgICAgLy9pZiBmbHVzaCBwb3NpdGlvbmluZyBkaWRuJ3Qgd29yayB0aGVuIHRyeSBqdXN0IHBvc2l0aW9uaW5nIGhvcml6b250YWxseSAocnVsZSAxLmIuaWlpICYgcnVsZSAxLmIuaXYpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlIb3Jpem9udGFsUG9zaXRpb25pbmcoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vUnVsZSAyIC0gbm8gc3BlY2lmaWMgbG9naWMgYmVsb3cgZm9yIHRoaXMgcnVsZSBzaW5jZSBpdCBpcyBpbmhlcml0ZW50IHRvIHRoZSBwb3NpdGlvbmluZyBmdW5jdGlvbnMsIGllIHdlIGF0dGVtcHQgdG8gbmV2ZXJcbiAgICAgICAgICAgIC8vcG9zaXRpb24gYSBwb3B1cCB3aGVyZSB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgaXQuXG5cbiAgICAgICAgICAgIC8vUnVsZSAzIC0gUG9wdXAgU2l6ZSBiYXNlZCBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcblxuICAgICAgICAgICAgLy9pZiB0aGUgcG9wdXAgaXMgd2lkZSB0aGVuIHVzZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgaWYgKGNsaWVudFJlY3Qud2lkdGggPiB0aGlzLmNvbnRhaW5lci53aWRlUG9wdXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBseVZlcnRpY2FsUG9zaXRpb25pbmcoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHRoZSBwb3B1cCBpcyBsb25nIHRoZW4gdXNlIGhvcml6b250YWwgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudFJlY3QuaGVpZ2h0ID4gdGhpcy5jb250YWluZXIubG9uZ1BvcHVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlIb3Jpem9udGFsUG9zaXRpb25pbmcoKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vUnVsZSA0IC0gRmF2b3IgdG9wIG9yIGJvdHRvbSBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlWZXJ0aWNhbFBvc2l0aW9uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2J1dCBpZiB0aGF0cyBub3QgcG9zc2libGUgdHJ5IGhvcml6b250YWxcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXBwbHlIb3Jpem9udGFsUG9zaXRpb25pbmcoKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1J1bGUgNSAtIG5vIHNwZWNpZmljIGxvZ2ljIGJlbG93IGZvciB0aGlzIHJ1bGUgc2luY2UgaXQgaXMgYnVpbHQgaW50byB0aGUgdmVydGljYWwgcG9zaXRpb24gZnVuY3Rpb25zLCBpZSB3ZSBhdHRlbXB0IHRvXG4gICAgICAgICAgICAvLyAgICAgICAgIHVzZSBhIGJvdHRvbSBwb3NpdGlvbiBmb3IgdGhlIHBvcHVwIGFzIG11Y2ggcG9zc2libGUuXG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vXG5cbiAgICAvKipcbiAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcG9wdXAgd2lsbCBmaXQgb25zY3JlZW4gaWYgbW92ZWQgYmVsb3cgb3IgYWJvdmUgdGhlIGFjdGl2YXRvci5cbiAgICAqXG4gICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgcG9wdXAgd2lsbCBmaXQgb25zY3JlZW47IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGluaXRWZXJ0aWNhbFBvc2l0aW9uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbmluZygpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygndmVydGljYWwnKTtcblxuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KHRoaXMuY29udGFpbmVyLm5vZGUpO1xuICAgICAgICB2YXIgaW5uZXJIZWlnaHQgPSB0aGlzLmdldFZpZXdIZWlnaHQoKTtcblxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIuZmxvYXRpbmcpe1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0LnRvcCA8IChpbm5lckhlaWdodCAvIDIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6IHRoaXMub2Zmc2V0LnRvcCArIHRoaXMub2Zmc2V0LmhlaWdodCwgYm90dG9tOiAnYXV0byd9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnYmVsb3cnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIGNsaWVudFJlY3QuaGVpZ2h0LCBib3R0b206ICdhdXRvJ30pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdhYm92ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9pZiB0aGUgcG9wdXAncyBib3R0b20gZ29lcyBvZmYgdGhlIHNjcmVlbiB0aGVuIHB1dCBpdCBvbiB0aGUgdG9wIG9mIHRoZSBpbnZva2luZyBjb250cm9sXG4gICAgICAgICAgICBpZiAoKGNsaWVudFJlY3QudG9wICsgY2xpZW50UmVjdC5oZWlnaHQgPiBpbm5lckhlaWdodCkgJiYgKChpbm5lckhlaWdodCAtIGNsaWVudFJlY3QuYm90dG9tKSA8IChjbGllbnRSZWN0LnRvcCAtIGNsaWVudFJlY3QuaGVpZ2h0KSkpe1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdhYm92ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnYmVsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgbW92aW5nIHRoZSBwb3B1cCBhYm92ZSBvciBiZWxvdyB0aGUgYWN0aXZhdG9yIHB1dHMgaXQgcGFzdCB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuIHRoZW4gdmVydGljYWwgZG9lc24ndCB3b3JrXG4gICAgICAgIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgaWYgKChjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0KSA+IGlubmVySGVpZ2h0IHx8IGNsaWVudFJlY3QudG9wIDwgMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBNb3ZlcyB0aGUgcG9wdXAgYmVsb3cgb3IgYWJvdmUgdGhlIGFjdGl2YXRpbmcgY29udHJvbC5cbiAgICAqXG4gICAgKiBAcmV0dXJuIHtCb29sZWFufSBgZmFsc2VgIGlmIHBvcHVwIHdhcyBub3QgbW92ZWQgYmVjYXVzZSBpdCB3b3VsZCBub3QgZml0IG9uc2NyZWVuXG4gICAgKiBpbiB0aGUgbmV3IHBvc2l0aW9uOyBvdGhlcndpc2UsIGB0cnVlYC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGFwcGx5VmVydGljYWxQb3NpdGlvbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2lmIHdlIGNhbid0IGZpdCB0aGUgcG9wdXAgYWJvdmUgb3IgYmVsb3cgdGhlIGFjdGl2YXRvciB0aGVuIGZvcmdldCB2ZXJ0aWNhbCBwb3NpdGlvbmluZ1xuICAgICAgICBpZiAoIXRoaXMuaW5pdFZlcnRpY2FsUG9zaXRpb25pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSB0aGlzLmdldFZpZXdXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5mbG9hdGluZyl7XG4gICAgICAgICAgICAvL0dldCB0aGUgbGVmdCBlZGdlIGRlbHRhIHRvIGhvcml6b250YWxseSBjZW50ZXIgdGhlIHBvcHVwXG4gICAgICAgICAgICB2YXIgY2VudGVyZWRMZWZ0ID0gdGhpcy5vZmZzZXQubGVmdCArIHRoaXMub2Zmc2V0LndpZHRoLzIgLSBjbGllbnRSZWN0LndpZHRoLzI7XG4gICAgICAgICAgICBpZiAoY2VudGVyZWRMZWZ0ICsgY2xpZW50UmVjdC53aWR0aCA+IGlubmVyV2lkdGgpIHsvL3BvcHVwIGdvZXMgb2ZmIHJpZ2h0IGVkZ2Ugb2YgdGhlIHNjcmVlbiBpZiBjZW50ZXJlZFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7bGVmdDogdGhpcy5vZmZzZXQubGVmdCArIHRoaXMub2Zmc2V0LndpZHRoIC0gY2xpZW50UmVjdC53aWR0aH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNlbnRlcmVkTGVmdCA8IDApIHsvL3BvcHVwIGdvZXMgb2ZmIGxlZnQgZWRnZSBvZiB0aGUgc2NyZWVuIGlmIGNlbnRlcmVkXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHtsZWZ0OnRoaXMub2Zmc2V0LmxlZnR9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygncmlnaHQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7Ly9jZW50ZXIgdGhlIHBvcHVwXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHtsZWZ0OiBjZW50ZXJlZExlZnR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9HZXQgdGhlIGxlZnQgZWRnZSBkZWx0YSB0byBob3Jpem9udGFsbHkgY2VudGVyIHRoZSBwb3B1cFxuICAgICAgICAgICAgdmFyIGNlbnRlcmVkTGVmdERlbHRhID0gdGhpcy5vZmZzZXQubGVmdCArIHRoaXMub2Zmc2V0LndpZHRoLzIgLSBjbGllbnRSZWN0LmxlZnQgLSBjbGllbnRSZWN0LndpZHRoLzI7XG4gICAgICAgICAgICBpZiAoY2xpZW50UmVjdC5yaWdodCArIGNlbnRlcmVkTGVmdERlbHRhID4gaW5uZXJXaWR0aCkgey8vcG9wdXAgZ29lcyBvZmYgcmlnaHQgZWRnZSBvZiB0aGUgc2NyZWVuIGlmIGNlbnRlcmVkXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHtsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0ICsgdGhpcy5vZmZzZXQud2lkdGggLSBjbGllbnRSZWN0LnJpZ2h0fSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkUmVtb3ZlQ2xhc3MoJ2xlZnQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50UmVjdC5sZWZ0ICsgY2VudGVyZWRMZWZ0RGVsdGEgPCAwKSB7Ly9wb3B1cCBnb2VzIG9mZiBsZWZ0IGVkZ2Ugb2YgdGhlIHNjcmVlbiBpZiBjZW50ZXJlZFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdyaWdodCcsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHsvL2NlbnRlciB0aGUgcG9wdXBcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6IGNlbnRlcmVkTGVmdERlbHRhfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBQb3NpdGlvbnMgdGhlIHBvcHVwIHZlcnRpY2FsbHkgZmx1c2ggd2l0aCB0aGUgYWN0aXZhdGluZyBjb250cm9sLlxuICAgICpcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0Rmx1c2hQdCAtIExlZnQgc2lkZSBjdXRvZmYuXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcmlnaHRGbHVzaFB0IC0gUmlnaHQgc2lkZSBjdXRvZmYuXG4gICAgKiBAcmV0dXJuIHtCb29sZWFufSBgZmFsc2VgIGlmIHBvcHVwIHdpbGwgbm90IGZpdCBvbnNjcmVlbiBpbiBuZXcgcG9zaXRpb247XG4gICAgKiBvdGhlcndpc2UsIGB0cnVlYC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGFwcGx5VmVydGljYWxGbHVzaFBvc2l0aW9uaW5nOiBmdW5jdGlvbiAobGVmdEZsdXNoUHQsIHJpZ2h0Rmx1c2hQdCkge1xuICAgICAgICAvL2lmIHdlIGNhbid0IGZpdCB0aGUgcG9wdXAgYWJvdmUgb3IgYmVsb3cgdGhlIGFjdGl2YXRvciB0aGVuIGZvcmdldCB2ZXJ0aWNhbCBwb3NpdGlvbmluZ1xuICAgICAgICBpZiAoIXRoaXMuaW5pdFZlcnRpY2FsUG9zaXRpb25pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSB0aGlzLmdldFZpZXdXaWR0aCgpO1xuXG4gICAgICAgIC8vSWYgdGhlIGFjdGl2YXRvcidzIHJpZ2h0IHNpZGUgaXMgd2l0aGluIG91ciBsZWZ0IHNpZGUgY3V0IG9mZiB1c2UgZmx1c2ggcG9zaXRpb25pbmdcbiAgICAgICAgaWYgKCh0aGlzLm9mZnNldC5sZWZ0ICsgdGhpcy5vZmZzZXQud2lkdGgvMikgPCBsZWZ0Rmx1c2hQdCl7XG4gICAgICAgICAgICAvL2lmIHRoZSBhY3RpdmF0b3IncyBsZWZ0IGVkZ2UgaXMgdG9vIGNsb3NlIG9yIHBhc3QgdGhlIHNjcmVlbiBsZWZ0IGVkZ2VcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldC5sZWZ0ICsgdGhpcy5vZmZzZXQud2lkdGgvMiA8IHRoaXMuY29udGFpbmVyLmhvcml6QnVmZmVyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6dGhpcy5jb250YWluZXIuaG9yaXpCdWZmZXIgKyAodGhpcy5jb250YWluZXIuZmxvYXRpbmcgPyAwIDogLWNsaWVudFJlY3QubGVmdCl9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHtsZWZ0OnRoaXMub2Zmc2V0LndpZHRoLzIgICsgKHRoaXMuY29udGFpbmVyLmZsb2F0aW5nID8gdGhpcy5vZmZzZXQubGVmdCA6IDApfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdyaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Nvcm5lcicpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy9JZiB0aGUgYWN0aXZhdG9yJ3MgbGVmdCBzaWRlIGlzIHdpdGhpbiBvdXIgcmlnaHQgc2lkZSBjdXQgb2ZmIHVzZSBmbHVzaCBwb3NpdGlvbmluZ1xuICAgICAgICBlbHNlIGlmICh0aGlzLm9mZnNldC5sZWZ0ICsgdGhpcy5vZmZzZXQud2lkdGgvMiA+IHJpZ2h0Rmx1c2hQdCkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLm9mZnNldC5sZWZ0K3RoaXMub2Zmc2V0LndpZHRoLzIpID4gKGlubmVyV2lkdGgtdGhpcy5jb250YWluZXIuaG9yaXpCdWZmZXIpKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6aW5uZXJXaWR0aCAtIHRoaXMuY29udGFpbmVyLmhvcml6QnVmZmVyIC0gY2xpZW50UmVjdC5yaWdodH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6ICh0aGlzLm9mZnNldC5sZWZ0ICsgdGhpcy5vZmZzZXQud2lkdGgvMikgLSBjbGllbnRSZWN0LnJpZ2h0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnbGVmdCcpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Nvcm5lcicpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHBvcHVwIHdpbGwgZml0IG9uc2NyZWVuIGlmIG1vdmVkIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IG9mIHRoZVxuICAgICogYWN0aXZhdG9yLlxuICAgICpcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcG9wdXAgd2lsbCBmaXQgb25zY3JlZW47IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIGluaXRIb3Jpem9udGFsUG9zaXRpb25pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uaW5nKCk7XG5cbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSB0aGlzLmdldFZpZXdXaWR0aCgpO1xuXG4gICAgICAgIC8vYWRqdXN0IGhvcml6b250YWwgcG9zaXRpb25pbmcgb2YgdGhlIHBvcHVwICYgbnViIHZlcnRpY2FsIHBvc2l0aW9uaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5mbG9hdGluZyl7XG4gICAgICAgICAgICBpZiAoKHRoaXMub2Zmc2V0LmxlZnQgKyB0aGlzLm9mZnNldC53aWR0aCkgPCBpbm5lcldpZHRoLzIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgKyB0aGlzLm9mZnNldC53aWR0aH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdsZWZ0JywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7bGVmdDogdGhpcy5vZmZzZXQubGVmdCAtIGNsaWVudFJlY3Qud2lkdGh9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygncmlnaHQnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldC5sZWZ0IC0gY2xpZW50UmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe2xlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSBjbGllbnRSZWN0LmxlZnQgLSBjbGllbnRSZWN0LndpZHRofSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkUmVtb3ZlQ2xhc3MoJ3JpZ2h0JywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7bGVmdDogdGhpcy5vZmZzZXQud2lkdGh9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbGVmdCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdob3Jpem9udGFsJywgdHJ1ZSk7XG5cbiAgICAgICAgLy9pZiBtb3ZpbmcgdGhlIHBvcHVwIGxlZnQgb3IgcmlnaHQgb2YgdGhlIGFjdGl2YXRvciBwdXRzIGl0IHBhc3QgdGhlIGVkZ2Ugb2YgdGhlIHNjcmVlbiB0aGVuIGhvcml6b250YWwgd29uJ3Qgd29ya1xuICAgICAgICBjbGllbnRSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QodGhpcy5jb250YWluZXIubm9kZSk7XG4gICAgICAgIGlmIChjbGllbnRSZWN0LmxlZnQgPCAwIHx8IChjbGllbnRSZWN0LmxlZnQgKyBjbGllbnRSZWN0LndpZHRoKSA+IGlubmVyV2lkdGgpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIHBvcHVwIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IG9mIHRoZSBhY3RpdmF0aW5nIGNvbnRyb2wuXG4gICAgKlxuICAgICogQHJldHVybiB7Qm9vbGVhbn0gYGZhbHNlYCBpZiBwb3B1cCB3YXMgbm90IG1vdmVkIGJlY2F1c2UgaXQgd291bGQgbm90IGZpdCBvbnNjcmVlblxuICAgICogaW4gdGhlIG5ldyBwb3NpdGlvbjsgb3RoZXJ3aXNlLCBgdHJ1ZWAuXG4gICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBhcHBseUhvcml6b250YWxQb3NpdGlvbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2lmIHdlIGNhbid0IGZpdCB0aGUgcG9wdXAgbGVmdCBvciByaWdodCBvZiB0aGUgYWN0aXZhdG9yIHRoZW4gZm9yZ2V0IGhvcml6b250YWwgcG9zaXRpb25pbmdcbiAgICAgICAgaWYgKCF0aGlzLmluaXRIb3Jpem9udGFsUG9zaXRpb25pbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0aGlzLmNvbnRhaW5lci5ub2RlKTtcbiAgICAgICAgdmFyIGlubmVySGVpZ2h0ID0gdGhpcy5nZXRWaWV3SGVpZ2h0KCk7XG4gICAgICAgIHZhciBhY3RpdmF0b3JDZW50ZXIgPSB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9mZnNldC5oZWlnaHQvMjtcblxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIuZmxvYXRpbmcpe1xuICAgICAgICAgICAgLy9pZiB0aGUgYWN0aXZhdG9yJ3MgY2VudGVyIGlzIHdpdGhpbiAxMCUgb2YgdGhlIGNlbnRlciBvZiB0aGUgdmlldywgdmVydGljYWxseSBjZW50ZXIgdGhlIHBvcHVwXG4gICAgICAgICAgICBpZiAoKGFjdGl2YXRvckNlbnRlciA+PSAoaW5uZXJIZWlnaHQvMiAtIDAuMDUgKiBpbm5lckhlaWdodCkpICYmIChhY3RpdmF0b3JDZW50ZXIgPD0gKGlubmVySGVpZ2h0LzIgKyAwLjA1ICogaW5uZXJIZWlnaHQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7dG9wOiB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9mZnNldC5oZWlnaHQvMiAtIGNsaWVudFJlY3QuaGVpZ2h0LzIsIGJvdHRvbTogJ2F1dG8nfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub2Zmc2V0LnRvcCArIHRoaXMub2Zmc2V0LmhlaWdodCA8IGlubmVySGVpZ2h0LzIpIHsgLy90aGUgYWN0aXZhdG9yIGlzIGluIHRoZSB0b3AgMS8yIG9mIHRoZSBzY3JlZW5cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe3RvcDogdGhpcy5vZmZzZXQudG9wLCBib3R0b206ICdhdXRvJ30pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdoaWdoJywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvL290aGVyd2lzZSB0aGUgcG9wdXAgd2lsbCBiZSBwb3NpdGlvbmVkIGluIHRoZSBib3R0b20gMS8yIG9mIHRoZSBzY3JlZW5cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb24oe3RvcDogdGhpcy5vZmZzZXQudG9wIC0gY2xpZW50UmVjdC5oZWlnaHQgKyB0aGlzLm9mZnNldC5oZWlnaHQqMiwgYm90dG9tOiAnYXV0byd9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2lmIHRoZSBhY3RpdmF0b3IncyBjZW50ZXIgaXMgd2l0aGluIDEwJSBvZiB0aGUgY2VudGVyIG9mIHRoZSB2aWV3LCB2ZXJ0aWNhbGx5IGNlbnRlciB0aGUgcG9wdXBcbiAgICAgICAgICAgIGlmICgoYWN0aXZhdG9yQ2VudGVyID49IChpbm5lckhlaWdodC8yIC0gMC4wNSAqIGlubmVySGVpZ2h0KSkgJiYgKGFjdGl2YXRvckNlbnRlciA8PSAoaW5uZXJIZWlnaHQvMiArIDAuMDUgKiBpbm5lckhlaWdodCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6ICh0aGlzLm9mZnNldC5oZWlnaHQgLSBjbGllbnRSZWN0LmhlaWdodCkvMn0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9mZnNldC5oZWlnaHQgPCBpbm5lckhlaWdodC8yKSB7IC8vdGhlIGFjdGl2YXRvciBpcyBpbiB0aGUgdG9wIDEvMiBvZiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6IC10aGlzLm9mZnNldC5oZWlnaHR9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnaGlnaCcsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlcndpc2UgdGhlIHBvcHVwIHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgYm90dG9tIDEvMiBvZiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6IGNsaWVudFJlY3QudG9wIC0gY2xpZW50UmVjdC5oZWlnaHQgLSB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9mZnNldC5oZWlnaHR9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgKiBQb3NpdGlvbnMgdGhlIHBvcHVwIGhvcml6b250YWxseSBmbHVzaCB3aXRoIHRoZSBhY3RpdmF0aW5nIGNvbnRyb2wuXG4gICAgKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnRGbHVzaFB0IC0gTGVmdCBzaWRlIGN1dG9mZi5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSByaWdodEZsdXNoUHQgLSBSaWdodCBzaWRlIGN1dG9mZi5cbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGBmYWxzZWAgaWYgcG9wdXAgd2lsbCBub3QgZml0IG9uc2NyZWVuIGluIG5ldyBwb3NpdGlvbjtcbiAgICAqIG90aGVyd2lzZSwgYHRydWVgLlxuICAgICogQHB1YmxpY1xuICAgICovXG4gICAgYXBwbHlIb3Jpem9udGFsRmx1c2hQb3NpdGlvbmluZzogZnVuY3Rpb24gKGxlZnRGbHVzaFB0LCByaWdodEZsdXNoUHQpIHtcbiAgICAgICAgLy9pZiB3ZSBjYW4ndCBmaXQgdGhlIHBvcHVwIGxlZnQgb3IgcmlnaHQgb2YgdGhlIGFjdGl2YXRvciB0aGVuIGZvcmdldCBob3Jpem9udGFsIHBvc2l0aW9uaW5nXG4gICAgICAgIGlmICghdGhpcy5pbml0SG9yaXpvbnRhbFBvc2l0aW9uaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbGllbnRSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QodGhpcy5jb250YWluZXIubm9kZSk7XG4gICAgICAgIHZhciBpbm5lckhlaWdodCA9IHRoaXMuZ2V0Vmlld0hlaWdodCgpO1xuXG4gICAgICAgIC8vYWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9uaW5nIChoaWdoIG9yIGxvdyBudWIgJiBwb3B1cCBwb3NpdGlvbilcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmZsb2F0aW5nKXtcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldC50b3AgPCAoaW5uZXJIZWlnaHQvMikpe1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7dG9wOiB0aGlzLm9mZnNldC50b3AgKyB0aGlzLm9mZnNldC5oZWlnaHQvMn0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdoaWdoJywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7dG9wOnRoaXMub2Zmc2V0LnRvcCArIHRoaXMub2Zmc2V0LmhlaWdodC8yIC0gY2xpZW50UmVjdC5oZWlnaHR9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoKChjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0KSA+IGlubmVySGVpZ2h0KSAmJiAoKGlubmVySGVpZ2h0IC0gY2xpZW50UmVjdC5ib3R0b20pIDwgKGNsaWVudFJlY3QudG9wIC0gY2xpZW50UmVjdC5oZWlnaHQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7dG9wOiBjbGllbnRSZWN0LnRvcCAtIGNsaWVudFJlY3QuaGVpZ2h0IC0gdGhpcy5vZmZzZXQudG9wIC0gdGhpcy5vZmZzZXQuaGVpZ2h0LzJ9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbih7dG9wOiB0aGlzLm9mZnNldC5oZWlnaHQvMn0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFJlbW92ZUNsYXNzKCdoaWdoJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL0lmIHRoZSBhY3RpdmF0b3IncyByaWdodCBzaWRlIGlzIHdpdGhpbiBvdXIgbGVmdCBzaWRlIGN1dCBvZmYgdXNlIGZsdXNoIHBvc2l0aW9uaW5nXG4gICAgICAgIGlmICgodGhpcy5vZmZzZXQubGVmdCArIHRoaXMub2Zmc2V0LndpZHRoKSA8IGxlZnRGbHVzaFB0KXtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnY29ybmVyJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvL0lmIHRoZSBhY3RpdmF0b3IncyBsZWZ0IHNpZGUgaXMgd2l0aGluIG91ciByaWdodCBzaWRlIGN1dCBvZmYgdXNlIGZsdXNoIHBvc2l0aW9uaW5nXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub2Zmc2V0LmxlZnQgPiByaWdodEZsdXNoUHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdyaWdodCcpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Nvcm5lcicpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZGVzY3JpYmluZyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGVcbiAgICAqIHBhc3NlZC1pbiBET00gbm9kZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtTdHJpbmd9IGluTm9kZSAtIERPTSBub2RlIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdGhlIERPTSBub2RlJ3MgYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogIGZ1bmN0aW9uIChpbk5vZGUpe1xuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgcmV0dXJucyB0b3AvbGVmdCB2YWx1ZXMgd2hpY2ggYXJlIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBhbmQgbm90IGFic29sdXRlXG4gICAgICAgIHZhciBvID0gaW5Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIW8ud2lkdGggfHwgIW8uaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IG8ubGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogby5yaWdodCxcbiAgICAgICAgICAgICAgICB0b3A6IG8udG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogby5ib3R0b20sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG8ucmlnaHQgLSBvLmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvLmJvdHRvbSAtIG8udG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBnZXRWaWV3SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVySGVpZ2h0ID09PSB1bmRlZmluZWQpID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgZ2V0Vmlld1dpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggPT09IHVuZGVmaW5lZCkgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgYXBwbHlQb3NpdGlvbjogZnVuY3Rpb24gKGluUmVjdCkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBuIGluIGluUmVjdCkge1xuICAgICAgICAgICAgcyArPSAobiArICc6JyArIGluUmVjdFtuXSArIChpc05hTihpblJlY3Rbbl0pID8gJzsgJyA6ICdweDsgJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZFN0eWxlcyhzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgcmVzZXRQb3NpdGlvbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygncmlnaHQnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2xlZnQnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2hpZ2gnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2xvdycpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY29ybmVyJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdiZWxvdycpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnYWJvdmUnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ3ZlcnRpY2FsJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdob3Jpem9udGFsJyk7XG5cbiAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHtsZWZ0OiAnYXV0byd9KTtcbiAgICAgICAgdGhpcy5hcHBseVBvc2l0aW9uKHt0b3A6ICdhdXRvJ30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICByZWZsb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmNvbnRhaW5lci5hY3RpdmF0b3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWRqdXN0UG9zaXRpb24oKTtcbiAgICB9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvTGF5b3V0XCI6MjYsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjZ9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyk7XG5cbnZhclxuXHRMaW5rZWRMaXN0Tm9kZSA9IHJlcXVpcmUoJy4vTGlua2VkTGlzdE5vZGUnKTtcblxuLyoqXG4qIEFuIGFic3RyYWN0IGxpbmtlZC1saXN0LlxuKlxuKiBAY2xhc3MgZW55by5MaW5rZWRMaXN0XG4qIEBwcml2YXRlXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uTGlua2VkTGlzdC5wcm90b3R5cGUgKi8ge1xuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogbnVsbCxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5vZGVLaW5kOiBMaW5rZWRMaXN0Tm9kZSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhlYWQ6IG51bGwsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWlsOiBudWxsLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGVuZ3RoOiAwLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5oZWFkKSB7XG5cdFx0XHQvLyB0aGlzIHdpbGwgdHJpZ2dlciBhIGNoYWluIGV2ZW50IGRvd24gdGhlIGxpc3Rcblx0XHRcdHRoaXMuaGVhZC5kZXN0cm95KCk7XG5cdFx0fVxuXHRcdHRoaXMuaGVhZCA9IG51bGw7XG5cdFx0dGhpcy50YWlsID0gbnVsbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XHRcdFx0XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzbGljZTogZnVuY3Rpb24gKGZyb21Ob2RlLCB0b05vZGUpIHtcblx0XHR2YXIgbm9kZSA9IGZyb21Ob2RlIHx8IHRoaXMuaGVhZFxuXHRcdFx0LCBsaXN0ID0gbmV3IHRoaXMuY3RvcigpXG5cdFx0XHQsIGNweTtcblx0XHRcblx0XHQvLyBlbnN1cmUgd2UgaGF2ZSBhIGZpbmFsIG5vZGUgb3Igb3VyIHRhaWxcblx0XHR0b05vZGUgPSB0b05vZGUgfHwgdGhpcy50YWlsO1xuXHRcdFxuXHRcdGlmIChub2RlICYmIG5vZGUgIT09IHRvTm9kZSkge1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRjcHkgPSBub2RlLmNvcHkoKTtcblx0XHRcdFx0bGlzdC5hcHBlbmROb2RlKGNweSk7XG5cdFx0XHR9IHdoaWxlICgobm9kZSA9IG5vZGUubmV4dCkgJiYgbm9kZSAhPT0gdG9Ob2RlKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdHJldHVybiBuZXcgdGhpcy5ub2RlS2luZChwcm9wcyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZWxldGVOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdHRoaXMucmVtb3ZlTm9kZShub2RlKTtcblx0XHRcblx0XHQvLyBjYW4ndCBjaGFpbiBkZXN0cnVjdCBiZWNhdXNlIHdlIHJlbW92ZWQgaXRzIGNoYWluIHJlZmVyZW5jZXNcblx0XHRub2RlLmRlc3Ryb3koKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbW92ZU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0dmFyIHByZXYgPSBub2RlLnByZXZcblx0XHRcdCwgbmV4dCA9IG5vZGUubmV4dDtcblx0XHRcdFxuXHRcdHByZXYgJiYgKHByZXYubmV4dCA9IG5leHQpO1xuXHRcdG5leHQgJiYgKG5leHQucHJldiA9IHByZXYpO1xuXHRcdHRoaXMubGVuZ3RoLS07XG5cdFx0bm9kZS5uZXh0ID0gbm9kZS5wcmV2ID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFwcGVuZE5vZGU6IGZ1bmN0aW9uIChub2RlLCB0YXJnZXROb2RlKSB7XG5cdFx0dGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGUgfHwgdGhpcy50YWlsO1xuXHRcdFxuXHRcdGlmICh0YXJnZXROb2RlKSB7XG5cdFx0XHRpZiAodGFyZ2V0Tm9kZS5uZXh0KSB7XG5cdFx0XHRcdG5vZGUubmV4dCA9IHRhcmdldE5vZGUubmV4dDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGFyZ2V0Tm9kZS5uZXh0ID0gbm9kZTtcblx0XHRcdG5vZGUucHJldiA9IHRhcmdldE5vZGU7XG5cdFx0XHRcblx0XHRcdGlmICh0YXJnZXROb2RlID09PSB0aGlzLnRhaWwpIHtcblx0XHRcdFx0dGhpcy50YWlsID0gbm9kZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0XG5cdFx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBub2RlO1xuXHRcdFx0bm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaW5kOiBmdW5jdGlvbiAoZm4sIGN0eCwgdGFyZ2V0Tm9kZSkge1xuXHRcdHZhciBub2RlID0gdGFyZ2V0Tm9kZSB8fCB0aGlzLmhlYWQ7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKGZuLmNhbGwoY3R4IHx8IHRoaXMsIG5vZGUsIHRoaXMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKChub2RlID0gbm9kZS5uZXh0KSk7XG5cdFx0fVxuXHRcdC8vIGlmIG5vIG5vZGUgcXVhbGlmaWVkIGl0IHJldHVybnMgZmFsc2Vcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmb3J3YXJkOiBmdW5jdGlvbiAoZm4sIGN0eCwgdGFyZ2V0Tm9kZSkge1xuXHRcdHZhciBub2RlID0gdGFyZ2V0Tm9kZSB8fCB0aGlzLmhlYWQ7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKGZuLmNhbGwoY3R4IHx8IHRoaXMsIG5vZGUsIHRoaXMpKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKChub2RlID0gbm9kZS5uZXh0KSk7XG5cdFx0fVxuXHRcdC8vIHJldHVybnMgdGhlIGxhc3Qgbm9kZSAoaWYgYW55KSB0aGF0IHdhcyBwcm9jZXNzZWQgaW4gdGhlIGNoYWluXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRiYWNrd2FyZDogZnVuY3Rpb24gKGZuLCBjdHgsIHRhcmdldE5vZGUpIHtcblx0XHR2YXIgbm9kZSA9IHRhcmdldE5vZGUgfHwgdGhpcy50YWlsO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChmbi5jYWxsKGN0eCB8fCB0aGlzLCBub2RlLCB0aGlzKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICgobm9kZSA9IG5vZGUucHJldikpO1xuXHRcdH1cblx0XHQvLyByZXR1cm5zIHRoZSBsYXN0IG5vZGUgKGlmIGFueSkgdGhhdCB3YXMgcHJvY2Vzc2VkIGluIHRoZSBjaGFpblxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm5vZGVUeXBlID0ga2luZC5jb25zdHJ1Y3RvckZvcktpbmQodGhpcy5ub2RlVHlwZSk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vTGlua2VkTGlzdE5vZGVcIjoyOCxcIi4va2luZFwiOjY2fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdExpbmtlZExpc3ROb2RlID0gcmVxdWlyZSgnLi9MaW5rZWRMaXN0Tm9kZScpO1xuXG5mdW5jdGlvbiBnZXQgKGJhc2UsIHByb3ApIHtcblx0cmV0dXJuIGJhc2UgJiYgLyppc09iamVjdChiYXNlKSovICh0eXBlb2YgYmFzZSA9PSAnb2JqZWN0Jyk/IChcblx0XHRiYXNlLmdldD8gYmFzZS5nZXQocHJvcCk6IGJhc2VbcHJvcF1cblx0KTogdW5kZWZpbmVkO1xufVxuXG4vKipcbiogQW4gaW50ZXJuYWxseSB1c2VkIHtAZ2xvc3Nhcnkga2luZH0uXG4qXG4qIEBjbGFzcyBlbnlvLk9ic2VydmVyQ2hhaW5Ob2RlXG4qIEBleHRlbmRzIGVueW8uTGlua2VkTGlzdE5vZGVcbiogQHByaXZhdGVcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5PYnNlcnZlckNoYWluTm9kZS5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IExpbmtlZExpc3ROb2RlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblx0XG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3Rvcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmNvbm5lY3QoKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5vYnNlcnZlciA9IG51bGw7XG5cdFx0XHR0aGlzLmxpc3QgPSBudWxsO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBudWxsO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29ubmVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvYmogPSB0aGlzLm9iamVjdFxuXHRcdFx0LCBvYnMgPSB0aGlzLl9jaGFuZ2VkXG5cdFx0XHQsIHByb3AgPSB0aGlzLnByb3BlcnR5O1xuXHRcdGlmIChvYmopIHtcblx0XHRcdGlmIChvYmoub2JzZXJ2ZSkgb2JqLm9ic2VydmUocHJvcCwgb2JzLCB0aGlzLCB7bm9DaGFpbjogdHJ1ZSwgcHJpb3JpdHk6IHRydWV9KTtcblx0XHRcdHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMubGlzdC5jb25uZWN0ZWQrKztcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG9iaiA9IHRoaXMub2JqZWN0XG5cdFx0XHQsIG9icyA9IHRoaXMuX2NoYW5nZWRcblx0XHRcdCwgcHJvcCA9IHRoaXMucHJvcGVydHlcblx0XHRcdCwgd2FzID0gdGhpcy5jb25uZWN0ZWQ7XG5cdFx0b2JqICYmIG9iai51bm9ic2VydmUgJiYgb2JqLnVub2JzZXJ2ZShwcm9wLCBvYnMsIHRoaXMpO1xuXHRcdHRoaXMuY29ubmVjdGVkID0gbnVsbDtcblx0XHRpZiAod2FzKSB0aGlzLmxpc3QuY29ubmVjdGVkLS07XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZXRPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHR2YXIgY3VyID0gdGhpcy5vYmplY3Rcblx0XHRcdCwgcHJvcCA9IHRoaXMucHJvcGVydHlcblx0XHRcdCwgd2FzLCBpcztcblx0XHRcblx0XHRpZiAoY3VyICE9PSBvYmplY3QpIHtcblx0XHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0XHR0aGlzLmNvbm5lY3QoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubGlzdC50YWlsID09PSB0aGlzKSB7XG5cdFx0XHRcdHdhcyA9IGdldChjdXIsIHByb3ApO1xuXHRcdFx0XHRpcyA9IGdldChvYmplY3QsIHByb3ApO1xuXHRcdFx0XHQvLyBAVE9ETzogSXQgd291bGQgYmUgYmV0dGVyIHRvIHNvbWVob3cgY2FjaGUgdmFsdWVzXG5cdFx0XHRcdC8vIHN1Y2ggdGhhdCBpdCBjb3VsZCBpbnRlbGxpZ2VudGx5IGRlcml2ZSB0aGUgZGlmZmVyZW5jZVxuXHRcdFx0XHQvLyB3aXRob3V0IG5lZWRpbmcgdG8gY29udGludW91c2x5IGxvb2sgaXQgdXAgd2l0aCBnZXRcblx0XHRcdFx0d2FzICE9PSBpcyAmJiB0aGlzLmxpc3Qub2JzZXJ2ZWQodGhpcywgd2FzLCBpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uICh3YXMsIGlzKSB7XG5cdFx0dGhpcy5saXN0Lm9ic2VydmVkKHRoaXMsIHdhcywgaXMpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0xpbmtlZExpc3ROb2RlXCI6MjgsXCIuL2tpbmRcIjo2NixcIi4vdXRpbHNcIjo3NX1dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0QXJyYW5nZXIgPSByZXF1aXJlKCcuL0FycmFuZ2VyJyk7XG5cblxuLyoqXG4qIHtAbGluayBlbnlvLkNhcmRBcnJhbmdlcn0gaXMgYW4ge0BsaW5rIGVueW8uQXJyYW5nZXJ9IHRoYXQgZGlzcGxheXMgb25seVxuKiBvbmUgYWN0aXZlIGNvbnRyb2wuIFRoZSBub24tYWN0aXZlIGNvbnRyb2xzIGFyZSBoaWRkZW4gd2l0aFxuKiBgc2V0U2hvd2luZyhmYWxzZSlgLiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSBmYWRpbmdcbiogZnJvbSBvbmUgY29udHJvbCB0byB0aGUgbmV4dC5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbQXJyYW5nZXJzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvYXJyYW5nZXJzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzICBlbnlvLkNhcmRBcnJhbmdlclxuKiBAZXh0ZW5kcyBlbnlvLkFycmFuZ2VyXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgIGVueW8uQ2FyZEFycmFuZ2VyLnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uQ2FyZEFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBBcnJhbmdlcixcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRsYXlvdXRDbGFzczogJ2VueW8tYXJyYW5nZXIgZW55by1hcnJhbmdlci1maXQnLFxuXG5cdC8qKlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuY2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZX1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGNhbGNBcnJhbmdlbWVudERpZmZlcmVuY2U6IGZ1bmN0aW9uIChpMCwgYTAsIGkxLCBhMSkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lckJvdW5kcy53aWR0aDtcblx0fSxcblxuXHQvKipcblx0KiBBcHBsaWVzIG9wYWNpdHkgdG8gdGhlIGFjdGl2YXRpb24gYW5kIGRlYWN0aXZhdGlvbiBvZiBwYW5lbHMuIEV4cGVjdHMgdGhlIHBhc3NlZC1pblxuXHQqIGFycmF5IG9mIGNvbnRyb2xzIHRvIGJlIG9yZGVyZWQgc3VjaCB0aGF0IHRoZSBmaXJzdCBjb250cm9sIGluIHRoZSBhcnJheSBpcyB0aGUgYWN0aXZlXG5cdCogcGFuZWwuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmFycmFuZ2V9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRhcnJhbmdlOiBmdW5jdGlvbiAoY29udHJvbHMsIGFycmFuZ2VtZW50KSB7XG5cdFx0Zm9yICh2YXIgaT0wLCBjLCB2OyAoYz1jb250cm9sc1tpXSk7IGkrKykge1xuXHRcdFx0diA9IChpID09PSAwKSA/IDEgOiAwO1xuXHRcdFx0dGhpcy5hcnJhbmdlQ29udHJvbChjLCB7b3BhY2l0eTogdn0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBTaG93cyB0aGUgYWN0aXZlIHBhbmVsIGF0IHRoZSBzdGFydCBvZiB0cmFuc2l0aW9uLiBBbHNvIHRyaWdnZXJzIGEgcmVzaXplIG9uXG5cdCogdGhlIGFjdGl2ZSBwYW5lbCBpZiBpdCB3YXNuJ3QgcHJldmlvdXNseSBzaG93aW5nLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5zdGFydH1cblx0KiBAbWV0aG9kXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRzdGFydDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0dmFyIHdhc1Nob3dpbmc9Yy5zaG93aW5nO1xuXHRcdFx0XHRjLnNldFNob3dpbmcoaSA9PSB0aGlzLmNvbnRhaW5lci5mcm9tSW5kZXggfHwgaSA9PSAodGhpcy5jb250YWluZXIudG9JbmRleCkpO1xuXHRcdFx0XHRpZiAoYy5zaG93aW5nICYmICF3YXNTaG93aW5nKSB7XG5cdFx0XHRcdFx0Yy5yZXNpemUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEhpZGVzIGFsbCBub24tYWN0aXZlIHBhbmVscyB3aGVuIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcy5cblx0KlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuZmluaXNofVxuXHQqIEBtZXRob2Rcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGZpbmlzaDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0Yy5zZXRTaG93aW5nKGkgPT0gdGhpcy5jb250YWluZXIudG9JbmRleCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogRW5zdXJlcyBhbGwgcGFuZWxzIGFyZSBzaG93aW5nIGFuZCB2aXNpYmxlIHdoZW4gdGhlIGFycmFuZ2VyIGlzIGRlc3Ryb3llZC5cblx0KlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0QXJyYW5nZXIub3BhY2lmeUNvbnRyb2woYywgMSk7XG5cdFx0XHRcdGlmICghYy5zaG93aW5nKSB7XG5cdFx0XHRcdFx0Yy5zZXRTaG93aW5nKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KVxufSk7XG59LHtcIi4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4vQXJyYW5nZXJcIjo3OH1dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9kb20nKTtcblxudmFyXG5cdEFycmFuZ2VyID0gcmVxdWlyZSgnLi9BcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uQ2Fyb3VzZWxBcnJhbmdlcn0gaXMgYW4ge0BsaW5rIGVueW8uQXJyYW5nZXJ9IHRoYXQgZGlzcGxheXNcbiogdGhlIGFjdGl2ZSBjb250cm9sLCBhbG9uZyB3aXRoIHNvbWUgbnVtYmVyIG9mIGluYWN0aXZlIGNvbnRyb2xzIHRvIGZpbGwgdGhlXG4qIGF2YWlsYWJsZSBzcGFjZS4gVGhlIGFjdGl2ZSBjb250cm9sIGlzIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGVcbiogY29udGFpbmVyLCBhbmQgdGhlIHJlc3Qgb2YgdGhlIHZpZXdzIGFyZSBsYWlkIG91dCB0byB0aGUgcmlnaHQuXG4qXG4qIE9uZSBvZiB0aGUgY29udHJvbHMgbWF5IGhhdmUgYGZpdDogdHJ1ZWAgc2V0LCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgdGFrZSB1cFxuKiBhbnkgcmVtYWluaW5nIHNwYWNlIGFmdGVyIGFsbCBvZiB0aGUgb3RoZXIgY29udHJvbHMgaGF2ZSBiZWVuIHNpemVkLlxuKlxuKiBGb3IgYmVzdCByZXN1bHRzIHdpdGggQ2Fyb3VzZWxBcnJhbmdlciwgeW91IHNob3VsZCBzZXQgYSBtaW5pbXVtIHdpZHRoIGZvclxuKiBlYWNoIGNvbnRyb2wgdmlhIGEgQ1NTIHN0eWxlLCBlLmcuLCBgbWluLXdpZHRoOiAyNSVgIG9yIGBtaW4td2lkdGg6IDI1MHB4YC5cbipcbiogVHJhbnNpdGlvbnMgYmV0d2VlbiBhcnJhbmdlbWVudHMgYXJlIGhhbmRsZWQgYnkgc2xpZGluZyB0aGUgbmV3IGNvbnRyb2xzIGluXG4qIGZyb20gdGhlIHJpZ2h0IGFuZCBzbGlkaW5nIHRoZSBvbGQgY29udHJvbHMgb2ZmIHRvIHRoZSBsZWZ0LlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uQ2Fyb3VzZWxBcnJhbmdlclxuKiBAZXh0ZW5kcyBlbnlvLkFycmFuZ2VyXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5DYXJvdXNlbEFycmFuZ2VyICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5DYXJvdXNlbEFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBBcnJhbmdlcixcblxuXHQvKipcblx0KiBDYWxjdWxhdGVzIHRoZSBzaXplIG9mIGVhY2ggcGFuZWwuIENvbnNpZGVycyB0aGUgcGFkZGluZyBvZiB0aGUgY29udGFpbmVyIGJ5IGNhbGxpbmdcblx0KiB7QGxpbmsgZW55by5kb20jY2FsY1BhZGRpbmdFeHRlbnRzfSBhbmQgY29udHJvbCBtYXJnaW4gYnkgY2FsbGluZ1xuXHQqIHtAbGluayBlbnlvLmRvbSNjYWxjTWFyZ2luRXh0ZW50c30uIElmIHRoZSBjb250YWluZXIgaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbWJpbmVkIHNpemVzIG9mXG5cdCogdGhlIGNvbnRyb2xzLCBvbmUgY29udHJvbCBtYXkgYmUgc2V0IHRvIGZpbGwgdGhlIHJlbWFpbmluZyBzcGFjZSBieSBzZXR0aW5nIGl0cyBgZml0YFxuXHQqIHByb3BlcnR5IHRvIGB0cnVlYC4gSWYgbXVsdGlwbGUgY29udHJvbHMgaGF2ZSBgZml0OiB0cnVlYCBzZXQsIHRoZSBsYXN0IGNvbnRyb2wgdG8gYmUgc29cblx0KiBtYXJrZWQgd2lsbCBoYXZlIHByZWNlZGVuY2UuXG5cdCpcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHR2YXIgcGFkZGluZyA9IHRoaXMuY29udGFpbmVyUGFkZGluZyA9IHRoaXMuY29udGFpbmVyLmhhc05vZGUoKSA/IGRvbS5jYWxjUGFkZGluZ0V4dGVudHModGhpcy5jb250YWluZXIubm9kZSkgOiB7fTtcblx0XHR2YXIgcGIgPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcblx0XHR2YXIgaSwgZSwgcywgbSwgYztcblx0XHRwYi5oZWlnaHQgLT0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcblx0XHRwYi53aWR0aCAtPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuXHRcdC8vIHVzZWQgc3BhY2Vcblx0XHR2YXIgZml0O1xuXHRcdGZvciAoaT0wLCBzPTA7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRtID0gZG9tLmNhbGNNYXJnaW5FeHRlbnRzKGMuaGFzTm9kZSgpKTtcblx0XHRcdGMud2lkdGggPSBjLmdldEJvdW5kcygpLndpZHRoO1xuXHRcdFx0Yy5tYXJnaW5XaWR0aCA9IG0ucmlnaHQgKyBtLmxlZnQ7XG5cdFx0XHRzICs9IChjLmZpdCA/IDAgOiBjLndpZHRoKSArIGMubWFyZ2luV2lkdGg7XG5cdFx0XHRpZiAoYy5maXQpIHtcblx0XHRcdFx0Zml0ID0gYztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZpdCkge1xuXHRcdFx0dmFyIHcgPSBwYi53aWR0aCAtIHM7XG5cdFx0XHRmaXQud2lkdGggPSB3ID49IDAgPyB3IDogZml0LndpZHRoO1xuXHRcdH1cblx0XHRmb3IgKGk9MCwgZT1wYWRkaW5nLmxlZnQ7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRjLnNldEJvdW5kcyh7dG9wOiBwYWRkaW5nLnRvcCwgYm90dG9tOiBwYWRkaW5nLmJvdHRvbSwgd2lkdGg6IGMuZml0ID8gYy53aWR0aCA6IG51bGx9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5hcnJhbmdlfVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0YXJyYW5nZTogZnVuY3Rpb24gKGNvbnRyb2xzLCBhcnJhbmdlbWVudCkge1xuXHRcdGlmICh0aGlzLmNvbnRhaW5lci53cmFwKSB7XG5cdFx0XHR0aGlzLmFycmFuZ2VXcmFwKGNvbnRyb2xzLCBhcnJhbmdlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXJyYW5nZU5vV3JhcChjb250cm9scywgYXJyYW5nZW1lbnQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBBIG5vbi13cmFwcGluZyBjYXJvdXNlbCBhcnJhbmdlcyB0aGUgY29udHJvbHMgZnJvbSBsZWZ0IHRvIHJpZ2h0IHdpdGhvdXQgcmVnYXJkIHRvIHRoZVxuXHQqIG9yZGVyZWQgYXJyYXkgcGFzc2VkIHZpYSBgY29udHJvbHNgLiBgYXJyYW5nZW1lbnRgIHdpbGwgY29udGFpbiB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZVxuXHQqIHBhbmVsLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YXJyYW5nZU5vV3JhcDogZnVuY3Rpb24gKGNvbnRyb2xzLCBhcnJhbmdlbWVudCkge1xuXHRcdHZhciBpLCBhdywgY3csIGM7XG5cdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0dmFyIHMgPSB0aGlzLmNvbnRhaW5lci5jbGFtcChhcnJhbmdlbWVudCk7XG5cdFx0dmFyIG53ID0gdGhpcy5jb250YWluZXJCb3VuZHMud2lkdGg7XG5cdFx0Ly8gZG8gd2UgaGF2ZSBlbm91Z2ggY29udGVudCB0byBmaWxsIHRoZSB3aWR0aD9cblx0XHRmb3IgKGk9cywgY3c9MDsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdGN3ICs9IGMud2lkdGggKyBjLm1hcmdpbldpZHRoO1xuXHRcdFx0aWYgKGN3ID4gbncpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlmIGNvbnRlbnQgd2lkdGggaXMgbGVzcyB0aGFuIG5lZWRlZCwgYWRqdXN0IHN0YXJ0aW5nIHBvaW50IGluZGV4IGFuZCBvZmZzZXRcblx0XHR2YXIgbiA9IG53IC0gY3c7XG5cdFx0dmFyIG8gPSAwO1xuXHRcdGlmIChuID4gMCkge1xuXHRcdFx0Zm9yIChpPXMtMSwgYXc9MDsgKGM9YyRbaV0pOyBpLS0pIHtcblx0XHRcdFx0YXcgKz0gYy53aWR0aCArIGMubWFyZ2luV2lkdGg7XG5cdFx0XHRcdGlmIChuIC0gYXcgPD0gMCkge1xuXHRcdFx0XHRcdG8gPSAobiAtIGF3KTtcblx0XHRcdFx0XHRzID0gaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBhcnJhbmdlIHN0YXJ0aW5nIGZyb20gbmVlZGVkIGluZGV4IHdpdGggZGV0ZWN0ZWQgb2Zmc2V0IHNvIHdlIGZpbGwgc3BhY2Vcblx0XHR2YXIgdywgZTtcblx0XHRmb3IgKGk9MCwgZT10aGlzLmNvbnRhaW5lclBhZGRpbmcubGVmdCArIG87IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHR3ID0gYy53aWR0aCArIGMubWFyZ2luV2lkdGg7XG5cdFx0XHRpZiAoaSA8IHMpIHtcblx0XHRcdFx0dGhpcy5hcnJhbmdlQ29udHJvbChjLCB7bGVmdDogLXd9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJyYW5nZUNvbnRyb2woYywge2xlZnQ6IE1hdGguZmxvb3IoZSl9KTtcblx0XHRcdFx0ZSArPSB3O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBBcnJhbmdlcyBgY29udHJvbHNgIGZyb20gbGVmdCB0byByaWdodCBzdWNoIHRoYXQgdGhlIGFjdGl2ZSBwYW5lbCBpcyBhbHdheXMgdGhlXG5cdCogbGVmdG1vc3QsIHdpdGggc3Vic2VxdWVudCBwYW5lbHMgcG9zaXRpb25lZCB0byBpdHMgcmlnaHQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhcnJhbmdlV3JhcDogZnVuY3Rpb24gKGNvbnRyb2xzLCBhcnJhbmdlbWVudCkge1xuXHRcdGZvciAodmFyIGk9MCwgZT10aGlzLmNvbnRhaW5lclBhZGRpbmcubGVmdCwgYzsgKGM9Y29udHJvbHNbaV0pOyBpKyspIHtcblx0XHRcdHRoaXMuYXJyYW5nZUNvbnRyb2woYywge2xlZnQ6IGV9KTtcblx0XHRcdGUgKz0gYy53aWR0aCArIGMubWFyZ2luV2lkdGg7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGN1bGF0ZXMgdGhlIGNoYW5nZSBpbiBgbGVmdGAgcG9zaXRpb24gYmV0d2VlbiB0aGUgdHdvIGFycmFuZ2VtZW50cyBgYTBgIGFuZCBgYTFgLlxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0Y2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZTogZnVuY3Rpb24gKGkwLCBhMCwgaTEsIGExKSB7XG5cdFx0dmFyIGkgPSBNYXRoLmFicyhpMCAlIHRoaXMuYyQubGVuZ3RoKTtcblx0XHRyZXR1cm4gYTBbaV0ubGVmdCAtIGExW2ldLmxlZnQ7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzZXRzIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBhbGwgcGFuZWxzLlxuXHQqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0XHRBcnJhbmdlci5wb3NpdGlvbkNvbnRyb2woYywge2xlZnQ6IG51bGwsIHRvcDogbnVsbH0pO1xuXHRcdFx0XHRjLmFwcGx5U3R5bGUoJ3RvcCcsIG51bGwpO1xuXHRcdFx0XHRjLmFwcGx5U3R5bGUoJ2JvdHRvbScsIG51bGwpO1xuXHRcdFx0XHRjLmFwcGx5U3R5bGUoJ2xlZnQnLCBudWxsKTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCd3aWR0aCcsIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSlcbn0pO1xufSx7XCIuLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4vQXJyYW5nZXJcIjo3OH1dLDg0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9kb20nKTtcblxudmFyXG5cdEFycmFuZ2VyID0gcmVxdWlyZSgnLi9BcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uRG9ja1JpZ2h0QXJyYW5nZXJ9IGlzIGFuIHtAbGluayBlbnlvLkFycmFuZ2VyfSB0aGF0IGRpc3BsYXlzIHRoZVxuKiBhY3RpdmUgY29udHJvbCwgYWxvbmcgd2l0aCBzb21lIG51bWJlciBvZiBpbmFjdGl2ZSBjb250cm9scyB0byBmaWxsIHRoZVxuKiBhdmFpbGFibGUgc3BhY2UuIFRoZSBhY3RpdmUgY29udHJvbCBpcyBwb3NpdGlvbmVkIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZVxuKiBjb250YWluZXIgYW5kIHRoZSByZXN0IG9mIHRoZSB2aWV3cyBhcmUgbGFpZCBvdXQgdG8gdGhlIHJpZ2h0LlxuKlxuKiBGb3IgYmVzdCByZXN1bHRzIHdpdGggRG9ja1JpZ2h0QXJyYW5nZXIsIHlvdSBzaG91bGQgc2V0IGEgbWluaW11bSB3aWR0aFxuKiBmb3IgZWFjaCBjb250cm9sIHZpYSBhIENTUyBzdHlsZSwgZS5nLiwgYG1pbi13aWR0aDogMjUlYCBvclxuKiBgbWluLXdpZHRoOiAyNTBweGAuXG4qXG4qIFRyYW5zaXRpb25zIGJldHdlZW4gYXJyYW5nZW1lbnRzIGFyZSBoYW5kbGVkIGJ5IHNsaWRpbmcgdGhlIG5ldyBjb250cm9sXHRpblxuKiBmcm9tIHRoZSByaWdodC4gSWYgdGhlIHdpZHRoIG9mIHRoZSBvbGQgY29udHJvbChzKSBjYW4gZml0IHdpdGhpbiB0aGVcbiogY29udGFpbmVyLCB0aGV5IHdpbGwgc2xpZGUgdG8gdGhlIGxlZnQuIElmIG5vdCwgdGhleSB3aWxsIGNvbGxhcHNlIHRvIHRoZSBsZWZ0LlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uRG9ja1JpZ2h0QXJyYW5nZXJcbiogQGV4dGVuZHMgZW55by5BcnJhbmdlclxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uRG9ja1JpZ2h0QXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Eb2NrUmlnaHRBcnJhbmdlcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQXJyYW5nZXIsXG5cblx0LyoqXG5cdCogSWYgYHRydWVgLCB0aGUgYmFzZSBwYW5lbCAoaS5lLiwgdGhlIHBhbmVsIGF0IGluZGV4IGAwYCkgd2lsbCBmaWxsIHRoZSB3aWR0aFxuXHQqIG9mIHRoZSBjb250YWluZXIsIHdoaWxlIG5ld2VyIGNvbnRyb2xzIHdpbGwgc2xpZGUgaW4gYW5kIGNvbGxhcHNlIG9uIHRvcCBvZiBpdC5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0ICBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YmFzZVBhbmVsOiBmYWxzZSxcblxuXHQvKipcblx0KiBQYW5lbHMgd2lsbCBvdmVybGFwIGJ5IHRoaXMgbnVtYmVyIG9mIHBpeGVscy5cblx0KlxuXHQqIE5vdGUgdGhhdCB0aGlzIGlzIGltcG9ydGVkIGZyb20gdGhlIGNvbnRhaW5lciBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQGRlZmF1bHQgIDBcblx0KiBAcHVibGljXG5cdCovXG5cdG92ZXJsYXA6IDAsXG5cblx0LyoqXG5cdCogVGhlIGNvbHVtbiB3aWR0aCBpbiBwaXhlbHMuXG5cdCpcblx0KiBOb3RlIHRoYXQgdGhpcyBpcyBpbXBvcnRlZCBmcm9tIHRoZSBjb250YWluZXIgYXQgY29uc3RydWN0aW9uIHRpbWUuXG5cdCpcblx0KiBAdHlwZSB7TnVtYmVyfVxuXHQqIEBkZWZhdWx0ICAwXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRsYXlvdXRXaWR0aDogMCxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHRBcnJhbmdlci5wcm90b3R5cGUuX2NvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5vdmVybGFwID0gdGhpcy5jb250YWluZXIub3ZlcmxhcCAhPSBudWxsID8gdGhpcy5jb250YWluZXIub3ZlcmxhcCA6IHRoaXMub3ZlcmxhcDtcblx0XHR0aGlzLmxheW91dFdpZHRoID0gdGhpcy5jb250YWluZXIubGF5b3V0V2lkdGggIT0gbnVsbCA/IHRoaXMuY29udGFpbmVyLmxheW91dFdpZHRoIDogdGhpcy5sYXlvdXRXaWR0aDtcblx0fSxcblxuXHQvKipcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLnNpemV9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0dmFyIHBhZGRpbmcgPSB0aGlzLmNvbnRhaW5lclBhZGRpbmcgPSB0aGlzLmNvbnRhaW5lci5oYXNOb2RlKCkgPyBkb20uY2FsY1BhZGRpbmdFeHRlbnRzKHRoaXMuY29udGFpbmVyLm5vZGUpIDoge307XG5cdFx0dmFyIHBiID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG5cdFx0dmFyIGksIG0sIGM7XG5cdFx0cGIud2lkdGggLT0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcblx0XHR2YXIgbncgPSBwYi53aWR0aDtcblx0XHR2YXIgbGVuID0gYyQubGVuZ3RoO1xuXHRcdHZhciBvZmZzZXQ7XG5cdFx0Ly8gcGFuZWwgYXJyYW5nZW1lbnQgcG9zaXRpb25zXG5cdFx0dGhpcy5jb250YWluZXIudHJhbnNpdGlvblBvc2l0aW9ucyA9IHt9O1xuXG5cdFx0Zm9yIChpPTA7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRjLndpZHRoID0gKChpPT09MCkgJiYgKHRoaXMuY29udGFpbmVyLmJhc2VQYW5lbCkpID8gbncgOiBjLmdldEJvdW5kcygpLndpZHRoO1xuXHRcdH1cblxuXHRcdGZvciAoaT0wOyAoYz1jJFtpXSk7IGkrKykge1xuXG5cdFx0XHRpZiAoKGk9PT0wKSAmJiAodGhpcy5jb250YWluZXIuYmFzZVBhbmVsKSkge1xuXHRcdFx0XHRjLnNldEJvdW5kcyh7d2lkdGg6IG53fSk7XG5cdFx0XHR9XG5cdFx0XHRjLnNldEJvdW5kcyh7dG9wOiBwYWRkaW5nLnRvcCwgYm90dG9tOiBwYWRkaW5nLmJvdHRvbX0pO1xuXG5cdFx0XHRmb3IgKHZhciBqPTA7IChjPWMkW2pdKTsgaisrKSB7XG5cdFx0XHRcdHZhciB4UG9zO1xuXHRcdFx0XHQvLyBpbmRleCAwIGFsd2F5cyBzaG91bGQgYWx3YXlzIGJlIGxlZnQtYWxpZ25lZCBhdCAwcHhcblx0XHRcdFx0aWYgKChpPT09MCkgJiYgKHRoaXMuY29udGFpbmVyLmJhc2VQYW5lbCkpIHtcblx0XHRcdFx0XHR4UG9zID0gMDtcblx0XHRcdFx0Ly8gZWxzZSBuZXdlciBwYW5lbHMgc2hvdWxkIGJlIHBvc2l0aW9uZWQgb2ZmIHRoZSB2aWV3cG9ydFxuXHRcdFx0XHR9IGVsc2UgaWYgKGogPCBpKSB7XG5cdFx0XHRcdFx0eFBvcyA9IG53O1xuXHRcdFx0XHQvLyBlbHNlIGFjdGl2ZSBwYW5lbCBzaG91bGQgYmUgcmlnaHQtYWxpZ25lZFxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IGopIHtcblx0XHRcdFx0XHRvZmZzZXQgPSBudyA+IHRoaXMubGF5b3V0V2lkdGggPyB0aGlzLm92ZXJsYXAgOiAwO1xuXHRcdFx0XHRcdHhQb3MgPSAobncgLSBjJFtpXS53aWR0aCkgKyBvZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jb250YWluZXIudHJhbnNpdGlvblBvc2l0aW9uc1tpICsgJy4nICsgal0gPSB4UG9zO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaiA8IGxlbikge1xuXHRcdFx0XHR2YXIgbGVmdEFsaWduID0gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGs9aSsxOyBrPGxlbjsgaysrKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdFx0XHQvLyBwb3NpdGlvbiBwYW5lbCB0byBsZWZ0OiAwcHhcblx0XHRcdFx0XHRpZiAobGVmdEFsaWduKSB7XG5cdFx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0XHRcdC8vIGVsc2UgaWYgbmV4dCBwYW5lbCBjYW5ub3QgZml0IHdpdGhpbiBjb250YWluZXJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoYyRbaV0ud2lkdGggKyBjJFtrXS53aWR0aCAtIHRoaXMub3ZlcmxhcCkgPiBudyApIHtcblx0XHRcdFx0XHQvL30gZWxzZSBpZiAoIChjJFtpXS53aWR0aCArIGMkW2tdLndpZHRoKSA+IG53ICkge1xuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdFx0XHRcdGxlZnRBbGlnbiA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG9mZnNldCA9IGMkW2ldLndpZHRoIC0gdGhpcy5vdmVybGFwO1xuXHRcdFx0XHRcdFx0Zm9yIChtPWk7IG08azsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfdyA9IG9mZnNldCArIGMkW20rMV0ud2lkdGggLSB0aGlzLm92ZXJsYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChfdyA8IG53KSB7XG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gX3c7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gbnc7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9mZnNldCA9IG53IC0gb2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lci50cmFuc2l0aW9uUG9zaXRpb25zW2kgKyAnLicgKyBrXSA9IG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIGBsZWZ0YCBwb3NpdGlvbiBmb3IgZWFjaCBwYW5lbCBhY2NvcmRpbmcgdG8gdGhlIGBhcnJhbmdlbWVudGAuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmFycmFuZ2V9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRhcnJhbmdlOiBmdW5jdGlvbiAoY29udHJvbHMsIGFycmFuZ2VtZW50KSB7XG5cdFx0dmFyIGksIGM7XG5cdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0dmFyIHMgPSB0aGlzLmNvbnRhaW5lci5jbGFtcChhcnJhbmdlbWVudCk7XG5cblx0XHRmb3IgKGk9MDsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdHZhciB4UG9zID0gdGhpcy5jb250YWluZXIudHJhbnNpdGlvblBvc2l0aW9uc1tpICsgJy4nICsgc107XG5cdFx0XHR0aGlzLmFycmFuZ2VDb250cm9sKGMsIHtsZWZ0OiB4UG9zfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgaW4gd2lkdGggYmV0d2VlbiB0aGUgcGFuZWxzIGF0IGBpMGAgYW5kIGBpMWAuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmNhbGNBcnJhbmdlbWVudERpZmZlcmVuY2V9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRjYWxjQXJyYW5nZW1lbnREaWZmZXJlbmNlOiBmdW5jdGlvbiAoaTAsIGEwLCBpMSwgYTEpIHtcblx0XHR2YXIgcCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdHZhciB3ID0gKGkwIDwgaTEpID8gcFtpMV0ud2lkdGggOiBwW2kwXS53aWR0aDtcblx0XHRyZXR1cm4gdztcblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYW5lbHMuXG5cdCpcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdEFycmFuZ2VyLnBvc2l0aW9uQ29udHJvbChjLCB7bGVmdDogbnVsbCwgdG9wOiBudWxsfSk7XG5cdFx0XHRjLmFwcGx5U3R5bGUoJ3RvcCcsIG51bGwpO1xuXHRcdFx0Yy5hcHBseVN0eWxlKCdib3R0b20nLCBudWxsKTtcblx0XHRcdGMuYXBwbHlTdHlsZSgnbGVmdCcsIG51bGwpO1xuXHRcdFx0Yy5hcHBseVN0eWxlKCd3aWR0aCcsIG51bGwpO1xuXHRcdH1cblx0XHRBcnJhbmdlci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55by9saWIvZG9tXCI6NTgsXCIuLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuL0FycmFuZ2VyXCI6Nzh9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL2tpbmQnKTtcblxudmFyXG5cdEFycmFuZ2VyID0gcmVxdWlyZSgnLi9BcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uR3JpZEFycmFuZ2VyfSBpcyBhbiB7QGxpbmsgZW55by5BcnJhbmdlcn0gdGhhdCBhcnJhbmdlc1xuKiBjb250cm9scyBpbiBhIGdyaWQuIFRoZSBhY3RpdmUgY29udHJvbCBpcyBwb3NpdGlvbmVkIGF0IHRoZSB0b3AtbGVmdCBvZiB0aGVcbiogZ3JpZCBhbmQgdGhlIG90aGVyIGNvbnRyb2xzIGFyZSBsYWlkIG91dCBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHRoZW4gZnJvbVxuKiB0b3AgdG8gYm90dG9tLlxuKlxuKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSBtb3ZpbmcgdGhlIGFjdGl2ZSBjb250cm9sIHRvXG4qIHRoZSBlbmQgb2YgdGhlIGdyaWQgYW5kIHNoaWZ0aW5nIHRoZSBvdGhlciBjb250cm9sc1x0dG8gdGhlIGxlZnQsIG9yIGJ5XG4qIG1vdmluZyBpdCB1cCB0byB0aGUgcHJldmlvdXMgcm93LCB0byBmaWxsIHRoZSBzcGFjZS5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbQXJyYW5nZXJzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvYXJyYW5nZXJzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5HcmlkQXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5HcmlkQXJyYW5nZXInLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IEFycmFuZ2VyLFxuXG5cdC8qKlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuaW5jcmVtZW50YWxQb2ludHN9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5jcmVtZW50YWxQb2ludHM6IHRydWUsXG5cblx0LyoqXG5cdCAqIFRoZSBjb2x1bW4gd2lkdGggaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0Y29sV2lkdGg6IDEwMCxcblxuXHQvKipcblx0ICogVGhlIGNvbHVtbiBoZWlnaHQgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0Y29sSGVpZ2h0OiAxMDAsXG5cblx0LyoqXG5cdCogU2l6ZXMgZWFjaCBwYW5lbCB0byBiZSBbY29sV2lkdGhde0BsaW5rIGVueW8uR3JpZEFycmFuZ2VyI2NvbFdpZHRofSBwaXhlbHMgd2lkZVxuXHQqIGFuZCBbY29sSGVpZ2h0XXtAbGluayBlbnlvLkdyaWRBcnJhbmdlciNjb2xIZWlnaHR9IHBpeGVscyBoaWdoLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5zaXplfVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0c2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdHZhciB3PXRoaXMuY29sV2lkdGgsIGg9dGhpcy5jb2xIZWlnaHQ7XG5cdFx0Zm9yICh2YXIgaT0wLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0Yy5zZXRCb3VuZHMoe3dpZHRoOiB3LCBoZWlnaHQ6IGh9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYmFzZWQgb24gdGhlIGNvbnRhaW5lcidzIHdpZHRoIGFuZFxuXHQqIFtjb2xXaWR0aF17QGxpbmsgZW55by5HcmlkQXJyYW5nZXIjY29sV2lkdGh9LiBFYWNoIHJvdyBpcyBwb3NpdGlvbmVkXG5cdCogc3RhcnRpbmcgYXQgdGhlIHRvcC1sZWZ0IG9mIHRoZSBjb250YWluZXIuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmFycmFuZ2V9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRhcnJhbmdlOiBmdW5jdGlvbiAoY29udHJvbHMsIGFycmFuZ2VtZW50KSB7XG5cdFx0dmFyIHc9dGhpcy5jb2xXaWR0aCwgaD10aGlzLmNvbEhlaWdodDtcblx0XHR2YXIgY29scyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodGhpcy5jb250YWluZXJCb3VuZHMud2lkdGggLyB3KSk7XG5cdFx0dmFyIGM7XG5cdFx0Zm9yICh2YXIgeT0wLCBpPTA7IGk8Y29udHJvbHMubGVuZ3RoOyB5KyspIHtcblx0XHRcdGZvciAodmFyIHg9MDsgKHg8Y29scykgJiYgKGM9Y29udHJvbHNbaV0pOyB4KyssIGkrKykge1xuXHRcdFx0XHR0aGlzLmFycmFuZ2VDb250cm9sKGMsIHtsZWZ0OiB3KngsIHRvcDogaCp5fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIElmIHRoZSBjb250cm9sIGlzIG1vdmluZyBiZXR3ZWVuIHJvd3MsIGFkanVzdHMgaXRzIG9wYWNpdHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5mbG93Q29udHJvbH1cblx0KiBAbWV0aG9kXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRmbG93Q29udHJvbDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGluQ29udHJvbCwgaW5BKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdEFycmFuZ2VyLm9wYWNpZnlDb250cm9sKGluQ29udHJvbCwgaW5BLnRvcCAlIHRoaXMuY29sSGVpZ2h0ICE9PSAwID8gMC4yNSA6IDEpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuY2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZX1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGNhbGNBcnJhbmdlbWVudERpZmZlcmVuY2U6IGZ1bmN0aW9uIChpbkkwLCBpbkEwLCBpbkkxLCBpbkExKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29sV2lkdGg7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzZXRzIHBvc2l0aW9uIG9mIHBhbmVscy5cblx0KlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0QXJyYW5nZXIucG9zaXRpb25Db250cm9sKGMsIHtsZWZ0OiBudWxsLCB0b3A6IG51bGx9KTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCdsZWZ0JywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgndG9wJywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgnaGVpZ2h0JywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgnd2lkdGgnLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9BcnJhbmdlclwiOjc4fV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9raW5kJyk7XG5cbnZhclxuXHRBcnJhbmdlciA9IHJlcXVpcmUoJy4vQXJyYW5nZXInKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyfSBpcyBhbiB7QGxpbmsgZW55by5BcnJhbmdlcn0gdGhhdCBkaXNwbGF5c1xuKiB0aGUgYWN0aXZlIGNvbnRyb2wgYW5kIHNvbWUgb2YgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGNvbnRyb2xzLiBUaGUgYWN0aXZlXG4qIGNvbnRyb2wgaXMgY2VudGVyZWQgaG9yaXpvbnRhbGx5IGluIHRoZSBjb250YWluZXIsIGFuZCB0aGUgcHJldmlvdXMgYW5kIG5leHRcbiogY29udHJvbHMgYXJlIGxhaWQgb3V0IHRvIHRoZSBsZWZ0IGFuZCByaWdodCwgcmVzcGVjdGl2ZWx5LlxuKlxuKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSBzbGlkaW5nIHRoZSBuZXcgY29udHJvbCBpblxuKiBmcm9tIHRoZSByaWdodCBhbmQgc2xpZGluZyB0aGUgYWN0aXZlIGNvbnRyb2wgb3V0IHRvIHRoZSBsZWZ0LlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uTGVmdFJpZ2h0QXJyYW5nZXJcbiogQGV4dGVuZHMgZW55by5BcnJhbmdlclxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uTGVmdFJpZ2h0QXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5MZWZ0UmlnaHRBcnJhbmdlcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQXJyYW5nZXIsXG5cblx0LyoqXG5cdCAqIFRoZSBtYXJnaW4gd2lkdGggKGkuZS4sIGhvdyBtdWNoIG9mIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjb250cm9sc1xuXHQgKiBhcmUgdmlzaWJsZSkgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBpcyBpbXBvcnRlZCBmcm9tIHRoZSBjb250YWluZXIgYXQgY29uc3RydWN0aW9uIHRpbWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDQwXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdG1hcmdpbjogNDAsXG5cblx0LyoqXG5cdCAqIFRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBwYW5lbHMgd2lsbCBhbmltYXRlLlxuXHQgKlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAcmVhZE9ubHlcblx0ICogQGRlZmF1bHQgJ3dpZHRoJ1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRheGlzU2l6ZTogJ3dpZHRoJyxcblxuXHQvKipcblx0ICogVGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIHBhbmVscyB3aWxsICoqbm90KiogYW5pbWF0ZS5cblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHJlYWRPbmx5XG5cdCAqIEBkZWZhdWx0ICdoZWlnaHQnXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdG9mZkF4aXNTaXplOiAnaGVpZ2h0JyxcblxuXHQvKipcblx0ICogVGhlIGF4aXMgcG9zaXRpb24gYXQgd2hpY2ggdGhlIHBhbmVsIHdpbGwgYW5pbWF0ZS5cblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQHJlYWRPbmx5XG5cdCAqIEBkZWZhdWx0ICdsZWZ0J1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRheGlzUG9zaXRpb246ICdsZWZ0JyxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tYXJnaW4gPSB0aGlzLmNvbnRhaW5lci5tYXJnaW4gIT0gbnVsbCA/IHRoaXMuY29udGFpbmVyLm1hcmdpbiA6IHRoaXMubWFyZ2luO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFNpemVzIHRoZSBwYW5lbHMgc3VjaCB0aGF0IHRoZXkgZmlsbCBbb2ZmQXhpc1NpemVde0BsaW5rIGVueW8uTGVmdFJpZ2h0QXJyYW5nZXIjb2ZmQXhpc1NpemV9XG5cdCogYW5kIHlpZWxkIFttYXJnaW5de0BsaW5rIGVueW8uTGVmdFJpZ2h0QXJyYW5nZXIjbWFyZ2lufSBwaXhlbHMgb24gZWFjaCBzaWRlIG9mXG5cdCogW2F4aXNTaXplXXtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyI2F4aXNTaXplfS5cblx0KlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuc2l6ZX1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHR2YXIgcG9ydCA9IHRoaXMuY29udGFpbmVyQm91bmRzW3RoaXMuYXhpc1NpemVdO1xuXHRcdHZhciBib3ggPSBwb3J0IC0gdGhpcy5tYXJnaW4gLXRoaXMubWFyZ2luO1xuXHRcdGZvciAodmFyIGk9MCwgYiwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdGIgPSB7fTtcblx0XHRcdGJbdGhpcy5heGlzU2l6ZV0gPSBib3g7XG5cdFx0XHRiW3RoaXMub2ZmQXhpc1NpemVdID0gJzEwMCUnO1xuXHRcdFx0Yy5zZXRCb3VuZHMoYik7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFRvIHByZXZlbnQgYSBwYW5lbCB0aGF0IGlzIHN3aXRjaGluZyBzaWRlcyAodG8gbWFpbnRhaW4gdGhlIGJhbGFuY2UpIGZyb20gb3ZlcmxhcHBpbmdcblx0KiB0aGUgYWN0aXZlIHBhbmVsIGR1cmluZyB0aGUgYW5pbWF0aW9uLCB1cGRhdGVzIHRoZSBgei1pbmRleGAgb2YgdGhlIHN3aXRjaGluZyBwYW5lbFxuXHQqIHRvIGVuc3VyZSB0aGF0IGl0IHN0YXlzIGJlaGluZCB0aGUgb3RoZXIgcGFuZWxzLlxuXHQqXG5cdCogQHRvZG8gQ291bGQgdXNlIHNvbWUgb3B0aW1pemF0aW9uIGluIGl0cyBgZm9yYCBsb29wIChlLmcuIC5sZW5ndGggbG9va3VwIGFuZCBjYWxjKVxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuc3RhcnR9XG5cdCogQG1ldGhvZFxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0c3RhcnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHR2YXIgcyA9IHRoaXMuY29udGFpbmVyLmZyb21JbmRleDtcblx0XHRcdHZhciBmID0gdGhpcy5jb250YWluZXIudG9JbmRleDtcblx0XHRcdHZhciBjJCA9IHRoaXMuZ2V0T3JkZXJlZENvbnRyb2xzKGYpO1xuXHRcdFx0dmFyIG8gPSBNYXRoLmZsb29yKGMkLmxlbmd0aC8yKTtcblxuXHRcdFx0Zm9yICh2YXIgaT0wLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0XHRpZiAocyA+IGYpe1xuXHRcdFx0XHRcdGlmIChpID09IChjJC5sZW5ndGggLSBvKSl7XG5cdFx0XHRcdFx0XHRjLmFwcGx5U3R5bGUoJ3otaW5kZXgnLCAwKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Yy5hcHBseVN0eWxlKCd6LWluZGV4JywgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpID09IChjJC5sZW5ndGgtMSAtIG8pKXtcblx0XHRcdFx0XHRcdGMuYXBwbHlTdHlsZSgnei1pbmRleCcsIDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjLmFwcGx5U3R5bGUoJ3otaW5kZXgnLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBCYWxhbmNlcyB0aGUgcGFuZWxzIGxhaWQgb3V0IHRvIGVhY2ggc2lkZSBvZiB0aGUgYWN0aXZlIHBhbmVsXG5cdCogc3VjaCB0aGF0LCBmb3IgYSBzZXQgb2YgYG5gIHBhbmVscywgYGZsb29yKG4vMilgIGFyZSBiZWZvcmUgYW5kIGBjZWlsKG4vMilgIGFyZSBhZnRlclxuXHQqIHRoZSBhY3RpdmUgcGFuZWwuXG5cdCpcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGFycmFuZ2U6IGZ1bmN0aW9uIChjb250cm9scywgYXJyYW5nZW1lbnQpIHtcblx0XHR2YXIgaSxjLGI7XG5cdFx0aWYgKHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpLmxlbmd0aD09MSl7XG5cdFx0XHRiID0ge307XG5cdFx0XHRiW3RoaXMuYXhpc1Bvc2l0aW9uXSA9IHRoaXMubWFyZ2luO1xuXHRcdFx0dGhpcy5hcnJhbmdlQ29udHJvbCh0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKVswXSwgYik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBvID0gTWF0aC5mbG9vcih0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKS5sZW5ndGgvMik7XG5cdFx0dmFyIGMkID0gdGhpcy5nZXRPcmRlcmVkQ29udHJvbHMoTWF0aC5mbG9vcihhcnJhbmdlbWVudCktbyk7XG5cdFx0dmFyIGJveCA9IHRoaXMuY29udGFpbmVyQm91bmRzW3RoaXMuYXhpc1NpemVdIC0gdGhpcy5tYXJnaW4gLSB0aGlzLm1hcmdpbjtcblx0XHR2YXIgZSA9IHRoaXMubWFyZ2luIC0gYm94ICogbztcblx0XHRmb3IgKGk9MDsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdGIgPSB7fTtcblx0XHRcdGJbdGhpcy5heGlzUG9zaXRpb25dID0gZTtcblx0XHRcdHRoaXMuYXJyYW5nZUNvbnRyb2woYywgYik7XG5cdFx0XHRlICs9IGJveDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBhbG9uZyB0aGVcblx0KiBbYXhpc1Bvc2l0aW9uXXtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyI2F4aXNQb3NpdGlvbn0gKGUuZy4sIGAnbGVmdCdgKS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbkkwIC0gVGhlIGluaXRpYWwgbGF5b3V0IHNldHRpbmcuXG5cdCogQHBhcmFtIHtPYmplY3R9IGluQTAgLSBUaGUgaW5pdGlhbCBhcnJhbmdlbWVudC5cblx0KiBAcGFyYW0ge051bWJlcn0gaW5JMSAtIFRoZSB0YXJnZXQgbGF5b3V0IHNldHRpbmcuXG5cdCogQHBhcmFtIHtPYmplY3R9IGluQTEgLSBUaGUgdGFyZ2V0IGFycmFuZ2VtZW50LlxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0Y2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZTogZnVuY3Rpb24gKGluSTAsIGluQTAsIGluSTEsIGluQTEpIHtcblx0XHRpZiAodGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCkubGVuZ3RoPT0xKXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBpID0gTWF0aC5hYnMoaW5JMCAlIHRoaXMuYyQubGVuZ3RoKTtcblx0XHQvL2VueW8ubG9nKGluSTAsIGluSTEpO1xuXHRcdHJldHVybiBpbkEwW2ldW3RoaXMuYXhpc1Bvc2l0aW9uXSAtIGluQTFbaV1bdGhpcy5heGlzUG9zaXRpb25dO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyB0aGUgcG9zaXRpb25pbmcgYW5kIG9wYWNpdHkgb2YgcGFuZWxzLlxuXHQqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0XHRBcnJhbmdlci5wb3NpdGlvbkNvbnRyb2woYywge2xlZnQ6IG51bGwsIHRvcDogbnVsbH0pO1xuXHRcdFx0XHRBcnJhbmdlci5vcGFjaWZ5Q29udHJvbChjLCAxKTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCdsZWZ0JywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgndG9wJywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgnaGVpZ2h0JywgbnVsbCk7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgnd2lkdGgnLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9BcnJhbmdlclwiOjc4fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0QXJyYW5nZXIgPSByZXF1aXJlKCcuL0FycmFuZ2VyJyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5TcGlyYWxBcnJhbmdlcn0gaXMgYW4ge0BsaW5rIGVueW8uQXJyYW5nZXJ9IHRoYXQgYXJyYW5nZXNcbiogY29udHJvbHMgaW4gYSBzcGlyYWwuIFRoZSBhY3RpdmUgY29udHJvbCBpcyBwb3NpdGlvbmVkIG9uIHRvcCBhbmQgdGhlIG90aGVyXG4qIGNvbnRyb2xzIGFyZSBsYWlkIG91dCBpbiBhIHNwaXJhbCBwYXR0ZXJuIGJlbG93LlxuKlxuKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSByb3RhdGluZyB0aGUgbmV3IGNvbnRyb2wgdXBcbiogZnJvbSBiZWxvdyBhbmQgcm90YXRpbmcgdGhlIGFjdGl2ZSBjb250cm9sIGRvd24gdG8gdGhlIGVuZCBvZiB0aGUgc3BpcmFsLlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uU3BpcmFsQXJyYW5nZXJcbiogQGV4dGVuZHMgZW55by5BcnJhbmdlclxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uU3BpcmFsQXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5TcGlyYWxBcnJhbmdlcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQXJyYW5nZXIsXG5cblx0LyoqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5pbmNyZW1lbnRhbFBvaW50c31cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbmNyZW1lbnRhbFBvaW50czogdHJ1ZSxcblxuXHQvKipcblx0KiBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gc3VjY2Vzc2l2ZSBjb250cm9sc1xuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5jOiAyMCxcblxuXHQvKipcblx0KiBTaXplcyBlYWNoIHBhbmVsIHRvIG9uZSB0aGlyZCBvZiB0aGUgY29udGFpbmVyLlxuXHQqXG5cdCogQHNlZSAge0BsaW5rIGVueW8uQXJyYW5nZXIuc2l6ZX1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHR2YXIgYiA9IHRoaXMuY29udGFpbmVyQm91bmRzO1xuXHRcdHZhciB3ID0gdGhpcy5jb250cm9sV2lkdGggPSBiLndpZHRoLzM7XG5cdFx0dmFyIGggPSB0aGlzLmNvbnRyb2xIZWlnaHQgPSBiLmhlaWdodC8zO1xuXHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdGMuc2V0Qm91bmRzKHt3aWR0aDogdywgaGVpZ2h0OiBofSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEFycmFuZ2VzIHBhbmVscyBpbiBhIHNwaXJhbCB3aXRoIHRoZSBhY3RpdmUgcGFuZWwgYXQgdGhlIGNlbnRlci5cblx0KlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuYXJyYW5nZX1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGFycmFuZ2U6IGZ1bmN0aW9uIChjb250cm9scywgYXJyYW5nZW1lbnQpIHtcblx0XHR2YXIgcyA9IHRoaXMuaW5jO1xuXHRcdGZvciAodmFyIGk9MCwgbD1jb250cm9scy5sZW5ndGgsIGM7IChjPWNvbnRyb2xzW2ldKTsgaSsrKSB7XG5cdFx0XHR2YXIgeCA9IE1hdGguY29zKGkvbCAqIDIqTWF0aC5QSSkgKiBpICogcyArIHRoaXMuY29udHJvbFdpZHRoO1xuXHRcdFx0dmFyIHkgPSBNYXRoLnNpbihpL2wgKiAyKk1hdGguUEkpICogaSAqIHMgKyB0aGlzLmNvbnRyb2xIZWlnaHQ7XG5cdFx0XHR0aGlzLmFycmFuZ2VDb250cm9sKGMsIHtsZWZ0OiB4LCB0b3A6IHl9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQXBwbGllcyBkZXNjZW5kaW5nIGB6LWluZGV4YCB2YWx1ZXMgdG8gZWFjaCBwYW5lbCwgc3RhcnRpbmcgd2l0aCB0aGUgYWN0aXZlIHBhbmVsLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5zdGFydH1cblx0KiBAbWV0aG9kXG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRzdGFydDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmdldE9yZGVyZWRDb250cm9scyh0aGlzLmNvbnRhaW5lci50b0luZGV4KTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCd6LWluZGV4JywgYyQubGVuZ3RoIC0gaSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5jYWxjQXJyYW5nZW1lbnREaWZmZXJlbmNlfVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0Y2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZTogZnVuY3Rpb24gKGluSTAsIGluQTAsIGluSTEsIGluQTEpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sV2lkdGg7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzZXRzIHBvc2l0aW9uIGFuZCB6LWluZGV4IG9mIGFsbCBwYW5lbHMuXG5cdCpcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGM7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGMuYXBwbHlTdHlsZSgnei1pbmRleCcsIG51bGwpO1xuXHRcdFx0XHRBcnJhbmdlci5wb3NpdGlvbkNvbnRyb2woYywge2xlZnQ6IG51bGwsIHRvcDogbnVsbH0pO1xuXHRcdFx0XHRjLmFwcGx5U3R5bGUoJ2xlZnQnLCBudWxsKTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCd0b3AnLCBudWxsKTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCdoZWlnaHQnLCBudWxsKTtcblx0XHRcdFx0Yy5hcHBseVN0eWxlKCd3aWR0aCcsIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSlcbn0pO1xufSx7XCIuLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuL0FycmFuZ2VyXCI6Nzh9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpO1xuXG52YXJcblx0TGlua2VkTGlzdCA9IHJlcXVpcmUoJy4vTGlua2VkTGlzdCcpLFxuXHRPYnNlcnZlckNoYWluTm9kZSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXJDaGFpbk5vZGUnKTtcblxuZnVuY3Rpb24gZ2V0IChiYXNlLCBwcm9wKSB7XG5cdHJldHVybiBiYXNlICYmIC8qaXNPYmplY3QoYmFzZSkqLyAodHlwZW9mIGJhc2UgPT0gJ29iamVjdCcpPyAoXG5cdFx0YmFzZS5nZXQ/IGJhc2UuZ2V0KHByb3ApOiBiYXNlW3Byb3BdXG5cdCk6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4qIEFuIGludGVybmFsbHkgdXNlZCB7QGdsb3NzYXJ5IGtpbmR9LlxuKlxuKiBAY2xhc3MgZW55by5PYnNlcnZlckNoYWluXG4qIEBleHRlbmRzIGVueW8uTGlua2VkTGlzdFxuKiBAcHJpdmF0ZVxuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLk9ic2VydmVyQ2hhaW4ucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBMaW5rZWRMaXN0LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5vZGVLaW5kOiBPYnNlcnZlckNoYWluTm9kZSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25uZWN0ZWQ6IDAsXG5cdFxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHRoaXMucGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cdFx0dGhpcy5jcmVhdGVDaGFpbigpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBudWxsO1xuXHRcdFx0dGhpcy5wYXJ0cyA9IG51bGw7XG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVidWlsZDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmICghdGhpcy5yZWJ1aWxkaW5nKSB7XG5cdFx0XHR0aGlzLnJlYnVpbGRpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5mb3J3YXJkKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcdGlmIChub2RlICE9PSB0aGlzLmhlYWQpIHtcblx0XHRcdFx0XHR2YXIgc3JjID0gbm9kZS5wcmV2Lm9iamVjdFxuXHRcdFx0XHRcdFx0LCBwcm9wID0gbm9kZS5wcmV2LnByb3BlcnR5O1xuXHRcdFx0XHRcdG5vZGUuc2V0T2JqZWN0KGdldChzcmMsIHByb3ApKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcywgdGFyZ2V0KTtcblx0XHRcdHRoaXMucmVidWlsZGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzQ29ubmVjdGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhICh0aGlzLmNvbm5lY3RlZCA9PT0gdGhpcy5sZW5ndGggJiYgdGhpcy5sZW5ndGgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YnVpbGRQYXRoOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0dmFyIHN0ciA9ICcnO1xuXHRcdFxuXHRcdHRoaXMuYmFja3dhcmQoZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHN0ciA9IG5vZGUucHJvcGVydHkgKyAoc3RyPyAoJy4nICsgc3RyKTogc3RyKTtcblx0XHR9LCB0aGlzLCB0YXJnZXQpO1xuXHRcdFxuXHRcdHJldHVybiBzdHI7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGVDaGFpbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMucGFydHNcblx0XHRcdCwgbmV4dCA9IHRoaXMub2JqZWN0XG5cdFx0XHQsICQgPSBmYWxzZVxuXHRcdFx0LCBub2RlLCBwcm9wO1xuXHRcdFx0XG5cdFx0Zm9yICh2YXIgaT0wOyAocHJvcD1wYXJ0c1tpXSk7ICsraSkge1xuXHRcdFx0XG5cdFx0Ly8gZm9yRWFjaChwYXJ0cywgZnVuY3Rpb24gKHByb3AsIGlkeCkge1xuXHRcdFx0Ly8gd2UgY3JlYXRlIGEgc3BlY2lhbCBjYXNlIGZvciB0aGUgJCBoYXNoIHByb3BlcnR5XG5cdFx0XHRpZiAocHJvcCA9PSAnJCcpIHtcblx0XHRcdFx0JCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpbiBjYXNlcyB3aGVyZSB0aGUgY2hhaW4gaGFzIHRoZSAkIHByb3BlcnR5IHdlIGFyYml0cmFyaWx5XG5cdFx0XHRcdC8vIGZvcmNlIGl0IG9udG8gb3VyIGN1cnJlbnQgbm9kZXMgcHJvcGVydHkgYW5kIGxldCB0aGUgc3BlY2lhbCBoYW5kbGluZ1xuXHRcdFx0XHQvLyBpbiBPYnNlcnZlckNoYWluTm9kZSBhbmQgT2JzZXJ2ZXJTdXBwb3J0IGhhbmRsZSB0aGUgcmVzdFxuXHRcdFx0XHQkICYmIChwcm9wID0gJyQuJyArIHByb3ApO1xuXHRcdFx0XHRub2RlID0gdGhpcy5jcmVhdGVOb2RlKHtwcm9wZXJ0eTogcHJvcCwgb2JqZWN0OiBuZXh0LCBsaXN0OiB0aGlzfSk7XG5cdFx0XHRcdHRoaXMuYXBwZW5kTm9kZShub2RlKTtcblx0XHRcdFx0bmV4dCA9IGdldChuZXh0LCBwcm9wKTtcblx0XHRcdFx0JCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdC8vIH0sIHRoaXMpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG9ic2VydmVkOiBmdW5jdGlvbiAobm9kZSwgd2FzLCBpcykge1xuXHRcdHRoaXMub2JqZWN0LnN0b3BOb3RpZmljYXRpb25zKCk7XG5cdFx0Ly8gQE5PVEU6IEFib3V0IHRoZSBmb2xsb3dpbmcgdHdvIGNhc2VzLCB0aGV5IGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYW5kIHRoaXMgc2VlbXMgcGVyZmVjdFxuXHRcdC8vIHRoYXQgd2UgZG9uJ3Qgc2VlIGRvdWJsZSBub3RpZmljYXRpb25zXG5cdFx0Ly8gQFRPRE86IE9ubHkgbm90aWZ5IGlmIGl0IHdhcyB0aGUgZnVsbCBwcm9wZXJ0eSBwYXRoPyBUaGlzIGlzIGZhciBtb3JlIGVmZmljaWVudCBhZnRlclxuXHRcdC8vIHRlc3RpbmcgYnV0IG5vdCBhcyBmbGV4aWJsZS4uLlxuXHRcdG5vZGUgPT09IHRoaXMudGFpbCAvKiYmIHdhcyAhPT0gaXMqLyAmJiB0aGlzLm9iamVjdC5ub3RpZnkodGhpcy5idWlsZFBhdGgobm9kZSksIHdhcywgaXMpO1xuXHRcdC8vIEBUT0RPOiBJdCBzZWVtcyB0aGUgc2FtZSBjYXNlIGFjcm9zcyB0aGUgYm9hcmQgdGhhdCB0aGUgcmVidWlsZCBvbmx5IG5lZWRzIHRvIHRha2UgcGxhY2Vcblx0XHQvLyBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gdGhlIHNlY29uZC10by1sYXN0IGVsZW1cblx0XHRub2RlICE9PSB0aGlzLnRhaWwgJiYgd2FzICE9PSBpcyAmJiB0aGlzLnJlYnVpbGQobm9kZSk7XG5cdFx0dGhpcy5vYmplY3Quc3RhcnROb3RpZmljYXRpb25zKCk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vTGlua2VkTGlzdFwiOjI3LFwiLi9PYnNlcnZlckNoYWluTm9kZVwiOjMzLFwiLi9raW5kXCI6NjYsXCIuL3V0aWxzXCI6NzV9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL2tpbmQnKTtcblxudmFyXG5cdEFycmFuZ2VyID0gcmVxdWlyZSgnLi9BcnJhbmdlcicpLFxuXHRDYXJkQXJyYW5nZXIgPSByZXF1aXJlKCcuL0NhcmRBcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uQ2FyZFNsaWRlSW5BcnJhbmdlcn0gaXMgYW4ge0BsaW5rIGVueW8uQXJyYW5nZXJ9IHRoYXRcbiogZGlzcGxheXMgb25seSBvbmUgYWN0aXZlIGNvbnRyb2wuIFRoZSBub24tYWN0aXZlIGNvbnRyb2xzIGFyZSBoaWRkZW4gd2l0aFxuKiBgc2V0U2hvd2luZyhmYWxzZSlgLiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieVxuKiBzbGlkaW5nIHRoZSBuZXcgY29udHJvbFx0b3ZlciB0aGUgY3VycmVudCBvbmUuXG4qXG4qIE5vdGUgdGhhdCBDYXJkU2xpZGVJbkFycmFuZ2VyIGFsd2F5cyBzbGlkZXMgY29udHJvbHMgaW4gZnJvbSB0aGUgcmlnaHQuIElmXG4qIHlvdSB3YW50IGFuIGFycmFuZ2VyIHRoYXQgc2xpZGVzIHRvIHRoZSByaWdodCBhbmQgbGVmdCwgdHJ5XG4qIHtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyfS5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbQXJyYW5nZXJzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvYXJyYW5nZXJzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uQ2FyZFNsaWRlSW5BcnJhbmdlclxuKiBAZXh0ZW5kcyBlbnlvLkNhcmRBcnJhbmdlclxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzICBlbnlvLkNhcmRTbGlkZUluQXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5DYXJkU2xpZGVJbkFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBDYXJkQXJyYW5nZXIsXG5cblx0LyoqXG5cdCogU2hvd3MgdGhlIGFjdGl2ZSBwYW5lbCBhdCB0aGUgc3RhcnQgb2YgdHJhbnNpdGlvbi4gQWxzbyB0cmlnZ2VycyBhIHJlc2l6ZSBvblxuXHQqIHRoZSBhY3RpdmUgcGFuZWwgaWYgaXQgd2Fzbid0IHByZXZpb3VzbHkgc2hvd2luZy5cblx0KlxuXHQqIEB0b2RvIFNlZW1zIGxpa2UgcG9vciB2YXJpYWJsZSByZXVzZSBvZiBgaWBcblx0KiBAdG9kbyBTaG91bGQgaW5oZXJpdCBmcm9tIHN1cGVyIGFuZCBvbWl0IHRoZSBgZm9yYCBibG9ja1xuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuc3RhcnR9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRzdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdHZhciB3YXNTaG93aW5nPWMuc2hvd2luZztcblx0XHRcdGMuc2V0U2hvd2luZyhpID09IHRoaXMuY29udGFpbmVyLmZyb21JbmRleCB8fCBpID09ICh0aGlzLmNvbnRhaW5lci50b0luZGV4KSk7XG5cdFx0XHRpZiAoYy5zaG93aW5nICYmICF3YXNTaG93aW5nKSB7XG5cdFx0XHRcdGMucmVzaXplKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBsID0gdGhpcy5jb250YWluZXIuZnJvbUluZGV4O1xuXHRcdGkgPSB0aGlzLmNvbnRhaW5lci50b0luZGV4O1xuXHRcdHRoaXMuY29udGFpbmVyLnRyYW5zaXRpb25Qb2ludHMgPSBbXG5cdFx0XHRpICsgJy4nICsgbCArICcucycsXG5cdFx0XHRpICsgJy4nICsgbCArICcuZidcblx0XHRdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEB0b2RvICBUaGlzIG1ldGhvZCBpcyBhbiBleGFjdCBjb3B5IG9mIENhcmRBcnJhbmdlci4gU2luY2UgaXQncyBjYWxsaW5nIHRoZSBzdXBlcixcblx0KiBcdHRoZSB3b3JrIGlzIGJlaW5nIGRvbmUgdHdpY2UsIHNvIHRoaXMgbWV0aG9kIHNob3VsZCBiZSByZW1vdmVkLlxuXHQqIEBzZWUge0BsaW5rIGVueW8uQXJyYW5nZXIuZmluaXNofVxuXHQqIEBtZXRob2Rcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGZpbmlzaDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgYyQgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdFx0Yy5zZXRTaG93aW5nKGkgPT0gdGhpcy5jb250YWluZXIudG9JbmRleCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogUGFyc2VzIHRoZSB0cmFuc2l0aW9uIHBvaW50IHZhbHVlIHRvIHBvc2l0aW9uIHRoZSBwYW5lbHMgdG8gc2xpZGUgaW4gZnJvbSB0aGUgcmlnaHQuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmFycmFuZ2V9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRhcnJhbmdlOiBmdW5jdGlvbiAoY29udHJvbHMsIGFycmFuZ2VtZW50KSB7XG5cdFx0dmFyIHAgPSBhcnJhbmdlbWVudC5zcGxpdCgnLicpLFxuXHRcdFx0ZiA9IHBbMF0sXG5cdFx0XHRzID0gcFsxXSxcblx0XHRcdHN0YXJ0aW5nID0gKHBbMl0gPT0gJ3MnKSxcblx0XHRcdGIgPSB0aGlzLmNvbnRhaW5lckJvdW5kcy53aWR0aDtcblxuXHRcdGZvciAodmFyIGk9MCwgYyQ9dGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCksIGMsIHY7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHR2ID0gYjtcblx0XHRcdGlmIChzID09IGkpIHtcblx0XHRcdFx0diA9IHN0YXJ0aW5nID8gMCA6IC1iO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGYgPT0gaSkge1xuXHRcdFx0XHR2ID0gc3RhcnRpbmcgPyBiIDogMDtcblx0XHRcdH1cblx0XHRcdGlmIChzID09IGkgJiYgcyA9PSBmKSB7XG5cdFx0XHRcdHYgPSAwO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hcnJhbmdlQ29udHJvbChjLCB7bGVmdDogdn0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIGBsZWZ0YCBwb3NpdGlvbiBvZiBhbGwgcGFuZWxzLlxuXHQqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0XHRBcnJhbmdlci5wb3NpdGlvbkNvbnRyb2woYywge2xlZnQ6IG51bGx9KTtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9BcnJhbmdlclwiOjc4LFwiLi9DYXJkQXJyYW5nZXJcIjo3OX1dLDgyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0Q2Fyb3VzZWxBcnJhbmdlciA9IHJlcXVpcmUoJy4vQ2Fyb3VzZWxBcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uQ29sbGFwc2luZ0FycmFuZ2VyfSBpcyBhbiB7QGxpbmsgZW55by5BcnJhbmdlcn0gdGhhdCBkaXNwbGF5cyB0aGVcbiogYWN0aXZlIGNvbnRyb2wsIGFsb25nIHdpdGggc29tZSBudW1iZXIgb2YgaW5hY3RpdmVcdGNvbnRyb2xzIHRvIGZpbGwgdGhlXG4qIGF2YWlsYWJsZSBzcGFjZS4gVGhlIGFjdGl2ZSBjb250cm9sIGlzIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGVcbiogY29udGFpbmVyIGFuZCB0aGUgcmVzdCBvZiB0aGUgdmlld3MgYXJlIGxhaWQgb3V0IHRvIHRoZSByaWdodC4gVGhlIGxhc3RcbiogY29udHJvbCwgaWYgdmlzaWJsZSwgd2lsbCBleHBhbmQgdG8gZmlsbCB3aGF0ZXZlciBzcGFjZSBpcyBub3QgdGFrZW4gdXAgYnlcbiogdGhlIHByZXZpb3VzIGNvbnRyb2xzLlxuKlxuKiBGb3IgYmVzdCByZXN1bHRzIHdpdGggQ29sbGFwc2luZ0FycmFuZ2VyLCB5b3Ugc2hvdWxkIHNldCBhIG1pbmltdW0gd2lkdGhcbiogZm9yIGVhY2ggY29udHJvbCB2aWEgYSBDU1Mgc3R5bGUsIGUuZy4sIGBtaW4td2lkdGg6IDI1JWAgb3JcbiogYG1pbi13aWR0aDogMjUwcHhgLlxuKlxuKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSBzbGlkaW5nIHRoZSBuZXcgY29udHJvbFx0aW5cbiogZnJvbSB0aGUgcmlnaHQgYW5kIGNvbGxhcHNpbmcgdGhlIG9sZCBjb250cm9sIHRvIHRoZSBsZWZ0LlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgZW55by5Db2xsYXBzaW5nQXJyYW5nZXJcbiogQGV4dGVuZHMgZW55by5DYXJvdXNlbEFycmFuZ2VyXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Db2xsYXBzaW5nQXJyYW5nZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Db2xsYXBzaW5nQXJyYW5nZXInLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENhcm91c2VsQXJyYW5nZXIsXG5cblx0LyoqXG5cdCogVGhlIGRpc3RhbmNlIChpbiBwaXhlbHMpIHRoYXQgZWFjaCBwYW5lbCBzaG91bGQgYmUgb2Zmc2V0IGZyb20gdGhlIGxlZnRcblx0KiB3aGVuIGl0IGlzIHNlbGVjdGVkLiBUaGlzIGFsbG93cyBjb250cm9scyBvbiB0aGUgdW5kZXJseWluZyBwYW5lbCB0byB0aGVcblx0KiBsZWZ0IG9mIHRoZSBzZWxlY3RlZCBvbmUgdG8gYmUgcGFydGlhbGx5IHJldmVhbGVkLlxuXHQqXG5cdCogTm90ZSB0aGF0IHRoaXMgaXMgaW1wb3J0ZWQgZnJvbSB0aGUgY29udGFpbmVyIGF0IGNvbnN0cnVjdGlvbiB0aW1lLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRwZWVrV2lkdGg6IDAsXG5cblx0LyoqXG5cdCogSWYgYSBwYW5lbCBpcyBhZGRlZCBvciByZW1vdmVkIGFmdGVyIGNvbnN0cnVjdGlvbiwgZW5zdXJlcyB0aGF0IGFueSBjb250cm9sXG5cdCogbWFya2VkIHRvIGZpbGwgcmVtYWluaW5nIHNwYWNlICh2aWEgaXRzIGBfZml0YCBtZW1iZXIpIGlzIHJlc2V0LlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5zaXplfVxuXHQqIEBtZXRob2Rcblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdHNpemU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY2xlYXJMYXN0U2l6ZSgpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogUmVzZXRzIGFueSBwYW5lbCBtYXJrZWQgdG8gZmlsbCByZW1haW5pbmcgc3BhY2UgdGhhdCBpc24ndCwgaW4gZmFjdCwgdGhlIGxhc3QgcGFuZWwuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGVhckxhc3RTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaT0wLCBjJD10aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKSwgYzsgKGM9YyRbaV0pOyBpKyspIHtcblx0XHRcdGlmIChjLl9maXQgJiYgaSAhPSBjJC5sZW5ndGgtMSkge1xuXHRcdFx0XHRjLmFwcGx5U3R5bGUoJ3dpZHRoJywgbnVsbCk7XG5cdFx0XHRcdGMuX2ZpdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3Rvcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnBlZWtXaWR0aCA9IHRoaXMuY29udGFpbmVyLnBlZWtXaWR0aCAhPSBudWxsID8gdGhpcy5jb250YWluZXIucGVla1dpZHRoIDogdGhpcy5wZWVrV2lkdGg7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQXJyYW5nZXMgY29udHJvbHMgZnJvbSBsZWZ0IHRvIHJpZ2h0IHN0YXJ0aW5nIHdpdGggZmlyc3QgcGFuZWwuIElmXG5cdCogW3BlZWtXaWR0aF17QGxpbmsgZW55by5Db2xsYXBzaW5nQXJyYW5nZXIjcGVla1dpZHRofSBpcyBzZXQsIGFueSB2aXNpYmxlIGNvbnRyb2xcblx0KiB3aG9zZSBpbmRleCBpcyBsZXNzIHRoYW4gYGFycmFuZ2VtZW50YCAodGhlIGFjdGl2ZSBwYW5lbCdzIGluZGV4KSB3aWxsIGJlIHJldmVhbGVkXG5cdCogYnkgYHBlZWtXaWR0aGAgcGl4ZWxzLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5hcnJhbmdlfVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0YXJyYW5nZTogZnVuY3Rpb24gKGNvbnRyb2xzLCBhcnJhbmdlbWVudCkge1xuXHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdGZvciAodmFyIGk9MCwgZT10aGlzLmNvbnRhaW5lclBhZGRpbmcubGVmdCwgYywgbj0wOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0aWYoYy5nZXRTaG93aW5nKCkpe1xuXHRcdFx0XHR0aGlzLmFycmFuZ2VDb250cm9sKGMsIHtsZWZ0OiBlICsgbiAqIHRoaXMucGVla1dpZHRofSk7XG5cdFx0XHRcdGlmIChpID49IGFycmFuZ2VtZW50KSB7XG5cdFx0XHRcdFx0ZSArPSBjLndpZHRoICsgYy5tYXJnaW5XaWR0aCAtIHRoaXMucGVla1dpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4rKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJyYW5nZUNvbnRyb2woYywge2xlZnQ6IGV9KTtcblx0XHRcdFx0aWYgKGkgPj0gYXJyYW5nZW1lbnQpIHtcblx0XHRcdFx0XHRlICs9IGMud2lkdGggKyBjLm1hcmdpbldpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBGSVhNRTogb3ZlcmRyYWdnaW5nLWlzaFxuXHRcdFx0aWYgKGkgPT0gYyQubGVuZ3RoIC0gMSAmJiBhcnJhbmdlbWVudCA8IDApIHtcblx0XHRcdFx0dGhpcy5hcnJhbmdlQ29udHJvbChjLCB7bGVmdDogZSAtIGFycmFuZ2VtZW50fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGN1bGF0ZXMgdGhlIGNoYW5nZSBpbiBgbGVmdGAgcG9zaXRpb24gb2YgdGhlIGxhc3QgcGFuZWwgYmV0d2VlbiB0aGUgdHdvXG5cdCogYXJyYW5nZW1lbnRzIGBhMGAgYW5kIGBhMWAuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmNhbGNBcnJhbmdlbWVudERpZmZlcmVuY2V9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY0FycmFuZ2VtZW50RGlmZmVyZW5jZTogZnVuY3Rpb24gKGkwLCBhMCwgaTEsIGExKSB7XG5cdFx0dmFyIGkgPSB0aGlzLmNvbnRhaW5lci5nZXRQYW5lbHMoKS5sZW5ndGgtMTtcblx0XHRyZXR1cm4gTWF0aC5hYnMoYTFbaV0ubGVmdCAtIGEwW2ldLmxlZnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIElmIHRoZSBjb250YWluZXIncyBgcmVhbHRpbWVGaXRgIHByb3BlcnR5IGlzIGB0cnVlYCwgcmVzaXplcyB0aGUgbGFzdCBwYW5lbCB0b1xuXHQqIGZpbGwgdGhlIHNwYWNlLiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIGRyYWdnaW5nIG9yIGFuaW1hdGluZyB0byB0aGUgbGFzdCBpbmRleCxcblx0KiB0aGVyZSBpcyBuZXZlciBibGFuayBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGxhc3QgcGFuZWwuIElmIGByZWFsdGltZUZpdGAgaXNcblx0KiBmYWxzeSwgdGhlIGxhc3QgcGFuZWwgaXMgbm90IHJlc2l6ZWQgdW50aWwgdGhlXG5cdCogW2ZpbmlzaCgpXXtAbGluayBlbnlvLkNvbGxhcHNpbmdBcnJhbmdlciNmaW5pc2h9IG1ldGhvZCBpcyBjYWxsZWQuXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmZsb3dDb250cm9sc31cblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Zmxvd0NvbnRyb2w6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChpbkNvbnRyb2wsIGluQSkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAodGhpcy5jb250YWluZXIucmVhbHRpbWVGaXQpIHtcblx0XHRcdFx0dmFyIGMkID0gdGhpcy5jb250YWluZXIuZ2V0UGFuZWxzKCk7XG5cdFx0XHRcdHZhciBsID0gYyQubGVuZ3RoLTE7XG5cdFx0XHRcdHZhciBsYXN0ID0gYyRbbF07XG5cdFx0XHRcdGlmIChpbkNvbnRyb2wgPT0gbGFzdCkge1xuXHRcdFx0XHRcdHRoaXMuZml0Q29udHJvbChpbkNvbnRyb2wsIGluQS5sZWZ0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogRW5zdXJlcyB0aGF0IHRoZSBsYXN0IHBhbmVsIGZpbGxzIHRoZSByZW1haW5pbmcgc3BhY2Ugd2hlbiBhIHRyYW5zaXRpb24gY29tcGxldGVzLlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5maW5pc2h9XG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZpbmlzaDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuY29udGFpbmVyLnJlYWx0aW1lRml0ICYmIHRoaXMuY29udGFpbmVyQm91bmRzKSB7XG5cdFx0XHRcdHZhciBjJCA9IHRoaXMuY29udGFpbmVyLmdldFBhbmVscygpO1xuXHRcdFx0XHR2YXIgYSQgPSB0aGlzLmNvbnRhaW5lci5hcnJhbmdlbWVudDtcblx0XHRcdFx0dmFyIGwgPSBjJC5sZW5ndGgtMTtcblx0XHRcdFx0dmFyIGMgPSBjJFtsXTtcblx0XHRcdFx0dGhpcy5maXRDb250cm9sKGMsIGEkW2xdLmxlZnQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFJlc2l6ZXMgdGhlIGdpdmVuIGBjb250cm9sYCB0byBtYXRjaCB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciBtaW51cyB0aGVcblx0KiBnaXZlbiBgb2Zmc2V0YC5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5Db250cm9sfSBjb250cm9sIC0gVGhlIGNvbnRyb2wgdGhhdCBzaG91bGQgZml0IGluIHRoZSByZW1haW5pbmcgc3BhY2UuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAgICAgICAgLSBUaGUgbGVmdCBvZmZzZXQgb2YgdGhlIGNvbnRyb2wgd2l0aCByZXNwZWN0IHRvIHRoZVxuXHQqIGNvbnRhaW5lci5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaXRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCwgb2Zmc2V0KSB7XG5cdFx0Y29udHJvbC5fZml0ID0gdHJ1ZTtcblx0XHRjb250cm9sLmFwcGx5U3R5bGUoJ3dpZHRoJywgKHRoaXMuY29udGFpbmVyQm91bmRzLndpZHRoIC0gb2Zmc2V0KSArICdweCcpO1xuXHRcdGNvbnRyb2wucmVzaXplKCk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuL0Nhcm91c2VsQXJyYW5nZXJcIjo4MX1dLDEwNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL2tpbmQnKTtcblxudmFyXG5cdExlZnRSaWdodEFycmFuZ2VyID0gcmVxdWlyZSgnLi9MZWZ0UmlnaHRBcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uVG9wQm90dG9tQXJyYW5nZXJ9IGlzIGFuIHtAbGluayBlbnlvLkFycmFuZ2VyfSB0aGF0IGRpc3BsYXlzXG4qIHRoZSBhY3RpdmUgY29udHJvbCBhbmQgc29tZSBvZiB0aGUgcHJldmlvdXMgYW5kIG5leHQgY29udHJvbHMuIFRoZSBhY3RpdmVcbiogY29udHJvbCBpcyBjZW50ZXJlZCB2ZXJ0aWNhbGx5IGluIHRoZSBjb250YWluZXIsIGFuZCB0aGUgcHJldmlvdXMgYW5kIG5leHRcbiogY29udHJvbHMgYXJlIGxhaWQgb3V0IGFib3ZlIGFuZCBiZWxvdywgcmVzcGVjdGl2ZWx5LlxuKlxuKiBUcmFuc2l0aW9ucyBiZXR3ZWVuIGFycmFuZ2VtZW50cyBhcmUgaGFuZGxlZCBieSBzbGlkaW5nIHRoZSBuZXcgY29udHJvbCBpblxuKiBmcm9tIHRoZSBib3R0b20gYW5kIHNsaWRpbmcgdGhlIGFjdGl2ZSBjb250cm9sIG91dCB0aGUgdG9wLlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtBcnJhbmdlcnNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9hcnJhbmdlcnMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgZW55by5Ub3BCb3R0b21BcnJhbmdlclxuKiBAZXh0ZW5kcyBlbnlvLkxlZnRSaWdodEFycmFuZ2VyXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Ub3BCb3R0b21BcnJhbmdlci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLlRvcEJvdHRvbUFycmFuZ2VyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBMZWZ0UmlnaHRBcnJhbmdlcixcblxuXHQvKipcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmRyYWdQcm9wfVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdQcm9wOiAnZGR5JyxcblxuXHQvKipcblx0KiBAc2VlIHtAbGluayBlbnlvLkFycmFuZ2VyLmRyYWdEaXJlY3Rpb25Qcm9wfVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdEaXJlY3Rpb25Qcm9wOiAneURpcmVjdGlvbicsXG5cblx0LyoqXG5cdCogQHNlZSB7QGxpbmsgZW55by5BcnJhbmdlci5jYW5EcmFnUHJvcH1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYW5EcmFnUHJvcDogJ3ZlcnRpY2FsJyxcblxuXHQvKipcblx0KiBAc2VlIHtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyLmF4aXNTaXplfVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0YXhpc1NpemU6ICdoZWlnaHQnLFxuXG5cdC8qKlxuXHQqIEBzZWUge0BsaW5rIGVueW8uTGVmdFJpZ2h0QXJyYW5nZXIub2ZmQXhpc1NpemV9XG5cdCogQHByb3RlY3RlZFxuXHQqL1xuXHRvZmZBeGlzU2l6ZTogJ3dpZHRoJyxcblxuXHQvKipcblx0KiBAc2VlIHtAbGluayBlbnlvLkxlZnRSaWdodEFycmFuZ2VyLmF4aXNQb3NpdGlvbn1cblx0KiBAcHJvdGVjdGVkXG5cdCovXG5cdGF4aXNQb3NpdGlvbjogJ3RvcCdcbn0pO1xufSx7XCIuLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuL0xlZnRSaWdodEFycmFuZ2VyXCI6OTR9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXJcblx0T2JzZXJ2ZXJDaGFpbiA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXJDaGFpbicpO1xuXG52YXIgb2JzZXJ2ZXJUYWJsZSA9IHt9O1xuXHRcbmtpbmQuY29uY2F0ZW5hdGVkLnB1c2goXCJvYnNlcnZlcnNcIik7XG5cbi8qKlxuKiBSZXNwb25kcyB0byBjaGFuZ2VzIGluIG9uZSBvciBtb3JlIHByb3BlcnRpZXMuXG4qIFtPYnNlcnZlcnNde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0fm9ic2VydmVyfSBtYXkgYmUgcmVnaXN0ZXJlZCBpblxuKiBzZXZlcmFsIGRpZmZlcmVudCB3YXlzLiBTZWUgdGhlIHtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH0gZG9jdW1lbnRhdGlvblxuKiBmb3IgbW9yZSBkZXRhaWxzLiBBbHNvIG5vdGUgdGhhdCwgd2hpbGUgb2JzZXJ2ZXJzIHNob3VsZCBub3QgYmUgY2FsbGVkXG4qIGRpcmVjdGx5LCBpZiBkZWZpbmVkIG9uIGEgW2tpbmRde0BnbG9zc2FyeSBraW5kfSwgdGhleSBtYXkgYmVcbiogb3ZlcmxvYWRlZCBmb3Igc3BlY2lhbCBiZWhhdmlvci5cbipcbiogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydFxuKiBAc2VlIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm9ic2VydmVcbiogQGNhbGxiYWNrIGVueW8uT2JzZXJ2ZXJTdXBwb3J0fk9ic2VydmVyXG4qIEBwYXJhbSB7Kn0gd2FzIC0gVGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGhhcyBjaGFuZ2VkLlxuKiBAcGFyYW0geyp9IGlzIC0gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaGFzIGNoYW5nZWQuXG4qIEBwYXJhbSB7U3RyaW5nfSBwcm9wIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaGFzIGNoYW5nZWQuXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGFkZE9ic2VydmVyIChwYXRoLCBmbiwgY3R4LCBvcHRzKSB7XG5cdFxuXHR2YXIgb2JzZXJ2ZXJzID0gdGhpcy5nZXRPYnNlcnZlcnMoKSxcblx0XHRjaGFpbnMgPSB0aGlzLmdldENoYWlucygpLFxuXHRcdHBhcnRzID0gcGF0aC5zcGxpdCgnLicpLFxuXHRcdHByaW8gPSBvcHRzICYmIG9wdHMucHJpb3JpdHksXG5cdFx0ZW50cmllcyxcblx0XHRub0NoYWluO1xuXHRcdFxuXHRub0NoYWluID0gKG9wdHMgJiYgb3B0cy5ub0NoYWluKSB8fFxuXHRcdFx0Y2hhaW5zW3BhdGhdIHx8XG5cdFx0XHRwYXJ0cy5sZW5ndGggPCAyIHx8XG5cdFx0XHQocGFydHMubGVuZ3RoID09PSAyICYmIHBhdGhbMF0gPT0gJyQnKTtcblx0XG5cdGlmIChvYnNlcnZlcnNbcGF0aF0gJiYgIW9ic2VydmVycy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuXHRcdG9ic2VydmVyc1twYXRoXSA9IG9ic2VydmVyc1twYXRoXS5zbGljZSgpO1xuXHR9XG5cdFxuXHRlbnRyaWVzID0gb2JzZXJ2ZXJzW3BhdGhdIHx8IChvYnNlcnZlcnNbcGF0aF0gPSBbXSk7XG5cdGVudHJpZXNbcHJpbyA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oe21ldGhvZDogZm4sIGN0eDogY3R4IHx8IHRoaXN9KTtcblx0XG5cdGlmICghbm9DaGFpbikge1xuXHRcdHRoaXMuZ2V0Q2hhaW5zKClbcGF0aF0gPSBuZXcgT2JzZXJ2ZXJDaGFpbihwYXRoLCB0aGlzKTtcblx0fVxuXHRcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyIChvYmosIHBhdGgsIGZuLCBjdHgpIHtcblx0dmFyIG9ic2VydmVycyA9IG9iai5nZXRPYnNlcnZlcnMocGF0aClcblx0XHQsIGNoYWlucyA9IG9iai5nZXRDaGFpbnMoKVxuXHRcdCwgaWR4LCBjaGFpbjtcblx0XHRcblx0aWYgKG9ic2VydmVycyAmJiBvYnNlcnZlcnMubGVuZ3RoKSB7XG5cdFx0aWR4ID0gb2JzZXJ2ZXJzLmZpbmRJbmRleChmdW5jdGlvbiAobG4pIHtcblx0XHRcdHJldHVybiBsbi5tZXRob2QgPT09IGZuICYmIChjdHg/IGxuLmN0eCA9PT0gY3R4OiB0cnVlKTtcblx0XHR9KTtcblx0XHRpZHggPiAtMSAmJiBvYnNlcnZlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdH1cblx0XG5cdGlmICgoY2hhaW4gPSBjaGFpbnNbcGF0aF0pICYmICFvYnNlcnZlcnMubGVuZ3RoKSB7XG5cdFx0Y2hhaW4uZGVzdHJveSgpO1xuXHR9XG5cdFxuXHRyZXR1cm4gb2JqO1xufVxuXG4vKipcbiogQHByaXZhdGVcbiovXG5mdW5jdGlvbiBub3RpZnlPYnNlcnZlcnMgKG9iaiwgcGF0aCwgd2FzLCBpcywgb3B0cykge1xuXHRpZiAob2JqLmlzT2JzZXJ2aW5nKCkpIHtcblx0XHR2YXIgb2JzZXJ2ZXJzID0gb2JqLmdldE9ic2VydmVycyhwYXRoKTtcblx0XHRcblx0XHRpZiAob2JzZXJ2ZXJzICYmIG9ic2VydmVycy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGk9MCwgbG47IChsbj1vYnNlcnZlcnNbaV0pOyArK2kpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBsbi5tZXRob2QgPT0gXCJzdHJpbmdcIikgb2JqW2xuLm1ldGhvZF0od2FzLCBpcywgcGF0aCwgb3B0cyk7XG5cdFx0XHRcdGVsc2UgbG4ubWV0aG9kLmNhbGwobG4uY3R4IHx8IG9iaiwgd2FzLCBpcywgcGF0aCwgb3B0cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgZW5xdWV1ZShvYmosIHBhdGgsIHdhcywgaXMsIG9wdHMpO1xuXHRcblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZW5xdWV1ZSAob2JqLCBwYXRoLCB3YXMsIGlzLCBvcHRzKSB7XG5cdGlmIChvYmouX25vdGlmaWNhdGlvblF1ZXVlRW5hYmxlZCkge1xuXHRcdHZhciBxdWV1ZSA9IG9iai5fbm90aWZpY2F0aW9uUXVldWUgfHwgKG9iai5fbm90aWZpY2F0aW9uUXVldWUgPSB7fSlcblx0XHRcdCwgbG4gPSBxdWV1ZVtwYXRoXSB8fCAocXVldWVbcGF0aF0gPSB7fSk7XG5cdFxuXHRcdGxuLndhcyA9IHdhcztcblx0XHRsbi5pcyA9IGlzO1xuXHRcdGxuLm9wdHMgPSBvcHRzO1xuXHR9XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGZsdXNoUXVldWUgKG9iaikge1xuXHR2YXIgcXVldWUgPSBvYmouX25vdGlmaWNhdGlvblF1ZXVlXG5cdFx0LCBwYXRoLCBsbjtcblx0XG5cdGlmIChxdWV1ZSkge1xuXHRcdG9iai5fbm90aWZpY2F0aW9uUXVldWUgPSBudWxsO1xuXHRcdFxuXHRcdGZvciAocGF0aCBpbiBxdWV1ZSkge1xuXHRcdFx0bG4gPSBxdWV1ZVtwYXRoXTtcblx0XHRcdG9iai5ub3RpZnkocGF0aCwgbG4ud2FzLCBsbi5pcywgbG4ub3B0cyk7XG5cdFx0fVxuXHR9XG59XG5cdFxuLyoqXG4qIEFkZHMgc3VwcG9ydCBmb3Igbm90aWZpY2F0aW9ucyBvbiBwcm9wZXJ0eSBjaGFuZ2VzLiBNb3N0XG4qIFtraW5kc117QGdsb3NzYXJ5IGtpbmR9IChpbmNsdWRpbmcgYWxsIGtpbmRzIHRoYXQgaW5oZXJpdCBmcm9tXG4qIHtAbGluayBlbnlvLk9iamVjdH0pIGFscmVhZHkgaGF2ZSB0aGlzIHtAZ2xvc3NhcnkgbWl4aW59IGFwcGxpZWQuXG4qIFRoaXMgYWxsb3dzIGZvclxuKiBbb2JzZXJ2ZXJzXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH5PYnNlcnZlcn0gdG8gYmVcbiogW2RlY2xhcmVkXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5vYnNlcnZlcnN9IG9yIFwiaW1wbGllZFwiIChzZWUgYmVsb3cpLlxuKlxuKiBJbXBsaWVkIG9ic2VydmVycyBhcmUgbm90IGRlY2xhcmVkLCBidXQgZGVyaXZlZCBmcm9tIHRoZWlyIGBuYW1lYC4gVGhleSB0YWtlXG4qIHRoZSBmb3JtIGA8cHJvcGVydHk+Q2hhbmdlZGAsIHdoZXJlIGA8cHJvcGVydHk+YCBpcyB0aGUgcHJvcGVydHkgdG9cbiogW29ic2VydmVde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm9ic2VydmV9LiBGb3IgZXhhbXBsZTpcbipcbiogYGBgamF2YXNjcmlwdFxuKiBlbnlvLmtpbmQoe1xuKiBcdG5hbWU6ICdNeUtpbmQnLFxuKlxuKiBcdC8vIHNvbWUgbG9jYWwgcHJvcGVydHlcbiogXHR2YWx1ZTogdHJ1ZSxcbipcbiogXHQvLyBhbmQgdGhlIGltcGxpZWQgb2JzZXJ2ZXIgb2YgdGhhdCBwcm9wZXJ0eVxuKiBcdHZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKHdhcywgaXMpIHtcbiogXHRcdC8vIGRvIHNvbWV0aGluZyBub3cgdGhhdCBpdCBoYXMgY2hhbmdlZFxuKiBcdFx0ZW55by5sb2coJ3ZhbHVlIHdhcyBcIicgKyB3YXMgKyAnXCIgYnV0IG5vdyBpdCBpcyBcIicgKyBpcyArICdcIicpO1xuKiBcdH1cbiogfSk7XG4qXG4qIHZhciBtaW5lID0gbmV3IE15S2luZCgpO1xuKiBtaW5lLnNldCgndmFsdWUnLCBmYWxzZSk7IC8vIC0+IHZhbHVlIHdhcyBcInRydWVcIiBidXQgbm93IGl0IGlzIFwiZmFsc2VcIlxuKiBgYGBcbipcbiogVXNpbmcgdGhlIGBvYnNlcnZlcnNgIHByb3BlcnR5IGZvciBpdHMgZGVjbGFyYXRpdmUgc3ludGF4LCBhbiBvYnNlcnZlciBtYXlcbiogb2JzZXJ2ZSBhbnkgcHJvcGVydHkgKG9yIHByb3BlcnRpZXMpLCByZWdhcmRsZXNzIG9mIGl0cyBgbmFtZWAuIEZvciBleGFtcGxlOlxuKlxuKiBgYGBqYXZhc2NyaXB0XG4qIGVueW8ua2luZCh7XG4qIFx0bmFtZTogJ015S2luZCcsXG4qXG4qIFx0Ly8gc29tZSBsb2NhbCBwcm9wZXJ0eVxuKiBcdHZhbHVlOiB0cnVlLFxuKlxuKiBcdC8vIGFub3RoZXIgbG9jYWwgcHJvcGVydHlcbiogXHRjb3VudDogMSxcbipcbiogXHQvLyBkZWNsYXJpbmcgdGhlIG9ic2VydmVyXG4qIFx0b2JzZXJ2ZXJzOiBbXG4qIFx0XHQvLyB0aGUgcGF0aCBjYW4gYmUgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3NcbiogXHRcdHttZXRob2Q6ICdteU9ic2VydmVyJywgcGF0aDogWyd2YWx1ZScsICdjb3VudCddfVxuKiBcdF0sXG4qXG4qIFx0Ly8gbm93IHRoaXMgb2JzZXJ2ZXIgd2lsbCBiZSBub3RpZmllZCBvZiBjaGFuZ2VzIHRvIGJvdGggcHJvcGVydGllc1xuKiBcdG15T2JzZXJ2ZXI6IGZ1bmN0aW9uICh3YXMsIGlzLCBwcm9wKSB7XG4qIFx0XHQvLyBkbyBzb21ldGhpbmcgbm93IHRoYXQgaXQgY2hhbmdlZFxuKiBcdFx0ZW55by5sb2cocHJvcCArICcgd2FzIFwiJyArIHdhcyArICdcIiBidXQgbm93IGl0IGlzIFwiJyArIGlzICsgJ1wiJyk7XG4qIFx0fVxuKiB9KTtcbipcbiogdmFyIG1pbmUgPSBuZXcgTXlLaW5kKCk7XG4qIG1pbmUuc2V0KCd2YWx1ZScsIGZhbHNlKTsgLy8gLT4gdmFsdWUgd2FzIFwidHJ1ZVwiIGJ1dCBub3cgaXQgaXMgXCJmYWxzZVwiXG4qIG1pbmUuc2V0KCdjb3VudCcsIDIpOyAvLyAtPiBjb3VudCB3YXMgXCIxXCIgYnV0IG5vdyBpdCBpcyBcIjJcIlxuKiBgYGBcbipcbiogV2hpbGUgb2JzZXJ2ZXJzIG1heSBiZSBbbm90aWZpZWRde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm5vdGlmeX0gb2ZcbiogY2hhbmdlcyB0byBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB0aGlzIGlzIG5vdCBhIHR5cGljYWwgdXNlIGNhc2UgZm9yIGltcGxpZWRcbiogb2JzZXJ2ZXJzLCBzaW5jZSwgYnkgY29udmVudGlvbiwgdGhleSBhcmUgb25seSByZWdpc3RlcmVkIGZvciB0aGUgbmFtZWRcbiogcHJvcGVydHkuXG4qXG4qIFRoZXJlIGlzIG9uZSBhZGRpdGlvbmFsIHdheSB0byB1c2Ugb2JzZXJ2ZXJzLCBpZiBuZWNlc3NhcnkuIFlvdSBtYXkgdXNlIHRoZVxuKiBBUEkgbWV0aG9kcyBbb2JzZXJ2ZSgpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5vYnNlcnZlfSBhbmRcbiogW3Vub2JzZXJ2ZSgpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC51bm9ic2VydmV9IHRvIGR5bmFtaWNhbGx5XG4qIHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIG9ic2VydmVycyBhcyBuZWVkZWQuIEZvciBleGFtcGxlOlxuKlxuKiBgYGBqYXZhc2NyaXB0XG4qIHZhciBvYmplY3QgPSBuZXcgZW55by5PYmplY3Qoe3ZhbHVlOiB0cnVlfSk7XG4qIHZhciBvYnNlcnZlciA9IGZ1bmN0aW9uICh3YXMsIGlzKSB7XG4qIFx0ZW55by5sb2coJ3ZhbHVlIHdhcyBcIicgKyB3YXMgKyAnXCIgYnV0IG5vdyBpdCBpcyBcIicgKyBpcyArICdcIicpO1xuKiB9O1xuKlxuKiBvYmplY3Qub2JzZXJ2ZSgndmFsdWUnLCBvYnNlcnZlcik7XG4qIG9iamVjdC5zZXQoJ3ZhbHVlJywgZmFsc2UpOyAvLyAtPiB2YWx1ZSB3YXMgXCJ0cnVlXCIgYnV0IG5vdyBpdCBpcyBcImZhbHNlXCJcbiogb2JqZWN0LnVub2JzZXJ2ZSgndmFsdWUnLCBvYnNlcnZlcik7XG4qIG9iamVjdC5zZXQoJ3ZhbHVlJywgdHJ1ZSk7IC8vIG5vIG91dHB1dCBiZWNhdXNlIHRoZXJlIGlzIG5vIG9ic2VydmVyXG4qIGBgYFxuKlxuKiBCZSBzdXJlIHRvIHJlYWQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZXNlIEFQSSBtZXRob2RzOyBwcm9wZXIgdXNhZ2Ugb2ZcbiogdGhlc2UgbWV0aG9kcyBpcyBpbXBvcnRhbnQgZm9yIGF2b2lkaW5nIGNvbW1vbiBwaXRmYWxscyBhbmQgbWVtb3J5IGxlYWtzLlxuKlxuKiBAbWl4aW4gZW55by5PYnNlcnZlclN1cHBvcnRcbiogQHB1YmxpY1xuKi9cbnZhciBPYnNlcnZlclN1cHBvcnQgPSBtb2R1bGUuZXhwb3J0cyA9IC8qKiBAbGVuZHMgZW55by5PYnNlcnZlclN1cHBvcnQgKi8ge1xuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogXCJPYnNlcnZlclN1cHBvcnRcIixcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9vYnNlcnZpbmc6IHRydWUsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfb2JzZXJ2ZUNvdW50OiAwLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X25vdGlmaWNhdGlvblF1ZXVlOiBudWxsLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X25vdGlmaWNhdGlvblF1ZXVlRW5hYmxlZDogdHJ1ZSxcblx0XG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciBgX29ic2VydmluZ2AgaXMgZW5hYmxlZC4gSWZcblx0KiBbc3RvcE5vdGlmaWNhdGlvbnMoKV17QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnQuc3RvcE5vdGlmaWNhdGlvbnN9IGhhc1xuXHQqIGJlZW4gY2FsbGVkLCB0aGVuIHRoaXMgd2lsbCByZXR1cm4gYGZhbHNlYC5cblx0KlxuXHQqIEBzZWUgZW55by5PYnNlcnZlclN1cHBvcnQuc3RvcE5vdGlmaWNhdGlvbnNcblx0KiBAc2VlIGVueW8uT2JzZXJ2ZXJTdXBwb3J0LnN0YXJ0Tm90aWZpY2F0aW9uc1xuXHQqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgY2FsbGVlIGlzIG9ic2VydmluZy5cblx0Ki9cblx0aXNPYnNlcnZpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2JzZXJ2aW5nO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmV0dXJucyBhbiBpbW11dGFibGUgbGlzdCBvZiBbb2JzZXJ2ZXJzXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH5PYnNlcnZlcn1cblx0KiBmb3IgdGhlIGdpdmVuIGBwYXRoYCwgb3IgYWxsIG9ic2VydmVycyBmb3IgdGhlIGNhbGxlZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gLSBQYXRoIG9yIHByb3BlcnR5IHBhdGggZm9yIHdoaWNoXG5cdCogW29ic2VydmVyc117QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9IHdpbGwgYmUgcmV0dXJuZWQuIElmIG5vdFxuXHQqIHNwZWNpZmllZCwgYWxsIG9ic2VydmVycyBmb3IgdGhlIGNhbGxlZSB3aWxsIGJlIHJldHVybmVkLlxuXHQqXG5cdCogQHJldHVybnMge2VueW8uT2JzZXJ2ZXJTdXBwb3J0fk9ic2VydmVyW119IFRoZSBpbW11dGFibGVcblx0KiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2Ygb2JzZXJ2ZXJzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0T2JzZXJ2ZXJzOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdHZhciBldWlkID0gdGhpcy5ldWlkIHx8ICh0aGlzLmV1aWQgPSB1dGlscy51aWQoJ28nKSksXG5cdFx0XHRyZXQsXG5cdFx0XHRsb2M7XG5cdFx0XHRcblx0XHRsb2MgPSBvYnNlcnZlclRhYmxlW2V1aWRdIHx8IChvYnNlcnZlclRhYmxlW2V1aWRdID0gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXJzPyBPYmplY3QuY3JlYXRlKHRoaXMuX29ic2VydmVycyk6IHt9XG5cdFx0KSk7XG5cdFx0XG5cdFx0aWYgKCFwYXRoKSByZXR1cm4gbG9jO1xuXHRcdFxuXHRcdHJldCA9IGxvY1twYXRoXTtcblx0XHRcblx0XHQvLyBpZiB0aGUgc3BlY2lhbCBwcm9wZXJ0eSBleGlzdHMuLi5cblx0XHRpZiAobG9jWycqJ10pIHJldCA9IHJldCA/IHJldC5jb25jYXQobG9jWycqJ10pIDogbG9jWycqJ10uc2xpY2UoKTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0Q2hhaW5zOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29ic2VydmVyQ2hhaW5zIHx8ICh0aGlzLl9vYnNlcnZlckNoYWlucyA9IHt9KTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQGFsaWFzIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm9ic2VydmVcblx0KiBAcHVibGljXG5cdCovXG5cdGFkZE9ic2VydmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQE5PVEU6IEluIHRoaXMgY2FzZSB3ZSB1c2UgYXBwbHkgYmVjYXVzZSBvZiBpbnRlcm5hbCB2YXJpYWJsZSB1c2Ugb2YgcGFyYW1ldGVyc1xuXHRcdHJldHVybiBhZGRPYnNlcnZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVnaXN0ZXJzIGFuIFtvYnNlcnZlcl17QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9IHRvIGJlXG5cdCogW25vdGlmaWVkXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5ub3RpZnl9IHdoZW4gdGhlIGdpdmVuIHByb3BlcnR5IGhhc1xuXHQqIGJlZW4gY2hhbmdlZC4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byByZWdpc3RlciB0aGVcblx0KiBzYW1lIG9ic2VydmVyIG11bHRpcGxlIHRpbWVzIChhbHRob3VnaCB0aGlzIGlzIG5ldmVyIHRoZSBpbnRlbnRpb24pLCBzb1xuXHQqIGNhcmUgc2hvdWxkIGJlIHRha2VuIHRvIGF2b2lkIHRoYXQgc2NlbmFyaW8uIEl0IGlzIGFsc28gaW1wb3J0YW50IHRvXG5cdCogdW5kZXJzdGFuZCBob3cgb2JzZXJ2ZXJzIGFyZSBzdG9yZWQgYW5kIHVucmVnaXN0ZXJlZFxuXHQqIChbdW5vYnNlcnZlZF17QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnQudW5vYnNlcnZlfSkuIFRoZSBgY3R4YCAoY29udGV4dClcblx0KiBwYXJhbWV0ZXIgaXMgc3RvcmVkIHdpdGggdGhlIG9ic2VydmVyIHJlZmVyZW5jZS4gKipJZiB1c2VkIHdoZW5cblx0KiByZWdpc3RlcmluZywgaXQgc2hvdWxkIGFsc28gYmUgdXNlZCB3aGVuIHVucmVnaXN0ZXJpbmcuKipcblx0KlxuXHQqIEBzZWUgZW55by5PYnNlcnZlclN1cHBvcnQudW5vYnNlcnZlXG5cdCogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBUaGUgcHJvcGVydHkgb3IgcHJvcGVydHkgcGF0aCB0byBvYnNlcnZlLlxuXHQqIEBwYXJhbSB7ZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9IGZuIC0gVGhlXG5cdCpcdFtvYnNlcnZlcl17QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9IG1ldGhvZCB0aGF0IHJlc3BvbmRzIHRvIGNoYW5nZXMuXG5cdCogQHBhcmFtIHsqfSBbY3R4XSAtIFRoZSBgdGhpc2AgKGNvbnRleHQpIHVuZGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIG9ic2VydmVyLlxuXHQqXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0b2JzZXJ2ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBOT1RFOiBJbiB0aGlzIGNhc2Ugd2UgdXNlIGFwcGx5IGJlY2F1c2Ugb2YgaW50ZXJuYWwgdmFyaWFibGUgdXNlIG9mIHBhcmFtZXRlcnNcblx0XHRyZXR1cm4gYWRkT2JzZXJ2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQGFsaWFzIGVueW8uT2JzZXJ2ZXJTdXBwb3J0LnVub2JzZXJ2ZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVtb3ZlT2JzZXJ2ZXI6IGZ1bmN0aW9uIChwYXRoLCBmbiwgY3R4KSB7XG5cdFx0cmV0dXJuIHJlbW92ZU9ic2VydmVyKHRoaXMsIHBhdGgsIGZuKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIFVucmVnaXN0ZXJzIGFuIFtvYnNlcnZlcl17QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9LiBJZiBhIGBjdHhgXG5cdCogKGNvbnRleHQpIHdhcyBzdXBwbGllZCB0byBbb2JzZXJ2ZSgpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5vYnNlcnZlfSxcblx0KiB0aGVuIGl0IHNob3VsZCBhbHNvIGJlIHN1cHBsaWVkIHRvIHRoaXMgbWV0aG9kLlxuXHQqXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydC5vYnNlcnZlXG5cdCogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBUaGUgcHJvcGVydHkgb3IgcHJvcGVydHkgcGF0aCB0byB1bm9ic2VydmUuXG5cdCogQHBhcmFtIHtlbnlvLk9ic2VydmVyU3VwcG9ydH5PYnNlcnZlcn0gZm4gLSBUaGVcblx0Klx0W29ic2VydmVyXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH5PYnNlcnZlcn0gbWV0aG9kIHRoYXQgcmVzcG9uZHMgdG8gY2hhbmdlcy5cblx0KiBAcGFyYW0geyp9IFtjdHhdIC0gVGhlIGB0aGlzYCAoY29udGV4dCkgdW5kZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgb2JzZXJ2ZXIuXG5cdCpcblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR1bm9ic2VydmU6IGZ1bmN0aW9uIChwYXRoLCBmbiwgY3R4KSB7XG5cdFx0cmV0dXJuIHJlbW92ZU9ic2VydmVyKHRoaXMsIHBhdGgsIGZuLCBjdHgpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgW29ic2VydmVyc117QGxpbmsgZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9IGZyb20gdGhlXG5cdCogY2FsbGVlLiBJZiBhIGBwYXRoYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIG9ic2VydmVycyB3aWxsIG9ubHkgYmUgcmVtb3ZlZFxuXHQqIGZyb20gdGhhdCBwYXRoIChvciBwcm9wZXJ0eSkuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIC0gQSBwcm9wZXJ0eSBvciBwcm9wZXJ0eSBwYXRoIGZyb20gd2hpY2ggdG8gcmVtb3ZlIGFsbFxuXHQqXHRbb2JzZXJ2ZXJzXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydH5PYnNlcnZlcn0uXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqL1xuXHRyZW1vdmVBbGxPYnNlcnZlcnM6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGV1aWQgPSB0aGlzLmV1aWRcblx0XHRcdCwgbG9jID0gZXVpZCAmJiBvYnNlcnZlclRhYmxlW2V1aWRdO1xuXHRcdFxuXHRcdGlmIChsb2MpIHtcblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdGxvY1twYXRoXSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvYnNlcnZlclRhYmxlW2V1aWRdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBhbGlhcyBlbnlvLk9ic2VydmVyU3VwcG9ydC5ub3RpZnlcblx0KiBAcHVibGljXG5cdCovXG5cdG5vdGlmeU9ic2VydmVyczogZnVuY3Rpb24gKHBhdGgsIHdhcywgaXMsIG9wdHMpIHtcblx0XHRyZXR1cm4gbm90aWZ5T2JzZXJ2ZXJzKHRoaXMsIHBhdGgsIHdhcywgaXMsIG9wdHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogVHJpZ2dlcnMgYW55IFtvYnNlcnZlcnNde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0fk9ic2VydmVyfSBmb3IgdGhlXG5cdCogZ2l2ZW4gYHBhdGhgLiBUaGUgcHJldmlvdXMgYW5kIGN1cnJlbnQgdmFsdWVzIG11c3QgYmUgc3VwcGxpZWQuIFRoaXNcblx0KiBtZXRob2QgaXMgdHlwaWNhbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5LCBidXQgaXQgbWF5IGFsc28gYmUgY2FsbGVkXG5cdCogZm9yY2libHkgYnkgW3NldHRpbmdde0BsaW5rIGVueW8uT2JqZWN0I3NldH0gYSB2YWx1ZSB3aXRoIHRoZVxuXHQqIGBmb3JjZWAgb3B0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBUaGUgcHJvcGVydHkgb3IgcHJvcGVydHkgcGF0aCB0byBub3RpZnkuXG5cdCogQHBhcmFtIHsqfSB3YXMgLSBUaGUgcHJldmlvdXMgdmFsdWUuXG5cdCogQHBhcmFtIHsqfSBpcyAtIFRoZSBjdXJyZW50IHZhbHVlLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0Ki9cblx0bm90aWZ5OiBmdW5jdGlvbiAocGF0aCwgd2FzLCBpcywgb3B0cykge1xuXHRcdHJldHVybiBub3RpZnlPYnNlcnZlcnModGhpcywgcGF0aCwgd2FzLCBpcywgb3B0cyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBTdG9wcyBhbGwgW25vdGlmaWNhdGlvbnNde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm5vdGlmeX0gZnJvbVxuXHQqIHByb3BhZ2F0aW5nLiBCeSBkZWZhdWx0LCBhbGwgbm90aWZpY2F0aW9ucyB3aWxsIGJlIHF1ZXVlZCBhbmQgZmx1c2hlZCBvbmNlXG5cdCogW3N0YXJ0Tm90aWZpY2F0aW9ucygpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5zdGFydE5vdGlmaWNhdGlvbnN9XG5cdCogaGFzIGJlZW4gY2FsbGVkLiBTZXR0aW5nIHRoZSBvcHRpb25hbCBgbm9RdWV1ZWAgZmxhZyB3aWxsIGFsc28gZGlzYWJsZSB0aGVcblx0KiBxdWV1ZSwgb3IgeW91IGNhbiB1c2UgdGhlXG5cdCogW2Rpc2FibGVOb3RpZmljYXRpb25RdWV1ZSgpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5kaXNhYmxlTm90aWZpY2F0aW9uUXVldWV9IGFuZFxuXHQqIFtlbmFibGVOb3RpZmljYXRpb25RdWV1ZSgpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5lbmFibGVOb3RpZmljYXRpb25RdWV1ZX1cblx0KiBBUEkgbWV0aG9kcy4gYHN0YXJ0Tm90aWZpY2F0aW9ucygpYCB3aWxsIG5lZWQgdG8gYmUgY2FsbGVkIHRoZSBzYW1lIG51bWJlclxuXHQqIG9mIHRpbWVzIHRoYXQgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuXHQqXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydC5zdGFydE5vdGlmaWNhdGlvbnNcblx0KiBAc2VlIGVueW8uT2JzZXJ2ZXJTdXBwb3J0LmRpc2FibGVOb3RpZmljYXRpb25RdWV1ZVxuXHQqIEBzZWUgZW55by5PYnNlcnZlclN1cHBvcnQuZW5hYmxlTm90aWZpY2F0aW9uUXVldWVcblx0KiBAcGFyYW0ge0Jvb2xlYW59IFtub1F1ZXVlXSAtIElmIGB0cnVlYCwgdGhpcyB3aWxsIGFsc28gZGlzYWJsZSB0aGUgbm90aWZpY2F0aW9uIHF1ZXVlLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0Ki9cblx0c3RvcE5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChub1F1ZXVlKSB7XG5cdFx0dGhpcy5fb2JzZXJ2aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fb2JzZXJ2ZUNvdW50Kys7XG5cdFx0bm9RdWV1ZSAmJiB0aGlzLmRpc2FibGVOb3RpZmljYXRpb25RdWV1ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogU3RhcnRzIFtub3RpZmljYXRpb25zXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5ub3RpZnl9IGlmIHRoZXkgaGF2ZVxuXHQqIGJlZW4gW2Rpc2FibGVkXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5zdG9wTm90aWZpY2F0aW9uc30uIElmIHRoZVxuXHQqIG5vdGlmaWNhdGlvbiBxdWV1ZSB3YXMgbm90IGRpc2FibGVkLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseSBmbHVzaCB0aGVcblx0KiBxdWV1ZSBvZiBhbGwgbm90aWZpY2F0aW9ucyB0aGF0IHdlcmUgZW5jb3VudGVyZWQgd2hpbGUgc3RvcHBlZC4gVGhpc1xuXHQqIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB0aGUgc2FtZSBudW1iZXIgb2YgdGltZXMgdGhhdFxuXHQqIFtzdG9wTm90aWZpY2F0aW9ucygpXXtAbGluayBlbnlvLk9ic2VydmVyU3VwcG9ydC5zdG9wTm90aWZpY2F0aW9uc30gd2FzXG5cdCogY2FsbGVkLlxuXHQqXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydC5zdG9wTm90aWZpY2F0aW9uc1xuXHQqIEBzZWUgZW55by5PYnNlcnZlclN1cHBvcnQuZGlzYWJsZU5vdGlmaWNhdGlvblF1ZXVlXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydC5lbmFibGVOb3RpZmljYXRpb25RdWV1ZVxuXHQqIEBwYXJhbSB7Qm9vbGVhbn0gW3F1ZXVlXSAtIElmIGB0cnVlYCBhbmQgdGhlIG5vdGlmaWNhdGlvbiBxdWV1ZSBpcyBkaXNhYmxlZCxcblx0KiB0aGUgcXVldWUgd2lsbCBiZSByZS1lbmFibGVkLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0Ki9cblx0c3RhcnROb3RpZmljYXRpb25zOiBmdW5jdGlvbiAocXVldWUpIHtcblx0XHR0aGlzLl9vYnNlcnZlQ291bnQgJiYgdGhpcy5fb2JzZXJ2ZUNvdW50LS07XG5cdFx0dGhpcy5fb2JzZXJ2ZUNvdW50ID09PSAwICYmICh0aGlzLl9vYnNlcnZpbmcgPSB0cnVlKTtcblx0XHRxdWV1ZSAmJiB0aGlzLmVuYWJsZU5vdGlmaWNhdGlvblF1ZXVlKCk7XG5cdFx0dGhpcy5pc09ic2VydmluZygpICYmIGZsdXNoUXVldWUodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBSZS1lbmFibGVzIHRoZSBub3RpZmljYXRpb24gcXVldWUsIGlmIGl0IHdhcyBkaXNhYmxlZC5cblx0KlxuXHQqIEBzZWUgZW55by5PYnNlcnZlclN1cHBvcnQuZGlzYWJsZU5vdGlmaWNhdGlvblF1ZXVlXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqL1xuXHRlbmFibGVOb3RpZmljYXRpb25RdWV1ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX25vdGlmaWNhdGlvblF1ZXVlRW5hYmxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBJZiB0aGUgbm90aWZpY2F0aW9uIHF1ZXVlIGlzIGVuYWJsZWQgKHRoZSBkZWZhdWx0KSwgaXQgd2lsbCBiZSBkaXNhYmxlZFxuXHQqIGFuZCBhbnkgbm90aWZpY2F0aW9ucyBpbiB0aGUgcXVldWUgd2lsbCBiZSByZW1vdmVkLlxuXHQqXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydC5lbmFibGVOb3RpZmljYXRpb25RdWV1ZVxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0Ki9cblx0ZGlzYWJsZU5vdGlmaWNhdGlvblF1ZXVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbm90aWZpY2F0aW9uUXVldWVFbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5fbm90aWZpY2F0aW9uUXVldWUgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFpbnMsIGNoYWluLCBwYXRoLCBlbnRyaWVzLCBpO1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgYW55IG9ic2VydmVycyB0aGF0IG5lZWQgdG8gY3JlYXRlIGR5bmFtaWMgY2hhaW5zXG5cdFx0XHQvLyB3ZSBsb29rIGZvciBhbmQgaW5zdGFuY2UgdGhvc2Ugbm93XG5cdFx0XHRpZiAodGhpcy5fb2JzZXJ2ZXJDaGFpbnMpIHtcblx0XHRcdFx0Y2hhaW5zID0gdGhpcy5fb2JzZXJ2ZXJDaGFpbnM7XG5cdFx0XHRcdHRoaXMuX29ic2VydmVyQ2hhaW5zID0ge307XG5cdFx0XHRcdGZvciAocGF0aCBpbiBjaGFpbnMpIHtcblx0XHRcdFx0XHRlbnRyaWVzID0gY2hhaW5zW3BhdGhdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IChjaGFpbiA9IGVudHJpZXNbaV0pOyArK2kpIHRoaXMub2JzZXJ2ZShwYXRoLCBjaGFpbi5tZXRob2QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYWlucyA9IHRoaXMuX29ic2VydmVyQ2hhaW5zLFxuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRjaGFpbjtcblx0XHRcdFxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHRcdGlmIChjaGFpbnMpIHtcblx0XHRcdFx0Zm9yIChwYXRoIGluIGNoYWlucykge1xuXHRcdFx0XHRcdGNoYWluID0gY2hhaW5zW3BhdGhdO1xuXHRcdFx0XHRcdGNoYWluLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5fb2JzZXJ2ZXJDaGFpbnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pXG5cdFxufTtcblxuLyoqXG4qIEhpamFjayB0aGUgb3JpZ2luYWwgc28gd2UgY2FuIGFkZCBhZGRpdGlvbmFsIGRlZmF1bHQgYmVoYXZpb3IuXG4qXG4qIEBwcml2YXRlXG4qL1xudmFyIHN1cCA9IGtpbmQuY29uY2F0SGFuZGxlcjtcblxuLy8gQE5PVEU6IEl0IHNlZW1zIGxpa2UgYSBsb3Qgb2Ygd29yayBidXQgaXQgcmVhbGx5IHdvbid0IGhhcHBlbiB0aGF0IG11Y2ggYW5kIHRoZSBtb3JlXG4vLyB3ZSBwdXNoIHRvIGtpbmQtdGltZSB0aGUgYmV0dGVyIGZvciBpbml0aWFsaXphdGlvbiB0aW1lXG5cbi8qKiBAcHJpdmF0ZSAqL1xua2luZC5jb25jYXRIYW5kbGVyID0gZnVuY3Rpb24gKGN0b3IsIHByb3BzLCBpbnN0YW5jZSkge1xuXHRcblx0c3VwLmNhbGwodGhpcywgY3RvciwgcHJvcHMsIGluc3RhbmNlKTtcblx0XG5cdGlmIChwcm9wcyA9PT0gT2JzZXJ2ZXJTdXBwb3J0KSByZXR1cm47XG5cblx0dmFyIHByb3RvID0gY3Rvci5wcm90b3R5cGUgfHwgY3RvclxuXHRcdCwgb2JzZXJ2ZXJzID0gcHJvdG8uX29ic2VydmVycz8gT2JqZWN0LmNyZWF0ZShwcm90by5fb2JzZXJ2ZXJzKTogbnVsbFxuXHRcdCwgaW5jb21pbmcgPSBwcm9wcy5vYnNlcnZlcnNcblx0XHQsIGNoYWlucyA9IHByb3RvLl9vYnNlcnZlckNoYWlucyAmJiBPYmplY3QuY3JlYXRlKHByb3RvLl9vYnNlcnZlckNoYWlucyk7XG5cdFx0XG5cdGlmICghb2JzZXJ2ZXJzKSB7XG5cdFx0aWYgKHByb3RvLmtpbmROYW1lKSBvYnNlcnZlcnMgPSB7fTtcblx0XHRlbHNlIHJldHVybjtcblx0fVxuXHRcdFxuXHRpZiAoaW5jb21pbmcgJiYgIShpbmNvbWluZyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdChmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdG1wID0gW10sIGRlcHMsIG5hbWU7XG5cdFx0XHQvLyBoZXJlIGlzIHRoZSBzbG93IGl0ZXJhdGlvbiBvdmVyIHRoZSBwcm9wZXJ0aWVzLi4uXG5cdFx0XHRmb3IgKG5hbWUgaW4gcHJvcHMub2JzZXJ2ZXJzKSB7XG5cdFx0XHRcdC8vIHBvaW50cyB0byB0aGUgZGVwZW5kZW5jaWVzIG9mIHRoZSBjb21wdXRlZCBtZXRob2Rcblx0XHRcdFx0ZGVwcyA9IHByb3BzLm9ic2VydmVyc1tuYW1lXTtcblx0XHRcdFx0Ly8gY3JlYXRlIGEgc2luZ2xlIGVudHJ5IG5vdyBmb3IgdGhlIG1ldGhvZC9jb21wdXRlZCB3aXRoIGFsbCBkZXBlbmRlbmNpZXNcblx0XHRcdFx0dG1wLnB1c2goe21ldGhvZDogbmFtZSwgcGF0aDogZGVwc30pO1xuXHRcdFx0fVxuXHRcdFx0aW5jb21pbmcgPSB0bXA7XG5cdFx0fSgpKTtcblx0XHQvLyB3ZSBuZWVkIHRvIGVuc3VyZSB3ZSBkb24ndCBtb2RpZnkgdGhlIGZpeGVkIGFycmF5IG9mIGEgbWl4aW4gb3IgcmV1c2VkIG9iamVjdFxuXHRcdC8vIGJlY2F1c2UgaXQgY291bGQgd2luZCB1cCBpbmFkdmVydGFudGx5IGFkZGluZyB0aGUgc2FtZSBlbnRyeSBtdWx0aXBsZSB0aW1lc1xuXHR9IGVsc2UgaWYgKGluY29taW5nKSBpbmNvbWluZyA9IGluY29taW5nLnNsaWNlKCk7XG5cdFxuXHQvLyB0aGlzIHNjYW4gaXMgcmVxdWlyZWQgdG8gZmlndXJlIG91dCB3aGF0IGF1dG8tb2JzZXJ2ZXJzIG1pZ2h0IGJlIHByZXNlbnRcblx0Zm9yICh2YXIga2V5IGluIHByb3BzKSB7XG5cdFx0aWYgKGtleS5zbGljZSgtNykgPT0gXCJDaGFuZ2VkXCIpIHtcblx0XHRcdGluY29taW5nIHx8IChpbmNvbWluZyA9IFtdKTtcblx0XHRcdGluY29taW5nLnB1c2goe21ldGhvZDoga2V5LCBwYXRoOiBrZXkuc2xpY2UoMCwgLTcpfSk7XG5cdFx0fVxuXHR9XG5cdFxuXHR2YXIgYWRkT2JzZXJ2ZXJFbnRyeSA9IGZ1bmN0aW9uIChwYXRoLCBtZXRob2QpIHtcblx0XHR2YXIgb2JzO1xuXHRcdC8vIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHBhdGggaXNuJ3QgYSBjaGFpbiBiZWNhdXNlIGlmIGl0IGlzIHdlIGFkZCBpdFxuXHRcdC8vIHRvIHRoZSBjaGFpbnMgaW5zdGVhZFxuXHRcdGlmIChwYXRoLmluZGV4T2YoXCIuXCIpID4gLTEpIHtcblx0XHRcdGlmICghY2hhaW5zKSBjaGFpbnMgPSB7fTtcblx0XHRcdG9icyA9IGNoYWluc1twYXRoXSB8fCAoY2hhaW5zW3BhdGhdID0gW10pO1xuXHRcdFx0b2JzLnB1c2goe21ldGhvZDogbWV0aG9kfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChvYnNlcnZlcnNbcGF0aF0gJiYgIW9ic2VydmVycy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkgb2JzZXJ2ZXJzW3BhdGhdID0gb2JzZXJ2ZXJzW3BhdGhdLnNsaWNlKCk7XG5cdFx0XHRvYnMgPSBvYnNlcnZlcnNbcGF0aF0gfHwgKG9ic2VydmVyc1twYXRoXSA9IFtdKTtcblx0XHRcdGlmICghb2JzLmZpbmQoZnVuY3Rpb24gKGxuKSB7IHJldHVybiBsbi5tZXRob2QgPT0gbWV0aG9kOyB9KSkgb2JzLnB1c2goe21ldGhvZDogbWV0aG9kfSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0aWYgKGluY29taW5nKSB7XG5cdFx0aW5jb21pbmcuZm9yRWFjaChmdW5jdGlvbiAobG4pIHtcblx0XHRcdC8vIGZpcnN0IHdlIGRldGVybWluZSBpZiB0aGUgcGF0aCBpdHNlbGYgaXMgYW4gYXJyYXkgb2YgcGF0aHMgdG8gb2JzZXJ2ZVxuXHRcdFx0aWYgKGxuLnBhdGggJiYgbG4ucGF0aCBpbnN0YW5jZW9mIEFycmF5KSBsbi5wYXRoLmZvckVhY2goZnVuY3Rpb24gKGVuKSB7IGFkZE9ic2VydmVyRW50cnkoZW4sIGxuLm1ldGhvZCk7IH0pO1xuXHRcdFx0ZWxzZSBhZGRPYnNlcnZlckVudHJ5KGxuLnBhdGgsIGxuLm1ldGhvZCk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8vIHdlIGNsZWFyIHRoZSBrZXkgc28gaXQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHByb3RvdHlwZVxuXHQvLyBkZWxldGUgcHJvcHMub2JzZXJ2ZXJzO1xuXHQvLyB3ZSB1cGRhdGUgdGhlIHByb3BlcnRpZXMgdG8gd2hhdGV2ZXIgdGhlaXIgbmV3IHZhbHVlcyBtYXkgYmVcblx0cHJvdG8uX29ic2VydmVycyA9IG9ic2VydmVycztcblx0cHJvdG8uX29ic2VydmVyQ2hhaW5zID0gY2hhaW5zO1xufTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL09ic2VydmVyQ2hhaW5cIjozMixcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHRsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdE1peGluU3VwcG9ydCA9IHJlcXVpcmUoJy4vTWl4aW5TdXBwb3J0JyksXG5cdE9ic2VydmVyU3VwcG9ydCA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXJTdXBwb3J0JyksXG5cdEJpbmRpbmdTdXBwb3J0ID0gcmVxdWlyZSgnLi9CaW5kaW5nU3VwcG9ydCcpO1xuXHRcbi8qKlxuKiBVc2VkIGJ5IGFsbCBbb2JqZWN0c117QGxpbmsgZW55by5PYmplY3R9IGFuZCBbc3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfSB3aGVuIHVzaW5nIHRoZVxuKiB7QGxpbmsgZW55by5PYmplY3QjbG9nfSwge0BsaW5rIGVueW8uT2JqZWN0I3dhcm59IGFuZCB7QGxpbmsgZW55by5PYmplY3QjZXJyb3J9IG1ldGhvZHMuXG4qXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gbG9nIChtZXRob2QsIGFyZ3MpIHtcblx0aWYgKGxvZ2dlci5zaG91bGRMb2cobWV0aG9kKSkge1xuXHRcdHRyeSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHR9IGNhdGNoKGVycikge1xuXHRcdFx0bG9nZ2VyLl9sb2cobWV0aG9kLCBbYXJncy5jYWxsZWUuY2FsbGVyLmRpc3BsYXlOYW1lICsgJzogJ11cblx0XHRcdFx0LmNvbmNhdCh1dGlscy5jbG9uZUFycmF5KGFyZ3MpKSk7XG5cdFx0XHRsb2dnZXIubG9nKGVyci5zdGFjayk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuKiB7QGxpbmsgZW55by5PYmplY3R9IGxpZXMgYXQgdGhlIGhlYXJ0IG9mIHRoZSBFbnlvIGZyYW1ld29yaydzIGltcGxlbWVudGF0aW9ucyBvZiBwcm9wZXJ0eVxuKiBwdWJsaXNoaW5nLCBjb21wdXRlZCBwcm9wZXJ0aWVzICh2aWEgdGhlIHtAbGluayBlbnlvLkNvbXB1dGVkU3VwcG9ydH0ge0BnbG9zc2FyeSBtaXhpbn0pLFxuKiBhbmQgZGF0YSBiaW5kaW5nICh2aWEgdGhlIHtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSBtaXhpbiBhbmQge0BsaW5rIGVueW8uQmluZGluZ31cbiogb2JqZWN0KS4gSXQgYWxzbyBwcm92aWRlcyBzZXZlcmFsIHV0aWxpdHkgW2Z1bmN0aW9uc117QGdsb3NzYXJ5IEZ1bmN0aW9ufSBmb3IgaXRzXG4qIFtzdWJraW5kc117QGdsb3NzYXJ5IHN1YmtpbmR9LlxuKlxuKiBAY2xhc3MgZW55by5PYmplY3RcbiogQG1peGVzIGVueW8uTWl4aW5TdXBwb3J0XG4qIEBtaXhlcyBlbnlvLk9ic2VydmVyU3VwcG9ydFxuKiBAbWl4ZXMgZW55by5CaW5kaW5nU3VwcG9ydFxuKiBAcHVibGljXG4qL1xudmFyIENvcmVPYmplY3QgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5PYmplY3QucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5PYmplY3QnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IG51bGwsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblxuXG5cdC8qKlxuXHQqIFdpbGwgYmUgYHRydWVgIGlmIHRoZSBbZGVzdHJveSgpXXtAbGluayBlbnlvLk9iamVjdCNkZXN0cm95fSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkO1xuXHQqIG90aGVyd2lzZSwgYGZhbHNlYC5cblx0KlxuXHQqIEByZWFkb25seVxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IGZhbHNlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkZXN0cm95ZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1peGluczogW01peGluU3VwcG9ydCwgT2JzZXJ2ZXJTdXBwb3J0LCBCaW5kaW5nU3VwcG9ydF0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdHRoaXMuaW1wb3J0UHJvcHMocHJvcHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEltcG9ydHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fS4gQXV0b21hdGljYWxseSBjYWxsZWRcblx0KiBmcm9tIHRoZSBbY29uc3RydWN0b3Jde0BsaW5rIGVueW8uT2JqZWN0I2NvbnN0cnVjdG9yfS5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIElmIHByb3ZpZGVkLCB0aGUgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gZnJvbSB3aGljaCB0b1xuXHQqXHRyZXRyaWV2ZSBba2V5cy92YWx1ZXNde0BnbG9zc2FyeSBPYmplY3Qua2V5c30gdG8gbWl4IGluLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGltcG9ydFByb3BzOiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRraW5kLmNvbmNhdEhhbmRsZXIodGhpcywgcHJvcHMsIHRydWUpO1xuXHRcdFx0Ly8gaWYgcHJvcHMgaXMgYSBkZWZhdWx0IGhhc2ggdGhpcyBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuXG5cdFx0XHQvLyByZXF1aXJpbmcgdGhlIGhhc093blByb3BlcnR5IGNoZWNrIGV2ZXJ5IHRpbWVcblx0XHRcdGlmICghcHJvcHMua2luZE5hbWUpIHtcblx0XHRcdFx0Zm9yIChrZXkgaW4gcHJvcHMpIHtcblx0XHRcdFx0XHRraW5kLmNvbmNhdGVuYXRlZC5pbmRleE9mKGtleSkgPT09IC0xICYmICh0aGlzW2tleV0gPSBwcm9wc1trZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChrZXkgaW4gcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAoa2luZC5jb25jYXRlbmF0ZWQuaW5kZXhPZihrZXkpID09PSAtMSAmJiBwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIENhbGxzIHRoZSBbZGVzdHJveSgpXXtAbGluayBlbnlvLk9iamVjdCNkZXN0cm95fSBtZXRob2QgZm9yIHRoZSBuYW1lZCB7QGxpbmsgZW55by5PYmplY3R9IFxuXHQqIHByb3BlcnR5LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGVzdHJveSwgaWYgcG9zc2libGUuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzdHJveU9iamVjdDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAodGhpc1tuYW1lXSAmJiB0aGlzW25hbWVdLmRlc3Ryb3kpIHtcblx0XHRcdHRoaXNbbmFtZV0uZGVzdHJveSgpO1xuXHRcdH1cblx0XHR0aGlzW25hbWVdID0gbnVsbDtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIFNlbmRzIGEgbG9nIG1lc3NhZ2UgdG8gdGhlIFtjb25zb2xlXXtAZ2xvc3NhcnkgY29uc29sZX0sIHByZXBlbmRlZCB3aXRoIHRoZSBuYW1lXG5cdCogb2YgdGhlIHtAZ2xvc3Nhcnkga2luZH0gYW5kIG1ldGhvZCBmcm9tIHdoaWNoIGBsb2coKWAgd2FzIGludm9rZWQuIE11bHRpcGxlXG5cdCoge0BnbG9zc2FyeSBhcmd1bWVudHN9IGFyZSBjb2VyY2VkIHRvIHtAZ2xvc3NhcnkgU3RyaW5nfSBhbmRcblx0KiBbam9pbmVkIHdpdGggc3BhY2VzXXtAZ2xvc3NhcnkgQXJyYXkuam9pbn0uXG5cdCpcblx0KiBgYGBqYXZhc2NyaXB0XG5cdCogZW55by5raW5kKHtcblx0Klx0bmFtZTogJ015T2JqZWN0Jyxcblx0Klx0a2luZDogJ2VueW8uT2JqZWN0Jyxcblx0Klx0aGVsbG86IGZ1bmN0aW9uKCkge1xuXHQqXHRcdHRoaXMubG9nKCdzYXlzJywgJ2hpJyk7XG5cdCpcdFx0Ly8gc2hvd3MgaW4gdGhlIGNvbnNvbGU6IE15T2JqZWN0LmhlbGxvOiBzYXlzIGhpXG5cdCpcdH1cblx0KiB9KTtcblx0KiBgYGBcblx0KiBAcHVibGljXG5cdCovXG5cdGxvZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhY2MgPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcixcblx0XHRcdG5vbSA9ICgoYWNjID8gYWNjLmRpc3BsYXlOYW1lIDogJycpIHx8ICcoaW5zdGFuY2UgbWV0aG9kKScpICsgJzonLFxuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0YXJncy51bnNoaWZ0KG5vbSk7XG5cdFx0bG9nZ2VyLmxvZygnbG9nJywgYXJncyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBTYW1lIGFzIFtsb2coKV17QGxpbmsgZW55by5PYmplY3QjbG9nfSwgZXhjZXB0IHRoYXQgaXQgdXNlcyB0aGUgXG5cdCogY29uc29sZSdzIFt3YXJuKClde0BnbG9zc2FyeSBjb25zb2xlLndhcm59IG1ldGhvZCAoaWYgaXQgZXhpc3RzKS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0d2FybjogZnVuY3Rpb24gKCkge1xuXHRcdGxvZygnd2FybicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBTYW1lIGFzIFtsb2coKV17QGxpbmsgZW55by5PYmplY3QjbG9nfSwgZXhjZXB0IHRoYXQgaXQgdXNlcyB0aGUgXG5cdCogY29uc29sZSdzIFtlcnJvcigpXXtAZ2xvc3NhcnkgY29uc29sZS5lcnJvcn0gbWV0aG9kIChpZiBpdCBleGlzdHMpLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRlcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdGxvZygnZXJyb3InLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIHJldHJpZXZlZCBhcyBsb25nIGFzIHRoZSBnaXZlbiBcblx0KiBwYXRoIGlzIHJlc29sdmFibGUgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHtAbGluayBlbnlvLk9iamVjdH0uIFNlZVxuXHQqIFtlbnlvLmdldFBhdGgoKV17QGxpbmsgZW55by5nZXRQYXRofSBmb3IgY29tcGxldGUgZGV0YWlscy5cblx0KlxuXHQqIFRoaXMgbWV0aG9kIGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIGFuZCB3aWxsIGF1dG9tYXRpY2FsbHkgY2FsbCBhbnkgZXhpc3RpbmcgZ2V0dGVyXG5cdCogbWV0aG9kIHRoYXQgdXNlcyB0aGUgXCJnZXRQcm9wZXJ0eVwiIG5hbWluZyBjb252ZW50aW9uLiAoTW92aW5nIGZvcndhcmQsIGhvd2V2ZXIsIEVueW8gY29kZVxuXHQqIHNob3VsZCB1c2UgW2NvbXB1dGVkIHByb3BlcnRpZXNde0BsaW5rIGVueW8uQ29tcHV0ZWRTdXBwb3J0fSBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIFxuXHQqIGdldHRlciBuYW1pbmcgY29udmVudGlvbi4pXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIGZyb20gd2hpY2ggdG8gcmV0cmlldmUgYSB2YWx1ZS5cblx0KiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGF0aCBvciBbdW5kZWZpbmVkXXtAZ2xvc3NhcnkgdW5kZWZpbmVkfSBpZiBcblx0Klx0dGhlIHBhdGggY291bGQgbm90IGJlIGNvbXBsZXRlbHkgcmVzb2x2ZWQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdXRpbHMuZ2V0UGF0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogVXBkYXRlcyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIHNldCBhcyBsb25nIGFzIHRoZVxuXHQqIGdpdmVuIHBhdGggaXMgcmVzb2x2YWJsZSByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4ge0BsaW5rIGVueW8uT2JqZWN0fS4gU2VlXG5cdCogW2VueW8uc2V0UGF0aCgpXXtAbGluayBlbnlvLnNldFBhdGh9IGZvciBjb21wbGV0ZSBkZXRhaWxzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBUaGUgcGF0aCBmb3Igd2hpY2ggdG8gc2V0IHRoZSBnaXZlbiB2YWx1ZS5cblx0KiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cblx0KiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gQW4gb3B0aW9ucyBoYXNoLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB1dGlscy5zZXRQYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQmluZHMgYSBbY2FsbGJhY2tde0BnbG9zc2FyeSBjYWxsYmFja30gdG8gdGhpcyBbb2JqZWN0XXtAbGluayBlbnlvLk9iamVjdH0uXG5cdCogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIHRoZSBib3VuZCBtZXRob2Qgd2lsbCBiZSBhYm9ydGVkIGNsZWFubHksXG5cdCogd2l0aCBubyB2YWx1ZSByZXR1cm5lZC5cblx0KlxuXHQqIFRoaXMgbWV0aG9kIHNob3VsZCBnZW5lcmFsbHkgYmUgdXNlZCBpbnN0ZWFkIG9mIHtAbGluayBlbnlvLmJpbmR9IGZvciBydW5uaW5nXG5cdCogY29kZSBpbiB0aGUgY29udGV4dCBvZiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgZW55by5PYmplY3R9IG9yIG9uZSBvZiBpdHNcblx0KiBbc3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfS5cblx0KlxuXHQqIEBhbGlhcyBlbnlvLmJpbmRTYWZlbHlcblx0KiBAcHVibGljXG5cdCovXG5cdGJpbmRTYWZlbHk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0YXJncy51bnNoaWZ0KHRoaXMpO1xuXHRcdHJldHVybiB1dGlscy5iaW5kU2FmZWx5LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQW4gYWJzdHJhY3QgbWV0aG9kIChwcmltYXJpbHkpIHRoYXQgc2V0cyB0aGUgW2Rlc3Ryb3llZF17QGxpbmsgZW55by5PYmplY3QjZGVzdHJveWVkfSBcblx0KiBwcm9wZXJ0eSB0byBgdHJ1ZWAuXG5cdCpcblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XG5cdFx0Ly8gU2luY2UgSlMgb2JqZWN0cyBhcmUgbmV2ZXIgdHJ1bHkgZGVzdHJveWVkIChHQydkKSB1bnRpbCBhbGwgcmVmZXJlbmNlcyBhcmVcblx0XHQvLyBnb25lLCB3ZSBtaWdodCBoYXZlIHNvbWUgZGVsYXllZCBhY3Rpb24gb24gdGhpcyBvYmplY3QgdGhhdCBuZWVkcyBhY2Nlc3Ncblx0XHQvLyB0byB0aGlzIGZsYWcuXG5cdFx0Ly8gVXNpbmcgdGhpcy5zZXQgdG8gbWFrZSB0aGUgcHJvcGVydHkgb2JzZXJ2YWJsZVxuXHRcdHJldHVybiB0aGlzLnNldCgnZGVzdHJveWVkJywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5Db3JlT2JqZWN0LmNvbmNhdCA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcykge1xuXHR2YXIgcHVicyA9IHByb3BzLnB1Ymxpc2hlZCxcblx0XHRjcHksXG5cdFx0cHJvcDtcblx0XHRcblx0aWYgKHB1YnMpIHtcblx0XHRjcHkgPSBjdG9yLnByb3RvdHlwZSB8fCBjdG9yO1xuXHRcdGZvciAocHJvcCBpbiBwdWJzKSB7XG5cdFx0XHQvLyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGV2ZW4gdGhvdWdoIGEgcHJvcGVydHkgaXMgJ3B1Ymxpc2hlZCdcblx0XHRcdC8vIGl0IGRvZXMgbm90IG92ZXJ3cml0ZSBhbnkgY29tcHV0ZWQgcHJvcGVydGllc1xuXHRcdFx0aWYgKHByb3BzW3Byb3BdICYmIHR5cGVvZiBwcm9wc1twcm9wXSA9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcblx0XHRcdGFkZEdldHRlclNldHRlcihwcm9wLCBwdWJzW3Byb3BdLCBjcHkpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBnZXR0ZXIvc2V0dGVyIGZvciBhIHB1Ymxpc2hlZCBwcm9wZXJ0eSBvZiBhbiB7QGxpbmsgZW55by5PYmplY3R9LCBidXQgaXNcbiogZGVwcmVjYXRlZC4gSXQgaXMgbWFpbnRhaW5lZCBmb3IgcHVycG9zZXMgb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZSBwcmVmZXJyZWQgbWV0aG9kIGlzIFxuKiB0byBtYXJrIHB1YmxpYyBhbmQgcHJvdGVjdGVkIChwcml2YXRlKSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHVzaW5nIGRvY3VtZW50YXRpb24gb3Igb3RoZXIgXG4qIG1lYW5zIGFuZCByZWx5IG9uIHRoZSBbZ2V0XXtAbGluayBlbnlvLk9iamVjdCNnZXR9IGFuZCBbc2V0XXtAbGluayBlbnlvLk9iamVjdCNzZXR9IG1ldGhvZHMgb2Zcbioge0BsaW5rIGVueW8uT2JqZWN0fSBpbnN0YW5jZXMuXG4qXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gYWRkR2V0dGVyU2V0dGVyIChwcm9wLCB2YWx1ZSwgcHJvdG8pIHtcblx0XG5cdC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gcmUtZXhlY3V0ZSB0aGlzIG92ZXIgYW5kIG92ZXIgYW5kIG92ZXIuLi5cblx0dmFyIGNhcCA9IHV0aWxzLmNhcChwcm9wKSxcblx0XHRnZXROYW1lID0gJ2dldCcgKyBjYXAsXG5cdFx0c2V0TmFtZSA9ICdzZXQnICsgY2FwLFxuXHRcdGdldHRlcnMgPSBwcm90by5fZ2V0dGVycyB8fCAocHJvdG8uX2dldHRlcnMgPSB7fSksXG5cdFx0c2V0dGVycyA9IHByb3RvLl9zZXR0ZXJzIHx8IChwcm90by5fc2V0dGVycyA9IHt9KSxcblx0XHRmbjtcblx0XG5cdC8vIHdlIGFzc2lnbiB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBwdWJsaXNoZWQgYmxvY2sgdG8gdGhlIHByb3RvdHlwZVxuXHQvLyBzbyBpdCB3aWxsIGJlIGluaXRpYWxpemVkIHByb3Blcmx5XG5cdHByb3RvW3Byb3BdID0gdmFsdWU7XG5cdFxuXHQvLyBjaGVjayBmb3IgYSBzdXBwbGllZCBnZXR0ZXIgYW5kIGlmIHRoZXJlIGlzbid0IG9uZSB3ZSBjcmVhdGUgb25lIG90aGVyd2lzZVxuXHQvLyB3ZSBtYXJrIHRoZSBzdXBwbGllZCBnZXR0ZXIgaW4gdGhlIHRyYWNraW5nIG9iamVjdCBzbyB0aGUgZ2xvYmFsIGdldFBhdGggd2lsbFxuXHQvLyBrbm93IGFib3V0IGl0XG5cdGlmICghKGZuID0gcHJvdG9bZ2V0TmFtZV0pIHx8IHR5cGVvZiBmbiAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0Zm4gPSBwcm90b1tnZXROYW1lXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB1dGlscy5nZXRQYXRoLmZhc3QuY2FsbCh0aGlzLCBwcm9wKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGFuZCB3ZSBtYXJrIGl0IGFzIGdlbmVyYXRlZFxuXHRcdGZuLmdlbmVyYXRlZCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoZm4gJiYgdHlwZW9mIGZuID09ICdmdW5jdGlvbicgJiYgIWZuLmdlbmVyYXRlZCkgZ2V0dGVyc1twcm9wXSA9IGdldE5hbWU7XG5cdFxuXHQvLyB3ZSBuZWVkIHRvIGRvIHRoZSBzYW1lIHRoaW5nIGZvciB0aGUgc2V0dGVyc1xuXHRpZiAoIShmbiA9IHByb3RvW3NldE5hbWVdKSB8fCB0eXBlb2YgZm4gIT0gJ2Z1bmN0aW9uJykge1xuXHRcdGZuID0gcHJvdG9bc2V0TmFtZV0gPSBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHMuc2V0UGF0aC5mYXN0LmNhbGwodGhpcywgcHJvcCwgdmFsKTtcblx0XHR9O1xuXHRcdFxuXHRcdC8vIGFuZCB3ZSBtYXJrIGl0IGFzIGdlbmVyYXRlZFxuXHRcdGZuLmdlbmVyYXRlZCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoZm4gJiYgdHlwZW9mIGZuID09ICdmdW5jdGlvbicgJiYgIWZuLmdlbmVyYXRlZCkgc2V0dGVyc1twcm9wXSA9IHNldE5hbWU7XG59XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9CaW5kaW5nU3VwcG9ydFwiOjksXCIuL01peGluU3VwcG9ydFwiOjI5LFwiLi9PYnNlcnZlclN1cHBvcnRcIjozNCxcIi4va2luZFwiOjY2LFwiLi9sb2dnZXJcIjo2NyxcIi4vdXRpbHNcIjo3NX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdENvcmVPYmplY3QgPSByZXF1aXJlKCcuL0NvcmVPYmplY3QnKTtcblxuLyoqXG4qIEFuIGFic3RyYWN0IFtraW5kXXtAZ2xvc3Nhcnkga2luZH0gZGVzaWduZWQgdG8gYWlkIGluIGhhbmRsaW5nIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLlxuKiBJdCByZXByZXNlbnRzIGEgdGFzayB0aGF0IGhhcyBub3QgeWV0IGNvbXBsZXRlZC4gQ2FsbGJhY2sgZnVuY3Rpb25zIG1heSBiZSByZWdpc3RlcmVkIHRvIGJlXG4qIG5vdGlmaWVkIHdoZW4gdGhlIHRhc2sgaXMgY29tcGxldGUuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb24gW0NvbnN1bWluZyBXZWJcbiogU2VydmljZXNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL21hbmFnaW5nLWRhdGEvY29uc3VtaW5nLXdlYi1zZXJ2aWNlcy5odG1sfVxuKiBpbiB0aGUgRW55byBEZXZlbG9wZXIgR3VpZGUuXG4qXG4qIEBjbGFzcyBlbnlvLkFzeW5jXG4qIEBleHRlbmRzIGVueW8uT2JqZWN0XG4qIEBwdWJsaWNcbiovXG52YXIgQXN5bmMgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Bc3luYy5wcm90b3R5cGUgKi8ge1xuXHRcblx0bmFtZTogJ2VueW8uQXN5bmMnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29yZU9iamVjdCxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBbZXhlY3V0aW9uXXtAbGluayBlbnlvLkFzeW5jI2dvfSBiZWdpbnNcblx0XHQqIGJlZm9yZSBmYWlsaW5nIHdpdGggYSB0aW1lb3V0IGVycm9yLiBJZiBzZXQgdG8gYDBgICh0aGUgZGVmYXVsdCksIHdpbGwgbm90XG5cdFx0KiBhdXRvbWF0aWNhbGx5IHRocm93IGEgdGltZW91dCBlcnJvci5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQG1lbWJlcm9mIGVueW8uQXlzbmMucHJvdG90eXBlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR0aW1lb3V0OiAwXG5cdH0sXG5cdFxuXHQvKipcblx0KiBXaWxsIGJlIGB0cnVlYCBpZiBhbiBlcnJvciBoYXMgb2NjdXJyZWQgYW5kIGEgaGFuZGxlciBjYWxscyB0aGVcblx0KiBbZmFpbCgpXXtAbGluayBlbnlvLkFzeW5jI2ZhaWx9IG1ldGhvZC4gQ2FuIGJlIGNsZWFyZWQgdXNpbmdcblx0KiBbcmVjb3ZlcigpXXtAbGluayBlbnlvLkFzeW5jI3JlY292ZXJ9LlxuXHQqXG5cdCogQHJlYWRvbmx5XG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHVibGljXG5cdCovXG5cdGZhaWxlZDogZmFsc2UsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb250ZXh0OiBudWxsLFxuXHRcblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnN0cnVjdG9yOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMucmVzcG9uZGVycyA9IFtdO1xuXHRcdFx0dGhpcy5lcnJvckhhbmRsZXJzID0gW107XG5cdFx0XHR0aGlzLnByb2dyZXNzSGFuZGxlcnMgPSBbXTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy50aW1lb3V0Sm9iKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFjY3VtdWxhdGU6IGZ1bmN0aW9uIChhcnJheSwgZm4sIGN0eCkge1xuXHRcdHZhciB0bXA7XG5cdFx0XG5cdFx0Ly8gdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3ZSBoYXZlIHRvIGFjY2VwdCB0aGF0IHRoZSBvcmRlciBvZiB0aGUgYXJndW1lbnRzXG5cdFx0Ly8gbWlnaHQgYmUgZGlmZmVyZW50XG5cdFx0aWYgKGN0eCAmJiB0eXBlb2YgY3R4ID09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRtcCA9IGZuO1xuXHRcdFx0Zm4gPSBjdHg7XG5cdFx0XHRjdHggPSB0bXA7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHdlIGdvIGFoZWFkIGFuZCBiaW5kIHRoZSBtZXRob2QgdG8gaXRzIGNvbnRleHQgdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsXG5cdFx0Ly8gaW1wbGVtZW50YXRpb25cblx0XHRpZiAoY3R4KSB7XG5cdFx0XHRpZiAodHlwZW9mIGN0eCA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZuID0gdXRpbHMuYmluZChmbiwgY3R4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZuID0gZm4uYmluZChjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBub3cgc3RvcmUgaXQgZm9yIHVzZSBsYXRlclxuXHRcdGFycmF5LnB1c2goZm4pO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVnaXN0ZXJzIGEgW2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IHRvIGJlIGZpcmVkIHdoZW5cblx0KiBbZXhlY3V0aW9uXXtAbGluayBlbnlvLkFzeW5jI2dvfSBpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBQYXJhbWV0ZXJzIG1heSBiZVxuXHQqIGluIGFueSBvcmRlciwgdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cblx0KlxuXHQqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGNhbGxiYWNrIHRvIHJlZ2lzdGVyLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbY3R4XSAtIFRoZSBvcHRpb25hbCBjb250ZXh0IHVuZGVyIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlc3BvbnNlOiBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHRcdHRoaXMuYWNjdW11bGF0ZSh0aGlzLnJlc3BvbmRlcnMsIGZuLCBjdHgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVnaXN0ZXJzIGEgW2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IHRvIGJlIGZpcmVkIHdoZW5cblx0KiBbZXhlY3V0aW9uXXtAbGluayBlbnlvLkFzeW5jI2dvfSBjb21wbGV0ZXMgd2l0aCBhbiBlcnJvci4gUGFyYW1ldGVycyBtYXkgYmVcblx0KiBpbiBhbnkgb3JkZXIsIHRvIHByZXNlcnZlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG5cdCpcblx0KiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBjYWxsYmFjayB0byByZWdpc3Rlci5cblx0KiBAcGFyYW0ge09iamVjdH0gW2N0eF0gLSBUaGUgb3B0aW9uYWwgY29udGV4dCB1bmRlciB3aGljaCB0byBleGVjdXRlIHRoZSBjYWxsYmFjay5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRlcnJvcjogZnVuY3Rpb24gKGZuLCBjdHgpIHtcblx0XHR0aGlzLmFjY3VtdWxhdGUodGhpcy5lcnJvckhhbmRsZXJzLCBmbiwgY3R4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIFJlZ2lzdGVycyBhIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSB0byBiZSBmaXJlZCBvbiBwcm9ncmVzcyBldmVudHMuXG5cdCogUGFyYW1ldGVycyBtYXkgYmUgaW4gYW55IG9yZGVyLCB0byBwcmVzZXJ2ZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuXHQqXG5cdCogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgY2FsbGJhY2sgdG8gcmVnaXN0ZXIuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtjdHhdIC0gVGhlIG9wdGlvbmFsIGNvbnRleHQgdW5kZXIgd2hpY2ggdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cHJvZ3Jlc3M6IGZ1bmN0aW9uIChmbiwgY3R4KSB7XG5cdFx0dGhpcy5hY2N1bXVsYXRlKHRoaXMucHJvZ3Jlc3NIYW5kbGVycywgZm4sIGN0eCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyb3V0ZTogZnVuY3Rpb24gKGFzeW5jLCB2YWx1ZSkge1xuXHRcdHZhciByID0gdGhpcy5iaW5kU2FmZWx5KCdyZXNwb25kJyk7XG5cdFx0YXN5bmMucmVzcG9uc2UoZnVuY3Rpb24gKHNlbmRlciwgdmFsdWUpIHtcblx0XHRcdHIodmFsdWUpO1xuXHRcdH0pO1xuXHRcdHZhciBmID0gdGhpcy5iaW5kU2FmZWx5KCdmYWlsJyk7XG5cdFx0YXN5bmMuZXJyb3IoZnVuY3Rpb24gKHNlbmRlciwgdmFsdWUpIHtcblx0XHRcdGYodmFsdWUpO1xuXHRcdH0pO1xuXHRcdGFzeW5jLmdvKHZhbHVlKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZTogZnVuY3Rpb24gKHZhbHVlLCBoYW5kbGVycykge1xuXHRcdHZhciByID0gaGFuZGxlcnMuc2hpZnQoKTtcblx0XHRpZiAocikge1xuXHRcdFx0aWYgKHIgaW5zdGFuY2VvZiBBc3luYykge1xuXHRcdFx0XHR0aGlzLnJvdXRlKHIsIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGhhbmRsZXIgY2FuIHJldHVybiBhIG5ldyAndmFsdWUnXG5cdFx0XHRcdHZhciB2ID0gdXRpbHMuY2FsbCh0aGlzLmNvbnRleHQgfHwgdGhpcywgciwgW3RoaXMsIHZhbHVlXSk7XG5cdFx0XHRcdC8vIC4uLiBidXQgb25seSBpZiBpdCByZXR1cm5zIHNvbWV0aGluZyBvdGhlciB0aGFuIHVuZGVmaW5lZFxuXHRcdFx0XHR2ID0gKHYgIT09IHVuZGVmaW5lZCkgPyB2IDogdmFsdWU7XG5cdFx0XHRcdC8vIG5leHQgaGFuZGxlclxuXHRcdFx0XHQodGhpcy5mYWlsZWQgPyB0aGlzLmZhaWwgOiB0aGlzLnJlc3BvbmQpLmNhbGwodGhpcywgdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhcnRUaW1lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gdXRpbHMucGVyZk5vdygpO1xuXHRcdGlmICh0aGlzLnRpbWVvdXQpIHtcblx0XHRcdHRoaXMudGltZW91dEpvYiA9IHNldFRpbWVvdXQodGhpcy5iaW5kU2FmZWx5KCd0aW1lb3V0Q29tcGxldGUnKSwgdGhpcy50aW1lb3V0KTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlbmRUaW1lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnRpbWVvdXRKb2IpIHtcblx0XHRcdHRoaXMuZW5kVGltZSA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRKb2IpO1xuXHRcdFx0dGhpcy50aW1lb3V0Sm9iID0gbnVsbDtcblx0XHRcdHRoaXMubGF0ZW5jeSA9IHRoaXMuZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRpbWVvdXRDb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMudGltZWRvdXQgPSB0cnVlO1xuXHRcdHRoaXMuZmFpbCgndGltZW91dCcpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogVHJpZ2dlcnMgdGhlIGhhbmRsZXIgY2hhaW4gZm9yIHZhbGlkIG91dGNvbWVzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVzcG9uZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5mYWlsZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuZFRpbWVyKCk7XG5cdFx0dGhpcy5oYW5kbGUodmFsdWUsIHRoaXMucmVzcG9uZGVycyk7XG5cdH0sXG5cblx0LyoqXG5cdCogRmFpbHMgdGhlIFt0YXNrXXtAbGluayBlbnlvLkFzeW5jfSBhbmQgdHJpZ2dlcnMgdGhlIGVycm9yIGNoYWluLiBNYXkgYmUgY2FsbGVkIGZyb20gYW55XG5cdCogaGFuZGxlci5cblx0KiBcblx0KiBAcGFyYW0geyp9IGVyciAtIFRoZSBlcnJvciB2YWx1ZSB0byBwYXNzIHRvIGVycm9yIGhhbmRsZXJzLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGZhaWw6IGZ1bmN0aW9uIChlcnIpIHtcblx0XHR0aGlzLmZhaWxlZCA9IHRydWU7XG5cdFx0dGhpcy5lbmRUaW1lcigpO1xuXHRcdHRoaXMuaGFuZGxlKGVyciwgdGhpcy5lcnJvckhhbmRsZXJzKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdC8qKlxuXHQqIENsZWFycyB0aGUgZXJyb3IgY29uZGl0aW9uIChbZmFpbGVkXXtAbGluayBlbnlvLkFzeW5jI2ZhaWxlZH0pIGJ5IHNldHRpbmcgaXQgdG8gYGZhbHNlYC5cblx0KiBJZiBjYWxsZWQgd2hpbGUgcmVzcG9uZGluZyB0byBoYW5kbGVycywgaXQgd2lsbCBjb250aW51ZS5cblx0KlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlY292ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmZhaWxlZCA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2VuZFByb2dyZXNzOiBmdW5jdGlvbihjdXJyZW50LCBtaW4sIG1heCwgc291cmNlRXZlbnQpIHtcblx0XHR2YXIgZXZlbnQgPSB1dGlscy5taXhpbih7fSwgc291cmNlRXZlbnQpO1xuXHRcdGV2ZW50LnR5cGUgPSAncHJvZ3Jlc3MnO1xuXHRcdGV2ZW50LmN1cnJlbnQgPSBjdXJyZW50O1xuXHRcdGV2ZW50Lm1pbiA9IG1pbjtcblx0XHRldmVudC5tYXggPSBtYXg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb2dyZXNzSGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHV0aWxzLmNhbGwodGhpcy5jb250ZXh0IHx8IHRoaXMsIHRoaXMucHJvZ3Jlc3NIYW5kbGVyc1tpXSwgW3RoaXMsIGV2ZW50XSk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogSW5pdGlhdGVzIHRoZSBhc3luY2hyb25vdXMgcm91dGluZSwgc3VwcGx5aW5nIHRoZSBnaXZlbiB2YWx1ZSBpZiBpdCBjb21wbGV0ZXNcblx0KiBzdWNjZXNzZnVsbHkuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgb3ZlcmxvYWRlZCBpbiBbc3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfS5cblx0KlxuXHQqIEB2aXJ0dWFsXG5cdCogQHBhcmFtIHsqfSAtIHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIHJlc3BvbmRlcnMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z286IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5zZW5kUHJvZ3Jlc3MoMCwgMCwgMSk7XG5cdFx0dXRpbHMuYXN5bmNNZXRob2QodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNlbmRQcm9ncmVzcygxLCAwLCAxKTtcblx0XHRcdHRoaXMucmVzcG9uZCh2YWx1ZSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29yZU9iamVjdFwiOjE3LFwiLi9raW5kXCI6NjYsXCIuL3V0aWxzXCI6NzV9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXJcblx0TW9kZWxMaXN0ID0gcmVxdWlyZSgnLi9Nb2RlbExpc3QnKSxcblx0RXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXInKTtcblx0Q29yZU9iamVjdCA9IHJlcXVpcmUoJy4vQ29yZU9iamVjdCcpO1xuXG4vKipcbiogT25seSBuZWNlc3NhcnkgYmVjYXVzZSBvZiB0aGUgb3JkZXIgaW4gd2hpY2ggbWl4aW5zIGFyZSBhcHBsaWVkLlxuKlxuKiBAY2xhc3NcbiogQHByaXZhdGVcbiovXG52YXIgQmFzZVN0b3JlID0ga2luZCh7XG5cdGtpbmQ6IENvcmVPYmplY3QsXG5cdG1peGluczogW0V2ZW50RW1pdHRlcl1cbn0pO1xuXG4vKipcbiogVGhpcyBtZXRob2Qgc2hvdWxkIGRldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9XG4qIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlsdGVyZWQgc2V0IGZvciB0aGUgW2ZpbmQoKV17QGxpbmsgZW55by5TdG9yZSNmaW5kfVxuKiBtZXRob2QuXG4qIFxuKiBAY2FsbGJhY2sgZW55by5TdG9yZX5GaWx0ZXJcbiogQHBhcmFtIHtlbnlvLk1vZGVsfSBtb2RlbCAtIFRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IHRvIGZpbHRlci5cbiogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgbW9kZWwgbWVldHMgdGhlIGZpbHRlciByZXF1aXJlbWVudHM7XG4qIG90aGVyd2lzZSwgYGZhbHNlYC5cbiovXG5cbi8qKlxuKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgW2ZpbmQoKV17QGxpbmsgZW55by5TdG9yZSNmaW5kfSBtZXRob2QuXG4qIFxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLlN0b3JlfkZpbmRPcHRpb25zXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYWxsPXRydWUgLSBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIG1vcmUgdGhhbiBvbmUgbWF0Y2ggZm9yIHRoZVxuKlx0ZmlsdGVyIG1ldGhvZC4gSWYgYHRydWVgLCBhbiBhcnJheSBvZiBtYXRjaGVzIGlzIHJldHVybmVkOyBvdGhlcndpc2UsIGEgc2luZ2xlIG1hdGNoLlxuKiBAcHJvcGVydHkge09iamVjdH0gY29udGV4dCAtIElmIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGB0aGlzYCAoY29udGV4dCkgb2ZcbipcdHRoZSBmaWx0ZXIgbWV0aG9kLlxuKi9cblxuLyoqXG4qIEFuIGFub255bW91cyBraW5kIHVzZWQgaW50ZXJuYWxseSBmb3IgdGhlIHNpbmdsZXRvbiB7QGxpbmsgZW55by5zdG9yZX0uXG4qIFxuKiBAY2xhc3MgZW55by5TdG9yZVxuKiBAbWl4ZXMgZW55by5FdmVudEVtaXR0ZXJcbiogQGV4dGVuZHMgZW55by5PYmplY3RcbiogQHByb3RlY3RlZFxuKi9cbnZhciBTdG9yZSA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5TdG9yZS5wcm90b3R5cGUgKi8ge1xuXHRcblx0bmFtZTogJ2VueW8uU3RvcmUnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQmFzZVN0b3JlLFxuXHRcblx0LyoqXG5cdCogRmluZHMgYSBbbW9kZWwgKG9yIG1vZGVscylde0BsaW5rIGVueW8uTW9kZWx9IG9mIGEgY2VydGFpbiBba2luZF17QGdsb3NzYXJ5IGtpbmR9LlxuXHQqIEl0IHVzZXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIGEgZmlsdGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBhcnRpY3VsYXJcblx0KiBtb2RlbCB3aWxsIGJlIGluY2x1ZGVkLiBTZXQgdGhlIG9wdGlvbmFsIGBhbGxgIGZsYWcgdG8gYHRydWVgIHRvIGVuc3VyZSB0aGF0XG5cdCogdGhlIG1ldGhvZCBsb29rcyBmb3IgYWxsIG1hdGNoZXM7IG90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBvc2l0aXZlXG5cdCogbWF0Y2guXG5cdCogXG5cdCogQHNlZSB7QGdsb3NzYXJ5IEFycmF5LmZpbmR9XG5cdCogQHBhcmFtIHtlbnlvLk1vZGVsfSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBvZlxuXHQqXHRbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IHRvIGJlIGZpbHRlcmVkLlxuXHQqIEBwYXJhbSB7ZW55by5TdG9yZX5GaWx0ZXJ9IGZuIC0gVGhlIGZpbHRlciBtZXRob2QuXG5cdCogQHBhcmFtIHtlbnlvLlN0b3JlfkZpbmRPcHRpb25zfSBbb3B0c10gLSBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIuXG5cdCogQHJldHVybnMgeyhlbnlvLk1vZGVsfGVueW8uTW9kZWxbXXx1bmRlZmluZWQpfSBJZiB0aGUgYGFsbGAgZmxhZyBpcyBgdHJ1ZWAsXG5cdCpcdHJldHVybnMgYW4gYXJyYXkgb2YgbW9kZWxzOyBvdGhlcndpc2UsIHJldHVybnMgdGhlIGZpcnN0IG1vZGVsIHRoYXQgcmV0dXJuZWRcblx0Klx0dGhhdCByZXR1cm5lZCBgdHJ1ZWAgZnJvbSB0aGUgZmlsdGVyIG1ldGhvZC4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBgYWxsYCBpc1xuXHQqIGBmYWxzZWAgYW5kIG5vIG1hdGNoIGNvdWxkIGJlIGZvdW5kLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmluZDogZnVuY3Rpb24gKGN0b3IsIGZuLCBvcHRzKSB7XG5cdFx0dmFyIGtpbmROYW1lID0gY3Rvci5wcm90b3R5cGUua2luZE5hbWUsXG5cdFx0XHRsaXN0ID0gdGhpcy5tb2RlbHNba2luZE5hbWVdLFxuXHRcdFx0b3B0aW9ucyA9IHthbGw6IHRydWUsIGNvbnRleHQ6IHRoaXN9O1xuXHRcdFxuXHRcdC8vIGFsbG93cyB0aGUgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aXRoIGEgY29uc3RydWN0b3Igb25seSBhbmQgd2lsbCByZXR1cm4gYW5cblx0XHQvLyBpbW11dGFibGUgY29weSBvZiB0aGUgYXJyYXkgb2YgYWxsIG1vZGVscyBvZiB0aGF0IHR5cGUgb3IgYW4gZW1wdHkgYXJyYXlcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxIHx8IHR5cGVvZiBmbiAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbGlzdCA/IGxpc3Quc2xpY2UoKSA6IFtdO1xuXHRcdH1cblx0XHRcblx0XHQvLyBlbnN1cmUgd2UgdXNlIGRlZmF1bHRzIHdpdGggYW55IHByb3ZpZGVkIG9wdGlvbnNcblx0XHRvcHRzID0gb3B0cyA/IHV0aWxzLm1peGluKHt9LCBbb3B0aW9ucywgb3B0c10pIDogb3B0aW9ucztcblx0XHRcdFxuXHRcdGlmIChsaXN0KSByZXR1cm4gb3B0cy5hbGwgPyBsaXN0LmZpbHRlcihmbiwgb3B0cy5jb250ZXh0KSA6IGxpc3QuZmluZChmbiwgb3B0cy5jb250ZXh0KTtcblx0XHRcblx0XHQvLyBpZiBpdCBoYXBwZW5zIGl0IGNvdWxkIG5vdCBmaW5kIGEgbGlzdCBmb3IgdGhlIHJlcXVlc3RlZCBraW5kIHdlIGZ1ZGdlIHRoZSByZXR1cm5cblx0XHQvLyBzbyBpdCBjYW4ga2VlcCBvbiBleGVjdXRpbmdcblx0XHRlbHNlIHJldHVybiBvcHRzLmFsbCA/IFtdIDogdW5kZWZpbmVkO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogVGhpcyBtZXRob2QgaXMgYW4gYWxpYXMgZm9yIFtmaW5kKClde0BsaW5rIGVueW8uU3RvcmUjZmluZH0uXG5cdCpcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmluZExvY2FsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YWRkOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRzKSB7XG5cdFx0dmFyIGN0b3IgPSBtb2RlbHMgJiYgKG1vZGVscyBpbnN0YW5jZW9mIEFycmF5ID8gbW9kZWxzWzBdLmN0b3IgOiBtb2RlbHMuY3RvciksXG5cdFx0XHRraW5kTmFtZSA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGUua2luZE5hbWUsXG5cdFx0XHRsaXN0ID0ga2luZE5hbWUgJiYgdGhpcy5tb2RlbHNba2luZE5hbWVdLFxuXHRcdFx0YWRkZWQsXG5cdFx0XHRpO1xuXHRcdFx0XG5cdFx0Ly8gaWYgd2Ugd2VyZSBhYmxlIHRvIGZpbmQgdGhlIGxpc3QgdGhlbiB3ZSBnbyBhaGVhZCBhbmQgYXR0ZW1wdCB0byBhZGQgdGhlIG1vZGVsc1xuXHRcdGlmIChsaXN0KSB7XG5cdFx0XHRhZGRlZCA9IGxpc3QuYWRkKG1vZGVscyk7XG5cdFx0XHQvLyBpZiB3ZSBzdWNjZXNzZnVsbHkgYWRkZWQgbW9kZWxzIGFuZCB0aGlzIHdhcyBhIGRlZmF1bHQgb3BlcmF0aW9uIChub3QgYmVpbmdcblx0XHRcdC8vIGJhdGNoZWQgYnkgYSBjb2xsZWN0aW9uIG9yIG90aGVyIGZlYXR1cmUpIHdlIGVtaXQgdGhlIGV2ZW50IG5lZWRlZCBwcmltYXJpbHlcblx0XHRcdC8vIGJ5IHJlbGF0aW9uYWwgbW9kZWxzIGJ1dCBjb3VsZCBiZSB1c2VmdWwgb3RoZXIgcGxhY2VzXG5cdFx0XHRpZiAoYWRkZWQubGVuZ3RoICYmICghb3B0cyB8fCAhb3B0cy5zaWxlbnQpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHRoaXMuZW1pdChjdG9yLCAnYWRkJywge21vZGVsOiBhZGRlZFtpXX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVtb3ZlOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRzKSB7XG5cdFx0dmFyIGN0b3IgPSBtb2RlbHMgJiYgKG1vZGVscyBpbnN0YW5jZW9mIEFycmF5ID8gbW9kZWxzWzBdLmN0b3IgOiBtb2RlbHMuY3RvciksXG5cdFx0XHRraW5kTmFtZSA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGUua2luZE5hbWUsXG5cdFx0XHRsaXN0ID0ga2luZE5hbWUgJiYgdGhpcy5tb2RlbHNba2luZE5hbWVdLFxuXHRcdFx0cmVtb3ZlZCxcblx0XHRcdGk7XG5cdFx0XG5cdFx0Ly8gaWYgd2Ugd2VyZSBhYmxlIHRvIGZpbmQgdGhlIGxpc3QgdGhlbiB3ZSBnbyBhaGVhZCBhbmQgYXR0ZW1wdCB0byByZW1vdmUgdGhlIG1vZGVsc1xuXHRcdGlmIChsaXN0KSB7XG5cdFx0XHRyZW1vdmVkID0gbGlzdC5yZW1vdmUobW9kZWxzKTtcblx0XHRcdC8vIGlmIHdlIHN1Y2Nlc3NmdWxseSByZW1vdmVkIG1vZGVscyBhbmQgdGhpcyB3YXMgYSBkZWZhdWx0IG9wZXJhdGlvbiAobm90IGJlaW5nXG5cdFx0XHQvLyBiYXRjaGVkIGJ5IGEgY29sbGVjdGlvbiBvciBvdGhlciBmZWF0dXJlKSB3ZSBlbWl0IHRoZSBldmVudC4gTmVlZGVkIHByaW1hcmlseVxuXHRcdFx0Ly8gYnkgcmVsYXRpb25hbCBtb2RlbHMgYnV0IGNvdWxkIGJlIHVzZWZ1bCBvdGhlciBwbGFjZXNcblx0XHRcdGlmIChyZW1vdmVkLmxlbmd0aCAmJiAoIW9wdHMgfHwgIW9wdHMuc2lsZW50KSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHRoaXMuZW1pdChjdG9yLCAncmVtb3ZlJywge21vZGVsOiByZW1vdmVkW2ldfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBEZXRlcm1pbmVzLCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLCB3aGV0aGVyIHRoZSBbc3RvcmVde0BsaW5rIGVueW8uc3RvcmV9XG5cdCogaGFzIGEgc3BlY2lmaWMgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfS5cblx0KlxuXHQqIEBwYXJhbSB7KEZ1bmN0aW9ufGVueW8uTW9kZWwpfSBjdG9yIENhbiBiZSB0aGUgY29uc3RydWN0b3IgZm9yIGFuIHtAbGluayBlbnlvLk1vZGVsfVxuXHQqXHRvciBhIG1vZGVsIGluc3RhbmNlLiBNdXN0IGJlIGEgY29uc3RydWN0b3IgdW5sZXNzIGEgbW9kZWwgaW5zdGFuY2UgaXMgcGFzc2VkIGFzIHRoZVxuXHQqIG9wdGlvbmFsIGBtb2RlbGAgcGFyYW1ldGVyLlxuXHQqIEBwYXJhbSB7KFN0cmluZ3xOdW1iZXJ8ZW55by5Nb2RlbCl9IFttb2RlbF0gSWYgdGhlIGBjdG9yYCBwYXJhbWV0ZXIgaXMgYVxuXHQqXHRjb25zdHJ1Y3RvciwgdGhpcyBtYXkgYmUgYSBbTnVtYmVyXXtAZ2xvc3NhcnkgTnVtYmVyfSBvciBhIFtTdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9XG5cdCogcmVwcmVzZW50aW5nIGEgW3ByaW1hcnlLZXlde0BsaW5rIGVueW8uTW9kZWwjcHJpbWFyeUtleX0gZm9yIHRoZSBnaXZlbiBtb2RlbCwgb3IgYW5cblx0Klx0aW5zdGFuY2Ugb2YgYSBtb2RlbC5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIFtzdG9yZV17QGxpbmsgZW55by5zdG9yZX0gaGFzIHRoZSBnaXZlblxuXHQqXHRbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGFzOiBmdW5jdGlvbiAoY3RvciwgbW9kZWwpIHtcblx0XHR2YXIgbGlzdDtcblx0XHRcblx0XHRpZiAoIW1vZGVsKSB7XG5cdFx0XHRtb2RlbCA9IGN0b3I7XG5cdFx0XHRjdG9yID0gbW9kZWwuY3Rvcjtcblx0XHR9XG5cdFx0XG5cdFx0bGlzdCA9IHRoaXMubW9kZWxzW2N0b3IucHJvdG90eXBlLmtpbmROYW1lXTtcblx0XHRyZXR1cm4gbGlzdCA/IGxpc3QuaGFzKG1vZGVsKSA6IGZhbHNlO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVzb2x2ZTogZnVuY3Rpb24gKGN0b3IsIG1vZGVsKSB7XG5cdFx0dmFyIGxpc3QgPSB0aGlzLm1vZGVsc1tjdG9yICYmIGN0b3IucHJvdG90eXBlLmtpbmROYW1lXTtcblx0XHRyZXR1cm4gbGlzdD8gbGlzdC5yZXNvbHZlKG1vZGVsKTogdW5kZWZpbmVkO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9zY29wZUxpc3RlbmVycyA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBhbGwgZnV0dXJlIHN1Yi1raW5kcyBvZiBlbnlvLk1vZGVsIHRoYXQgYXJlIHByb2Nlc3NlZCB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGNyZWF0ZS9hZGQgdGhlaXIgZW50cmllcyB0byB0aGlzIG9iamVjdCBpbiB0aGVpciBjb25jYXQgbWV0aG9kXG5cdFx0XHR0aGlzLm1vZGVscyA9IHtcblx0XHRcdFx0J2VueW8uTW9kZWwnOiBuZXcgTW9kZWxMaXN0KClcblx0XHRcdH07XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY29wZUxpc3RlbmVyczogZnVuY3Rpb24gKHNjb3BlLCBlKSB7XG5cdFx0cmV0dXJuICFzY29wZSA/IHRoaXMuX3Njb3BlTGlzdGVuZXJzIDogdGhpcy5fc2NvcGVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsbikge1xuXHRcdFx0cmV0dXJuIGxuLnNjb3BlID09PSBzY29wZSA/ICFlID8gdHJ1ZSA6IGxuLmV2ZW50ID09IGUgOiBmYWxzZTtcblx0XHR9KTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG9uOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY3RvciwgZSwgZm4sIGN0eCkge1xuXHRcdFx0aWYgKHR5cGVvZiBjdG9yID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5zY29wZUxpc3RlbmVycygpLnB1c2goe1xuXHRcdFx0XHRcdHNjb3BlOiBjdG9yLFxuXHRcdFx0XHRcdGV2ZW50OiBlLFxuXHRcdFx0XHRcdG1ldGhvZDogZm4sXG5cdFx0XHRcdFx0Y3R4OiBjdHggfHwgdGhpc1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRvZmY6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjdG9yLCBlLCBmbikge1xuXHRcdFx0dmFyIGxpc3RlbmVycyxcblx0XHRcdFx0aWR4O1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIGN0b3IgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLnNjb3BlTGlzdGVuZXJzKGN0b3IpO1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGlkeCA9IGxpc3RlbmVycy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbG4uZXZlbnQgPT0gZSAmJiBsbi5tZXRob2QgPT09IGZuO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGlmIGl0IGZvdW5kIHRoZSBlbnRyeSB3ZSByZW1vdmUgaXRcblx0XHRcdFx0XHRpZiAoaWR4ID49IDApIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGVtaXQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjdG9yLCBlKSB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzLFxuXHRcdFx0XHRhcmdzO1xuXHRcdFx0XG5cdFx0XHRpZiAodHlwZW9mIGN0b3IgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLnNjb3BlTGlzdGVuZXJzKGN0b3IsIGUpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGgpIHtcblx0XHRcdFx0XHRhcmdzID0gdXRpbHMudG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpO1xuXHRcdFx0XHRcdGFyZ3MudW5zaGlmdCh0aGlzKTtcblx0XHRcdFx0XHRsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobG4pIHtcblx0XHRcdFx0XHRcdGxuLm1ldGhvZC5hcHBseShsbi5jdHgsIGFyZ3MpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pXG59KTtcblxuLyoqXG4qIEEgcnVudGltZSBkYXRhYmFzZSBmb3Igd29ya2luZyB3aXRoIFttb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9LiBJdCBpcyBwcmltYXJpbHkgdXNlZFxuKiBpbnRlcm5hbGx5IGJ5IGRhdGEgbGF5ZXIgW2tpbmRzXXtAZ2xvc3Nhcnkga2luZH0gKHtAbGluayBlbnlvLk1vZGVsfSxcbioge0BsaW5rIGVueW8uQ29sbGVjdGlvbn0sIGFuZCB7QGxpbmsgZW55by5SZWxhdGlvbmFsTW9kZWx9KS5cbiogXG4qIEBzZWUgZW55by5Nb2RlbFxuKiBAc2VlIGVueW8uQ29sbGVjdGlvblxuKiBAc2VlIGVueW8uUmVsYXRpb25hbE1vZGVsXG4qIEB0eXBlIGVueW8uU3RvcmVcbiogQG1lbWJlcm9mIGVueW9cbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0gbmV3IFN0b3JlKCk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db3JlT2JqZWN0XCI6MTcsXCIuL0V2ZW50RW1pdHRlclwiOjE5LFwiLi9Nb2RlbExpc3RcIjozMSxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKTtcblx0XG52YXIgQ29yZU9iamVjdCA9IHJlcXVpcmUoJy4vQ29yZU9iamVjdCcpO1xuXG4vKipcbiogVGhlIHtAbGluayBlbnlvLmpvYnN9IHNpbmdsZXRvbiBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgcXVldWVpbmcgdGFza3NcbiogKGkuZS4sIGZ1bmN0aW9ucykgZm9yIGV4ZWN1dGlvbiBpbiBvcmRlciBvZiBwcmlvcml0eS4gVGhlIGV4ZWN1dGlvbiBvZiB0aGVcbiogY3VycmVudCBqb2Igc3RhY2sgbWF5IGJlIGJsb2NrZWQgcHJvZ3JhbW1hdGljYWxseSBieSBzZXR0aW5nIGEgcHJpb3JpdHlcbiogbGV2ZWwgKHJ1biBsZXZlbCkgYmVsb3cgd2hpY2ggbm8gam9icyBhcmUgZXhlY3V0ZWQuXG4qXG4qIEF0IHRoZSBtb21lbnQsIG9ubHkge0BsaW5rIGVueW8uQW5pbWF0b3J9IHVzZXMgdGhpcyBpbnRlcmZhY2UsIHNldHRpbmcgYVxuKiBwcmlvcml0eSBvZiA0LCB3aGljaCBibG9ja3MgYWxsIGxvdyBwcmlvcml0eSB0YXNrcyBmcm9tIGV4ZWN1dGluZyBkdXJpbmdcbiogYW5pbWF0aW9ucy4gVG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgam9icyBhcmUgYXNzaWduZWQgYSBwcmlvcml0eVxuKiBvZiA1IGJ5IGRlZmF1bHQ7IHRodXMgdGhleSBhcmUgbm90IGJsb2NrZWQgYnkgYW5pbWF0aW9ucy5cbipcbiogTm9ybWFsbHksIGFwcGxpY2F0aW9uIGNvZGUgd2lsbCBub3QgdXNlIGBlbnlvLmpvYnNgIGRpcmVjdGx5LCBidXQgd2lsbFxuKiBpbnN0ZWFkIHVzZSB0aGUgW2pvYigpXXtAbGluayBlbnlvLkNvbXBvbmVudCNqb2J9IG1ldGhvZCBvZlxuKiB7QGxpbmsgZW55by5Db21wb25lbnR9LlxuKlxuKiBAbmFtZSBlbnlvLmpvYnNcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZC5zaW5nbGV0b24oXG5cdC8qKiBAbGVuZHMgZW55by5qb2JzICovIHtcblx0XG5cdGtpbmQ6IENvcmVPYmplY3QsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IC8qKiBAbGVuZHMgZW55by5qb2JzICovIHtcblx0XHRcblx0XHQvKipcblx0XHQqIFRoZSBjdXJyZW50IHByaW9yaXR5IGxldmVsLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCAwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRwcmlvcml0eUxldmVsOiAwXG5cdH0sXG5cdFxuXHQvKipcblx0KiBQcmlvcml0aXplZCBieSBpbmRleC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9qb2JzOiBbIFtdLCBbXSwgW10sIFtdLCBbXSwgW10sIFtdLCBbXSwgW10sIFtdIF0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfcHJpb3JpdGllczoge30sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfbmFtZWRKb2JzOiB7fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9tYWdpY1dvcmRzOiB7XG5cdFx0J2xvdyc6IDMsXG5cdFx0J25vcm1hbCc6IDUsXG5cdFx0J2hpZ2gnOiA3XG5cdH0sXG5cdFxuXHQvKipcblx0KiBBZGRzIGEgW2pvYl17QGxpbmsgZW55by5qb2J9IHRvIHRoZSBqb2IgcXVldWUuIElmIHRoZSBjdXJyZW50IHByaW9yaXR5XG5cdCogbGV2ZWwgaXMgaGlnaGVyIHRoYW4gdGhpcyBqb2IncyBwcmlvcml0eSwgdGhpcyBqb2IgZ2V0cyBkZWZlcnJlZCB1bnRpbCB0aGVcblx0KiBqb2IgbGV2ZWwgZHJvcHM7IGlmIGl0IGlzIGxvd2VyLCB0aGlzIGpvYiBpcyBydW4gaW1tZWRpYXRlbHkuXG5cdCpcblx0KiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgLSBUaGUgYWN0dWFsIHtAZ2xvc3NhcnkgRnVuY3Rpb259IHRvIGV4ZWN1dGUgYXMgdGhlXG5cdCogW2pvYl17QGxpbmsgZW55by5qb2J9LlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSBvZiB0aGUgam9iLlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBub20gLSBUaGUgbmFtZSBvZiB0aGUgam9iIGZvciBsYXRlciByZWZlcmVuY2UuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhZGQ6IGZ1bmN0aW9uIChqb2IsIHByaW9yaXR5LCBub20pIHtcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDU7XG5cblx0XHQvLyBtYWdpYyB3b3JkczogbG93ID0gMywgbm9ybWFsID0gNSwgaGlnaCA9IDdcblx0XHRwcmlvcml0eSA9IHV0aWxzLmlzU3RyaW5nKHByaW9yaXR5KSA/IHRoaXMuX21hZ2ljV29yZHNbcHJpb3JpdHldIDogcHJpb3JpdHk7XG5cblx0XHQvLyBpZiBhIGpvYiBvZiB0aGUgc2FtZSBuYW1lIGV4aXN0cywgcmVtb3ZlIGl0IGZpcnN0IChyZXBsYWNlIGl0KVxuXHRcdGlmKG5vbSl7XG5cdFx0XHR0aGlzLnJlbW92ZShub20pO1xuXHRcdFx0dGhpcy5fbmFtZWRKb2JzW25vbV0gPSBwcmlvcml0eTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgam9iIGlzIG9mIGhpZ2hlciBwcmlvcml0eSB0aGFuIHRoZSBjdXJyZW50IHByaW9yaXR5IGxldmVsIHRoZW5cblx0XHQvLyB0aGVyZSdzIG5vIHBvaW50IGluIHF1ZXVlaW5nIGl0XG5cdFx0aWYocHJpb3JpdHkgPj0gdGhpcy5wcmlvcml0eUxldmVsKXtcblx0XHRcdGpvYigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9qb2JzW3ByaW9yaXR5IC0gMV0ucHVzaCh7Zmt0OiBqb2IsIG5hbWU6IG5vbX0pO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIFdpbGwgcmVtb3ZlIHRoZSBuYW1lZCBbam9iXXtAbGluayBlbnlvLmpvYn0gZnJvbSB0aGUgcXVldWUuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIFtqb2Jde0BsaW5rIGVueW8uam9ifSB0byByZW1vdmUuXG5cdCogQHJldHVybnMge0FycmF5fSBBbiB7QGdsb3NzYXJ5IEFycmF5fSB0aGF0IHdpbGwgY29udGFpbiB0aGUgcmVtb3ZlZCBqb2IgaWZcblx0KiBpdCB3YXMgZm91bmQsIG9yIGVtcHR5IGlmIGl0IHdhcyBub3QgZm91bmQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uIChub20pIHtcblx0XHR2YXIgam9icyA9IHRoaXMuX2pvYnNbdGhpcy5fbmFtZWRKb2JzW25vbV0gLSAxXTtcblx0XHRpZihqb2JzKXtcblx0XHRcdGZvcih2YXIgaiA9IGpvYnMubGVuZ3RoLTE7IGogPj0gMDsgai0tKXtcblx0XHRcdFx0aWYoam9ic1tqXS5uYW1lID09PSBub20pe1xuXHRcdFx0XHRcdHJldHVybiBqb2JzLnNwbGljZShqLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEFkZHMgYSBuZXcgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggam9icyB3aWxsIGJlIGV4ZWN1dGVkLiBJZiBpdCBpcyBoaWdoZXIgdGhhbiB0aGVcblx0KiBoaWdoZXN0IGN1cnJlbnQgcHJpb3JpdHksIHRoZSBwcmlvcml0eSBsZXZlbCByaXNlcy4gTmV3bHkgYWRkZWQgam9icyBiZWxvdyB0aGF0IHByaW9yaXR5XG5cdCogbGV2ZWwgYXJlIGRlZmVycmVkIHVudGlsIHRoZSBwcmlvcml0eSBpcyByZW1vdmVkIChpLmUuLCB1bnJlZ2lzdGVyZWQpLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHZhbHVlIHRvIHJlZ2lzdGVyLlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBwcmlvcml0eS5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlZ2lzdGVyUHJpb3JpdHk6IGZ1bmN0aW9uKHByaW9yaXR5LCBpZCkge1xuXHRcdHRoaXMuX3ByaW9yaXRpZXNbaWRdID0gcHJpb3JpdHk7XG5cdFx0dGhpcy5zZXRQcmlvcml0eUxldmVsKCBNYXRoLm1heChwcmlvcml0eSwgdGhpcy5wcmlvcml0eUxldmVsKSApO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVtb3ZlcyBhIHByaW9yaXR5IGxldmVsLiBJZiB0aGUgcmVtb3ZlZCBwcmlvcml0eSB3YXMgcHJldmlvdXNseSB0aGVcblx0KiBoaWdoZXN0IHByaW9yaXR5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgZHJvcHMgdG8gdGhlIG5leHQgaGlnaGVzdCBwcmlvcml0eVxuXHQqIGFuZCBxdWV1ZWQgam9icyB3aXRoIGEgaGlnaGVyIHByaW9yaXR5IGFyZSBleGVjdXRlZC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBwcmlvcml0eSBsZXZlbCB0byByZW1vdmUuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR1bnJlZ2lzdGVyUHJpb3JpdHk6IGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBoaWdoZXN0UHJpb3JpdHkgPSAwO1xuXG5cdFx0Ly8gcmVtb3ZlIHByaW9yaXR5XG5cdFx0ZGVsZXRlIHRoaXMuX3ByaW9yaXRpZXNbaWRdO1xuXG5cdFx0Ly8gZmluZCBuZXcgaGlnaGVzdCBjdXJyZW50IHByaW9yaXR5XG5cdFx0Zm9yKCB2YXIgaSBpbiB0aGlzLl9wcmlvcml0aWVzICl7XG5cdFx0XHRoaWdoZXN0UHJpb3JpdHkgPSBNYXRoLm1heChoaWdoZXN0UHJpb3JpdHksIHRoaXMuX3ByaW9yaXRpZXNbaV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0UHJpb3JpdHlMZXZlbCggaGlnaGVzdFByaW9yaXR5ICk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBUcmllcyB0byBydW4gbmV4dCBqb2IgaWYgcHJpb3JpdHkgbGV2ZWwgaGFzIGRyb3BwZWQuXG5cdCpcblx0KiBAdHlwZSB7ZW55by5PYnNlcnZlclN1cHBvcnR+T2JzZXJ2ZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHJpb3JpdHlMZXZlbENoYW5nZWQ6IGZ1bmN0aW9uICh3YXMpIHtcblx0XHRpZih3YXMgPiB0aGlzLnByaW9yaXR5TGV2ZWwpe1xuXHRcdFx0dGhpcy5fZG9Kb2IoKTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBGaW5kcyBhbmQgZXhlY3V0ZXMgdGhlIGpvYiBvZiBoaWdoZXN0IHByaW9yaXR5OyBpbiB0aGlzIHdheSwgYWxsIGpvYnMgd2l0aCBwcmlvcml0eVxuXHQqIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBsZXZlbCBhcmUgcnVuLCBpbiBvcmRlciBvZiB0aGVpciBwcmlvcml0eSAoaGlnaGVzdFxuXHQqIHRvIGxvd2VzdCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfZG9Kb2I6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgam9iO1xuXHRcdC8vIGZpbmQgdGhlIGpvYiBvZiBoaWdoZXN0IHByaW9yaXR5IGFib3ZlIHRoZSBjdXJyZW50IHByaW9yaXR5IGxldmVsXG5cdFx0Ly8gYW5kIHJlbW92ZSBmcm9tIHRoZSBqb2IgbGlzdFxuXHRcdGZvciAodmFyIGkgPSA5OyBpID49IHRoaXMucHJpb3JpdHlMZXZlbDsgaS0tKXtcblx0XHRcdGlmICh0aGlzLl9qb2JzW2ldLmxlbmd0aCkge1xuXHRcdFx0XHRqb2IgPSB0aGlzLl9qb2JzW2ldLnNoaWZ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsbG93IG90aGVyIGV2ZW50cyB0byBwYXNzIHRocm91Z2hcblx0XHRpZiAoam9iKSB7XG5cdFx0XHRqb2IuZmt0KCk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbmFtZWRKb2JzW2pvYi5uYW1lXTtcblx0XHRcdHNldFRpbWVvdXQodXRpbHMuYmluZCh0aGlzLCAnX2RvSm9iJyksIDEwKTtcblx0XHR9XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29yZU9iamVjdFwiOjE3LFwiLi9raW5kXCI6NjYsXCIuL3V0aWxzXCI6NzV9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdGpzb24gPSByZXF1aXJlKCcuL2pzb24nKSxcblx0bG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxudmFyXG5cdEFqYXhQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9BamF4UHJvcGVydGllcycpLFxuXHRBc3luYyA9IHJlcXVpcmUoJy4vQXN5bmMnKSxcblx0Rm9ybURhdGEgPSByZXF1aXJlKCcuL0Zvcm1EYXRhJyksXG5cdFhociA9IHJlcXVpcmUoJy4veGhyJyk7XG5cdFxuXG4vKipcbiogQSBjYWNoZSBvZiByZXNwb25zZSBwcm9wZXJ0aWVzIHNldCBvbiB0aGUge0BsaW5rIGVueW8uQWpheH0gaW5zdGFuY2Ugb25jZSBpdCBoYXMgY29tcGxldGVkXG4qIGl0cyByZXF1ZXN0LlxuKlxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLkFqYXh+eGhyUmVzcG9uc2VcbiogQHByb3BlcnR5IHtOdW1iZXJ9IHN0YXR1cyAtIFRoZSByZXNwb25zZSBzdGF0dXMuXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgdXNlZCBmb3IgdGhlIHJlcXVlc3QuXG4qIEBwcm9wZXJ0eSB7U3RyaW5nfSBib2R5IC0gVGhlIHJlcXVlc3QgYm9keS5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEEgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBkZXNpZ25lZCB0byBleHBvc2UgdGhlIG5hdGl2ZVxuKiBbWE1MSHR0cFJlcXVlc3Rde0BnbG9zc2FyeSBYTUxIdHRwUmVxdWVzdH0gQVBJLiBBdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG4qIGFyZSBleHBvc2VkIGJ5IHtAbGluayBlbnlvLkFqYXhQcm9wZXJ0aWVzfS5cbipcbiogVGhpcyBraW5kIGRvZXMgbm90IGV4dGVuZCB7QGxpbmsgZW55by5Db21wb25lbnR9IGFuZCBjYW5ub3QgYmUgdXNlZFxuKiBpbiB0aGUgW2NvbXBvbmVudHMgYmxvY2tde0BsaW5rIGVueW8uQ29tcG9uZW50I2NvbXBvbmVudHN9LlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uIFtDb25zdW1pbmcgV2ViXG4qIFNlcnZpY2VzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9tYW5hZ2luZy1kYXRhL2NvbnN1bWluZy13ZWItc2VydmljZXMuaHRtbH1cbiogaW4gdGhlIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgZW55by5BamF4XG4qIEBleHRlbmRzIGVueW8uQXN5bmNcbiogQHB1YmxpY1xuKi9cbnZhciBBamF4ID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uQWpheC5wcm90b3R5cGUgKi8ge1xuXHRcblx0bmFtZTogJ2VueW8uQXN5bmMnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQXN5bmMsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IEFqYXhQcm9wZXJ0aWVzLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0b3I6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChpblBhcmFtcykge1xuXHRcdFx0dXRpbHMubWl4aW4odGhpcywgaW5QYXJhbXMpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBleHBsaWNpbHR5IHJlbGVhc2UgYW55IFhIUiByZWZzXG5cdFx0XHR0aGlzLnhociA9IG51bGw7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIFRoaXMgd2lsbCBiZSBzZXQgb25jZSBhIHJlcXVlc3QgaGFzIGNvbXBsZXRlZCAoc3VjY2Vzc2Z1bGx5IG9yIHVuc3VjY2Vzc2Z1bGx5KS5cblx0KiBJdCBpcyBhIGNhY2hlIG9mIHRoZSByZXNwb25zZSB2YWx1ZXMuXG5cdCpcblx0KiBAdHlwZSBlbnlvLkFqYXh+eGhyUmVzcG9uc2Vcblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR4aHJSZXNwb25zZTogbnVsbCxcblx0XG5cdC8qKlxuXHQqIEV4ZWN1dGVzIHRoZSByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuIFRoZSBwYXJhbWV0ZXIgbWF5IGJlIGFcblx0KiBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gb2YgcHJvcGVydGllcyBvciBhIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9LiBCb3RoXG5cdCogcmVwcmVzZW50IHRoZSBxdWVyeSBzdHJpbmcsIHdpdGggdGhlIGhhc2ggYmVpbmcgc2VyaWFsaXplZCBhbmQgdGhlIHN0cmluZ1xuXHQqIGJlaW5nIHVzZWQgZGlyZWN0bHkuXG5cdCpcblx0KiBgYGBqYXZhc2NyaXB0XG5cdCogdmFyIHF1ZXJ5ID0ge3E6ICdzZWFyY2hUZXJtJ307IC8vIC0+IFwiP3E9c2VhcmNoVGVybVwiXG5cdCogYGBgXG5cdCpcblx0KiBUbyBwcm92aWRlIGEgYFBPU1RgIGJvZHksIHNlZSB7QGxpbmsgZW55by5BamF4UHJvcGVydGllcy5wb3N0Qm9keX0uXG5cdCpcblx0KiBXaGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlZCwgaXQgd2lsbCBzZXQgdGhlXG5cdCogW3hoclJlc3BvbnNlXXtAbGluayBlbnlvLkFqYXgjeGhyUmVzcG9uc2V9IHByb3BlcnR5LlxuXHQqXG5cdCogQHNlZSBlbnlvLkFqYXhQcm9wZXJ0aWVzXG5cdCogQHNlZSBlbnlvLkFqYXgueGhyUmVzcG9uc2Vcblx0KiBAc2VlIGVueW8uQWpheH54aHJSZXNwb25zZVxuXHQqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmcpfSBbcGFyYW1zXSAtIEEgW3N0cmluZ117QGdsb3NzYXJ5IFN0cmluZ30gb3Jcblx0Klx0W2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHRvIGJlIHVzZWQgYXMgdGhlIHF1ZXJ5IHN0cmluZy5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnbzogZnVuY3Rpb24gKHBhcmFtcykge1xuXHRcdHRoaXMuZmFpbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5zdGFydFRpbWVyKCk7XG5cdFx0dGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZXF1ZXN0OiBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy51cmwuc3BsaXQoJz8nKTtcblx0XHR2YXIgdXJpID0gcGFydHMuc2hpZnQoKSB8fCAnJztcblx0XHR2YXIgYXJncyA9IHBhcnRzLmxlbmd0aCA/IChwYXJ0cy5qb2luKCc/Jykuc3BsaXQoJyYnKSkgOiBbXTtcblx0XHQvL1xuXHRcdHZhciBxdWVyeSA9IG51bGw7XG5cdFx0Ly9cblx0XHRpZih1dGlscy5pc1N0cmluZyhwYXJhbXMpKXtcblx0XHRcdC8vSWYgcGFyYW1zIHBhcmFtZXRlciBpcyBhIHN0cmluZywgdXNlIGl0IGFzIHJlcXVlc3QgYm9keVxuXHRcdFx0cXVlcnkgPSBwYXJhbXM7XG5cdFx0fVxuXHRcdGVsc2V7XG5cdFx0XHQvL0lmIHBhcmFtcyBwYXJhbWV0ZXIgaXMgbm90IGEgc3RyaW5nLCBidWlsZCBhIHF1ZXJ5IGZyb20gaXRcblx0XHRcdGlmKHBhcmFtcyl7XG5cdFx0XHRcdHF1ZXJ5ID0gQWpheC5vYmplY3RUb1F1ZXJ5KHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vXG5cdFx0aWYgKHF1ZXJ5KSB7XG5cdFx0XHRhcmdzLnB1c2gocXVlcnkpO1xuXHRcdFx0cXVlcnkgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jYWNoZUJ1c3QpIHtcblx0XHRcdGFyZ3MucHVzaChNYXRoLnJhbmRvbSgpKTtcblx0XHR9XG5cdFx0Ly9cblx0XHR2YXIgdXJsID0gYXJncy5sZW5ndGggPyBbdXJpLCBhcmdzLmpvaW4oJyYnKV0uam9pbignPycpIDogdXJpO1xuXHRcdC8vXG5cdFx0dmFyIHhocl9oZWFkZXJzID0ge307XG5cdFx0dmFyIGJvZHk7XG5cdFx0aWYgKHRoaXMubWV0aG9kICE9ICdHRVQnKSB7XG5cdFx0XHRib2R5ID0gdGhpcy5wb3N0Qm9keTtcblx0XHRcdGlmICh0aGlzLm1ldGhvZCA9PT0gJ1BPU1QnICYmIGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRpZiAoYm9keS5mYWtlKSB7XG5cdFx0XHRcdFx0eGhyX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gYm9keS5nZXRDb250ZW50VHlwZSgpO1xuXHRcdFx0XHRcdGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTm90aGluZyB0byBkbyBhcyB0aGVcblx0XHRcdFx0XHQvLyBjb250ZW50LXR5cGUgd2lsbCBiZVxuXHRcdFx0XHRcdC8vIGF1dG9tYWdpY2FsbHkgc2V0IGFjY29yZGluZ1xuXHRcdFx0XHRcdC8vIHRvIHRoZSBGb3JtRGF0YVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4aHJfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLmNvbnRlbnRUeXBlO1xuXHRcdFx0XHRpZiAoYm9keSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLmNvbnRlbnRUeXBlLm1hdGNoKC9eYXBwbGljYXRpb25cXC9qc29uKDsuKik/JC8pICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykge1xuXHRcdFx0XHRcdFx0Ym9keSA9IEFqYXgub2JqZWN0VG9RdWVyeShib2R5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gYm9keS50b1N0cmluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR1dGlscy5taXhpbih4aHJfaGVhZGVycywgdGhpcy5oZWFkZXJzKTtcblx0XHQvLyBkb24ndCBwYXNzIGluIGhlYWRlcnMgc3RydWN0dXJlIGlmIHRoZXJlIGFyZSBubyBoZWFkZXJzIGRlZmluZWQgYXMgdGhpcyBtZXNzZXNcblx0XHQvLyB1cCBDT1JTIGNvZGUgZm9yIElFOC05XG5cdFx0aWYgKHV0aWxzLmtleXMoeGhyX2hlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0eGhyX2hlYWRlcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdC8vXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMueGhyID0gWGhyLnJlcXVlc3Qoe1xuXHRcdFx0XHR1cmw6IHVybCxcblx0XHRcdFx0bWV0aG9kOiB0aGlzLm1ldGhvZCxcblx0XHRcdFx0Y2FsbGJhY2s6IHRoaXMuYmluZFNhZmVseSgncmVjZWl2ZScpLFxuXHRcdFx0XHRib2R5OiBib2R5LFxuXHRcdFx0XHRoZWFkZXJzOiB4aHJfaGVhZGVycyxcblx0XHRcdFx0c3luYzogdGhpcy5zeW5jLFxuXHRcdFx0XHR1c2VybmFtZTogdGhpcy51c2VybmFtZSxcblx0XHRcdFx0cGFzc3dvcmQ6IHRoaXMucGFzc3dvcmQsXG5cdFx0XHRcdHhockZpZWxkczogdXRpbHMubWl4aW4oe29ucHJvZ3Jlc3M6IHRoaXMuYmluZFNhZmVseSh0aGlzLnVwZGF0ZVByb2dyZXNzKX0sIHRoaXMueGhyRmllbGRzKSxcblx0XHRcdFx0bWltZVR5cGU6IHRoaXMubWltZVR5cGVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgY2FuIHRocm93IGVycm9ycyBoZXJlIGlmIHRoZSBYSFIgd291bGQgZmFpbCBDT1JTIGNoZWNrcyxcblx0XHRcdC8vIHNvIGNhdGNoIGFuZCB0dXJuIGludG8gYSBmYWlsdXJlLlxuXHRcdFx0dGhpcy5mYWlsKGUpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlY2VpdmU6IGZ1bmN0aW9uIChpblRleHQsIGluWGhyKSB7XG5cdFx0aWYgKCF0aGlzLmZhaWxlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcblx0XHRcdHZhciBib2R5O1xuXHRcdFx0aWYgKGluWGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuXHRcdFx0XHRib2R5ID0gaW5YaHIucmVzcG9uc2U7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpblhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGJvZHkgPSBpblhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJRSBjYXJyeWluZyBhIGJpbmFyeVxuXHRcdFx0XHRib2R5ID0gaW5YaHIucmVzcG9uc2VCb2R5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy54aHJSZXNwb25zZSA9IHtcblx0XHRcdFx0c3RhdHVzOiBpblhoci5zdGF0dXMsXG5cdFx0XHRcdGhlYWRlcnM6IEFqYXgucGFyc2VSZXNwb25zZUhlYWRlcnMoaW5YaHIpLFxuXHRcdFx0XHRib2R5OiBib2R5XG5cdFx0XHR9O1xuXHRcdFx0aWYgKHRoaXMuaXNGYWlsdXJlKGluWGhyKSkge1xuXHRcdFx0XHR0aGlzLmZhaWwoaW5YaHIuc3RhdHVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmVzcG9uZCh0aGlzLnhoclRvUmVzcG9uc2UoaW5YaHIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmYWlsOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoaW5FcnJvcikge1xuXHRcdFx0Ly8gb24gZmFpbHVyZSwgZXhwbGljaXRseSBjYW5jZWwgdGhlIFhIUiB0byBwcmV2ZW50XG5cdFx0XHQvLyBmdXJ0aGVyIHJlc3BvbnNlcy4gIGNhbmNlbGxhdGlvbiBhbHNvIHJlc2V0cyB0aGVcblx0XHRcdC8vIHJlc3BvbnNlIGhlYWRlcnMgJiBib2R5LFxuXHRcdFx0aWYgKHRoaXMueGhyKSB7XG5cdFx0XHRcdFhoci5jYW5jZWwodGhpcy54aHIpO1xuXHRcdFx0XHR0aGlzLnhociA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHhoclRvUmVzcG9uc2U6IGZ1bmN0aW9uIChpblhocikge1xuXHRcdGlmIChpblhocikge1xuXHRcdFx0cmV0dXJuIHRoaXNbKHRoaXMuaGFuZGxlQXMgfHwgJ3RleHQnKSArICdIYW5kbGVyJ10oaW5YaHIpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzRmFpbHVyZTogZnVuY3Rpb24gKGluWGhyKSB7XG5cdFx0Ly8gaWYgYW55IGV4Y2VwdGlvbnMgYXJlIHRocm93biB3aGlsZSBjaGVja2luZyBmaWVsZHMgaW4gdGhlIHhocixcblx0XHQvLyBhc3N1bWUgYSBmYWlsdXJlLlxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoaW5YaHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG5cdFx0XHRcdC8vIGlmIHdlIGFyZSBsb2FkaW5nIGJpbmFyeSBkYXRhLCBkb24ndCB0cnkgdG8gYWNjZXNzIGluWGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHQvLyBiZWNhdXNlIHRoYXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB3ZWJraXQuIEluc3RlYWQsIGp1c3QgbG9vayBmb3Jcblx0XHRcdFx0Ly8gdGhlIHJlc3BvbnNlLlxuXHRcdFx0XHRpZiAoaW5YaHIuc3RhdHVzID09PSAwICYmICFpblhoci5yZXNwb25zZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGV4dCA9ICcnO1xuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCBJRTgtOSBidWcgd2hlcmUgYWNjZXNzaW5nIHJlc3BvbnNlVGV4dCB3aWxsIHRocm93biBlcnJvclxuXHRcdFx0XHQvLyBmb3IgYmluYXJ5IHJlcXVlc3RzLlxuXHRcdFx0XHRpZiAodHlwZW9mIGluWGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0ZXh0ID0gaW5YaHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZvbGxvdyBzYW1lIGZhaWx1cmUgcG9saWN5IGFzIGpRdWVyeSdzIEFqYXggY29kZVxuXHRcdFx0XHQvLyBDT1JTIGZhaWx1cmVzIG9uIEZpcmVGb3ggd2lsbCBoYXZlIHN0YXR1cyAwIGFuZCBubyByZXNwb25zZVRleHQsXG5cdFx0XHRcdC8vIHNvIHRyZWF0IHRoYXQgYXMgZmFpbHVyZS5cblx0XHRcdFx0aWYgKGluWGhyLnN0YXR1cyA9PT0gMCAmJiB0ZXh0ID09PSAnJykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBPdGhlcndpc2UsIHN0YXR1cyAwIG1heSBiZSBnb29kIGZvciBsb2NhbCBmaWxlIGFjY2Vzcy4gIFdlIHRyZWF0IHRoZSByYW5nZVxuXHRcdFx0Ly8gMS0xOTkgYW5kIDMwMCsgYXMgZmFpbHVyZSAob25seSAyMDAtc2VyaWVzIGNvZGUgYXJlIE9LKS5cblx0XHRcdHJldHVybiAoaW5YaHIuc3RhdHVzICE9PSAwKSAmJiAoaW5YaHIuc3RhdHVzIDwgMjAwIHx8IGluWGhyLnN0YXR1cyA+PSAzMDApO1xuXHRcdH1cblx0XHRjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0eG1sSGFuZGxlcjogZnVuY3Rpb24gKGluWGhyKSB7XG5cdFx0cmV0dXJuIGluWGhyLnJlc3BvbnNlWE1MO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGV4dEhhbmRsZXI6IGZ1bmN0aW9uIChpblhocikge1xuXHRcdHJldHVybiBpblhoci5yZXNwb25zZVRleHQ7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRqc29uSGFuZGxlcjogZnVuY3Rpb24gKGluWGhyKSB7XG5cdFx0dmFyIHIgPSBpblhoci5yZXNwb25zZVRleHQ7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiByICYmIGpzb24ucGFyc2Uocik7XG5cdFx0fSBjYXRjaCAoeCkge1xuXHRcdFx0bG9nZ2VyLndhcm4oJ0FqYXggcmVxdWVzdCBzZXQgdG8gaGFuZGxlQXMgSlNPTiBidXQgZGF0YSB3YXMgbm90IGluIEpTT04gZm9ybWF0Jyk7XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRiaW5hcnlIYW5kbGVyOiBmdW5jdGlvbiAoaW5YaHIpIHtcblx0XHRyZXR1cm4gaW5YaHIucmVzcG9uc2U7XG5cdH0sIFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIElFOCBkb2Vzbid0IHByb3Blcmx5IHN1cHBvcnQgcHJvZ3Jlc3MgZXZlbnRzIGFuZCBkb2Vzbid0IHBhc3MgYW4gb2JqZWN0IHRvIHRoZVxuXHRcdC8vIGhhbmRsZXJzIHNvIHdlJ2xsIGNoZWNrIHRoYXQgYmVmb3JlIGNvbnRpbnVpbmcuXG5cdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHQvLyBmaWx0ZXIgb3V0ICdpbnB1dCcgYXMgaXQgY2F1c2VzIGV4Y2VwdGlvbnMgb24gc29tZSBGaXJlZm94IHZlcnNpb25zXG5cdFx0XHQvLyBkdWUgdG8gdW5pbXBsZW1lbnRlZCBpbnRlcm5hbCBBUElzXG5cdFx0XHR2YXIgZXYgPSB7fTtcblx0XHRcdGZvciAodmFyIGsgaW4gZXZlbnQpIHtcblx0XHRcdFx0aWYgKGsgIT09ICdpbnB1dCcpIHtcblx0XHRcdFx0XHRldltrXSA9IGV2ZW50W2tdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNlbmRQcm9ncmVzcyhldmVudC5sb2FkZWQsIDAsIGV2ZW50LnRvdGFsLCBldik7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhdGljczoge1xuXHRcdG9iamVjdFRvUXVlcnk6IGZ1bmN0aW9uICgvKk9iamVjdCovIG1hcCkge1xuXHRcdFx0dmFyIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudDtcblx0XHRcdHZhciBwYWlycyA9IFtdO1xuXHRcdFx0dmFyIGJhY2tzdG9wID0ge307XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG1hcCl7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hcFtuYW1lXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IGJhY2tzdG9wW25hbWVdKSB7XG5cdFx0XHRcdFx0dmFyIGFzc2lnbiA9IGVuYyhuYW1lKSArICc9Jztcblx0XHRcdFx0XHRpZiAodXRpbHMuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhaXJzLnB1c2goYXNzaWduICsgZW5jKHZhbHVlW2ldKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBhaXJzLnB1c2goYXNzaWduICsgZW5jKHZhbHVlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFpcnMuam9pbignJicpO1xuXHRcdH1cblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHByb3RlY3RlZFN0YXRpY3M6IHtcblx0XHRwYXJzZVJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKHhocikge1xuXHRcdFx0dmFyIGhlYWRlcnMgPSB7fTtcblx0XHRcdHZhciBoZWFkZXJzU3RyID0gW107XG5cdFx0XHRpZiAoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycykge1xuXHRcdFx0XHRoZWFkZXJzU3RyID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLyk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnNTdHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGhlYWRlclN0ciA9IGhlYWRlcnNTdHJbaV07XG5cdFx0XHRcdHZhciBpbmRleCA9IGhlYWRlclN0ci5pbmRleE9mKCc6ICcpO1xuXHRcdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGhlYWRlclN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGhlYWRlclN0ci5zdWJzdHJpbmcoaW5kZXggKyAyKTtcblx0XHRcdFx0XHRoZWFkZXJzW2tleV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoZWFkZXJzO1xuXHRcdH1cblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9BamF4UHJvcGVydGllc1wiOjMsXCIuL0FzeW5jXCI6NyxcIi4vRm9ybURhdGFcIjoyMCxcIi4vanNvblwiOjY1LFwiLi9raW5kXCI6NjYsXCIuL2xvZ2dlclwiOjY3LFwiLi91dGlsc1wiOjc1LFwiLi94aHJcIjo3Nn1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhclxuXHRPYnNlcnZlclN1cHBvcnQgPSByZXF1aXJlKCcuL09ic2VydmVyU3VwcG9ydCcpLFxuXHRDb21wdXRlZFN1cHBvcnQgPSByZXF1aXJlKCcuL0NvbXB1dGVkU3VwcG9ydCcpLFxuXHRCaW5kaW5nU3VwcG9ydCA9IHJlcXVpcmUoJy4vQmluZGluZ1N1cHBvcnQnKSxcblx0RXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXInKSxcblx0U3RhdGVTdXBwb3J0ID0gcmVxdWlyZSgnLi9TdGF0ZVN1cHBvcnQnKSxcblx0TW9kZWxMaXN0ID0gcmVxdWlyZSgnLi9Nb2RlbExpc3QnKSxcblx0U291cmNlID0gcmVxdWlyZSgnLi9Tb3VyY2UnKSxcblx0U3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0ZXMnKSxcblx0U3RvcmUgPSByZXF1aXJlKCcuL1N0b3JlJyk7XG5cbi8qKlxuKiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgdGhlIG9yZGVyIGluIHdoaWNoIG1peGlucyBhcmUgYXBwbGllZC5cbipcbiogQGNsYXNzXG4qIEBwcml2YXRlXG4qL1xudmFyIEJhc2VNb2RlbCA9IGtpbmQoe1xuXHRraW5kOiBudWxsLFxuXHRtaXhpbnM6IFtPYnNlcnZlclN1cHBvcnQsIENvbXB1dGVkU3VwcG9ydCwgQmluZGluZ1N1cHBvcnQsIEV2ZW50RW1pdHRlciwgU3RhdGVTdXBwb3J0XVxufSk7XG5cbi8qKlxuKiBUaGUgZXZlbnQgZW1pdHRlZCB3aGVuIFthdHRyaWJ1dGVzXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9IGhhdmUgYmVlbiBtb2RpZmllZC5cbiogVGhlIGV2ZW50IFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHdpbGwgY29uc2lzdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgYXR0cmlidXRlc1xuKiB0aGF0IGNoYW5nZWQgYW5kIHRoZWlyIG5ldyB2YWx1ZXMuXG4qXG4qIEBldmVudCBlbnlvLk1vZGVsI2NoYW5nZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogVGhlIGRlZmF1bHQgY29uZmlndXJhYmxlIFtvcHRpb25zXXtAbGluayBlbnlvLk1vZGVsI29wdGlvbnN9IHVzZWQgaW4gY2VydGFpbiBBUEkgbWV0aG9kc1xuKiBvZiB7QGxpbmsgZW55by5Nb2RlbH0uXG4qXG4qIEB0eXBlZGVmIHtPYmplY3R9IGVueW8uTW9kZWx+T3B0aW9uc1xuKiBAcHJvcGVydHkge0Jvb2xlYW59IHNpbGVudD1mYWxzZSAtIEtlZXAgZXZlbnRzIGFuZCBub3RpZmljYXRpb25zIGZyb20gYmVpbmcgZW1pdHRlZC5cbiogQHByb3BlcnR5IHtCb29sZWFufSBjb21taXQ9ZmFsc2UgLSBJbW1lZGlhdGVseSBbY29tbWl0XXtAbGluayBlbnlvLk1vZGVsI2NvbW1pdH0gY2hhbmdlc1xuKlx0YWZ0ZXIgdGhleSBoYXZlIG9jY3VycmVkLiBBbHNvIG5vdGUgdGhhdCwgaWYgYHRydWVgLCB3aGVuIHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9XG4qIGlzIFtkZXN0cm95ZWRde0BsaW5rIGVueW8uTW9kZWwjZGVzdHJveX0sIGl0IHdpbGwgYWxzbyBiZSBkZXN0cm95ZWQgdmlhIGFueVxuKiBbc291cmNlc117QGxpbmsgZW55by5Nb2RlbCNzb3VyY2V9IGl0IGhhcy5cbiogQHByb3BlcnR5IHtCb29sZWFufSBwYXJzZT1mYWxzZSAtIER1cmluZyBpbml0aWFsaXphdGlvbiwgW3BhcnNlXXtAbGluayBlbnlvLk1vZGVsI3BhcnNlfVxuKlx0YW55IGdpdmVuIFthdHRyaWJ1dGVzXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9OyBhZnRlclxuKlx0W2ZldGNoaW5nXXtAbGluayBlbnlvLk1vZGVsI2ZldGNofSwgcGFyc2UgdGhlIGRhdGEgYmVmb3JlIGNhbGxpbmdcbiogW3NldCgpXXtAbGluayBlbnlvLk1vZGVsI3NldH0uXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZmV0Y2g9ZmFsc2UgLSBBdXRvbWF0aWNhbGx5IGNhbGwgW2ZldGNoKClde0BsaW5rIGVueW8uTW9kZWwjZmV0Y2h9XG4qXHRkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4qL1xuXG4vKipcbiogVGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBbZmV0Y2goKV17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH0sXG4qIFtjb21taXQoKV17QGxpbmsgZW55by5Nb2RlbCNjb21taXR9LCBhbmQgW2Rlc3Ryb3koKV17QGxpbmsgZW55by5Nb2RlbCNkZXN0cm95fS5cbipcbiogQHR5cGVkZWYge2VueW8uTW9kZWx+T3B0aW9uc30gZW55by5Nb2RlbH5BY3Rpb25PcHRpb25zXG4qIEBwcm9wZXJ0eSB7ZW55by5Nb2RlbH5TdWNjZXNzfSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGV4ZWN1dGVkIHVwb24gc3VjY2Vzc2Z1bFxuKlx0Y29tcGxldGlvbi5cbiogQHByb3BlcnR5IHtlbnlvLk1vZGVsfkVycm9yfSBlcnJvciAtIFRoZSBjYWxsYmFjayBleGVjdXRlZCB1cG9uIGEgZmFpbGVkIGF0dGVtcHQuXG4qL1xuXG4vKipcbiogQGNhbGxiYWNrIGVueW8uTW9kZWx+U3VjY2Vzc1xuKiBAcGFyYW0ge2VueW8uTW9kZWx9IG1vZGVsIC0gVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gdGhhdCBpcyByZXR1cm5pbmcgc3VjY2Vzc2Z1bGx5LlxuKiBAcGFyYW0ge2VueW8uTW9kZWx+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0byB0aGUgYWN0aW9uIG1ldGhvZFxuKlx0dGhhdCBpcyByZXR1cm5pbmcgc3VjY2Vzc2Z1bGx5LlxuKiBAcGFyYW0geyp9IHJlcyAtIFRoZSByZXN1bHQsIGlmIGFueSwgcmV0dXJuZWQgYnkgdGhlIFtzb3VyY2Vde0BsaW5rIGVueW8uU291cmNlfSB0aGF0XG4qXHRleGVjdXRlZCBpdC5cbiogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBuYW1lIG9mIHRoZSBbc291cmNlXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0gdGhhdCBoYXNcbiogcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxuKi9cblxuLyoqXG4qIEBjYWxsYmFjayBlbnlvLk1vZGVsfkVycm9yXG4qIEBwYXJhbSB7ZW55by5Nb2RlbH0gbW9kZWwgLSBUaGUgbW9kZWwgdGhhdCBpcyByZXR1cm5pbmcgYW4gZXJyb3IuXG4qIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gLSBUaGUgbmFtZSBvZiB0aGUgYWN0aW9uIHRoYXQgZmFpbGVkLCBvbmUgb2YgYCdGRVRDSElORydgLFxuKlx0YCdDT01NSVRUSU5HJ2AsIG9yIGAnREVTVFJPWUlORydgLlxuKiBAcGFyYW0ge2VueW8uTW9kZWx+T3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0byB0aGUgYWN0aW9uIG1ldGhvZFxuKlx0dGhhdCBpcyByZXR1cm5pbmcgYW4gZXJyb3IuXG4qIEBwYXJhbSB7Kn0gcmVzIC0gVGhlIHJlc3VsdCwgaWYgYW55LCByZXR1cm5lZCBieSB0aGUgW3NvdXJjZV17QGxpbmsgZW55by5Tb3VyY2V9IHRoYXRcbipcdGV4ZWN1dGVkIGl0LlxuKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIFtzb3VyY2Vde0BsaW5rIGVueW8uTW9kZWwjc291cmNlfSB0aGF0IGhhc1xuKlx0cmV0dXJuZWQgYW4gZXJyb3IuXG4qL1xuXG4vKipcbiogQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdXNlZCB0byByZXByZXNlbnQgYW5kIG1haW50YWluIHN0YXRlLiBVc3VhbGx5LFxuKiBhbiB7QGxpbmsgZW55by5Nb2RlbH0gaXMgdXNlZCB0byBleHBvc2UgZGF0YSB0byB0aGUgdmlldyBsYXllci4gSXQga2VlcHMgbG9naWNcbiogcmVsYXRlZCB0byB0aGUgZGF0YSAocmV0cmlldmluZyBpdCwgdXBkYXRpbmcgaXQsIHN0b3JpbmcgaXQsIGV0Yy4pIG91dCBvZiB0aGVcbiogdmlldywgYW5kIHRoZSB2aWV3IGNhbiBhdXRvbWF0aWNhbGx5IHVwZGF0ZSBiYXNlZCBvbiBjaGFuZ2VzIGluIHRoZSBtb2RlbC5cbiogTW9kZWxzIGhhdmUgdGhlIGFiaWxpdHkgdG8gd29yayB3aXRoIG90aGVyIGRhdGEgbGF5ZXIgW2tpbmRzXXtAZ2xvc3Nhcnkga2luZH1cbiogdG8gcHJvdmlkZSBtb3JlIHNvcGhpc3RpY2F0ZWQgaW1wbGVtZW50YXRpb25zLlxuKlxuKiBNb2RlbHMgaGF2ZSBbYmluZGFibGVde0BsaW5rIGVueW8uQmluZGluZ1N1cHBvcnR9XG4qIFthdHRyaWJ1dGVzXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9LiBNb2RlbHMgZGlmZmVycyBmcm9tIG90aGVyXG4qIGJpbmRhYmxlIGtpbmRzIGluIHRoYXQgYXR0cmlidXRlIHZhbHVlcyBhcmUgcHJveGllZCBmcm9tIGFuIGludGVybmFsXG4qIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSBpbnN0ZWFkIG9mIGJlaW5nIHNldCBvbiB0aGUgdGFyZ2V0IHByb3BlcnRpZXNcbiogZGlyZWN0bHkuXG4qXG4qIEBzZWUgZW55by5TdG9yZVxuKiBAc2VlIGVueW8uQ29sbGVjdGlvblxuKiBAc2VlIGVueW8uUmVsYXRpb25hbE1vZGVsXG4qIEBzZWUgZW55by5Nb2RlbENvbnRyb2xsZXJcbiogQGNsYXNzIGVueW8uTW9kZWxcbiogQG1peGVzIGVueW8uT2JzZXJ2ZXJTdXBwb3J0XG4qIEBtaXhlcyBlbnlvLkNvbXB1dGVkU3VwcG9ydFxuKiBAbWl4ZXMgZW55by5CaW5kaW5nU3VwcG9ydFxuKiBAbWl4ZXMgZW55by5FdmVudEVtaXR0ZXJcbiogQG1peGVzIGVueW8uU3RhdGVTdXBwb3J0XG4qIEBwdWJsaWNcbiovXG52YXIgTW9kZWwgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Nb2RlbC5wcm90b3R5cGUgKi8ge1xuXG5cdG5hbWU6ICdlbnlvLk1vZGVsJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBCYXNlTW9kZWwsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblxuXG5cdC8qKlxuXHQqIFVzZWQgYnkgdmFyaW91cyBbc291cmNlc117QGxpbmsgZW55by5Nb2RlbCNzb3VyY2V9IGFzIHBhcnQgb2YgdGhlXG5cdCogW1VSSV17QGdsb3NzYXJ5IFVSSX0gZnJvbSB3aGljaCB0aGV5IG1heSBiZSBbZmV0Y2hlZF17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH0sXG5cdCogW2NvbW1pdHRlZF17QGxpbmsgZW55by5Nb2RlbCNjb21taXR9LCBvciBbZGVzdHJveWVkXXtAbGluayBlbnlvLk1vZGVsI2Rlc3Ryb3l9LlxuXHQqIFNvbWUgc291cmNlcyBtYXkgdXNlIHRoaXMgcHJvcGVydHkgaW4gb3RoZXIgd2F5cy5cblx0KlxuXHQqIEBzZWUgZW55by5Nb2RlbC5nZXRVcmxcblx0KiBAc2VlIGVueW8uU291cmNlXG5cdCogQHNlZSBlbnlvLkFqYXhTb3VyY2Vcblx0KiBAc2VlIGVueW8uSnNvbnBTb3VyY2Vcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICcnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR1cmw6ICcnLFxuXG5cdC8qKlxuXHQqIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBiZSB1c2VkIGJ5IFtzb3VyY2VzXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0gdG9cblx0KiBkeW5hbWljYWxseSBkZXJpdmUgdGhlIFtVUklde0BnbG9zc2FyeSBVUkl9IGZyb20gd2hpY2ggdGhleSBtYXkgYmVcblx0KiBbZmV0Y2hlZF17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH0sIFtjb21taXR0ZWRde0BsaW5rIGVueW8uTW9kZWwjY29tbWl0fSxcblx0KiBvciBbZGVzdHJveWVkXXtAbGluayBlbnlvLk1vZGVsI2Rlc3Ryb3l9LiBTb21lIHNvdXJjZXMgbWF5IHVzZSB0aGlzXG5cdCogcHJvcGVydHkgaW4gb3RoZXIgd2F5cy4gTm90ZSB0aGF0LCBpZiB0aGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCwgdGhlXG5cdCogW3VybF17QGxpbmsgZW55by5Nb2RlbCN1cmx9IHdpbGwgbm90IGJlIHVzZWQuXG5cdCpcblx0KiBAc2VlIGVueW8uTW9kZWwudXJsXG5cdCogQHNlZSBlbnlvLlNvdXJjZVxuXHQqIEBzZWUgZW55by5BamF4U291cmNlXG5cdCogQHNlZSBlbnlvLkpzb25wU291cmNlXG5cdCogQHR5cGUge0Z1bmN0aW9ufVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAdmlydHVhbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0VXJsOiBudWxsLFxuXG5cdC8qKlxuXHQqIFRoZSBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gb2YgcHJvcGVydGllcyBwcm94aWVkIGJ5IHRoaXMgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfS5cblx0KiBJZiBkZWZpbmVkIG9uIGEgW3N1YmtpbmRde0BnbG9zc2FyeSBzdWJraW5kfSwgaXQgbWF5IGJlIGFzc2lnbmVkIGRlZmF1bHQgdmFsdWVzIGFuZFxuXHQqIGFsbCBpbnN0YW5jZXMgd2lsbCBzaGFyZSBpdHMgZGVmYXVsdCBzdHJ1Y3R1cmUuIElmIG5vIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQsIGFuXG5cdCogZW1wdHkgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHdpbGwgYmUgYXNzaWduZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBJdCBpcyBub3Rcblx0KiBuZWNlc3NhcnkgdG8gcHJlLWRlZmluZSB0aGUgc3RydWN0dXJlIG9mIGEgbW9kZWw7IGRlcGVuZGluZyBvbiB0aGUgbW9kZWwncyBjb21wbGV4aXR5LFxuXHQqIHByZS1kZWZpbmluZyB0aGUgc3RydWN0dXJlIG1heSBwb3NzaWJseSBoaW5kZXIgcGVyZm9ybWFuY2UuXG5cdCpcblx0KiBJdCBzaG91bGQgYWxzbyBiZSBub3RlZCB0aGF0IGNhbGxzIHRvIFtnZXQoKV17QGxpbmsgZW55by5Nb2RlbCNnZXR9IG9yXG5cdCogW3NldCgpXXtAbGluayBlbnlvLk1vZGVsI3NldH0gd2lsbCBhY2Nlc3MgYW5kIG1vZGlmeSB0aGlzIHByb3BlcnR5LiBUaGlzIGluY2x1ZGVzXG5cdCogdGhlIHZhbHVlcyB0byB3aGljaCAob3IgZnJvbSB3aGljaCkgW2JpbmRpbmdzXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSBhcmUgYm91bmQuXG5cdCpcblx0KiBAdHlwZSB7T2JqZWN0fVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdGF0dHJpYnV0ZXM6IG51bGwsXG5cblx0LyoqXG5cdCogVGhlIFtzb3VyY2Uocylde0BsaW5rIGVueW8uU291cmNlfSB0byB1c2Ugd2hlbiBbZmV0Y2hpbmdde0BsaW5rIGVueW8uTW9kZWwjZmV0Y2h9LFxuXHQqIFtjb21taXR0aW5nXXtAbGluayBlbnlvLk1vZGVsI2NvbW1pdH0sIG9yIFtkZXN0cm95aW5nXXtAbGluayBlbnlvLk1vZGVsI2Rlc3Ryb3l9LlxuXHQqIEFueSBtZXRob2QgdGhhdCB1c2VzIHNvdXJjZXMgbWF5IG92ZXJyaWRlIHRoaXMgZGVmYXVsdCB2YWx1ZSBpbiBpdHMgY29uZmlndXJhdGlvblxuXHQqIG9wdGlvbnMuIFRoaXMgdmFsdWUgbWF5IGJlIGEgW3N0cmluZ117QGdsb3NzYXJ5IFN0cmluZ30sIGFuXG5cdCogW0FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IG9mIHN0cmluZ3MsIGFuIGluc3RhbmNlIG9mIHtAbGluayBlbnlvLlNvdXJjZX0sIG9yIGFuXG5cdCogYXJyYXkgb2YgYGVueW8uU291cmNlYCBpbnN0YW5jZXMuXG5cdCpcblx0KiBAc2VlIGVueW8uU291cmNlXG5cdCogQHNlZSBlbnlvLk1vZGVsLmZldGNoXG5cdCogQHNlZSBlbnlvLk1vZGVsLmNvbW1pdFxuXHQqIEBzZWUgZW55by5Nb2RlbC5kZXN0cm95XG5cdCogQHR5cGUgeyhTdHJpbmd8U3RyaW5nW118ZW55by5Tb3VyY2V8ZW55by5Tb3VyY2VbXSl9XG5cdCogQGRlZmF1bHQgbnVsbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c291cmNlOiBudWxsLFxuXG5cdC8qKlxuXHQqIFRoZXNlIFtrZXlzXXtAZ2xvc3NhcnkgT2JqZWN0LmtleXN9IHdpbGwgYmUgdGhlIG9ubHlcblx0KiBbYXR0cmlidXRlc117QGxpbmsgZW55by5Nb2RlbCNhdHRyaWJ1dGVzfSBpbmNsdWRlZCBpZiB0aGVcblx0KiBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IGlzIFtjb21taXR0ZWRde0BsaW5rIGVueW8uTW9kZWwjY29tbWl0fS4gVGhpc1xuXHQqIGRpcmVjdGx5IG1vZGlmaWVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBbcmF3KClde0BsaW5rIGVueW8uTW9kZWwjcmF3fS4gSWZcblx0KiBub3QgZGVmaW5lZCwgYWxsIGtleXMgZnJvbSB0aGUgW2F0dHJpYnV0ZXNde0BsaW5rIGVueW8uTW9kZWwjYXR0cmlidXRlc31cblx0KiBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gd2lsbCBiZSB1c2VkLlxuXHQqXG5cdCogQHNlZSBlbnlvLk1vZGVsLnJhd1xuXHQqIEBzZWUgZW55by5Nb2RlbC50b0pTT05cblx0KiBAdHlwZSB7U3RyaW5nW119XG5cdCogQGRlZmF1bHQgbnVsbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aW5jbHVkZUtleXM6IG51bGwsXG5cblx0LyoqXG5cdCogVGhlIGluaGVyaXRhYmxlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLiBUaGVzZSBzcGVjaWZ5IHRoZSBiZWhhdmlvciBvZiBwYXJ0aWN1bGFyXG5cdCogQVBJIGZlYXR1cmVzIG9mIHtAbGluayBlbnlvLk1vZGVsfS4gQW55IG1ldGhvZCB0aGF0IHVzZXMgdGhlc2Ugb3B0aW9ucyBtYXkgb3ZlcnJpZGVcblx0KiB0aGUgZGVmYXVsdCB2YWx1ZXMgaW4gaXRzIG93biBjb25maWd1cmF0aW9uIG9wdGlvbnMuIE5vdGUgdGhhdCBzZXR0aW5nIGFuXG5cdCogW29wdGlvbnMgaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gb24gYSBbc3Via2luZF17QGdsb3NzYXJ5IHN1YmtpbmR9IHdpbGwgcmVzdWx0IGluXG5cdCogdGhlIG5ldyB2YWx1ZXMnIGJlaW5nIG1lcmdlZCB3aXRoLS1ub3QgcmVwbGFjaW5nLS10aGVcblx0KiBbc3VwZXJraW5kJ3Nde0BnbG9zc2FyeSBzdXBlcmtpbmR9IG93biBgb3B0aW9uc2AuXG5cdCpcblx0KiBAdHlwZSB7ZW55by5Nb2RlbH5PcHRpb25zfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0b3B0aW9uczoge1xuXHRcdHNpbGVudDogZmFsc2UsXG5cdFx0Y29tbWl0OiBmYWxzZSxcblx0XHRwYXJzZTogZmFsc2UsXG5cdFx0ZmV0Y2g6IGZhbHNlXG5cdH0sXG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnQgW3N0YXRlKHMpXXtAbGluayBlbnlvLlN0YXRlc30gcG9zc2Vzc2VkIGJ5IHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9LlxuXHQqIFRoZXJlIGFyZSBsaW1pdGF0aW9ucyBhcyB0byB3aGljaCBzdGF0ZShzKSB0aGUgbW9kZWwgbWF5IHBvc3Nlc3MgYXQgYW55IGdpdmVuIHRpbWUuXG5cdCogQnkgZGVmYXVsdCwgYSBtb2RlbCBpcyBbTkVXXXtAbGluayBlbnlvLlN0YXRlcy5ORVd9IGFuZCBbQ0xFQU5de0BsaW5rIGVueW8uU3RhdGVzLkNMRUFOfS5cblx0KiBOb3RlIHRoYXQgdGhpcyBpcyAqKm5vdCoqIGEgW2JpbmRhYmxlXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSBwcm9wZXJ0eS5cblx0KlxuXHQqIEBzZWUgZW55by5TdGF0ZXNcblx0KiBAc2VlIGVueW8uU3RhdGVTdXBwb3J0XG5cdCogQHR5cGUge2VueW8uU3RhdGVzfVxuXHQqIEByZWFkb25seVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c3RhdHVzOiBTdGF0ZXMuTkVXIHwgU3RhdGVzLkNMRUFOLFxuXG5cdC8qKlxuXHQqIFRoZSB1bmlxdWUgYXR0cmlidXRlIGJ5IHdoaWNoIHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IG1heSBiZSBpbmRleGVkLiBUaGVcblx0KiBhdHRyaWJ1dGUncyB2YWx1ZSBtdXN0IGJlIHVuaXF1ZSBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZiB0aGUgc3BlY2lmaWMgbW9kZWxcblx0KiBba2luZF17QGdsb3NzYXJ5IGtpbmR9XG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICdpZCdcblx0KiBAcHVibGljXG5cdCovXG5cdHByaW1hcnlLZXk6ICdpZCcsXG5cblx0LyoqXG5cdCogSW5zcGVjdHMgYW5kIHJlc3RydWN0dXJlcyBpbmNvbWluZyBkYXRhIHByaW9yIHRvIFtzZXR0aW5nXXtAbGluayBlbnlvLk1vZGVsI3NldH0gaXQgb25cblx0KiB0aGUgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfS4gV2hpbGUgdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBkaXJlY3RseSwgaXQgaXMgbW9zdFxuXHQqIG9mdGVuIHVzZWQgdmlhIHRoZSBbcGFyc2Vde0BsaW5rIGVueW8uTW9kZWx+T3B0aW9ucy5wYXJzZX0gb3B0aW9uIGFuZCBleGVjdXRlZFxuXHQqIGF1dG9tYXRpY2FsbHksIGVpdGhlciBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb3Igd2hlbiBbZmV0Y2hlZF17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH1cblx0KiAob3IsIGluIHNvbWUgY2FzZXMsIGJvdGgpLiBUaGlzIGlzIGEgdmlydHVhbCBtZXRob2QgYW5kIG11c3QgYmUgcHJvdmlkZWQgdG8gc3VpdCBhXG5cdCogZ2l2ZW4gaW1wbGVtZW50YXRpb24ncyBuZWVkcy5cblx0KlxuXHQqIEBzZWUgZW55by5Nb2RlbH5PcHRpb25zLnBhcnNlXG5cdCogQHBhcmFtIHsqfSBkYXRhIC0gVGhlIGluY29taW5nIGRhdGEgdGhhdCBtYXkgbmVlZCB0byBiZSByZXN0cnVjdHVyZWQgb3IgcmVkdWNlZCBwcmlvciB0b1xuXHQqXHRiZWluZyBbc2V0XXtAbGluayBlbnlvLk1vZGVsI3NldH0gb24gdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0uXG5cdCogQHJldHVybnMge09iamVjdH0gVGhlIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBhcHBseSB0byB0aGVcblx0Klx0bW9kZWwgdmlhIFtzZXQoKV17QGxpbmsgZW55by5Nb2RlbCNzZXR9LlxuXHQqIEB2aXJ0dWFsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIGFuIFtPYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHRoYXQgcmVwcmVzZW50cyB0aGUgdW5kZXJseWluZyBkYXRhIHN0cnVjdHVyZVxuXHQqIG9mIHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9LiBUaGlzIGlzIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudFxuXHQqIFthdHRyaWJ1dGVzXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9IGFzIHdlbGwgYXMgdGhlXG5cdCogW2luY2x1ZGVLZXlzXXtAbGluayBlbnlvLk1vZGVsI2luY2x1ZGVLZXlzfS5cblx0KiBbQ29tcHV0ZWQgcHJvcGVydGllc117QGxpbmsgZW55by5Db21wdXRlZFN1cHBvcnR9IGFyZSAqKm5ldmVyKiogaW5jbHVkZWQuXG5cdCpcblx0KiBAc2VlIGVueW8uTW9kZWwuaW5jbHVkZUtleXNcblx0KiBAc2VlIGVueW8uTW9kZWwuYXR0cmlidXRlc1xuXHQqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHJlcHJlc2VudGluZyB0aGUgdW5kZXJseWluZ1xuXHQqXHRkYXRhIHN0cnVjdHVyZSBvZiB0aGUgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfS5cblx0KiBAcHVibGljXG5cdCovXG5cdHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbmMgPSB0aGlzLmluY2x1ZGVLZXlzXG5cdFx0XHQsIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzXG5cdFx0XHQsIGtleXMgPSBpbmMgfHwgT2JqZWN0LmtleXMoYXR0cnMpXG5cdFx0XHQsIGNweSA9IGluYz8gdXRpbHMub25seShpbmMsIGF0dHJzKTogdXRpbHMuY2xvbmUoYXR0cnMpO1xuXHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgZW50ID0gdGhpcy5nZXQoa2V5KTtcblx0XHRcdGlmICh0eXBlb2YgZW50ID09ICdmdW5jdGlvbicpIGNweVtrZXldID0gZW50LmNhbGwodGhpcyk7XG5cdFx0XHRlbHNlIGlmIChlbnQgJiYgZW50LnJhdykgY3B5W2tleV0gPSBlbnQucmF3KCk7XG5cdFx0XHRlbHNlIGNweVtrZXldID0gZW50O1xuXHRcdH0sIHRoaXMpO1xuXHRcdHJldHVybiBjcHk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgW0pTT05de0BnbG9zc2FyeSBKU09OfSBzZXJpYWxpemFibGUgW3JhdygpXXtAbGluayBlbnlvLk1vZGVsI3Jhd30gb3V0cHV0XG5cdCogb2YgdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0uIFdpbGwgYXV0b21hdGljYWxseSBiZSBleGVjdXRlZCBieVxuXHQqIFtKU09OLnBhcnNlKClde0BnbG9zc2FyeSBKU09OLnBhcnNlfS5cblx0KlxuXHQqIEBzZWUgZW55by5Nb2RlbC5yYXdcblx0KiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmV0dXJuIHZhbHVlIG9mIFtyYXcoKV17QGxpbmsgZW55by5Nb2RlbCNyYXd9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBATk9URTogQmVjYXVzZSB0aGlzIGlzIHN1cHBvc2VkIHRvIHJldHVybiBhIEpTT04gcGFyc2UtYWJsZSBvYmplY3Rcblx0XHRyZXR1cm4gdGhpcy5yYXcoKTtcblx0fSxcblxuXHQvKipcblx0KiBSZXN0b3JlcyBhbiBbYXR0cmlidXRlXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZS4gSWYgbm9cblx0KiBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkLCBhbGwgcHJldmlvdXMgdmFsdWVzIHdpbGwgYmUgcmVzdG9yZWQuXG5cdCpcblx0KiBAc2VlIGVueW8uTW9kZWwuc2V0XG5cdCogQHNlZSBlbnlvLk1vZGVsLnByZXZpb3VzXG5cdCogQHBhcmFtIHtTdHJpbmd9IFtwcm9wXSAtIFRoZSBbYXR0cmlidXRlXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9IHRvXG5cdCpcdFtyZXN0b3JlXXtAbGluayBlbnlvLk1vZGVsI3Jlc3RvcmV9LiBJZiBub3QgcHJvdmlkZWQsIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmVcblx0KiByZXN0b3JlZCB0byB0aGVpciBwcmV2aW91cyB2YWx1ZXMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVzdG9yZTogZnVuY3Rpb24gKHByb3ApIHtcblxuXHRcdC8vIHdlIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBpcyBmb3JjaWJseSBub3RpZmllZCAod2hlbiBwb3NzaWJsZSkgdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBiaW5kaW5ncyBvciBvdGhlciBvYnNlcnZlcnMgd2lsbCBrbm93IGl0IHJldHVybmVkIHRvIHRoYXQgdmFsdWVcblx0XHRpZiAocHJvcCkgdGhpcy5zZXQocHJvcCwgdGhpcy5wcmV2aW91c1twcm9wXSwge2ZvcmNlOiB0cnVlfSk7XG5cdFx0ZWxzZSB0aGlzLnNldCh0aGlzLnByZXZpb3VzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENvbW1pdHMgdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gdG8gYSBbc291cmNlIG9yIHNvdXJjZXNde0BsaW5rIGVueW8uTW9kZWwjc291cmNlfS5cblx0KiBBIG1vZGVsIGNhbm5vdCBiZSBbY29tbWl0dGVkXXtAbGluayBlbnlvLk1vZGVsI2NvbW1pdH0gaWYgaXQgaXMgaW4gYW5cblx0KiBbZXJyb3Jde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfSAoe0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LmlzRXJyb3J9KSBvclxuXHQqIFtidXN5XXtAbGluayBlbnlvLlN0YXRlcy5CVVNZfSAoe0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LmlzQnVzeX0pXG5cdCogW3N0YXRlXXtAbGluayBlbnlvLk1vZGVsI3N0YXR1c30uIFdoaWxlIGV4ZWN1dGluZywgaXQgd2lsbCBhZGQgdGhlXG5cdCogW0NPTU1JVFRJTkdde0BsaW5rIGVueW8uU3RhdGVzLkNPTU1JVFRJTkd9IGZsYWcgdG8gdGhlIG1vZGVsJ3Ncblx0KiBbc3RhdHVzXXtAbGluayBlbnlvLk1vZGVsI3N0YXR1c30uIE9uY2UgaXQgaGFzIGNvbXBsZXRlZCBleGVjdXRpb24sIGl0IHdpbGxcblx0KiByZW1vdmUgdGhpcyBmbGFnIChldmVuIGlmIGl0IGZhaWxzKS5cblx0KlxuXHQqIEBzZWUgZW55by5Nb2RlbC5jb21taXR0ZWRcblx0KiBAc2VlIGVueW8uTW9kZWwuc3RhdHVzXG5cdCogQHBhcmFtIHtlbnlvLk1vZGVsfkFjdGlvbk9wdGlvbnN9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb21taXQ6IGZ1bmN0aW9uIChvcHRzKSB7XG5cdFx0dmFyIG9wdGlvbnMsXG5cdFx0XHRzb3VyY2UsXG5cdFx0XHRpdCA9IHRoaXM7XG5cblx0XHQvLyBpZiB0aGUgY3VycmVudCBzdGF0dXMgaXMgbm90IG9uZSBvZiB0aGUgZXJyb3Igb3IgYnVzeSBzdGF0ZXMgd2UgY2FuIGNvbnRpbnVlXG5cdFx0aWYgKCEodGhpcy5zdGF0dXMgJiAoU3RhdGVzLkVSUk9SIHwgU3RhdGVzLkJVU1kpKSkge1xuXG5cdFx0XHQvLyBpZiB0aGVyZSB3ZXJlIG9wdGlvbnMgcGFzc2VkIGluIHdlIGNvcHkgdGhlbSBxdWlja2x5IHNvIHRoYXQgd2UgY2FuIGhpamFja1xuXHRcdFx0Ly8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIG1ldGhvZHMgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWxzIHRvIHVzZSBsYXRlclxuXHRcdFx0b3B0aW9ucyA9IG9wdHMgPyB1dGlscy5jbG9uZShvcHRzLCB0cnVlKSA6IHt9O1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgd2Uga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VyY2VzIHdlJ3JlIHJlcXVlc3Rpbmdcblx0XHRcdHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IHRoaXMuc291cmNlO1xuXHRcdFx0aWYgKHNvdXJjZSAmJiAoKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB8fCBzb3VyY2UgPT09IHRydWUpKSB7XG5cdFx0XHRcdHRoaXMuX3dhaXRpbmcgPSBzb3VyY2UubGVuZ3RoID8gc291cmNlLnNsaWNlKCkgOiBPYmplY3Qua2V5cyhlbnlvLnNvdXJjZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoc291cmNlLCByZXMpIHtcblx0XHRcdFx0aXQuY29tbWl0dGVkKG9wdHMsIHJlcywgc291cmNlKTtcblx0XHRcdH07XG5cblx0XHRcdG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbiAoc291cmNlLCByZXMpIHtcblx0XHRcdFx0aXQuZXJyb3JlZCgnQ09NTUlUVElORycsIG9wdHMsIHJlcywgc291cmNlKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIHNldCB0aGUgc3RhdGVcblx0XHRcdHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXMgfCBTdGF0ZXMuQ09NTUlUVElORztcblxuXHRcdFx0Ly8gbm93IHBhc3MgdGhpcyBvbiB0byB0aGUgc291cmNlIHRvIGV4ZWN1dGUgYXMgaXQgc2VlcyBmaXRcblx0XHRcdFNvdXJjZS5leGVjdXRlKCdjb21taXQnLCB0aGlzLCBvcHRpb25zKTtcblx0XHR9IGVsc2UgdGhpcy5lcnJvcmVkKHRoaXMuc3RhdHVzLCBvcHRzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEZldGNoZXMgdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gZnJvbSBhXG5cdCogW3NvdXJjZSBvciBzb3VyY2VzXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0uIEEgbW9kZWwgY2Fubm90IGJlXG5cdCogW2ZldGNoZWRde0BsaW5rIGVueW8uTW9kZWwjZmV0Y2h9IGlmIGl0IGlzIGluIGFuXG5cdCogW2Vycm9yXXtAbGluayBlbnlvLlN0YXRlcy5FUlJPUn0gKHtAbGluayBlbnlvLlN0YXRlU3VwcG9ydC5pc0Vycm9yfSkgb3Jcblx0KiBbYnVzeV17QGxpbmsgZW55by5TdGF0ZXMuQlVTWX0gKHtAbGluayBlbnlvLlN0YXRlU3VwcG9ydC5pc0J1c3l9KVxuXHQqIFtzdGF0ZV17QGxpbmsgZW55by5Nb2RlbCNzdGF0dXN9LiBXaGlsZSBleGVjdXRpbmcsIGl0IHdpbGwgYWRkIHRoZVxuXHQqIFtGRVRDSElOR117QGxpbmsgZW55by5TdGF0ZXMuRkVUQ0hJTkd9IGZsYWcgdG8gdGhlIG1vZGVsJ3Ncblx0KiBbc3RhdHVzXXtAbGluayBlbnlvLk1vZGVsI3N0YXR1c30uIE9uY2UgaXQgaGFzIGNvbXBsZXRlZCBleGVjdXRpb24sIGl0IHdpbGxcblx0KiByZW1vdmUgdGhpcyBmbGFnIChldmVuIGlmIGl0IGZhaWxzKS5cblx0KlxuXHQqIEBzZWUgZW55by5Nb2RlbC5mZXRjaGVkXG5cdCogQHNlZSBlbnlvLk1vZGVsLnN0YXR1c1xuXHQqIEBwYXJhbSB7ZW55by5Nb2RlbH5BY3Rpb25PcHRpb25zfSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmV0Y2g6IGZ1bmN0aW9uIChvcHRzKSB7XG5cdFx0dmFyIG9wdGlvbnMsXG5cdFx0XHRzb3VyY2UsXG5cdFx0XHRpdCA9IHRoaXM7XG5cblx0XHQvLyBpZiB0aGUgY3VycmVudCBzdGF0dXMgaXMgbm90IG9uZSBvZiB0aGUgZXJyb3Igb3IgYnVzeSBzdGF0ZXMgd2UgY2FuIGNvbnRpbnVlXG5cdFx0aWYgKCEodGhpcy5zdGF0dXMgJiAoU3RhdGVzLkVSUk9SIHwgU3RhdGVzLkJVU1kpKSkge1xuXG5cdFx0XHQvLyBpZiB0aGVyZSB3ZXJlIG9wdGlvbnMgcGFzc2VkIGluIHdlIGNvcHkgdGhlbSBxdWlja2x5IHNvIHRoYXQgd2UgY2FuIGhpamFja1xuXHRcdFx0Ly8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIG1ldGhvZHMgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWxzIHRvIHVzZSBsYXRlclxuXHRcdFx0b3B0aW9ucyA9IG9wdHMgPyB1dGlscy5jbG9uZShvcHRzLCB0cnVlKSA6IHt9O1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgd2Uga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VyY2VzIHdlJ3JlIHJlcXVlc3Rpbmdcblx0XHRcdHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IHRoaXMuc291cmNlO1xuXHRcdFx0aWYgKHNvdXJjZSAmJiAoKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB8fCBzb3VyY2UgPT09IHRydWUpKSB7XG5cdFx0XHRcdHRoaXMuX3dhaXRpbmcgPSBzb3VyY2UubGVuZ3RoID8gc291cmNlLnNsaWNlKCkgOiBPYmplY3Qua2V5cyhlbnlvLnNvdXJjZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoc291cmNlLCByZXMpIHtcblx0XHRcdFx0aXQuZmV0Y2hlZChvcHRzLCByZXMsIHNvdXJjZSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRvcHRpb25zLmVycm9yID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVzKSB7XG5cdFx0XHRcdGl0LmVycm9yZWQoJ0ZFVENISU5HJywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBzdGF0ZVxuXHRcdFx0dGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1cyB8IFN0YXRlcy5GRVRDSElORztcblxuXHRcdFx0Ly8gbm93IHBhc3MgdGhpcyBvbiB0byB0aGUgc291cmNlIHRvIGV4ZWN1dGUgYXMgaXQgc2VlcyBmaXRcblx0XHRcdFNvdXJjZS5leGVjdXRlKCdmZXRjaCcsIHRoaXMsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB0aGlzLmVycm9yZWQodGhpcy5zdGF0dXMsIG9wdHMpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogRGVzdHJveXMgdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0uIEJ5IGRlZmF1bHQsIHRoZSBtb2RlbCB3aWxsIG9ubHlcblx0KiBiZSBbZGVzdHJveWVkXXtAZ2xvc3NhcnkgZGVzdHJveX0gaW4gdGhlIGNsaWVudC4gVG8gZXhlY3V0ZSB3aXRoIGFcblx0KiBbc291cmNlIG9yIHNvdXJjZXNde0BsaW5rIGVueW8uTW9kZWwjc291cmNlfSwgZWl0aGVyIHRoZVxuXHQqIFtjb21taXQgZGVmYXVsdCBvcHRpb25de0BsaW5rIGVueW8uTW9kZWwjb3B0aW9uc30gbXVzdCBiZSBgdHJ1ZWAgb3IgYVxuXHQqIGBzb3VyY2VgIHByb3BlcnR5IG11c3QgYmUgZXhwbGljaXRseSBwcm92aWRlZCBpbiB0aGUgYG9wdHNgIHBhcmFtZXRlci5cblx0KiBBIG1vZGVsIGNhbm5vdCBiZSBkZXN0cm95ZWQgKHVzaW5nIGEgc291cmNlKSBpZiBpdCBpcyBpbiBhblxuXHQqIFtlcnJvcl17QGxpbmsgZW55by5TdGF0ZXMuRVJST1J9ICh7QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuaXNFcnJvcn0pXG5cdCogb3IgW2J1c3lde0BsaW5rIGVueW8uU3RhdGVzLkJVU1l9ICh7QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuaXNCdXN5fSlcblx0KiBbc3RhdGVde0BsaW5rIGVueW8uTW9kZWwjc3RhdHVzfS4gV2hpbGUgZXhlY3V0aW5nLCBpdCB3aWxsIGFkZCB0aGVcblx0KiBbREVTVFJPWUlOR117QGxpbmsgZW55by5TdGF0ZXMuREVTVFJPWUlOR30gZmxhZyB0byB0aGUgbW9kZWwnc1xuXHQqIFtzdGF0dXNde0BsaW5rIGVueW8uTW9kZWwjc3RhdHVzfS4gT25jZSBpdCBoYXMgY29tcGxldGVkIGV4ZWN1dGlvbiwgaXRcblx0KiB3aWxsIHJlbW92ZSB0aGlzIGZsYWcgKGV2ZW4gaWYgaXQgZmFpbHMpLlxuXHQqXG5cdCogQHNlZSBlbnlvLk1vZGVsLnN0YXR1c1xuXHQqIEBwYXJhbSB7ZW55by5Nb2RlbH5BY3Rpb25PcHRpb25zfSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKG9wdHMpIHtcblx0XHR2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5taXhpbih7fSwgW3RoaXMub3B0aW9ucywgb3B0c10pIDogdGhpcy5vcHRpb25zLFxuXHRcdFx0aXQgPSB0aGlzLFxuXHRcdFx0aWR4O1xuXG5cdFx0Ly8gdGhpcyBiZWNvbWVzIGFuIChwb3RlbnRpYWxseSkgYXN5bmMgb3BlcmF0aW9uIGlmIHdlIGFyZSBjb21taXR0aW5nIHRoaXMgZGVzdHJveVxuXHRcdC8vIHRvIGEgc291cmNlIGFuZCBpdHMga2luZCBvZiB0cmlja3kgdG8gZmlndXJlIG91dCBiZWNhdXNlIHRoZXJlIGFyZSBzZXZlcmFsIHdheXNcblx0XHQvLyBpdCBjb3VsZCBiZSBmbGFnZ2VkIHRvIGRvIHRoaXNcblxuXHRcdGlmIChvcHRpb25zLmNvbW1pdCB8fCBvcHRpb25zLnNvdXJjZSkge1xuXG5cdFx0XHQvLyBpZiB0aGUgY3VycmVudCBzdGF0dXMgaXMgbm90IG9uZSBvZiB0aGUgZXJyb3Igc3RhdGVzIHdlIGNhbiBjb250aW51ZVxuXHRcdFx0aWYgKCEodGhpcy5zdGF0dXMgJiAoU3RhdGVzLkVSUk9SIHwgU3RhdGVzLkJVU1kpKSkge1xuXG5cdFx0XHRcdC8vIHJlbWFwIHRvIHRoZSBvcmlnaW5hbHNcblx0XHRcdFx0b3B0aW9ucyA9IG9wdHMgPyB1dGlscy5jbG9uZShvcHRzLCB0cnVlKSA6IHt9O1xuXG5cdFx0XHRcdG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlcykge1xuXG5cdFx0XHRcdFx0aWYgKGl0Ll93YWl0aW5nKSB7XG5cdFx0XHRcdFx0XHRpZHggPSBpdC5fd2FpdGluZy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAobG4gaW5zdGFuY2VvZiBTb3VyY2UgPyBsbi5uYW1lIDogbG4pID09IHNvdXJjZTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYgKGlkeCA+IC0xKSBpdC5fd2FpdGluZy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcdGlmICghaXQuX3dhaXRpbmcubGVuZ3RoKSBpdC5fd2FpdGluZyA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY29udGludWUgdGhlIG9wZXJhdGlvbiB0aGlzIHRpbWUgd2l0aCBjb21taXQgZmFsc2UgZXhwbGljaXRseVxuXHRcdFx0XHRcdGlmICghaXQuX3dhaXRpbmcpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tbWl0ID0gb3B0aW9ucy5zb3VyY2UgPSBudWxsO1xuXHRcdFx0XHRcdFx0aXQuZGVzdHJveShvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdHMgJiYgb3B0cy5zdWNjZXNzKSBvcHRzLnN1Y2Nlc3ModGhpcywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbiAoc291cmNlLCByZXMpIHtcblxuXHRcdFx0XHRcdGlmIChpdC5fd2FpdGluZykge1xuXHRcdFx0XHRcdFx0aWR4ID0gaXQuX3dhaXRpbmcuZmluZEluZGV4KGZ1bmN0aW9uIChsbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGxuIGluc3RhbmNlb2YgU291cmNlID8gbG4ubmFtZSA6IGxuKSA9PSBzb3VyY2U7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmIChpZHggPiAtMSkgaXQuX3dhaXRpbmcuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XHRpZiAoIWl0Ll93YWl0aW5nLmxlbmd0aCkgaXQuX3dhaXRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNvbnRpbnVlIHRoZSBvcGVyYXRpb24gdGhpcyB0aW1lIHdpdGggY29tbWl0IGZhbHNlIGV4cGxpY2l0bHlcblx0XHRcdFx0XHRpZiAoIWl0Ll93YWl0aW5nKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbW1pdCA9IG9wdGlvbnMuc291cmNlID0gbnVsbDtcblx0XHRcdFx0XHRcdGl0LmRlc3Ryb3kob3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gd2UgZG9uJ3QgYm90aGVyIHNldHRpbmcgdGhlIGVycm9yIHN0YXRlIGlmIHdlIGFyZW4ndCB3YWl0aW5nIGJlY2F1c2UgaXRcblx0XHRcdFx0XHQvLyB3aWxsIGJlIGNsZWFyZWQgdG8gREVTVFJPWUVEIGFuZCBpdCB3b3VsZCBiZSBwb2ludGxlc3Ncblx0XHRcdFx0XHRlbHNlIHRoaXMuZXJyb3JlZCgnREVTVFJPWUlORycsIG9wdHMsIHJlcywgc291cmNlKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzIHwgU3RhdGVzLkRFU1RST1lJTkc7XG5cblx0XHRcdFx0U291cmNlLmV4ZWN1dGUoJ2Rlc3Ryb3knLCB0aGlzLCBvcHRpb25zKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgJiBTdGF0ZXMuRVJST1IpIHRoaXMuZXJyb3JlZCh0aGlzLnN0YXR1cywgb3B0cyk7XG5cblx0XHRcdC8vIHdlIGRvbid0IGFsbG93IHRoZSBkZXN0cm95IHRvIHRha2UgcGxhY2UgYW5kIHdlIGRvbid0IGZvcmNpYmx5IGJyZWFrLWRvd25cblx0XHRcdC8vIHRoZSBjb2xsZWN0aW9uIGVycmFudGx5IHNvIHRoZXJlIGlzIGFuIG9wcG9ydHVuaXkgdG8gcmVzb2x2ZSB0aGUgaXNzdWVcblx0XHRcdC8vIGJlZm9yZSB3ZSBsb3NlIGFjY2VzcyB0byB0aGUgY29sbGVjdGlvbidzIGNvbnRlbnQhXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblxuXHRcdC8vIHdlIGZsYWcgdGhpcyBlYXJseSBzbyBvYmplY3RzIHRoYXQgcmVjZWl2ZSBhbiBldmVudCBhbmQgcHJvY2VzcyBpdFxuXHRcdC8vIGNhbiBvcHRpb25hbGx5IGNoZWNrIHRoaXMgdG8gc3VwcG9ydCBmYXN0ZXIgY2xlYW51cCBpbiBzb21lIGNhc2VzXG5cdFx0Ly8gZS5nLiBDb2xsZWN0aW9uL1N0b3JlIGRvbid0IG5lZWQgdG8gcmVtb3ZlIGxpc3RlbmVycyBiZWNhdXNlIGl0IHdpbGxcblx0XHQvLyBiZSBkb25lIGluIGEgbXVjaCBxdWlja2VyIHdheSBhbHJlYWR5XG5cdFx0dGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdHRoaXMuc3RhdHVzID0gU3RhdGVzLkRFU1RST1lFRDtcblx0XHR0aGlzLnVuc2lsZW5jZSh0cnVlKS5lbWl0KCdkZXN0cm95Jyk7XG5cdFx0dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0XHR0aGlzLnJlbW92ZUFsbE9ic2VydmVycygpO1xuXG5cdFx0Ly8gaWYgdGhpcyBkb2VzIG5vdCBoYXZlIHRoZSB0aGUgYmF0Y2hpbmcgZmxhZyAodGhhdCB3b3VsZCBiZSBzZXQgYnkgYSBjb2xsZWN0aW9uKVxuXHRcdC8vIHRoZW4gd2UgbmVlZCB0byBkbyB0aGUgZGVmYXVsdCBvZiByZW1vdmluZyBpdCBmcm9tIHRoZSBzdG9yZVxuXHRcdGlmICghb3B0cyB8fCAhb3B0cy5iYXRjaGluZykgdGhpcy5zdG9yZS5yZW1vdmUodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IG9yIHBhdGguIElmIHRoZSBwcm9wZXJ0eSBpcyBhXG5cdCogW2NvbXB1dGVkIHByb3BlcnR5XXtAbGluayBlbnlvLkNvbXB1dGVkU3VwcG9ydC5jb21wdXRlZH0sIHRoZW4gaXQgd2lsbCByZXR1cm5cblx0KiB0aGF0IHZhbHVlOyBvdGhlcndpc2UsIGl0IHdpbGwgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZnJvbSB0aGVcblx0KiBbYXR0cmlidXRlcyBoYXNoXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBUaGUgcHJvcGVydHkgdG8gcmV0cmlldmUuXG5cdCogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBmb3IgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBvciBwYXRoLCBvciBgdW5kZWZpbmVkYCBpZlxuXHQqIGl0IGNhbm5vdCBiZSBmb3VuZCBvciBkb2VzIG5vdCBleGlzdC5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0NvbXB1dGVkKHBhdGgpID8gdGhpcy5fZ2V0Q29tcHV0ZWQocGF0aCkgOiB0aGlzLmF0dHJpYnV0ZXNbcGF0aF07XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgcmVxdWVzdGVkIGBwYXRoYCBvciBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gb2YgcHJvcGVydGllcyBvbiB0aGVcblx0KiBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9LiBQcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIHRoZVxuXHQqIFthdHRyaWJ1dGVzIGhhc2hde0BsaW5rIGVueW8uTW9kZWwjYXR0cmlidXRlc30gYW5kIGFyZSByZXRyaWV2YWJsZSB2aWFcblx0KiBbZ2V0KClde0BsaW5rIGVueW8uTW9kZWwjZ2V0fS4gSWYgcHJvcGVydGllcyB3ZXJlIHVwZGF0ZWQgYW5kIHRoZSBgc2lsZW50YFxuXHQqIG9wdGlvbiBpcyBub3QgYHRydWVgLCB0aGlzIG1ldGhvZCB3aWxsIGVtaXQgYSBgY2hhbmdlYCBldmVudCwgYXMgd2VsbCBhc1xuXHQqIGluZGl2aWR1YWwgW25vdGlmaWNhdGlvbnNde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm5vdGlmeX0gZm9yIHRoZVxuXHQqIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG1vZGlmaWVkLlxuXHQqXG5cdCogQGZpcmVzIGVueW8uTW9kZWwjY2hhbmdlXG5cdCogQHNlZSBlbnlvLk9ic2VydmVyU3VwcG9ydFxuXHQqIEBzZWUgZW55by5CaW5kaW5nU3VwcG9ydFxuXHQqIEBwYXJhbSB7KFN0cmluZ3xPYmplY3QpfSBwYXRoIC0gRWl0aGVyIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIGEgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9XG5cdCpcdG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBzZXQuXG5cdCogQHBhcmFtIHsoKnxlbnlvLk1vZGVsfk9wdGlvbnMpfSBpcyBJZiBgcGF0aGAgaXMgYSBbc3RyaW5nXXtAZ2xvc3NhcnkgU3RyaW5nfSxcblx0KiB0aGlzIHNob3VsZCBiZSB0aGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHk7IG90aGVyd2lzZSwgaXQgc2hvdWxkIGJlXG5cdCogYW4gb3B0aW9uYWwgaGFzaCBvZiBhdmFpbGFibGUgW2NvbmZpZ3VyYXRpb24gb3B0aW9uc117QGxpbmsgZW55by5Nb2RlbH5PcHRpb25zfS5cblx0KiBAcGFyYW0ge2VueW8uTW9kZWx+T3B0aW9uc30gW29wdHNdIC0gSWYgYHBhdGhgIGlzIGEgc3RyaW5nLCB0aGlzIHNob3VsZCBiZSB0aGVcblx0KiBvcHRpb25hbCBoYXNoIG9mIGF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM7IG90aGVyd2lzZSwgaXQgd2lsbCBub3QgYmUgdXNlZC5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXQ6IGZ1bmN0aW9uIChwYXRoLCBpcywgb3B0cykge1xuXHRcdGlmICghdGhpcy5kZXN0cm95ZWQpIHtcblxuXHRcdFx0dmFyIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFuZ2VkLFxuXHRcdFx0XHRpbmNvbWluZyxcblx0XHRcdFx0Zm9yY2UsXG5cdFx0XHRcdHNpbGVudCxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0Y29tbWl0LFxuXHRcdFx0XHRmZXRjaGVkO1xuXG5cdFx0XHQvLyB0aGUgZGVmYXVsdCBjYXNlIGZvciB0aGlzIHNldHRlciBpcyBhY2NlcHRpbmcgYW4gb2JqZWN0IG9mIGtleS0+dmFsdWUgcGFpcnNcblx0XHRcdC8vIHRvIGFwcGx5IHRvIHRoZSBtb2RlbCBpbiB3aGljaCBjYXNlIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBvcHRpb25hbFxuXHRcdFx0Ly8gY29uZmlndXJhdGlvbiBoYXNoXG5cdFx0XHRpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aW5jb21pbmcgPSBwYXRoO1xuXHRcdFx0XHRvcHRzID0gb3B0cyB8fCBpcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGhhdmUgYSBzaW5nbGUgcGF0aCBoZXJlIHdlIGZsdWIgaXQgc28gaXQgd2lsbCBrZWVwIG9uXG5cdFx0XHQvLyBnb2luZyBhcyBleHBlY3RlZFxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGluY29taW5nID0ge307XG5cdFx0XHRcdGluY29taW5nW3BhdGhdID0gaXM7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkIHNldHRlcnMgdGhhdCBhbGxvd2VkIHRoZSB0aGlyZFxuXHRcdFx0Ly8gcGFyYW1ldGVyIHRvIGJlIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0byBmb3JjZSBub3RpZmljYXRpb24gb2Zcblx0XHRcdC8vIGNoYW5nZSBldmVuIGlmIHRoZXJlIHdhcyBhbnlcblx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XG5cdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0b3B0cyA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRzID0gb3B0cyA/IHV0aWxzLm1peGluKHt9LCBbb3B0aW9ucywgb3B0c10pIDogb3B0aW9ucztcblx0XHRcdHNpbGVudCA9IG9wdHMuc2lsZW50O1xuXHRcdFx0Zm9yY2UgPSBmb3JjZSB8fCBvcHRzLmZvcmNlO1xuXHRcdFx0Y29tbWl0ID0gb3B0cy5jb21taXQ7XG5cdFx0XHRmZXRjaGVkID0gb3B0cy5mZXRjaGVkO1xuXG5cdFx0XHRmb3IgKGtleSBpbiBpbmNvbWluZykge1xuXHRcdFx0XHR2YWx1ZSA9IGluY29taW5nW2tleV07XG5cblx0XHRcdFx0aWYgKHZhbHVlICE9PSBhdHRyc1trZXldIHx8IGZvcmNlKSB7XG5cdFx0XHRcdFx0Ly8gdG8gZW5zdXJlIHdlIGhhdmUgYW4gb2JqZWN0IHRvIHdvcmsgd2l0aFxuXHRcdFx0XHRcdC8vIG5vdGUgdGhhdCB3ZSBjaGVjayBpbnNpZGUgdGhpcyBsb29wIHNvIHdlIGRvbid0IGhhdmUgdG8gZXhhbWluZSBrZXlzXG5cdFx0XHRcdFx0Ly8gbGF0ZXIgb25seSB0aGUgbG9jYWwgdmFyaWFibGUgY2hhbmdlZFxuXHRcdFx0XHRcdGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQgfHwgKHRoaXMuY2hhbmdlZCA9IHt9KTtcblx0XHRcdFx0XHQvL3N0b3JlIHRoZSBwcmV2aW91cyBhdHRyIHZhbHVlXG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c1trZXldID0gYXR0cnNba2V5XTtcblx0XHRcdFx0XHQvL3NldCBuZXcgdmFsdWVcblx0XHRcdFx0XHRjaGFuZ2VkW2tleV0gPSBhdHRyc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGNoYW5nZWQpIHtcblxuXHRcdFx0XHQvLyB3ZSBhZGQgZGlydHkgYXMgYSB2YWx1ZSBvZiB0aGUgc3RhdHVzIGJ1dCBjbGVhciB0aGUgQ0xFQU4gYml0IGlmIGl0XG5cdFx0XHRcdC8vIHdhcyBzZXQgLSB0aGlzIHdvdWxkIGFsbG93IGl0IHRvIGJlIGluIHRoZSBFUlJPUiBzdGF0ZSBhbmQgTkVXIGFuZCBESVJUWVxuXHRcdFx0XHRpZiAoIWZldGNoZWQpIHRoaXMuc3RhdHVzID0gKHRoaXMuc3RhdHVzIHwgU3RhdGVzLkRJUlRZKSAmIH5TdGF0ZXMuQ0xFQU47XG5cblx0XHRcdFx0aWYgKCFzaWxlbnQpIHRoaXMuZW1pdCgnY2hhbmdlJywgY2hhbmdlZCwgdGhpcyk7XG5cblx0XHRcdFx0aWYgKGNvbW1pdCAmJiAhZmV0Y2hlZCkgdGhpcy5jb21taXQob3B0cyk7XG5cblx0XHRcdFx0Ly8gcmVzZXQgdmFsdWUgc28gc3Vic2VxdWVudCBjaGFuZ2VzIHdvbid0IGJlIGFkZGVkIHRvIHRoaXMgY2hhbmdlLXNldFxuXHRcdFx0XHR0aGlzLmNoYW5nZWQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEEgYml0IG9mIGhhY2tlcnkgdG8gZmFjYWRlIHRoZSBub3JtYWwgW2dldHRlcl17QGxpbmsgZW55by5Db21wdXRlZFN1cHBvcnQuZ2V0fS4gTm90ZSB0aGF0XG5cdCogd2UgcGFzcyBhbiBhcmJpdHJhcnkgc3VwZXItbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSByZXR1cm5zIGB1bmRlZmluZWRgLCB3aGljaCBpc1xuXHQqIGNvbnNpc3RlbnQgd2l0aCB0aGlzIHVzZSBjYXNlIGFuZCBpdHMgaW50ZW5kZWQgcHVycG9zZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9nZXRDb21wdXRlZDogQ29tcHV0ZWRTdXBwb3J0LmdldC5mbihmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pLFxuXG5cdC8qKlxuXHQqIEluaXRpYWxpemVzIHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9LiBVbmxpa2Ugc29tZSBtZXRob2RzLCB0aGUgcGFyYW1ldGVycyBhcmUgbm90XG5cdCogaW50ZXJjaGFuZ2VhYmxlLiBJZiB5b3UgYXJlIG5vdCB1c2luZyBhIHBhcnRpY3VsYXIgKG9wdGlvbmFsKSBwYXJhbWV0ZXIsIHBhc3MgaW4gYG51bGxgLlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IFthdHRyc10gLSBPcHRpb25hbGx5IGluaXRpYWxpemUgdGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gd2l0aCBzb21lXG5cdCpcdFthdHRyaWJ1dGVzXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9LlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIC0gUHJvcGVydGllcyB0byBhcHBseSBkaXJlY3RseSB0byB0aGUgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBhbmRcblx0Klx0bm90IHRoZSBbYXR0cmlidXRlcyBoYXNoXXtAbGluayBlbnlvLk1vZGVsI2F0dHJpYnV0ZXN9LiBJZiB0aGVzZSBwcm9wZXJ0aWVzIGNvbnRhaW4gYW5cblx0Klx0YG9wdGlvbnNgIHByb3BlcnR5IChhIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSkgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCBleGlzdGluZ1xuXHQqXHRbb3B0aW9uc117QGxpbmsgZW55by5Nb2RlbCNvcHRpb25zfS5cblx0KiBAcGFyYW0ge2VueW8uTW9kZWx+T3B0aW9uc30gW29wdHNdIC0gVGhpcyBpcyBhIG9uZS10aW1lIFtvcHRpb25zIGhhc2hde0BsaW5rIGVueW8uTW9kZWx+T3B0aW9uc30gdGhhdFxuXHQqXHRpcyBvbmx5IHVzZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uIGFuZCBub3QgYXBwbGllZCBhcyBkZWZhdWx0cy5cblx0KiBAcHVibGljXG5cdCovXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXR0cnMsIHByb3BzLCBvcHRzKSB7XG5cblx0XHQvLyBpbiBjYXNlcyB3aGVyZSB0aGVyZSBpcyBhbiBvcHRpb25zIGhhc2ggcHJvdmlkZWQgaW4gdGhlIF9wcm9wc18gcGFyYW1cblx0XHQvLyB3ZSBuZWVkIHRvIGludGVncmF0ZSBpdCBtYW51YWxseS4uLlxuXHRcdGlmIChwcm9wcyAmJiBwcm9wcy5vcHRpb25zKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB1dGlscy5taXhpbih7fSwgW3RoaXMub3B0aW9ucywgcHJvcHMub3B0aW9uc10pO1xuXHRcdFx0ZGVsZXRlIHByb3BzLm9wdGlvbnM7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIF9vcHRzXyBwYXJhbWV0ZXIgaXMgYSBvbmUtaGl0IG9wdGlvbnMgaGFzaCBpdCBkb2VzIG5vdCBsZWF2ZVxuXHRcdC8vIGJlaGluZCBpdHMgdmFsdWVzIGFzIGRlZmF1bHQgb3B0aW9ucy4uLlxuXHRcdG9wdHMgPSBvcHRzPyB1dGlscy5taXhpbih7fSwgW3RoaXMub3B0aW9ucywgb3B0c10pOiB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBnbyBhaGVhZCBhbmQgbWl4IGFsbCBvZiB0aGUgcHJvcGVydGllcyBpblxuXHRcdHByb3BzICYmIHV0aWxzLm1peGluKHRoaXMsIHByb3BzKTtcblxuXHRcdHZhciBub0FkZCA9IG9wdHMubm9BZGRcblx0XHRcdCwgY29tbWl0ID0gb3B0cy5jb21taXRcblx0XHRcdCwgcGFyc2UgPSBvcHRzLnBhcnNlXG5cdFx0XHQsIGZldGNoID0gdGhpcy5vcHRpb25zLmZldGNoXG5cdFx0XHQsIGRlZmF1bHRzO1xuXG5cdFx0Ly8gZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzICYmICh0eXBlb2YgdGhpcy5kZWZhdWx0cyA9PSAnZnVuY3Rpb24nPyB0aGlzLmRlZmF1bHRzKGF0dHJzLCBvcHRzKTogdGhpcy5kZWZhdWx0cyk7XG5cdFx0ZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzICYmIHR5cGVvZiB0aGlzLmRlZmF1bHRzID09ICdmdW5jdGlvbic/IHRoaXMuZGVmYXVsdHMoYXR0cnMsIG9wdHMpOiBudWxsO1xuXG5cdFx0Ly8gZW5zdXJlIHdlIGhhdmUgYSB1bmlxdWUgaWRlbnRpZmllciB0aGF0IGNvdWxkIHBvdGVudGlhbGx5XG5cdFx0Ly8gYmUgdXNlZCBpbiByZW1vdGUgc3lzdGVtc1xuXHRcdHRoaXMuZXVpZCA9IHRoaXMuZXVpZCB8fCB1dGlscy51aWQoJ20nKTtcblxuXHRcdC8vIGlmIG5lY2Vzc2FyeSB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBpbmNvbWluZyBhdHRyaWJ1dGVzXG5cdFx0YXR0cnMgPSBhdHRycz8gcGFyc2U/IHRoaXMucGFyc2UoYXR0cnMpOiBhdHRyczogbnVsbDtcblxuXHRcdC8vIGVuc3VyZSB3ZSBoYXZlIHRoZSB1cGRhdGVkIGF0dHJpYnV0ZXNcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM/IGRlZmF1bHRzPyB1dGlscy5taXhpbih7fSwgW2RlZmF1bHRzLCB0aGlzLmF0dHJpYnV0ZXNdKTogdXRpbHMuY2xvbmUodGhpcy5hdHRyaWJ1dGVzLCB0cnVlKTogZGVmYXVsdHM/IHV0aWxzLmNsb25lKGRlZmF1bHRzLCB0cnVlKToge307XG5cdFx0YXR0cnMgJiYgdXRpbHMubWl4aW4odGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG5cdFx0dGhpcy5wcmV2aW91cyA9IHV0aWxzLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG5cblx0XHQvLyBub3cgd2UgbmVlZCB0byBlbnN1cmUgd2UgaGF2ZSBhIHN0b3JlIGFuZCByZWdpc3RlciB3aXRoIGl0XG5cdFx0dGhpcy5zdG9yZSA9IHRoaXMuc3RvcmUgfHwgU3RvcmU7XG5cblx0XHQvLyBAVE9ETzogVGhlIGlkZWEgaGVyZSBpcyB0aGF0IHdoZW4gYmF0Y2ggaW5zdGFuY2luZyByZWNvcmRzIGEgY29sbGVjdGlvblxuXHRcdC8vIHNob3VsZCBiZSBpbnRlbGxpZ2VudCBlbm91Z2ggdG8gYXZvaWQgZG9pbmcgZWFjaCBpbmRpdmlkdWFsbHkgb3IgaW4gc29tZVxuXHRcdC8vIGNhc2VzIGl0IG1heSBiZSB1c2VmdWwgdG8gaGF2ZSBhIHJlY29yZCB0aGF0IGlzIG5ldmVyIGFkZGVkIHRvIGEgc3RvcmU/XG5cdFx0aWYgKCFub0FkZCkgdGhpcy5zdG9yZS5hZGQodGhpcywgb3B0cyk7XG5cblx0XHRjb21taXQgJiYgdGhpcy5jb21taXQoKTtcblx0XHRmZXRjaCAmJiB0aGlzLmZldGNoKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogT3ZlcmxvYWRlZC4gV2UgZnVubmVsIGFyYml0cmFyeSBub3RpZmljYXRpb24gdXBkYXRlcyB0aHJvdWdoIGhlcmUsIGFzIHRoaXNcblx0KiBpcyBmYXN0ZXIgdGhhbiB1c2luZyB0aGUgYnVpbHQtaW4gbm90aWZpY2F0aW9uIHVwZGF0ZXMgZm9yIGJhdGNoIG9wZXJhdGlvbnMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlbWl0OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZSwgcHJvcHMpIHtcblx0XHRcdGlmIChlID09ICdjaGFuZ2UnICYmIHByb3BzICYmIHRoaXMuaXNPYnNlcnZpbmcoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHRoaXMubm90aWZ5KGtleSwgdGhpcy5wcmV2aW91c1trZXldLCBwcm9wc1trZXldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBPdmVybG9hZGVkIHRvIGFsaWFzIHRoZSAoYWxzbyBvdmVybG9hZGVkKSBbZW1pdCgpXXtAbGluayBlbnlvLk1vZGVsI2VtaXR9IG1ldGhvZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKipcblx0KiBXaGVuIGEgW2ZldGNoXXtAbGluayBlbnlvLk1vZGVsI2ZldGNofSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgaXQgaXMgcmV0dXJuZWRcblx0KiB0byB0aGlzIG1ldGhvZC4gVGhpcyBtZXRob2QgaGFuZGxlcyBzcGVjaWFsIGFuZCBpbXBvcnRhbnQgYmVoYXZpb3I7IGl0IHNob3VsZCBub3QgYmVcblx0KiBjYWxsZWQgZGlyZWN0bHkgYW5kLCB3aGVuIG92ZXJsb2FkaW5nLCBjYXJlIG11c3QgYmUgdGFrZW4gdG8gZW5zdXJlIHRoYXQgeW91IGNhbGxcblx0KiB0aGUgc3VwZXItbWV0aG9kLiBUaGlzIGNvcnJlY3RseSBzZXRzIHRoZSBbc3RhdHVzXXtAbGluayBlbnlvLk1vZGVsI3N0YXR1c30gYW5kLCBpblxuXHQqIGNhc2VzIHdoZXJlIG11bHRpcGxlIFtzb3VyY2VzXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0gd2VyZSB1c2VkLCBpdCB3YWl0cyB1bnRpbFxuXHQqIGFsbCBoYXZlIHJlc3BvbmRlZCBiZWZvcmUgY2xlYXJpbmcgdGhlIFtGRVRDSElOR117QGxpbmsgZW55by5TdGF0ZXMuRkVUQ0hJTkd9IGZsYWcuXG5cdCogSWYgYSBbc3VjY2Vzc117QGxpbmsgZW55by5Nb2RlbH5TdWNjZXNzfSBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkXG5cdCogb25jZSBmb3IgZWFjaCBzb3VyY2UuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uTW9kZWx+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0b1xuXHQqXHRbZmV0Y2goKV17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH0sIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0cy5cblx0KiBAcGFyYW0geyp9IFtyZXNdIC0gVGhlIHJlc3VsdCBwcm92aWRlZCBmcm9tIHRoZSBnaXZlbiBbc291cmNlXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0sXG5cdCogaWYgYW55LiBUaGlzIHdpbGwgdmFyeSBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZS5cblx0KiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIHNvdXJjZSB0aGF0IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmV0Y2hlZDogZnVuY3Rpb24gKG9wdHMsIHJlcywgc291cmNlKSB7XG5cdFx0dmFyIGlkeCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAodGhpcy5fd2FpdGluZykge1xuXHRcdFx0aWR4ID0gdGhpcy5fd2FpdGluZy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdHJldHVybiAobG4gaW5zdGFuY2VvZiBTb3VyY2UgPyBsbi5uYW1lIDogbG4pID09IHNvdXJjZTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlkeCA+IC0xKSB0aGlzLl93YWl0aW5nLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0aWYgKCF0aGlzLl93YWl0aW5nLmxlbmd0aCkgdGhpcy5fd2FpdGluZyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gbm9ybWFsaXplIG9wdGlvbnMgc28gd2UgaGF2ZSB2YWx1ZXMgYW5kIGVuc3VyZSBpdCBrbm93cyBpdCB3YXMganVzdCBmZXRjaGVkXG5cdFx0b3B0cyA9IG9wdHMgPyB1dGlscy5taXhpbih7fSwgW29wdGlvbnMsIG9wdHNdKSA6IG9wdGlvbnM7XG5cdFx0b3B0cy5mZXRjaGVkID0gdHJ1ZTtcblxuXHRcdC8vIGZvciBhIHNwZWNpYWwgY2FzZSBwdXJnZSB0byBvbmx5IHVzZSB0aGUgcmVzdWx0IHN1Yi10cmVlIG9mIHRoZSBmZXRjaGVkIGRhdGEgZm9yXG5cdFx0Ly8gdGhlIG1vZGVsIGF0dHJpYnV0ZXNcblx0XHRpZiAob3B0cy5wYXJzZSkgcmVzID0gdGhpcy5wYXJzZShyZXMpO1xuXG5cdFx0Ly8gbm90ZSB0aGlzIHdpbGwgbm90IGFkZCB0aGUgRElSVFkgc3RhdGUgYmVjYXVzZSBpdCB3YXMgZmV0Y2hlZCBidXQgYWxzbyBub3RlIHRoYXQgaXRcblx0XHQvLyB3aWxsIG5vdCBjbGVhciB0aGUgRElSVFkgZmxhZyBpZiBpdCB3YXMgYWxyZWFkeSBESVJUWVxuXHRcdGlmIChyZXMpIHRoaXMuc2V0KHJlcywgb3B0cyk7XG5cblx0XHQvLyBjbGVhciB0aGUgRkVUQ0hJTkcgYW5kIE5FVyBzdGF0ZSAoaWYgaXQgd2FzIE5FVykgd2UgZG8gbm90IHNldCBpdCBhcyBkaXJ0eSBhcyB0aGlzXG5cdFx0Ly8gYWN0aW9uIGFsb25lIGRvZXNuJ3Qgd2FycmFudCBhIGRpcnR5IGZsYWcgdGhhdCB3b3VsZCBuZWVkIHRvIGJlIHNldCBpbiB0aGUgc2V0IG1ldGhvZFxuXHRcdGlmICghdGhpcy5fd2FpdGluZykgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1cyAmIH4oU3RhdGVzLkZFVENISU5HIHwgU3RhdGVzLk5FVyk7XG5cblx0XHQvLyBub3cgbG9vayBmb3IgYW4gYWRkaXRpb25hbCBzdWNjZXNzIGNhbGxiYWNrXG5cdFx0aWYgKG9wdHMuc3VjY2Vzcykgb3B0cy5zdWNjZXNzKHRoaXMsIG9wdHMsIHJlcywgc291cmNlKTtcblx0fSxcblxuXHQvKipcblx0KiBXaGVuIGEgW2NvbW1pdF17QGxpbmsgZW55by5Nb2RlbCNjb21taXR9IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBpdCBpcyByZXR1cm5lZFxuXHQqIHRvIHRoaXMgbWV0aG9kLiBUaGlzIG1ldGhvZCBoYW5kbGVzIHNwZWNpYWwgYW5kIGltcG9ydGFudCBiZWhhdmlvcjsgaXQgc2hvdWxkIG5vdCBiZVxuXHQqIGNhbGxlZCBkaXJlY3RseSBhbmQsIHdoZW4gb3ZlcmxvYWRpbmcsIGNhcmUgbXVzdCBiZSB0YWtlbiB0byBlbnN1cmUgdGhhdCB5b3UgY2FsbCB0aGVcblx0KiBzdXBlci1tZXRob2QuIFRoaXMgY29ycmVjdGx5IHNldHMgdGhlIFtzdGF0dXNde0BsaW5rIGVueW8uTW9kZWwjc3RhdHVzfSBhbmQsIGluIGNhc2VzXG5cdCogd2hlcmUgbXVsdGlwbGUgW3NvdXJjZXNde0BsaW5rIGVueW8uTW9kZWwjc291cmNlfSB3ZXJlIHVzZWQsIGl0IHdhaXRzIHVudGlsIGFsbCBoYXZlXG5cdCogcmVzcG9uZGVkIGJlZm9yZSBjbGVhcmluZyB0aGUgW0NPTU1JVFRJTkdde0BsaW5rIGVueW8uU3RhdGVzLkNPTU1JVFRJTkd9IGZsYWcuIElmIGFcblx0KiBbc3VjY2Vzc117QGxpbmsgZW55by5Nb2RlbH5TdWNjZXNzfSBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yXG5cdCogZWFjaCBzb3VyY2UuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uTW9kZWx+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0b1xuXHQqXHRbY29tbWl0KClde0BsaW5rIGVueW8uTW9kZWwjY29tbWl0fSwgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRzLlxuXHQqIEBwYXJhbSB7Kn0gW3Jlc10gLSBUaGUgcmVzdWx0IHByb3ZpZGVkIGZyb20gdGhlIGdpdmVuIFtzb3VyY2Vde0BsaW5rIGVueW8uTW9kZWwjc291cmNlfSxcblx0KiBpZiBhbnkuIFRoaXMgd2lsbCB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgc291cmNlLlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIHRoYXQgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb21taXR0ZWQ6IGZ1bmN0aW9uIChvcHRzLCByZXMsIHNvdXJjZSkge1xuXHRcdHZhciBpZHg7XG5cblx0XHRpZiAodGhpcy5fd2FpdGluZykge1xuXHRcdFx0aWR4ID0gdGhpcy5fd2FpdGluZy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdHJldHVybiAobG4gaW5zdGFuY2VvZiBTb3VyY2UgPyBsbi5uYW1lIDogbG4pID09IHNvdXJjZTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlkeCA+IC0xKSB0aGlzLl93YWl0aW5nLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0aWYgKCF0aGlzLl93YWl0aW5nLmxlbmd0aCkgdGhpcy5fd2FpdGluZyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl93YWl0aW5nKSB7XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBDT01NSVRUSU5HIGJpdCBhbmQgRElSVFkgYml0IGFzIHdlbGwgYXMgZW5zdXJlIHRoYXQgdGhlXG5cdFx0XHQvLyAncHJldmlvdXMnIGhhc2ggaXMgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgYXR0cmlidXRlcyBhcmVcblx0XHRcdHRoaXMucHJldmlvdXMgPSB1dGlscy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuXHRcdFx0dGhpcy5zdGF0dXMgPSAodGhpcy5zdGF0dXMgfCBTdGF0ZXMuQ0xFQU4pICYgfihTdGF0ZXMuQ09NTUlUVElORyB8IFN0YXRlcy5ESVJUWSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMgJiYgb3B0cy5zdWNjZXNzKSBvcHRzLnN1Y2Nlc3ModGhpcywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFdoZW4gYW4gYWN0aW9uIChbZmV0Y2goKV17QGxpbmsgZW55by5Nb2RlbCNmZXRjaH0sIFtjb21taXQoKV17QGxpbmsgZW55by5Nb2RlbCNjb21taXR9LFxuXHQqIG9yIFtkZXN0cm95KClde0BsaW5rIGVueW8uTW9kZWwjZGVzdHJveX0pIGhhcyBmYWlsZWQsIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLlxuXHQqIFRoaXMgbWV0aG9kIGhhbmRsZXMgc3BlY2lhbCBhbmQgaW1wb3J0YW50IGJlaGF2aW9yOyBpdCBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseVxuXHQqIGFuZCwgd2hlbiBvdmVybG9hZGluZywgY2FyZSBtdXN0IGJlIHRha2VuIHRvIGVuc3VyZSB0aGF0IHlvdSBjYWxsIHRoZSBzdXBlci1tZXRob2QuXG5cdCogVGhpcyBjb3JyZWN0bHkgc2V0cyB0aGUgW3N0YXR1c117QGxpbmsgZW55by5Nb2RlbCNzdGF0dXN9IHRvIHRoZSBrbm93blxuXHQqIFtlcnJvciBzdGF0ZV17QGxpbmsgZW55by5TdGF0ZXMuRVJST1J9LCBvciB0byB0aGVcblx0KiBbdW5rbm93biBlcnJvciBzdGF0ZV17QGxpbmsgZW55by5TdGF0ZXMuRVJST1JfVU5LTk9XTn0gaWYgaXQgdGhlIGVycm9yIHN0YXRlIGNvdWxkIG5vdFxuXHQqIGJlIGRldGVybWluZWQuIElmIGFuIFtlcnJvciBjYWxsYmFja117QGxpbmsgZW55by5Nb2RlbH5FcnJvcn0gd2FzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZFxuXHQqIHdpbGwgZXhlY3V0ZSBpdC5cblx0KlxuXHQqIEBzZWUgZW55by5TdGF0ZVN1cHBvcnQuY2xlYXJFcnJvclxuXHQqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gLSBUaGUgYWN0aW9uIChvbmUgb2YgYCdGRVRDSElORydgLCBgJ0NPTU1JVFRJTkcnYCwgb3Jcblx0KiBgJ0RFU1RST1lJTkcnYCkgdGhhdCBmYWlsZWQgYW5kIGlzIG5vdyBpbiBhbiBbZXJyb3Igc3RhdGVde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfS5cblx0KiBAcGFyYW0ge2VueW8uTW9kZWx+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0byB0aGUgYGFjdGlvbmBcblx0KiBtZXRob2QsIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0cy5cblx0KiBAcGFyYW0geyp9IFtyZXNdIC0gVGhlIHJlc3VsdCBwcm92aWRlZCBmcm9tIHRoZSBnaXZlbiBbc291cmNlXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0sXG5cdCogaWYgYW55LiBUaGlzIHdpbGwgdmFyeSBkZXBlbmRpbmcgb24gdGhlIHNvdXJjZS5cblx0KiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIHNvdXJjZSB0aGF0IGhhcyByZXR1cm5lZCBhbiBlcnJvci5cblx0KiBAcHVibGljXG5cdCovXG5cdGVycm9yZWQ6IGZ1bmN0aW9uIChhY3Rpb24sIG9wdHMsIHJlcywgc291cmNlKSB7XG5cdFx0dmFyIHN0YXQsXG5cdFx0XHRpZHg7XG5cblx0XHQvLyBpZiB0aGUgZXJyb3IgYWN0aW9uIGlzIGEgc3RhdHVzIG51bWJlciB0aGVuIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGl0IG90aGVyd2lzZVxuXHRcdC8vIHdlIHNldCBpdCB0byB0aGUga25vd24gc3RhdGUgdmFsdWVcblx0XHRpZiAodHlwZW9mIGFjdGlvbiA9PSAnc3RyaW5nJykge1xuXG5cdFx0XHQvLyBhbGwgYnVpbHQtaW4gZXJyb3JzIHdpbGwgcGFzcyB0aGlzIGFzIHRoZWlyIHZhbHVlcyBhcmUgPiAwIGJ1dCB3ZSBnbyBhaGVhZCBhbmRcblx0XHRcdC8vIGVuc3VyZSB0aGF0IG5vIGRldmVsb3BlciB1c2VkIHRoZSAweDAwIGZvciBhbiBlcnJvciBjb2RlXG5cdFx0XHRzdGF0ID0gU1RBVEVTWydFUlJPUl8nICsgYWN0aW9uXTtcblx0XHR9IGVsc2Ugc3RhdCA9IGFjdGlvbjtcblxuXHRcdGlmIChpc05hTihzdGF0KSB8fCAoc3RhdCAmIH5TdGF0ZXMuRVJST1IpKSBzdGF0ID0gU3RhdGVzLkVSUk9SX1VOS05PV047XG5cblx0XHQvLyBjb3JyZWN0bHkgc2V0IHRoZSBjdXJyZW50IHN0YXR1cyBhbmQgZW5zdXJlIHdlIGNsZWFyIGFueSBidXN5IGZsYWdzXG5cdFx0dGhpcy5zdGF0dXMgPSAodGhpcy5zdGF0dXMgfCBzdGF0KSAmIH5TdGF0ZXMuQlVTWTtcblxuXHRcdGlmICh0aGlzLl93YWl0aW5nKSB7XG5cdFx0XHRpZHggPSB0aGlzLl93YWl0aW5nLmZpbmRJbmRleChmdW5jdGlvbiAobG4pIHtcblx0XHRcdFx0cmV0dXJuIChsbiBpbnN0YW5jZW9mIFNvdXJjZSA/IGxuLm5hbWUgOiBsbikgPT0gc291cmNlO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaWR4ID4gLTEpIHRoaXMuX3dhaXRpbmcuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRpZiAoIXRoaXMuX3dhaXRpbmcubGVuZ3RoKSB0aGlzLl93YWl0aW5nID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBvcHRpb25zIGhhbmRsZXIgZm9yIHRoaXMgZXJyb3Jcblx0XHRpZiAob3B0cyAmJiBvcHRzLmVycm9yKSBvcHRzLmVycm9yKHRoaXMsIGFjdGlvbiwgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHR9XG5cbn0pO1xuXG4vKipcbiogQG5hbWUgZW55by5Nb2RlbC5jb25jYXRcbiogQHN0YXRpY1xuKiBAcHJpdmF0ZVxuKi9cbk1vZGVsLmNvbmNhdCA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcykge1xuXHR2YXIgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSB8fCBjdG9yO1xuXG5cdGlmIChwcm9wcy5vcHRpb25zKSB7XG5cdFx0cHJvdG8ub3B0aW9ucyA9IHV0aWxzLm1peGluKHt9LCBbcHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9uc10pO1xuXHRcdGRlbGV0ZSBwcm9wcy5vcHRpb25zO1xuXHR9XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5raW5kLmZlYXR1cmVzLnB1c2goZnVuY3Rpb24gKGN0b3IpIHtcblx0aWYgKGN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcblx0XHQhU3RvcmUubW9kZWxzW2N0b3IucHJvdG90eXBlLmtpbmROYW1lXSAmJiAoU3RvcmUubW9kZWxzW2N0b3IucHJvdG90eXBlLmtpbmROYW1lXSA9IG5ldyBNb2RlbExpc3QoKSk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQmluZGluZ1N1cHBvcnRcIjo5LFwiLi9Db21wdXRlZFN1cHBvcnRcIjoxNSxcIi4vRXZlbnRFbWl0dGVyXCI6MTksXCIuL01vZGVsTGlzdFwiOjMxLFwiLi9PYnNlcnZlclN1cHBvcnRcIjozNCxcIi4vU291cmNlXCI6NDgsXCIuL1N0YXRlU3VwcG9ydFwiOjQ5LFwiLi9TdGF0ZXNcIjo1MCxcIi4vU3RvcmVcIjo1MSxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuXHRsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG52YXJcblx0Q29yZU9iamVjdCA9IHJlcXVpcmUoJy4vQ29yZU9iamVjdCcpLFxuXHRBcHBsaWNhdGlvblN1cHBvcnQgPSByZXF1aXJlKCcuL0FwcGxpY2F0aW9uU3VwcG9ydCcpLFxuXHRDb21wb25lbnRCaW5kaW5nU3VwcG9ydCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50QmluZGluZ1N1cHBvcnQnKSxcblx0Sm9icyA9IHJlcXVpcmUoJy4vam9icycpO1xuXG52YXJcblx0a2luZFByZWZpeCA9IHt9LFxuXHR1bm5hbWVkQ291bnRlciA9IDA7XG5cdFxuLyoqXG4qIEBjYWxsYmFjayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJcbiogQHBhcmFtIHtlbnlvLkNvbXBvbmVudH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nXG4qXHRldmVudCBpbmZvcm1hdGlvbi5cbiogQHJldHVybnMge0Jvb2xlYW59IEEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBldmVudCBoYXMgYmVlblxuKlx0aGFuZGxlZCBvciBub3QuIElmIGB0cnVlYCwgdGhlbiBidWJibGluZyBpcyBzdG9wcGVkLlxuKi9cblxuLyoqXG4qIEEgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IG9mIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9XG4qIG93bmVkIGJ5IHRoaXMgY29tcG9uZW50LiBUaGlzIHByb3BlcnR5IGlzIHVwZGF0ZWQgd2hlbmV2ZXIgYSBuZXdcbiogY29tcG9uZW50IGlzIGFkZGVkOyB0aGUgbmV3IGNvbXBvbmVudCBtYXkgYmUgYWNjZXNzZWQgdmlhIGl0c1xuKiBbbmFtZV17QGxpbmsgZW55by5Db21wb25lbnQjbmFtZX0gcHJvcGVydHkuIFdlIG1heSBhbHNvIG9ic2VydmUgY2hhbmdlcyBvblxuKiBwcm9wZXJ0aWVzIG9mIGNvbXBvbmVudHMgcmVmZXJlbmNlZCBieSB0aGUgYCRgIHByb3BlcnR5LlxuKlxuKiBDb21wb25lbnQgYWNjZXNzIHZpYSB0aGUgYCRgIGhhc2g6XG4qIGBgYGphdmFzY3JpcHRcbiogdmFyIGMgPSBuZXcgZW55by5Db21wb25lbnQoe1xuKlx0bmFtZTogJ21lJyxcbipcdGNvbXBvbmVudHM6IFtcbipcdFx0e2tpbmQ6ICdDb21wb25lbnQnLCBuYW1lOiAnb3RoZXInfVxuKlx0XVxuKiB9KTtcbipcbiogLy8gV2UgY2FuIG5vdyBhY2Nlc3MgJ290aGVyJyBvbiB0aGUgJCBoYXNoIG9mICdjJywgdmlhIGMuJC5vdGhlclxuKiBgYGBcbipcbiogT2JzZXJ2aW5nIGNoYW5nZXMgb24gYSBjb21wb25lbnQgcmVmZXJlbmNlZCBieSB0aGUgYCRgIHByb3BlcnR5OlxuKiBgYGBqYXZhc2NyaXB0XG4qIHZhciBjID0gbmV3IGVueW8uQ29tcG9uZW50KHtcbipcdG5hbWU6ICdtZScsXG4qXHRjb21wb25lbnRzOiBbXG4qXHRcdHtraW5kOiAnQ29tcG9uZW50JywgbmFtZTogJ290aGVyJ31cbipcdF1cbiogfSk7XG4qXG4qIGMuYWRkT2JzZXJ2ZXIoJyQub3RoZXIuYWN0aXZlJywgZnVuY3Rpb24oKSB7XG4qXHQvLyBkbyBzb21ldGhpbmcgdG8gcmVzcG9uZCB0byB0aGUgXCJhY3RpdmVcIiBwcm9wZXJ0eSBvZiBcIm90aGVyXCIgY2hhbmdpbmdcbiogfSlcbipcbiogYy4kLm90aGVyLnNldCgnYWN0aXZlJywgdHJ1ZSk7IC8vIHRoaXMgd2lsbCB0cmlnZ2VyIHRoZSBvYnNlcnZlciB0byBydW4gaXRzIGNhbGxiYWNrXG4qIGBgYFxuKlxuKiBAbmFtZSAkXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBkZWZhdWx0IG51bGxcbiogQG1lbWJlcm9mIGVueW8uQ29tcG9uZW50LnByb3RvdHlwZVxuKiBAcmVhZG9ubHlcbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIElmIGB0cnVlYCwgdGhpcyBbY29tcG9uZW50J3Nde0BsaW5rIGVueW8uQ29tcG9uZW50fSBbb3duZXJde0BsaW5rIGVueW8uQ29tcG9uZW50I293bmVyfSB3aWxsXG4qIGhhdmUgYSBkaXJlY3QgbmFtZSByZWZlcmVuY2UgdG8gdGhlIG93bmVkIGNvbXBvbmVudC5cbipcbiogQGV4YW1wbGVcbiogdmFyIGMgPSBuZXcgZW55by5Db21wb25lbnQoe1xuKlx0bmFtZTogJ21lJyxcbipcdGNvbXBvbmVudHM6IFtcbipcdFx0e2tpbmQ6ICdDb21wb25lbnQnLCBuYW1lOiAnb3RoZXInLCBwdWJsaXNoOiB0cnVlfVxuKlx0XVxuKiB9KTtcbipcbiogLy8gV2UgY2FuIG5vdyBhY2Nlc3MgJ290aGVyJyBkaXJlY3RseSwgdmlhIGMub3RoZXJcbipcbiogQG5hbWUgcHVibGlzaFxuKiBAdHlwZSB7Qm9vbGVhbn1cbiogQGRlZmF1bHQgdW5kZWZpbmVkXG4qIEBtZW1iZXJPZiBlbnlvLkNvbXBvbmVudC5wcm90b3R5cGVcbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIElmIGB0cnVlYCwgdGhlIFtsYXlvdXRde0BnbG9zc2FyeSBsYXlvdXR9IHN0cmF0ZWd5IHdpbGwgYWRqdXN0IHRoZSBzaXplIG9mIHRoaXNcbiogW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRvIG9jY3VweSB0aGUgcmVtYWluaW5nIGF2YWlsYWJsZSBzcGFjZS5cbipcbiogQG5hbWUgZml0XG4qIEB0eXBlIHtCb29sZWFufVxuKiBAZGVmYXVsdCB1bmRlZmluZWRcbiogQG1lbWJlck9mIGVueW8uQ29tcG9uZW50LnByb3RvdHlwZVxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uQ29tcG9uZW50fSBpcyB0aGUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgZm9yIEVueW8gYXBwbGljYXRpb25zLlxuKiBDb21wb25lbnRzIGFyZSBkZXNpZ25lZCB0byBmaXQgdG9nZXRoZXIsIGFsbG93aW5nIGNvbXBsZXggYmVoYXZpb3JzIHRvXG4qIGJlIGZhc2hpb25lZCBmcm9tIHNtYWxsZXIgYml0cyBvZiBmdW5jdGlvbmFsaXR5LlxuKlxuKiBDb21wb25lbnQgW2NvbnN0cnVjdG9yc117QGdsb3NzYXJ5IGNvbnN0cnVjdG9yfSB0YWtlIGEgc2luZ2xlXG4qIGFyZ3VtZW50IChzb21ldGltZXMgY2FsbGVkIGEgW2NvbXBvbmVudCBjb25maWd1cmF0aW9uXXtAZ2xvc3NhcnkgY29uZmlndXJhdGlvbkJsb2NrfSksXG4qIGEgSmF2YVNjcmlwdCBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0aGF0IGRlZmluZXMgdmFyaW91cyBwcm9wZXJ0aWVzIHRvIGJlIGluaXRpYWxpemVkIG9uIHRoZVxuKiBjb21wb25lbnQuICBGb3IgZXhhbXBsZTpcbipcbiogYGBgamF2YXNjcmlwdFxuKiAvLyBjcmVhdGUgYSBuZXcgY29tcG9uZW50LCBpbml0aWFsaXplIGl0cyBuYW1lIHByb3BlcnR5IHRvICdtZSdcbiogdmFyIGMgPSBuZXcgZW55by5Db21wb25lbnQoe1xuKlx0bmFtZTogJ21lJ1xuKiB9KTtcbiogYGBgXG4qXG4qIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCBpdGVtcyBjb25maWd1cmVkIGluIGl0c1xuKiBgY29tcG9uZW50c2AgcHJvcGVydHkgYXJlIGluc3RhbnRpYXRlZCwgdG9vOlxuKlxuKiBgYGBqYXZhc2NyaXB0XG4qIC8vIGNyZWF0ZSBhIG5ldyBjb21wb25lbnQsIHdoaWNoIGl0c2VsZiBoYXMgYSBjb21wb25lbnRcbiogdmFyIGMgPSBuZXcgZW55by5Db21wb25lbnQoe1xuKlx0bmFtZTogJ21lJyxcbipcdGNvbXBvbmVudHM6IFtcbipcdFx0e2tpbmQ6ICdDb21wb25lbnQnLCBuYW1lOiAnb3RoZXInfVxuKlx0XVxuKiB9KTtcbiogYGBgXG4qXG4qIEluIHRoaXMgY2FzZSwgd2hlbiBgbWVgIGlzIGNyZWF0ZWQsIGBvdGhlcmAgaXMgYWxzbyBjcmVhdGVkLCBhbmQgd2Ugc2F5IHRoYXQgYG1lYCBvd25zIGBvdGhlcmAuXG4qIEluIG90aGVyIHdvcmRzLCB0aGUgW293bmVyXXtAbGluayBlbnlvLkNvbXBvbmVudCNvd25lcn0gcHJvcGVydHkgb2YgYG90aGVyYCBlcXVhbHMgYG1lYC5cbiogTm90aWNlIHRoYXQgeW91IGNhbiBzcGVjaWZ5IHRoZSBba2luZF17QGdsb3NzYXJ5IGtpbmR9IG9mIGBvdGhlcmAgZXhwbGljaXRseSBpbiBpdHNcbiogY29uZmlndXJhdGlvbiBibG9jaywgdG8gdGVsbCBgbWVgIHdoYXQgY29uc3RydWN0b3IgdG8gdXNlIHRvIGNyZWF0ZSBgb3RoZXJgLlxuKlxuKiBOb3RlIHRoYXQgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB2YWx1ZXMgbWF5IGJlIHJlZmVyZW5jZXMgdG8gYWN0dWFsXG4qIGtpbmRzIG9yIHN0cmluZy1uYW1lcyBvZiBraW5kcy4gS2luZCBuYW1lcyB0aGF0IGRvIG5vdCByZXNvbHZlIGRpcmVjdGx5IHRvIGtpbmRzXG4qIGFyZSBsb29rZWQgdXAgaW4gZGVmYXVsdCBuYW1lc3BhY2VzLiBJbiB0aGlzIGNhc2UsIGBraW5kOiAnQ29tcG9uZW50J2AgcmVzb2x2ZXMgdG9cbiogYGVueW8uQ29tcG9uZW50YC5cbipcbiogVG8gbW92ZSBhIGNvbXBvbmVudCwgdXNlIHRoZSBgc2V0T3duZXIoKWAgbWV0aG9kIHRvIGNoYW5nZSB0aGVcbiogY29tcG9uZW50J3Mgb3duZXIuIElmIHlvdSB3YW50IGEgY29tcG9uZW50IHRvIGJlIHVub3duZWQsIHVzZSBgc2V0T3duZXIobnVsbClgLlxuKlxuKiBJZiB5b3UgbWFrZSBjaGFuZ2VzIHRvIGBlbnlvLkNvbXBvbmVudGAsIGJlIHN1cmUgdG8gYWRkIG9yIHVwZGF0ZSB0aGUgYXBwcm9wcmlhdGVcbioge0BsaW5rcGxhaW4gaHR0cHM6Ly9naXRodWIuY29tL2VueW9qcy9lbnlvL3RyZWUvbWFzdGVyL3Rvb2xzL3Rlc3QvY29yZS90ZXN0cyB1bml0IHRlc3RzfS5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbQ29tcG9uZW50c117QGxpbmtwbGFpbiAkZGV2LWd1aWRlL2tleS1jb25jZXB0cy9jb21wb25lbnRzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uQ29tcG9uZW50XG4qIEBleHRlbmRzIGVueW8uT2JqZWN0XG4qIEBtaXhlcyBlbnlvLkFwcGxpY2F0aW9uU3VwcG9ydFxuKiBAbWl4ZXMgZW55by5Db21wb25lbnRCaW5kaW5nU3VwcG9ydFxuKiBAcHVibGljXG4qL1xudmFyIENvbXBvbmVudCA9IG1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkNvbXBvbmVudC5wcm90b3R5cGUgKi8ge1xuXG5cdG5hbWU6ICdlbnlvLkNvbXBvbmVudCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29yZU9iamVjdCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FjaGVkQnViYmxlOiB0cnVlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhY2hlUG9pbnQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDpcblx0XHQvKiogQGxlbmRzIGVueW8uQ29tcG9uZW50LnByb3RvdHlwZSAqLyB7XG5cblx0XHQvKipcblx0XHQqIEEgdW5pcXVlIG5hbWUgZm9yIHRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gd2l0aGluIGl0c1xuXHRcdCogW293bmVyXXtAbGluayBlbnlvLkNvbXBvbmVudCNvd25lcn0uIFRoaXMgaXMgdXNlZCB0byBzZXQgdGhlIGFjY2VzcyBuYW1lIGluIHRoZVxuXHRcdCogb3duZXIncyBbJCBoYXNoXXtAbGluayBlbnlvLkNvbXBvbmVudCMkfS4gSWYgbm90XG5cdFx0KiBzcGVjaWZpZWQsIGEgZGVmYXVsdCBuYW1lIHdpbGwgYmUgcHJvdmlkZWQgYmFzZWQgb24gdGhlIG5hbWUgb2YgdGhlXG5cdFx0KiBbb2JqZWN0J3Nde0BsaW5rIGVueW8uT2JqZWN0fSBba2luZF17QGdsb3NzYXJ5IGtpbmR9LCB3aXRoIGEgbnVtZXJpY1xuXHRcdCogc3VmZml4IGFwcGVuZGVkIGlmIG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgZXhpc3RzIGluIHRoZSBvd25lci5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG5hbWU6ICcnLFxuXG5cdFx0LyoqXG5cdFx0KiBBIHVuaXF1ZSBpZCBmb3IgdGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSwgdXN1YWxseSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuXHRcdCogYmFzZWQgb24gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgY29tcG9uZW50IGhpZXJhcmNoeSwgYWx0aG91Z2hcblx0XHQqIGl0IG1heSBhbHNvIGJlIGRpcmVjdGx5IHNwZWNpZmllZC4ge0BsaW5rIGVueW8uQ29udHJvbH0gdXNlcyB0aGlzIGBpZGAgdmFsdWUgZm9yIHRoZVxuXHRcdCogRE9NIFtpZF17QGxpbmsgZW55by5Db250cm9sI2lkfSBhdHRyaWJ1dGUuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICcnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRpZDogJycsXG5cblx0XHQvKipcblx0XHQqIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBvd25zIHRoaXMgY29tcG9uZW50LlxuXHRcdCogSXQgaXMgdXN1YWxseSBkZWZpbmVkIGltcGxpY2l0bHkgYXQgY3JlYXRpb24gdGltZSBiYXNlZCBvbiB0aGVcblx0XHQqIFtjcmVhdGVDb21wb25lbnQoKV17QGxpbmsgZW55by5Db21wb25lbnQjY3JlYXRlQ29tcG9uZW50fSBjYWxsIG9yXG5cdFx0KiB0aGUgYGNvbXBvbmVudHNgIGhhc2guXG5cdFx0KlxuXHRcdCogQHR5cGUge2VueW8uQ29tcG9uZW50fVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0b3duZXI6IG51bGwsXG5cblx0XHQvKipcblx0XHQqIFRoaXMgY2FuIGJlIGEgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IG9mIGZlYXR1cmVzIHRvIGFwcGx5IHRvXG5cdFx0KiBbY2hyb21lXXtAZ2xvc3NhcnkgY2hyb21lfSBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9IG9mIHRoZSBiYXNlXG5cdFx0KiBba2luZF17QGdsb3NzYXJ5IGtpbmR9LiBUaGV5IGFyZSBtYXRjaGVkIGJ5IFtuYW1lXXtAbGluayBlbnlvLkNvbXBvbmVudCNuYW1lfVxuXHRcdCogKGlmIHRoZSBjb21wb25lbnQgeW91IHdpc2ggdG8gbW9kaWZ5IGRvZXMgbm90IGhhdmUgYSBuYW1lLCB0aGlzIHdpbGwgbm90IHdvcmspLlxuXHRcdCogWW91IGNhbiBtb2RpZnkgYW55IHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudCBleGNlcHQgZm9yIG1ldGhvZHMuIFNldHRpbmcgYVxuXHRcdCogdmFsdWUgZm9yIGBjb21wb25lbnRPdmVycmlkZXNgIGF0IHJ1bnRpbWUgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQqXG5cdFx0KiBAdHlwZSB7T2JqZWN0fVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y29tcG9uZW50T3ZlcnJpZGVzOiBudWxsXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVmYXVsdEtpbmQ6ICdDb21wb25lbnQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZXJzOiB7fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtaXhpbnM6IFtBcHBsaWNhdGlvblN1cHBvcnQsIENvbXBvbmVudEJpbmRpbmdTdXBwb3J0XSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmlkICsgJyBbJyArIHRoaXMua2luZE5hbWUgKyAnXSc7XG5cdH0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnN0cnVjdG9yOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdC8vIGluaXRpYWxpemUgaW5zdGFuY2Ugb2JqZWN0c1xuXHRcdFx0dGhpcy5fY29tcG9uZW50TmFtZU1hcCA9IHt9O1xuXHRcdFx0dGhpcy4kID0ge307XG5cdFx0XHR0aGlzLmNhY2hlZEJ1YmJsZVRhcmdldCA9IHt9O1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnN0cnVjdGVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdC8vIHBlcmZvcm0gaW5pdGlhbGl6YXRpb25cblx0XHRcdHRoaXMuY3JlYXRlKHByb3BzKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHN0b3AgYW5kIHF1ZXVlIGFsbCBvZiB0aGUgbm90aWZpY2F0aW9ucyBoYXBwZW5pbmcgc3luY2hyb25vdXNseSB0byBhbGxvd1xuXHRcdC8vIHJlc3BvbmRlcnMgdG8gb25seSBkbyBzaW5nbGUgcGFzc2VzIG9uIHdvcmsgdHJhdmVyc2luZyB0aGUgdHJlZVxuXHRcdHRoaXMuc3RvcE5vdGlmaWNhdGlvbnMoKTtcblx0XHR0aGlzLm93bmVyQ2hhbmdlZCgpO1xuXHRcdHRoaXMuaW5pdENvbXBvbmVudHMoKTtcblx0XHQvLyByZWxlYXNlIHRoZSBrcmFrZW4hXG5cdFx0dGhpcy5zdGFydE5vdGlmaWNhdGlvbnMoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbml0Q29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZSBfY29tcG9uZW50c18gcHJvcGVydHkgaW4ga2luZCBkZWNsYXJhdGlvbnMgaXMgcmVuYW1lZCB0b1xuXHRcdC8vIF9raW5kQ29tcG9uZW50c18gYnkgdGhlIENvbXBvbmVudCBzdWJjbGFzcyBtZWNoYW5pc20uICBUaGlzIG1ha2VzIGl0XG5cdFx0Ly8gZWFzeSBmb3IgdGhlIGRldmVsb3BlciB0byBkaXN0aW5ndWlzaCBraW5kQ29tcG9uZW50cyBmcm9tIHRoZSBjb21wb25lbnRzXG5cdFx0Ly8gaW4gX3RoaXMuY29tcG9uZW50c18sIHdpdGhvdXQgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHRoZSBhY3R1YWwgZGlmZmVyZW5jZS5cblx0XHQvL1xuXHRcdC8vIFNwZWNpZmljYWxseSwgdGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBraW5kQ29tcG9uZW50cyBhcmUgY29uc3RydWN0ZWQgYXNcblx0XHQvLyBvd25lZCBieSB0aGlzIGNvbnRyb2wgKHdoZXJlYXMgY29tcG9uZW50cyBpbiBfdGhpcy5jb21wb25lbnRzXyBhcmUgbm90KS5cblx0XHQvLyBJbiBhZGRpdGlvbiwga2luZENvbXBvbmVudHMgYXJlIG1hcmtlZCB3aXRoIHRoZSBfaXNDaHJvbWU6IHRydWVfIGZsYWcuXG5cdFx0dGhpcy5jcmVhdGVDaHJvbWUodGhpcy5raW5kQ29tcG9uZW50cyk7XG5cdFx0dGhpcy5jcmVhdGVDbGllbnRDb21wb25lbnRzKHRoaXMuY29tcG9uZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlQ2hyb21lOiBmdW5jdGlvbiAoY29tcHMpIHtcblx0XHR0aGlzLmNyZWF0ZUNvbXBvbmVudHMoY29tcHMsIHtpc0Nocm9tZTogdHJ1ZX0pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZUNsaWVudENvbXBvbmVudHM6IGZ1bmN0aW9uIChjb21wcykge1xuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50cyhjb21wcywge293bmVyOiB0aGlzLmdldEluc3RhbmNlT3duZXIoKX0pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldEluc3RhbmNlT3duZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKCF0aGlzLm93bmVyIHx8IHRoaXMub3duZXIubm90SW5zdGFuY2VPd25lcikgPyB0aGlzIDogdGhpcy5vd25lcjtcblx0fSxcblxuXHQvKipcblx0KiBSZW1vdmVzIHRoaXMgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IGZyb20gaXRzXG5cdCogW293bmVyXXtAbGluayBlbnlvLkNvbXBvbmVudCNvd25lcn0gKHNldHRpbmcgYG93bmVyYCB0byBgbnVsbGApXG5cdCogYW5kIGRvZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwLiBUaGUgY29tcG9uZW50IGlzIGZsYWdnZWQgd2l0aFxuXHQqIGBkZXN0cm95ZWQ6IHRydWVgLiBVc3VhbGx5LCB0aGUgY29tcG9uZW50IHdpbGwgYmUgc3VpdGFibGUgZm9yIGdhcmJhZ2Vcblx0KiBjb2xsZWN0aW9uIGFmdGVyIGJlaW5nIGRlc3Ryb3llZCwgdW5sZXNzIHVzZXIgY29kZSBrZWVwcyBhIHJlZmVyZW5jZVxuXHQqIHRvIGl0LlxuXHQqXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZGVzdHJveUNvbXBvbmVudHMoKTtcblx0XHRcdHRoaXMuc2V0T3duZXIobnVsbCk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuc3RvcEFsbEpvYnMoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIERlc3Ryb3lzIGFsbCBvd25lZCBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9LlxuXHQqXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzdHJveUNvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29tcHMgPSB0aGlzLmdldENvbXBvbmVudHMoKSxcblx0XHRcdGNvbXAsXG5cdFx0XHRpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRjb21wID0gY29tcHNbaV07XG5cdFx0XHQvLyBAdG9kbzogcHJldmlvdXMgY29tbWVudCBzYWlkIGxpc3QgbWlnaHQgYmUgc3RhbGUgYW5kIG93bmVyc2hpcCBtYXkgaGF2ZSBjYXVzZWRcblx0XHRcdC8vIGNvbXBvbmVudHMgdG8gYmUgZGVzdHJveWVkIGFzIGEgcmVzdWx0IG9mIHNvbWUgaW5uZXItY29udGFpbmVyLi4ubG9vayBpbnRvIHRoaXNcblx0XHRcdC8vIGJlY2F1c2UgdGhhdCBzZWVtcyBpbmNvcnJlY3Qgb3IgYXZvaWRhYmxlXG5cdFx0XHRpZiAoIWNvbXAuZGVzdHJveWVkKSBjb21wLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtYWtlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWxpbSA9ICdfJywgcHJlID0gdGhpcy5vd25lciAmJiB0aGlzLm93bmVyLmdldElkKCksXG5cdFx0XHRiYXNlTmFtZSA9IHRoaXMubmFtZSB8fCAoJ0BAJyArICgrK3VubmFtZWRDb3VudGVyKSk7XG5cdFx0cmV0dXJuIChwcmUgPyBwcmUgKyBkZWxpbSA6ICcnKSArIGJhc2VOYW1lO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG93bmVyQ2hhbmdlZDogZnVuY3Rpb24gKHdhcykge1xuXHRcdGlmICh3YXMgJiYgd2FzLnJlbW92ZUNvbXBvbmVudCkgd2FzLnJlbW92ZUNvbXBvbmVudCh0aGlzKTtcblx0XHRpZiAodGhpcy5vd25lciAmJiB0aGlzLm93bmVyLmFkZENvbXBvbmVudCkgdGhpcy5vd25lci5hZGRDb21wb25lbnQodGhpcyk7XG5cdFx0aWYgKCF0aGlzLmlkKSB0aGlzLmlkID0gdGhpcy5tYWtlSWQoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcCkge1xuXHRcdHZhciBwcmUgPSBwcmVmaXhGcm9tS2luZE5hbWUoY29tcC5raW5kTmFtZSksXG5cdFx0XHRsYXN0ID0gdGhpcy5fY29tcG9uZW50TmFtZU1hcFtwcmVdIHx8IDAsXG5cdFx0XHRub207XG5cblx0XHRkbyB7XG5cdFx0XHRub20gPSBwcmUgKyAoKytsYXN0ID4gMSA/IFN0cmluZyhsYXN0KSA6ICcnKTtcblx0XHR9IHdoaWxlICh0aGlzLiRbbm9tXSk7XG5cblx0XHR0aGlzLl9jb21wb25lbnROYW1lTWFwW3ByZV0gPSBOdW1iZXIobGFzdCk7XG5cdFx0Lypqc2hpbnQgLVcwOTMgKi9cblx0XHRyZXR1cm4gKGNvbXAubmFtZSA9IG5vbSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQWRkcyBhIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0byB0aGUgbGlzdCBvZiBjb21wb25lbnRzXG5cdCogb3duZWQgYnkgdGhlIGN1cnJlbnQgY29tcG9uZW50IChpLmUuLCBbdGhpcy4kXXtAbGluayBlbnlvLkNvbXBvbmVudCMkfSkuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29tcG9uZW50fSBjb21wIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0byBhZGQuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcCkge1xuXHRcdHZhciBub20gPSBjb21wLmdldCgnbmFtZScpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgaXMgbm8gbmFtZSB3ZSBoYXZlIHRvIGNvbWUgdXAgd2l0aCBhIGdlbmVyaWMgbmFtZVxuXHRcdGlmICghbm9tKSBub20gPSB0aGlzLm5hbWVDb21wb25lbnQoY29tcCk7XG5cblx0XHQvLyBpZiB0aGVyZSBhbHJlYWR5IHdhcyBhIGNvbXBvbmVudCBieSB0aGF0IG5hbWUgd2UgaXNzdWUgYSB3YXJuaW5nXG5cdFx0Ly8gQHRvZG86IGlmIHdlJ3JlIGdvaW5nIHRvIG5hbWUgcnVsZXMgYmVpbmcgdmlvbGF0ZWQgd2UgbmVlZCB0byBub3JtYWxpemUgdGhpcyBhcHByb2FjaFxuXHRcdC8vIGFuZCBlbnN1cmUgd2UgaGF2ZSBvbmUgZm9yIGV2ZXJ5IHdhcm5pbmcvZXJyb3Igd2UgdGhyb3dcblx0XHRpZiAodGhpcy4kW25vbV0pIHRoaXMud2Fybihcblx0XHRcdCdEdXBsaWNhdGUgY29tcG9uZW50IG5hbWUgJyArIG5vbSArICcgaW4gb3duZXIgJyArIHRoaXMuaWQgKyAnIHZpb2xhdGVzICcgK1xuXHRcdFx0J3VuaXF1ZS1uYW1lLXVuZGVyLW93bmVyIHJ1bGUsIHJlcGxhY2luZyBleGlzdGluZyBjb21wb25lbnQgaW4gdGhlIGhhc2ggYW5kICcgK1xuXHRcdFx0J2NvbnRpbnVpbmcsIGJ1dCB0aGlzIGlzIGFuIGVycm9yIGNvbmRpdGlvbiBhbmQgc2hvdWxkIGJlIGZpeGVkLidcblx0XHQpO1xuXG5cdFx0dGhpcy4kW25vbV0gPSBjb21wO1xuXHRcdHRoaXMubm90aWZ5KCckLicgKyBub20sIG51bGwsIGNvbXApO1xuXG5cdFx0Ly8gaWYgdGhlIGNvbXBvbmVudCBoYXMgdGhlIGBwdWJsaXNoYCB0cnVlIHByb3BlcnR5IHRoZW4gd2UgYWxzbyBjcmVhdGUgYSByZWZlcmVuY2UgdG9cblx0XHQvLyBpdCBkaXJlY3RseSBvbiB0aGUgb3duZXIgKHRoaXMpXG5cdFx0aWYgKGNvbXAucHVibGlzaCkge1xuXHRcdFx0dGhpc1tub21dID0gY29tcDtcblxuXHRcdFx0Ly8gYW5kIHRvIGVuc3VyZSB0aGF0IGJpbmRpbmdzIGFyZSBhd2FyZSB3ZSBoYXZlIHRvIG5vdGlmeSB0aGVtIGFzIHdlbGxcblx0XHRcdHRoaXMubm90aWZ5KG5vbSwgbnVsbCwgY29tcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVtb3ZlcyB0aGUgcGFzc2VkLWluIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSBmcm9tIHRob3NlIGtub3duXG5cdCogdG8gYmUgb3duZWQgYnkgdGhpcyBjb21wb25lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlXG5cdCogWyQgaGFzaF17QGxpbmsgZW55by5Db21wb25lbnQjJH0sIGFuZCBmcm9tIHRoZSBbb3duZXJde0BsaW5rIGVueW8uQ29tcG9uZW50I293bmVyfVxuXHQqIGRpcmVjdGx5IGlmIFtwdWJsaXNoXXtAbGluayBlbnlvLkNvbXBvbmVudCNwdWJsaXNofSBpcyBzZXQgdG8gYHRydWVgLlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLkNvbXBvbmVudH0gY29tcCAtIFRoZSBjb21wb25lbnQgdG8gcmVtb3ZlLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlbW92ZUNvbXBvbmVudDogZnVuY3Rpb24gKGNvbXApIHtcblx0XHR2YXIgbm9tID0gY29tcC5nZXQoJ25hbWUnKTtcblxuXHRcdC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBoYXNoIGlmIGl0IGV4aXN0ZWRcblx0XHRkZWxldGUgdGhpcy4kW25vbV07XG5cblx0XHQvLyBpZiBpdCB3YXMgcHVibGlzaGVkIHJlbW92ZSBpdCBmcm9tIHRoZSBjb21wb25lbnQgcHJvcGVyXG5cdFx0aWYgKGNvbXAucHVibGlzaCkgZGVsZXRlIHRoaXNbbm9tXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgYW4gW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IG9mIG93bmVkIFtjb21wb25lbnRzXXtAbGluayBlbnlvLkNvbXBvbmVudH07IGluXG5cdCogb3RoZXIgd29yZHMsIGNvbnZlcnRzIHRoZSBbJCBoYXNoXXtAbGluayBlbnlvLkNvbXBvbmVudCMkfSBpbnRvIGFuIGFycmF5XG5cdCogYW5kIHJldHVybnMgdGhlIGFycmF5LlxuXHQqXG5cdCogQHJldHVybnMge2VueW8uQ29tcG9uZW50W119IFRoZSBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9IGZvdW5kIGluIHRoZVxuXHQqXHRbJCBoYXNoXXtAbGluayBlbnlvLkNvbXBvbmVudCMkfS5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdXRpbHMudmFsdWVzKHRoaXMuJCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YWRqdXN0Q29tcG9uZW50UHJvcHM6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdGlmICh0aGlzLmRlZmF1bHRQcm9wcykgdXRpbHMubWl4aW4ocHJvcHMsIHRoaXMuZGVmYXVsdFByb3BzLCB7aWdub3JlOiB0cnVlfSk7XG5cdFx0cHJvcHMua2luZCA9IHByb3BzLmtpbmQgfHwgcHJvcHMuaXNhIHx8IHRoaXMuZGVmYXVsdEtpbmQ7XG5cdFx0cHJvcHMub3duZXIgPSBwcm9wcy5vd25lciB8fCB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9jcmVhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChwcm9wcywgZXh0KSB7XG5cdFx0dmFyIGRlZiA9IGV4dCA/IHV0aWxzLm1peGluKHt9LCBbZXh0LCBwcm9wc10pIDogdXRpbHMuY2xvbmUocHJvcHMpO1xuXG5cdFx0Ly8gYWx3YXlzIGFkanVzdCB0aGUgcHJvcGVydGllcyBhY2NvcmRpbmcgdG8gdGhlIG5lZWRzIG9mIHRoZSBraW5kIGFuZCBwYXJlbnQga2luZHNcblx0XHR0aGlzLmFkanVzdENvbXBvbmVudFByb3BzKGRlZik7XG5cblx0XHQvLyBwYXNzIGFsb25nIGZvciB0aGUgZmluYWwgc3RhZ2Vcblx0XHRyZXR1cm4gQ29tcG9uZW50LmNyZWF0ZShkZWYpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gYXMgZGVmaW5lZCBieSB0aGUgY29tYmluYXRpb24gb2Zcblx0KiBhIGJhc2UgYW5kIGFuIGFkZGl0aW9uYWwgcHJvcGVydHkgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9LiBUaGUgcHJvcGVydGllcyBwcm92aWRlZFxuXHQqIGluIHRoZSBzdGFuZGFyZCBwcm9wZXJ0eSBoYXNoIG92ZXJyaWRlIHRob3NlIHByb3ZpZGVkIGluIHRoZVxuXHQqIGFkZGl0aW9uYWwgcHJvcGVydHkgaGFzaC5cblx0KlxuXHQqIFRoZSBjcmVhdGVkIGNvbXBvbmVudCBwYXNzZXMgdGhyb3VnaCBpbml0aWFsaXphdGlvbiBtYWNoaW5lcnlcblx0KiBwcm92aWRlZCBieSB0aGUgY3JlYXRpbmcgY29tcG9uZW50LCB3aGljaCBtYXkgc3VwcGx5IHNwZWNpYWxcblx0KiBoYW5kbGluZy4gVW5sZXNzIHRoZSBbb3duZXJde0BsaW5rIGVueW8uQ29tcG9uZW50I293bmVyfSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgdGhlIG5ld1xuXHQqIGNvbXBvbmVudCB3aWxsIGJlIG93bmVkIGJ5IHRoZSBpbnN0YW5jZSBvbiB3aGljaCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIC8vIENyZWF0ZSBhIG5ldyBjb21wb25lbnQgbmFtZWQgJ2R5bmFtaWMnLCBvd25lZCBieSAndGhpcydcblx0KiAvLyAod2lsbCBiZSBhdmFpbGFibGUgYXMgdGhpcy4kLmR5bmFtaWMpLlxuXHQqIHRoaXMuY3JlYXRlQ29tcG9uZW50KHtuYW1lOiAnZHluYW1pYyd9KTtcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogLy8gQ3JlYXRlIGEgbmV3IGNvbXBvbmVudCBuYW1lZCAnYW5vdGhlcicgb3duZWQgYnkgJ290aGVyJ1xuXHQqIC8vICh3aWxsIGJlIGF2YWlsYWJsZSBhcyBvdGhlci4kLmFub3RoZXIpLlxuXHQqIHRoaXMuY3JlYXRlQ29tcG9uZW50KHtuYW1lOiAnYW5vdGhlcid9LCB7b3duZXI6IG90aGVyfSk7XG5cdCpcblx0KiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBUaGUgZGVjbGFyYXRpdmUgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBkZWZpbml0aW9uLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBleHQgLSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCAoZGVmYXVsdHMpLlxuXHQqIEByZXR1cm5zIHtlbnlvLkNvbXBvbmVudH0gVGhlIGluc3RhbmNlIGNyZWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cblx0KiBAcHVibGljXG5cdCovXG5cdGNyZWF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHByb3BzLCBleHQpIHtcblx0XHQvLyBjcmVhdGVDb21wb25lbnQgYW5kIGNyZWF0ZUNvbXBvbmVudHMgYm90aCBkZWxlZ2F0ZSB0byB0aGUgcHJvdGVjdGVkIG1ldGhvZFxuXHRcdC8vIChfY3JlYXRlQ29tcG9uZW50KSwgYWxsb3dpbmcgb3ZlcnJpZGVzIHRvIGN1c3RvbWl6ZSBjcmVhdGVDb21wb25lbnQgYW5kXG5cdFx0Ly8gY3JlYXRlQ29tcG9uZW50cyBzZXBhcmF0ZWx5LlxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVDb21wb25lbnQocHJvcHMsIGV4dCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ3JlYXRlcyBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9IGFzIGRlZmluZWQgYnkgdGhlIFthcnJheXNde0BnbG9zc2FyeSBBcnJheX1cblx0KiBvZiBiYXNlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnR5IFtoYXNoZXNde0BnbG9zc2FyeSBPYmplY3R9LiBUaGUgc3RhbmRhcmQgYW5kXG5cdCogYWRkaXRpb25hbCBwcm9wZXJ0eSBoYXNoZXMgYXJlIGNvbWJpbmVkIGFzIGRlc2NyaWJlZCBpblxuXHQqIFtjcmVhdGVDb21wb25lbnQoKV17QGxpbmsgZW55by5Db21wb25lbnQjY3JlYXRlQ29tcG9uZW50fS5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogLy8gYXNrIGZvbyB0byBjcmVhdGUgY29tcG9uZW50cyAnYmFyJyBhbmQgJ3pvdCcsIGJ1dCBzZXQgdGhlIG93bmVyIG9mXG5cdCogLy8gYm90aCBjb21wb25lbnRzIHRvICd0aGlzJy5cblx0KiB0aGlzLiQuZm9vLmNyZWF0ZUNvbXBvbmVudHMoW1xuXHQqXHR7bmFtZTogJ2Jhcid9LFxuXHQqXHR7bmFtZTogJ3pvdCd9XG5cdCogXSwge293bmVyOiB0aGlzfSk7XG5cdCpcblx0KiBAcGFyYW0ge09iamVjdFtdfSBwcm9wcyBUaGUgYXJyYXkgb2Yge0BsaW5rIGVueW8uQ29tcG9uZW50fSBkZWZpbml0aW9ucyB0byBiZSBjcmVhdGVkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBleHQgLSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgc3VwcGxpZWQgYXMgZGVmYXVsdHMgZm9yIGVhY2guXG5cdCogQHJldHVybnMge2VueW8uQ29tcG9uZW50W119IFRoZSBhcnJheSBvZiBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgd2VyZVxuXHQqXHRjcmVhdGVkLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y3JlYXRlQ29tcG9uZW50czogZnVuY3Rpb24gKHByb3BzLCBleHQpIHtcblx0XHR2YXIgY29tcHMgPSBbXSxcblx0XHRcdGNvbXAsXG5cdFx0XHRpO1xuXG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0Y29tcCA9IHByb3BzW2ldO1xuXHRcdFx0XHRjb21wcy5wdXNoKHRoaXMuX2NyZWF0ZUNvbXBvbmVudChjb21wLCBleHQpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcHM7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0QnViYmxlVGFyZ2V0OiBmdW5jdGlvbiAobm9tLCBldmVudCkge1xuXHRcdGlmIChldmVudC5kZWxlZ2F0ZSkgcmV0dXJuIHRoaXMub3duZXI7XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0aGlzLmJ1YmJsZVRhcmdldFxuXHRcdFx0XHR8fCAodGhpcy5jYWNoZWRCdWJibGUgJiYgdGhpcy5jYWNoZWRCdWJibGVUYXJnZXRbbm9tXSlcblx0XHRcdFx0fHwgdGhpcy5vd25lclxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQnViYmxlcyBhbiB7QGdsb3NzYXJ5IGV2ZW50fSB1cCBhbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjaGFpbixcblx0KiBzdGFydGluZyB3aXRoIGB0aGlzYC5cblx0KlxuXHQqIEEgaGFuZGxlciBmb3IgYW4gZXZlbnQgbWF5IGJlIHNwZWNpZmllZC4gU2VlIHtAbGluayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJ9XG5cdCogZm9yIGNvbXBsZXRlIGRldGFpbHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9IHRvIGJ1YmJsZS5cblx0KiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSAtIFRoZSBldmVudCBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBiZSBwYXNzZWQgYWxvbmdcblx0KiB3aGlsZSBidWJibGluZy5cblx0KiBAcGFyYW0ge2VueW8uQ29tcG9uZW50fSBbc2VuZGVyPXRoaXNdIC0gVGhlIHtAbGluayBlbnlvLkNvbXBvbmVudH0gcmVzcG9uc2libGUgZm9yXG5cdCpcdGJ1YmJsaW5nIHRoZSBldmVudC5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCBpZiB1bmhhbmRsZWQgb3IgdW5pbnRlcnJ1cHRlZDsgb3RoZXJ3aXNlLCBgdHJ1ZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRidWJibGU6IGZ1bmN0aW9uIChub20sIGV2ZW50LCBzZW5kZXIpIHtcblx0XHRpZiAoIXRoaXMuX3NpbGVuY2VkKSB7XG5cdFx0XHRldmVudCA9IGV2ZW50IHx8IHt9O1xuXHRcdFx0ZXZlbnQubGFzdEhhbmRsZWRDb21wb25lbnQgPSBudWxsO1xuXHRcdFx0ZXZlbnQuYnViYmxpbmcgPSB0cnVlO1xuXHRcdFx0Ly8gZGVsaWJlcmF0ZWx5IGRvbmUgdGhpcyB3YXlcblx0XHRcdGlmIChldmVudC5vcmlnaW5hdG9yID09IG51bGwpIGV2ZW50Lm9yaWdpbmF0b3IgPSBzZW5kZXIgfHwgdGhpcztcblx0XHRcdHJldHVybiB0aGlzLmRpc3BhdGNoQnViYmxlKG5vbSwgZXZlbnQsIHNlbmRlciB8fCB0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEJ1YmJsZXMgYW4ge0BnbG9zc2FyeSBldmVudH0gdXAgYW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY2hhaW4sXG5cdCogc3RhcnRpbmcgKiphYm92ZSoqIGB0aGlzYC5cblx0KlxuXHQqIEEgaGFuZGxlciBmb3IgYW4gZXZlbnQgbWF5IGJlIHNwZWNpZmllZC4gU2VlIHtAbGluayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJ9XG5cdCogZm9yIGNvbXBsZXRlIGRldGFpbHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIC0gVGhlIGV2ZW50IHByb3BlcnRpZXMgdG8gcGFzcyBhbG9uZyB3aGlsZSBidWJibGluZy5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gYGZhbHNlYCBpZiB1bmhhbmRsZWQgb3IgdW5pbnRlcnJ1cHRlZDsgb3RoZXJ3aXNlLCBgdHJ1ZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRidWJibGVVcDogZnVuY3Rpb24gKG5vbSwgZXZlbnQpIHtcblx0XHR2YXIgbmV4dDtcblxuXHRcdGlmICghdGhpcy5fc2lsZW5jZWQpIHtcblx0XHRcdGV2ZW50ID0gZXZlbnQgfHwge307XG5cdFx0XHRldmVudC5idWJibGluZyA9IHRydWU7XG5cdFx0XHRuZXh0ID0gdGhpcy5nZXRCdWJibGVUYXJnZXQobm9tLCBldmVudCk7XG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHQvLyB1c2UgZGVsZWdhdGUgYXMgc2VuZGVyIGlmIGl0IGV4aXN0cyB0byBwcmVzZXJ2ZSBpbGx1c2lvblxuXHRcdFx0XHQvLyB0aGF0IGV2ZW50IGlzIGRpc3BhdGNoZWQgZGlyZWN0bHkgZnJvbSB0aGF0LCBidXQgd2Ugc3RpbGxcblx0XHRcdFx0Ly8gaGF2ZSB0byBidWJibGUgdG8gZ2V0IGRlY29yYXRpb25zXG5cdFx0XHRcdHJldHVybiBuZXh0LmRpc3BhdGNoQnViYmxlKG5vbSwgZXZlbnQsIGV2ZW50LmRlbGVnYXRlIHx8IHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCogU2VuZHMgYW4ge0BnbG9zc2FyeSBldmVudH0gdG8gYSBuYW1lZCBbZGVsZWdhdGVde0BnbG9zc2FyeSBkZWxlZ2F0ZX0uXG5cdCogVGhpcyBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBtYXkgZGlzcGF0Y2ggYW4gZXZlbnQgdG9cblx0KiBpdHNlbGYgdmlhIGEgW2hhbmRsZXJde0BsaW5rIGVueW8uQ29tcG9uZW50fkV2ZW50SGFuZGxlcn0sIG9yIHRvIGl0c1xuXHQqIFtvd25lcl17QGxpbmsgZW55by5Db21wb25lbnQjb3duZXJ9IHZpYSBhbiBldmVudCBwcm9wZXJ0eSwgZS5nLjpcblx0KlxuXHQqXHRoYW5kbGVycyB7XG5cdCpcdFx0Ly8gJ3RhcCcgZXZlbnRzIGRpc3BhdGNoZWQgdG8gdGhpcy50YXBIYW5kbGVyXG5cdCpcdFx0b250YXA6ICd0YXBIYW5kbGVyJ1xuXHQqXHR9XG5cdCpcblx0Klx0Ly8gJ3RhcCcgZXZlbnRzIGRpc3BhdGNoZWQgdG8gJ3RhcEhhbmRsZXInIGRlbGVnYXRlIGluIHRoaXMub3duZXJcblx0Klx0b250YXA6ICd0YXBIYW5kbGVyJ1xuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKG5vbSwgZXZlbnQsIHNlbmRlcikge1xuXHRcdHZhciBkZWxlZ2F0ZSxcblx0XHRcdHJldDtcblxuXHRcdGlmICghdGhpcy5fc2lsZW5jZWQpIHtcblx0XHRcdC8vIGlmIHRoZSBldmVudCBoYXMgYSBkZWxlZ2F0ZSBhc3NvY2lhdGVkIHdpdGggaXQgd2UgZ3JhYiB0aGF0XG5cdFx0XHQvLyBmb3IgcmVmZXJlbmNlXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGlzIHVuZm9ydHVuYXRlIGJ1dCB3ZSBjYW4ndCB1c2UgYSBwb29sZWQgb2JqZWN0IGhlcmUgYmVjYXVzZVxuXHRcdFx0Ly8gd2UgZG9uJ3Qga25vdyB3aGVyZSB0byByZWxlYXNlIGl0XG5cdFx0XHRkZWxlZ2F0ZSA9IChldmVudCB8fCAoZXZlbnQgPSB7fSkpLmRlbGVnYXRlO1xuXG5cdFx0XHQvLyBib3R0bGVuZWNrIGV2ZW50IGRlY29yYXRpb24gdy8gb3B0aW1pemF0aW9uIHRvIGF2b2lkIGNhbGwgdG8gZW1wdHkgZnVuY3Rpb25cblx0XHRcdGlmICh0aGlzLmRlY29yYXRlRXZlbnQgIT09IENvbXBvbmVudC5wcm90b3R5cGUuZGVjb3JhdGVFdmVudCkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRlRXZlbnQobm9tLCBldmVudCwgc2VuZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyc3QsIGhhbmRsZSBhbnkgZGVsZWdhdGVkIGV2ZW50cyBpbnRlbmRlZCBmb3IgdGhpcyBvYmplY3Rcblx0XHRcdGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5vd25lciA9PT0gdGhpcykge1xuXHRcdFx0XHQvLyB0aGUgbW9zdCBsaWtlbHkgY2FzZSBpcyB0aGF0IHdlIGhhdmUgYSBtZXRob2QgdG8gaGFuZGxlIHRoaXNcblx0XHRcdFx0aWYgKHRoaXNbbm9tXSAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpc1tub21dKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2gobm9tLCBldmVudCwgc2VuZGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBidXQgaWYgd2UgZG9uJ3QsIGp1c3Qgc3RvcCB0aGUgZXZlbnQgZnJvbSBnb2luZyBmdXJ0aGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZm9yIG5vbi1kZWxnYXRlZCBldmVudHMsIHRyeSB0aGUgaGFuZGxlcnMgYmxvY2sgaWYgcG9zc2libGVcblx0XHRcdGlmICghZGVsZWdhdGUpIHtcblx0XHRcdFx0dmFyIGJIYW5kbGVyID0gdGhpcy5oYW5kbGVycyAmJiB0aGlzLmhhbmRsZXJzW25vbV07XG5cdFx0XHRcdHZhciBiRGVsZWdhdGVkRnVuY3Rpb24gPSB0aGlzW25vbV0gJiYgdXRpbHMuaXNTdHJpbmcodGhpc1tub21dKTtcblx0XHRcdFx0dmFyIGNhY2hlUG9pbnQgPSB0aGlzLmNhY2hlUG9pbnQgfHwgYkhhbmRsZXIgfHwgYkRlbGVnYXRlZEZ1bmN0aW9uIHx8IHRoaXMuaWQgPT09IFwibWFzdGVyXCIgO1xuXG5cdFx0XHRcdGlmIChldmVudC5idWJibGluZykge1xuXHRcdFx0XHRcdGlmIChldmVudC5sYXN0SGFuZGxlZENvbXBvbmVudCAmJiBjYWNoZVBvaW50KSB7XG5cdFx0XHRcdFx0XHRldmVudC5sYXN0SGFuZGxlZENvbXBvbmVudC5jYWNoZWRCdWJibGVUYXJnZXRbbm9tXSA9IHRoaXM7XG5cdFx0XHRcdFx0XHRldmVudC5sYXN0SGFuZGxlZENvbXBvbmVudCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghZXZlbnQubGFzdEhhbmRsZWRDb21wb25lbnQgJiYgdGhpcy5pZCAhPT0gXCJtYXN0ZXJcIikge1xuXHRcdFx0XHRcdFx0ZXZlbnQubGFzdEhhbmRsZWRDb21wb25lbnQgPSB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYkhhbmRsZXIgJiYgdGhpcy5kaXNwYXRjaChiSGFuZGxlciwgZXZlbnQsIHNlbmRlcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYkRlbGVnYXRlZEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0Ly8gd2UgZGlzcGF0Y2ggaXQgdXAgYXMgYSBzcGVjaWFsIGRlbGVnYXRlIGV2ZW50IHdpdGggdGhlXG5cdFx0XHRcdFx0Ly8gY29tcG9uZW50IHRoYXQgaGFkIHRoZSBkZWxlZ2F0aW9uIHN0cmluZyBwcm9wZXJ0eSBzdG9yZWQgaW5cblx0XHRcdFx0XHQvLyB0aGUgJ2RlbGVnYXRlJyBwcm9wZXJ0eVxuXHRcdFx0XHRcdGV2ZW50LmRlbGVnYXRlID0gdGhpcztcblx0XHRcdFx0XHRyZXQgPSB0aGlzLmJ1YmJsZVVwKHRoaXNbbm9tXSwgZXZlbnQsIHNlbmRlcik7XG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50LmRlbGVnYXRlO1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEludGVybmFsIC0gdHJ5IGRpc3BhdGNoaW5nIHtAZ2xvc3NhcnkgZXZlbnR9IHRvIHNlbGY7IGlmIHRoYXQgZmFpbHMsXG5cdCogW2J1YmJsZSBpdCB1cF17QGxpbmsgZW55by5Db21wb25lbnQjYnViYmxlVXB9IHRoZSB0cmVlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzcGF0Y2hCdWJibGU6IGZ1bmN0aW9uIChub20sIGV2ZW50LCBzZW5kZXIpIHtcblx0XHRpZiAoIXRoaXMuX3NpbGVuY2VkKSB7XG5cdFx0XHQvLyBUcnkgdG8gZGlzcGF0Y2ggZnJvbSBoZXJlLCBzdG9wIGJ1YmJsaW5nIG9uIHRydXRoeSByZXR1cm4gdmFsdWVcblx0XHRcdGlmICh0aGlzLmRpc3BhdGNoRXZlbnQobm9tLCBldmVudCwgc2VuZGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIEJ1YmJsZSB0byBuZXh0IHRhcmdldFxuXHRcdFx0cmV0dXJuIHRoaXMuYnViYmxlVXAobm9tLCBldmVudCwgc2VuZGVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlY29yYXRlRXZlbnQ6IGZ1bmN0aW9uIChub20sIGV2ZW50LCBzZW5kZXIpIHtcblx0XHQvLyBhbiBldmVudCBtYXkgZmxvYXQgYnkgdXMgYXMgcGFydCBvZiBhIGRpc3BhdGNoRXZlbnQgY2hhaW5cblx0XHQvLyBib3RoIGNhbGwgdGhpcyBtZXRob2Qgc28gaW50ZXJtZWRpYXJpZXMgY2FuIGRlY29yYXRlIGluRXZlbnRcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdG9wQWxsSm9iczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBqb2I7XG5cblx0XHRpZiAodGhpcy5fX2pvYnMpIGZvciAoam9iIGluIHRoaXMuX19qb2JzKSB0aGlzLnN0b3BKb2Ioam9iKTtcblx0fSxcblxuXHQvKipcblx0KiBEaXNwYXRjaGVzIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fSB0byBuYW1lZCBbZGVsZWdhdGVde0BnbG9zc2FyeSBkZWxlZ2F0ZX0gYG5vbWAsXG5cdCogaWYgaXQgZXhpc3RzLiBbU3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfSBtYXkgcmUtcm91dGUgZGlzcGF0Y2hlcy4gTm90ZSB0aGF0XG5cdCogYm90aCAnaGFuZGxlcnMnIGV2ZW50cyBhbmQgZXZlbnRzIGRlbGVnYXRlZCBmcm9tIG93bmVkIGNvbnRyb2xzIGFycml2ZSBoZXJlLlxuXHQqIElmIHlvdSBuZWVkIHRvIGhhbmRsZSB0aGVzZSB0eXBlcyBvZiBldmVudHMgZGlmZmVyZW50bHksIHlvdSBtYXkgYWxzbyBuZWVkIHRvXG5cdCogb3ZlcnJpZGUgW2Rpc3BhdGNoRXZlbnQoKV17QGxpbmsgZW55by5Db21wb25lbnQjZGlzcGF0Y2hFdmVudH0uXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGRpc3BhdGNoIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cblx0KiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSAtIFRoZSBldmVudCBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBwYXNzIGFsb25nLlxuXHQqIEBwYXJhbSB7ZW55by5Db21wb25lbnR9IFtzZW5kZXI9dGhpc10gLSBUaGUgb3JpZ2luYXRvciBvZiB0aGUgZXZlbnQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkaXNwYXRjaDogZnVuY3Rpb24gKG5vbSwgZXZlbnQsIHNlbmRlcikge1xuXHRcdHZhciBmbjtcblxuXHRcdGlmICghdGhpcy5fc2lsZW5jZWQpIHtcblx0XHRcdGZuID0gbm9tICYmIHRoaXNbbm9tXTtcblx0XHRcdGlmIChmbiAmJiB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvLyBAdG9kbzogZGVwcmVjYXRlIHNlbmRlclxuXHRcdFx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBzZW5kZXIgfHwgdGhpcywgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCogVHJpZ2dlcnMgdGhlIFtoYW5kbGVyXXtAbGluayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJ9IGZvciBhIGdpdmVuXG5cdCoge0BnbG9zc2FyeSBldmVudH0gdHlwZS5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogbXlDb250cm9sLnRyaWdnZXJIYW5kbGVyKCdvbnRhcCcpO1xuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fSB0byB0cmlnZ2VyLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIC0gVGhlIGV2ZW50IG9iamVjdCB0byBwYXNzIGFsb25nLlxuXHQqIEBwYXJhbSB7ZW55by5Db21wb25lbnR9IFtzZW5kZXI9dGhpc10gLSBUaGUgb3JpZ2luYXRvciBvZiB0aGUgZXZlbnQuXG5cdCogQHJldHVybnMge0Jvb2xlYW59IGBmYWxzZWAgaWYgdW5oYW5kbGVkIG9yIHVuaW50ZXJydXB0ZWQsIGB0cnVlYCBvdGhlcndpc2UuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKipcblx0KiBTZW5kcyBhIG1lc3NhZ2UgdG8gbXlzZWxmIGFuZCBhbGwgb2YgbXkgW2NvbXBvbmVudHNde0BsaW5rIGVueW8uQ29tcG9uZW50fS5cblx0KiBZb3UgY2FuIHN0b3AgYSB3YXRlcmZhbGwgaW50byBjb21wb25lbnRzIG93bmVkIGJ5IGEgcmVjZWl2aW5nIG9iamVjdFxuXHQqIGJ5IHJldHVybmluZyBhIHRydXRoeSB2YWx1ZSBmcm9tIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fVxuXHQqIFtoYW5kbGVyXXtAbGluayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJ9LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fSB0byB3YXRlcmZhbGwuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtldmVudF0gLSBUaGUgZXZlbnQgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdG8gcGFzcyBhbG9uZy5cblx0KiBAcGFyYW0ge2VueW8uQ29tcG9uZW50fSBbc2VuZGVyPXRoaXNdIC0gVGhlIG9yaWdpbmF0b3Igb2YgdGhlIGV2ZW50LlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHdhdGVyZmFsbDogZnVuY3Rpb24obm9tLCBldmVudCwgc2VuZGVyKSB7XG5cdFx0aWYgKCF0aGlzLl9zaWxlbmNlZCkge1xuXHRcdFx0ZXZlbnQgPSBldmVudCB8fCB7fTtcblx0XHRcdGV2ZW50LmJ1YmJsaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIGdpdmUgdGhlIGxvY2FscyBhbiBvcHBvcnR1bml0eSB0byBpbnRlcnJ1cHQgdGhlIGV2ZW50XG5cdFx0XHRpZiAodGhpcy5kaXNwYXRjaEV2ZW50KG5vbSwgZXZlbnQsIHNlbmRlcikpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBvdGhlcndpc2UgY2Fycnkgb25cblx0XHRcdHRoaXMud2F0ZXJmYWxsRG93bihub20sIGV2ZW50LCBzZW5kZXIgfHwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogU2VuZHMgYSBtZXNzYWdlIHRvIGFsbCBvZiBteSBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9LCBidXQgbm90IG15c2VsZi4gWW91IGNhblxuXHQqIHN0b3AgYSBbd2F0ZXJmYWxsXXtAbGluayBlbnlvLkNvbXBvbmVudCN3YXRlcmZhbGx9IGludG8gW2NvbXBvbmVudHNde0BsaW5rIGVueW8uQ29tcG9uZW50fVxuXHQqIG93bmVkIGJ5IGEgcmVjZWl2aW5nIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGJ5IHJldHVybmluZyBhIHRydXRoeSB2YWx1ZSBmcm9tIHRoZVxuXHQqIHtAZ2xvc3NhcnkgZXZlbnR9IFtoYW5kbGVyXXtAbGluayBlbnlvLkNvbXBvbmVudH5FdmVudEhhbmRsZXJ9LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cblx0KiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSAtIFRoZSBldmVudCBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBwYXNzIGFsb25nLlxuXHQqIEBwYXJhbSB7ZW55by5Db21wb25lbnR9IFtzZW5kZXI9dGhpc10gLSBUaGUgZXZlbnQgb3JpZ2luYXRvci5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR3YXRlcmZhbGxEb3duOiBmdW5jdGlvbihub20sIGV2ZW50LCBzZW5kZXIpIHtcblx0XHR2YXIgY29tcDtcblx0XHRldmVudCA9IGV2ZW50IHx8IHt9O1xuXHRcdGV2ZW50LmJ1YmJsaW5nID0gZmFsc2U7XG5cblx0XHRpZiAoIXRoaXMuX3NpbGVuY2VkKSB7XG5cdFx0XHRmb3IgKGNvbXAgaW4gdGhpcy4kKSB0aGlzLiRbY29tcF0ud2F0ZXJmYWxsKG5vbSwgZXZlbnQsIHNlbmRlciB8fCB0aGlzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfc2lsZW5jZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9zaWxlbmNlQ291bnQ6IDAsXG5cblx0LyoqXG5cdCogU2V0cyBhIGZsYWcgdGhhdCBkaXNhYmxlcyB7QGdsb3NzYXJ5IGV2ZW50fSBwcm9wYWdhdGlvbiBmb3IgdGhpc1xuXHQqIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fS4gQWxzbyBpbmNyZW1lbnRzIGFuIGludGVybmFsIGNvdW50ZXIgdGhhdCB0cmFja3Ncblx0KiB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBbdW5zaWxlbmNlKClde0BsaW5rIGVueW8uQ29tcG9uZW50I3Vuc2lsZW5jZX0gbWV0aG9kIG11c3Rcblx0KiBiZSBjYWxsZWQgYmVmb3JlIGV2ZW50IHByb3BhZ2F0aW9uIHdpbGwgY29udGludWUuXG5cdCpcblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzaWxlbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fc2lsZW5jZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3NpbGVuY2VDb3VudCArPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyBpZiB0aGUgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gaXMgY3VycmVudGx5XG5cdCogW3NpbGVuY2VkXXtAbGluayBlbnlvLkNvbXBvbmVudCNfc2lsZW5jZWR9LCB3aGljaCB3aWxsIHByZXZlbnQgcHJvcGFnYXRpb24gb2Zcblx0KiBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IChvZiBhbnkga2luZCkuXG5cdCpcblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHNpbGVuY2VkOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc1NpbGVuY2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpbGVuY2VkO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFsbG93cyB7QGdsb3NzYXJ5IGV2ZW50fSBwcm9wYWdhdGlvbiBmb3IgdGhpcyBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH1cblx0KiBpZiB0aGUgaW50ZXJuYWwgc2lsZW5jZSBjb3VudGVyIGlzIGAwYDsgb3RoZXJ3aXNlLCBkZWNyZW1lbnRzIHRoZSBjb3VudGVyIGJ5IG9uZS5cblx0KiBGb3IgZXZlbnQgcHJvcGFnYXRpb24gdG8gcmVzdW1lLCB0aGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBvbmUgdGltZSBlYWNoIGNhbGwgdG9cblx0KiBbc2lsZW5jZSgpXXtAbGluayBlbnlvLkNvbXBvbmVudCNzaWxlbmNlfS5cblx0KlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHtAbGluayBlbnlvLkNvbXBvbmVudH0gaXMgbm93IHVuc2lsZW5jZWQgY29tcGxldGVseTtcblx0Klx0YGZhbHNlYCBpZiBpdCByZW1haW5zIHNpbGVuY2VkLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dW5zaWxlbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKDAgIT09IHRoaXMuX3NpbGVuY2VDb3VudCkgLS10aGlzLl9zaWxlbmNlQ291bnQ7XG5cdFx0aWYgKDAgPT09IHRoaXMuX3NpbGVuY2VDb3VudCkgdGhpcy5fc2lsZW5jZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gIXRoaXMuX3NpbGVuY2VkO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBuZXcgW2pvYl17QGxpbmsgZW55by5qb2J9IHRpZWQgdG8gdGhpcyBpbnN0YW5jZSBvZiB0aGVcblx0KiBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0uIElmIHRoZSBjb21wb25lbnQgaXNcblx0KiBbZGVzdHJveWVkXXtAbGluayBlbnlvLkNvbXBvbmVudCNkZXN0cm95fSwgYW55IGpvYnMgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdCogd2lsbCBiZSBzdG9wcGVkLlxuXHQqXG5cdCogSWYgeW91IHN0YXJ0IGEgam9iIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHBlbmRpbmcgam9iLFxuXHQqIHRoZSBvcmlnaW5hbCBqb2Igd2lsbCBiZSBzdG9wcGVkOyB0aGlzIGNhbiBiZSB1c2VmdWwgZm9yIHJlc2V0dGluZ1xuXHQqIHRpbWVvdXRzLlxuXHQqXG5cdCogWW91IG1heSBzdXBwbHkgYSBwcmlvcml0eSBsZXZlbCAoMS0xMCkgYXQgd2hpY2ggdGhlIGpvYiBzaG91bGQgYmVcblx0KiBleGVjdXRlZC4gVGhlIGRlZmF1bHQgbGV2ZWwgaXMgYDVgLiBTZXR0aW5nIHRoZSBwcmlvcml0eSBsb3dlciB0aGFuIGA1YCAob3Igc2V0dGluZyBpdCB0b1xuXHQqIHRoZSBzdHJpbmcgYFwibG93XCJgKSB3aWxsIGRlZmVyIHRoZSBqb2IgaWYgYW4gYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLFxuXHQqIHdoaWNoIGNhbiBoZWxwIHRvIGF2b2lkIHN0dXR0ZXJpbmcuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbm9tIC0gVGhlIG5hbWUgb2YgdGhlIFtqb2Jde0BsaW5rIGVueW8uam9ifSB0byBzdGFydC5cblx0KiBAcGFyYW0geyhGdW5jdGlvbnxTdHJpbmcpfSBqb2IgLSBFaXRoZXIgdGhlIG5hbWUgb2YgYSBtZXRob2Qgb3IgYVxuXHQqXHRbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn0gdG8gZXhlY3V0ZSBhcyB0aGUgcmVxdWVzdGVkIGpvYi5cblx0KiBAcGFyYW0ge051bWJlcn0gd2FpdCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHN0YXJ0aW5nXG5cdCpcdHRoZSBqb2IuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eT01XSBUaGUgcHJpb3JpdHkgdmFsdWUgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXNcblx0Klx0am9iLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHN0YXJ0Sm9iOiBmdW5jdGlvbiAobm9tLCBqb2IsIHdhaXQsIHByaW9yaXR5KSB7XG5cdFx0dmFyIGpvYnMgPSAodGhpcy5fX2pvYnMgPSB0aGlzLl9fam9icyB8fCB7fSk7XG5cdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCA1O1xuXHRcdC8vIGFsbG93IHN0cmluZ3MgYXMgam9iIG5hbWVzLCB0aGV5IG1hcCB0byBsb2NhbCBtZXRob2QgbmFtZXNcblx0XHRpZiAodHlwZW9mIGpvYiA9PSAnc3RyaW5nJykgam9iID0gdGhpc1tqb2JdO1xuXHRcdC8vIHN0b3AgYW55IGV4aXN0aW5nIGpvYnMgd2l0aCBzYW1lIG5hbWVcblx0XHR0aGlzLnN0b3BKb2Iobm9tKTtcblx0XHRqb2JzW25vbV0gPSBzZXRUaW1lb3V0KHRoaXMuYmluZFNhZmVseShmdW5jdGlvbigpIHtcblx0XHRcdEpvYnMuYWRkKHRoaXMuYmluZFNhZmVseShqb2IpLCBwcmlvcml0eSwgbm9tKTtcblx0XHR9KSwgd2FpdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBTdG9wcyBhIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fS1zcGVjaWZpYyBbam9iXXtAbGluayBlbnlvLmpvYn0gYmVmb3JlIGl0IGhhc1xuXHQqIGJlZW4gYWN0aXZhdGVkLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSBbam9iXXtAbGluayBlbnlvLmpvYn0gdG8gYmUgc3RvcHBlZC5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdG9wSm9iOiBmdW5jdGlvbiAobm9tKSB7XG5cdFx0dmFyIGpvYnMgPSAodGhpcy5fX2pvYnMgPSB0aGlzLl9fam9icyB8fCB7fSk7XG5cdFx0aWYgKGpvYnNbbm9tXSkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KGpvYnNbbm9tXSk7XG5cdFx0XHRkZWxldGUgam9ic1tub21dO1xuXHRcdH1cblx0XHRKb2JzLnJlbW92ZShub20pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEV4ZWN1dGVzIHRoZSBzcGVjaWZpZWQgW2pvYl17QGxpbmsgZW55by5qb2J9IGltbWVkaWF0ZWx5LCB0aGVuIHByZXZlbnRzXG5cdCogYW55IG90aGVyIGNhbGxzIHRvIGB0aHJvdHRsZUpvYigpYCB3aXRoIHRoZSBzYW1lIGpvYiBuYW1lIGZyb20gcnVubmluZyBmb3Jcblx0KiB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSBbam9iXXtAbGluayBlbnlvLmpvYn0gdG8gdGhyb3R0bGUuXG5cdCogQHBhcmFtIHsoRnVuY3Rpb258U3RyaW5nKX0gam9iIC0gRWl0aGVyIHRoZSBuYW1lIG9mIGEgbWV0aG9kIG9yIGFcblx0Klx0W2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IHRvIGV4ZWN1dGUgYXMgdGhlIHJlcXVlc3RlZCBqb2IuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHdhaXQgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlXG5cdCpcdGpvYiBhZ2Fpbi5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0aHJvdHRsZUpvYjogZnVuY3Rpb24gKG5vbSwgam9iLCB3YWl0KSB7XG5cdFx0dmFyIGpvYnMgPSAodGhpcy5fX2pvYnMgPSB0aGlzLl9fam9icyB8fCB7fSk7XG5cdFx0Ly8gaWYgd2Ugc3RpbGwgaGF2ZSBhIGpvYiB3aXRoIHRoaXMgbmFtZSBwZW5kaW5nLCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRpZiAoIWpvYnNbbm9tXSkge1xuXHRcdFx0Ly8gYWxsb3cgc3RyaW5ncyBhcyBqb2IgbmFtZXMsIHRoZXkgbWFwIHRvIGxvY2FsIG1ldGhvZCBuYW1lc1xuXHRcdFx0aWYgKHR5cGVvZiBqb2IgPT0gJ3N0cmluZycpIGpvYiA9IHRoaXNbam9iXTtcblx0XHRcdGpvYi5jYWxsKHRoaXMpO1xuXHRcdFx0am9ic1tub21dID0gc2V0VGltZW91dCh0aGlzLmJpbmRTYWZlbHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc3RvcEpvYihub20pO1xuXHRcdFx0fSksIHdhaXQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbmtpbmQuc2V0RGVmYXVsdEN0b3IoQ29tcG9uZW50KTtcblxuLyoqXG4qIENyZWF0ZXMgbmV3IGluc3RhbmNlcyBmcm9tIFtjb25maWdde0BnbG9zc2FyeSBjb25maWd1cmF0aW9uQmxvY2t9XG4qIFtvYmplY3RzXXtAZ2xvc3NhcnkgT2JqZWN0fS4gVGhpcyBtZXRob2QgbG9va3MgdXAgdGhlIHByb3BlclxuKiBbY29uc3RydWN0b3Jde0BnbG9zc2FyeSBjb25zdHJ1Y3Rvcn0gYmFzZWQgb24gdGhlIHByb3ZpZGVkIFtraW5kXXtAZ2xvc3Nhcnkga2luZH1cbiogYXR0cmlidXRlLlxuKlxuKiBAbmFtZSBlbnlvLmNyZWF0ZVxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgW2tpbmRde0BnbG9zc2FyeSBraW5kfS5cbiogQHJldHVybnMgeyp9IEFuIGluc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWQgW2tpbmRde0BnbG9zc2FyeSBraW5kfS5cbiogQHB1YmxpY1xuKi9cbkNvbXBvbmVudC5jcmVhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcblx0dmFyIHRoZUtpbmQsXG5cdFx0Q3RvcjtcblxuXHRpZiAoIXByb3BzLmtpbmQgJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2tpbmQnKSkgdGhyb3cgbmV3IEVycm9yKFxuXHRcdCdlbnlvLmNyZWF0ZTogQXR0ZW1wdCB0byBjcmVhdGUgYSBudWxsIGtpbmQuIENoZWNrIGRlcGVuZGVuY2llcyBmb3IgWycgKyBwcm9wcy5uYW1lICsgJ10nXG5cdCk7XG5cblx0dGhlS2luZCA9IHByb3BzLmtpbmQgfHwgcHJvcHMuaXNhIHx8IGtpbmQuZ2V0RGVmYXVsdEN0b3IoKTtcblx0Q3RvciA9IGtpbmQuY29uc3RydWN0b3JGb3JLaW5kKHRoZUtpbmQpO1xuXG5cdGlmICghQ3Rvcikge1xuXHRcdGxvZ2dlci5lcnJvcignTm8gY29uc3RydWN0b3IgZm91bmQgZm9yIGtpbmQgJyArIHRoZUtpbmQpO1xuXHRcdEN0b3IgPSBDb21wb25lbnQ7XG5cdH1cblxuXHRyZXR1cm4gbmV3IEN0b3IocHJvcHMpO1xufTtcblxuLyoqXG4qIEBuYW1lIGVueW8uQ29tcG9uZW50LnN1YmNsYXNzXG4qIEBzdGF0aWNcbiogQHByaXZhdGVcbiovXG5Db21wb25lbnQuc3ViY2xhc3MgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMpIHtcblx0Ly8gTm90ZTogVG8gcmVkdWNlIEFQSSBzdXJmYWNlIGFyZWEsIHN1Yi1jb21wb25lbnRzIGFyZSBkZWNsYXJlZCBvbmx5IGFzXG5cdC8vICdjb21wb25lbnRzJyBpbiBib3RoIGtpbmQgYW5kIGluc3RhbmNlIGRlY2xhcmF0aW9ucy5cblx0Ly9cblx0Ly8gSG93ZXZlciwgJ2NvbXBvbmVudHMnIGZyb20ga2luZCBkZWNsYXJhdGlvbnMgbXVzdCBiZSBoYW5kbGVkIHNlcGFyYXRlbHlcblx0Ly8gYXQgY3JlYXRpb24gdGltZS5cblx0Ly9cblx0Ly8gV2UgcmVuYW1lIHRoZSBwcm9wZXJ0eSBoZXJlIHRvIGF2b2lkIGhhdmluZ1xuXHQvLyB0byBpbnRlcnJvZ2F0ZSB0aGUgcHJvdG90eXBlIGF0IGNyZWF0aW9uIHRpbWUuXG5cdC8vXG5cdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlO1xuXHQvL1xuXHRpZiAocHJvcHMuY29tcG9uZW50cykge1xuXHRcdHByb3RvLmtpbmRDb21wb25lbnRzID0gcHJvcHMuY29tcG9uZW50cztcblx0XHRkZWxldGUgcHJvdG8uY29tcG9uZW50cztcblx0fSBlbHNlIHtcblx0XHQvLyBGZWF0dXJlIHRvIG1peGluIG92ZXJyaWRlcyBvZiBzdXBlci1raW5kIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGZyb20gbmFtZWQgaGFzaFxuXHRcdC8vIChvbmx5IGFwcGxpZWQgd2hlbiB0aGUgc3ViLWtpbmQgZG9lc24ndCBzdXBwbHkgaXRzIG93biBjb21wb25lbnRzIGJsb2NrKVxuXHRcdGlmIChwcm9wcy5jb21wb25lbnRPdmVycmlkZXMpIHtcblx0XHRcdHByb3RvLmtpbmRDb21wb25lbnRzID0gQ29tcG9uZW50Lm92ZXJyaWRlQ29tcG9uZW50cyhcblx0XHRcdFx0cHJvdG8ua2luZENvbXBvbmVudHMsXG5cdFx0XHRcdHByb3BzLmNvbXBvbmVudE92ZXJyaWRlcyxcblx0XHRcdFx0cHJvdG8uZGVmYXVsdEtpbmRcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiogQG5hbWUgZW55by5Db21wb25lbnQuY29uY2F0XG4qIEBzdGF0aWNcbiogQHByaXZhdGVcbiovXG5Db21wb25lbnQuY29uY2F0ID0gZnVuY3Rpb24gKGN0b3IsIHByb3BzKSB7XG5cdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3IsXG5cdFx0aGFuZGxlcnM7XG5cdGlmIChwcm9wcy5oYW5kbGVycykge1xuXHRcdGhhbmRsZXJzID0gcHJvdG8uaGFuZGxlcnMgPyB1dGlscy5jbG9uZShwcm90by5oYW5kbGVycykgOiB7fTtcblx0XHRwcm90by5oYW5kbGVycyA9IHV0aWxzLm1peGluKGhhbmRsZXJzLCBwcm9wcy5oYW5kbGVycyk7XG5cdFx0ZGVsZXRlIHByb3BzLmhhbmRsZXJzO1xuXHR9XG5cdGlmIChwcm9wcy5ldmVudHMpIENvbXBvbmVudC5wdWJsaXNoRXZlbnRzKHByb3RvLCBwcm9wcyk7XG59O1xuXG4vKipcbiogQG5hbWUgZW55by5Db21wb25lbnQub3ZlcnJpZGVDb21wb25lbnRzXG4qIEBzdGF0aWNcbiogQHByaXZhdGVcbiovXG5Db21wb25lbnQub3ZlcnJpZGVDb21wb25lbnRzID0gZnVuY3Rpb24gKGNvbXBvbmVudHMsIG92ZXJyaWRlcywgZGVmYXVsdEtpbmQpIHtcblx0dmFyIGZuID0gZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuICEodXRpbHMuaXNGdW5jdGlvbih2KSB8fCBraW5kLmlzSW5oZXJpdGVkKHYpKTsgfTtcblx0Y29tcG9uZW50cyA9IHV0aWxzLmNsb25lKGNvbXBvbmVudHMpO1xuXHRmb3IgKHZhciBpPTA7IGk8Y29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjID0gdXRpbHMuY2xvbmUoY29tcG9uZW50c1tpXSk7XG5cdFx0dmFyIG8gPSBvdmVycmlkZXNbYy5uYW1lXTtcblx0XHR2YXIgY3RvciA9IGtpbmQuY29uc3RydWN0b3JGb3JLaW5kKGMua2luZCB8fCBkZWZhdWx0S2luZCk7XG5cdFx0aWYgKG8pIHtcblxuXHRcdFx0Ly8gTk9URTogWW91IGNhbm5vdCBvdmVybG9hZCBtaXhpbnMsIG9ic2VydmVycyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGZyb21cblx0XHRcdC8vIGNvbXBvbmVudCBvdmVycmlkZXNcblx0XHRcdGtpbmQuY29uY2F0SGFuZGxlcihjLCBvKTtcblx0XHRcdHZhciBiID0gKGMua2luZCAmJiAoKHR5cGVvZiBjLmtpbmQgPT0gJ3N0cmluZycgJiYgdXRpbHMuZ2V0UGF0aChjLmtpbmQpKSB8fCAodHlwZW9mIGMua2luZCA9PSAnZnVuY3Rpb24nICYmIGMua2luZCkpKSB8fCBraW5kLmdldERlZmF1bHRDdG9yKCk7XG5cdFx0XHR3aGlsZSAoYikge1xuXHRcdFx0XHRpZiAoYi5jb25jYXQpIHsgYi5jb25jYXQoYywgbywgdHJ1ZSk7IH1cblx0XHRcdFx0YiA9IGIucHJvdG90eXBlLmJhc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBBbGwgb3RoZXJzIGp1c3QgbWl4IGluXG5cdFx0XHR1dGlscy5taXhpbihjLCBvLCB7ZmlsdGVyOiBmbn0pO1xuXHRcdH1cblx0XHRpZiAoYy5jb21wb25lbnRzKSB7XG5cdFx0XHRjLmNvbXBvbmVudHMgPSBDb21wb25lbnQub3ZlcnJpZGVDb21wb25lbnRzKGMuY29tcG9uZW50cywgb3ZlcnJpZGVzLCBjdG9yLnByb3RvdHlwZS5kZWZhdWx0S2luZCk7XG5cdFx0fVxuXHRcdGNvbXBvbmVudHNbaV0gPSBjO1xuXHR9XG5cdHJldHVybiBjb21wb25lbnRzO1xufTtcblxuLyoqXG4qIEBuYW1lIGVueW8uQ29tcG9uZW50LnB1Ymxpc2hFdmVudHNcbiogQHN0YXRpY1xuKiBAcHJpdmF0ZVxuKi9cbkNvbXBvbmVudC5wdWJsaXNoRXZlbnRzID0gZnVuY3Rpb24gKGN0b3IsIHByb3BzKSB7XG5cdHZhciBldmVudHMgPSBwcm9wcy5ldmVudHMsXG5cdFx0ZXZlbnQsXG5cdFx0cHJvdG87XG5cdGlmIChldmVudHMpIHtcblx0XHRwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3I7XG5cdFx0Zm9yIChldmVudCBpbiBldmVudHMpIENvbXBvbmVudC5hZGRFdmVudChldmVudCwgZXZlbnRzW2V2ZW50XSwgcHJvdG8pO1xuXHR9XG59O1xuXG4vKipcbiogQG5hbWUgZW55by5Db21wb25lbnQuYWRkRXZlbnRcbiogQHN0YXRpY1xuKiBAcHJpdmF0ZVxuKi9cbkNvbXBvbmVudC5hZGRFdmVudCA9IGZ1bmN0aW9uIChub20sIHZhbCwgcHJvdG8pIHtcblx0dmFyIHYsIGZuO1xuXHRpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbCkpIHtcblx0XHR2ID0gdmFsLnZhbHVlO1xuXHRcdGZuID0gdmFsLmNhbGxlcjtcblx0fSBlbHNlIHtcblx0XHRpZiAobm9tLnNsaWNlKDAsIDIpICE9ICdvbicpIHtcblx0XHRcdGxvZ2dlci53YXJuKCdlbnlvLkNvbXBvbmVudC5hZGRFdmVudDogZXZlbnQgbmFtZXMgbXVzdCBzdGFydCB3aXRoIFwib25cIi4gJyArIHByb3RvLmtpbmROYW1lICsgJyAnICtcblx0XHRcdFx0J2V2ZW50IFwiJyArIG5vbSArICdcIiB3YXMgYXV0by1jb3JyZWN0ZWQgdG8gXCJvbicgKyBub20gKyAnXCIuJyk7XG5cdFx0XHRub20gPSAnb24nICsgbm9tO1xuXHRcdH1cblx0XHR2ID0gdmFsO1xuXHRcdGZuID0gJ2RvJyArIHV0aWxzLmNhcChub20uc2xpY2UoMikpO1xuXHR9XG5cdHByb3RvW25vbV0gPSB2O1xuXHRpZiAoIXByb3RvW2ZuXSkge1xuXHRcdHByb3RvW2ZuXSA9IGZ1bmN0aW9uKHBheWxvYWQsIG90aGVyKSB7XG5cdFx0XHQvLyBidWJibGUgdGhpcyBldmVudFxuXG5cdFx0XHQvLyBpZiB0aGUgc2Vjb25kIHBhcmFtZXRlciBleGlzdHMgdGhlbiB3ZSB1c2UgdGhhdCAtIHRoaXMgaXMgZm9yIGEgc2luZ2xlIGNhc2Vcblx0XHRcdC8vIHdoZXJlIGEgbmFtZWQgZXZlbnQgZGVsZWdhdGVzIGhhcHBlbnQgdG8gcG9pbnQgdG8gYW4gYXV0byBnZW5lcmF0ZWQgZXZlbnRcblx0XHRcdC8vIGJ1YmJsZXIgbGlrZSB0aGlzIG9uZSAtIGluIHRoYXQgY2FzZSB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGFjdHVhbGx5IHRoZVxuXHRcdFx0Ly8gc2VuZGVyXG5cdFx0XHR2YXIgZSA9IG90aGVyIHx8IHBheWxvYWQ7XG5cdFx0XHRpZiAoIWUpIHtcblx0XHRcdFx0ZSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGQgPSBlLmRlbGVnYXRlO1xuXHRcdFx0Ly8gZGVsZXRlIHBheWxvYWQuZGVsZWdhdGU7XG5cdFx0XHRlLmRlbGVnYXRlID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKCF1dGlscy5leGlzdHMoZS50eXBlKSkge1xuXHRcdFx0XHRlLnR5cGUgPSBub207XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmJ1YmJsZShub20sIGUpO1xuXHRcdFx0aWYgKGQpIHtcblx0XHRcdFx0ZS5kZWxlZ2F0ZSA9IGQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gcHJlZml4RnJvbUtpbmROYW1lIChub20pIHtcblx0dmFyIHByZSA9IGtpbmRQcmVmaXhbbm9tXSxcblx0XHRsYXN0O1xuXG5cdGlmICghcHJlKSB7XG5cdFx0bGFzdCA9IG5vbS5sYXN0SW5kZXhPZignLicpO1xuXHRcdHByZSA9IChsYXN0ID49IDApID8gbm9tLnNsaWNlKGxhc3QrMSkgOiBub207XG5cdFx0cHJlID0gcHJlLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHJlLnNsaWNlKDEpO1xuXHRcdGtpbmRQcmVmaXhbbm9tXSA9IHByZTtcblx0fVxuXG5cdHJldHVybiBwcmU7XG59XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9BcHBsaWNhdGlvblN1cHBvcnRcIjo2LFwiLi9Db21wb25lbnRCaW5kaW5nU3VwcG9ydFwiOjE0LFwiLi9Db3JlT2JqZWN0XCI6MTcsXCIuL2pvYnNcIjo2NCxcIi4va2luZFwiOjY2LFwiLi9sb2dnZXJcIjo2NyxcIi4vdXRpbHNcIjo3NX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhclxuXHRBc3luYyA9IHJlcXVpcmUoJy4vQXN5bmMnKSxcblx0QWpheCA9IHJlcXVpcmUoJy4vQWpheCcpO1xuXG4vKipcbioge0BsaW5rIGVueW8uSnNvbnBSZXF1ZXN0fSBpcyBhbiBbQXN5bmNde0BsaW5rIGVueW8uQXN5bmN9IHRhc2sgc3BlY2lmaWNhbGx5IGRlc2lnbmVkXG4qIHRvIHdyYXAge0BnbG9zc2FyeSBKU09OUH0gcmVxdWVzdHMgdG8gYSByZW1vdGUgc2VydmVyLiBCZSBzdXJlIHRvIHJlYWQgYWJvdXQgdGhlIHVzZVxuKiBjYXNlcyBmb3IgSlNPTlAgcmVxdWVzdHMsIGFsb25nIHdpdGggdGhlIGRvY3VtZW50YXRpb24gb24gW0NvbnN1bWluZyBXZWJcbiogU2VydmljZXNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL21hbmFnaW5nLWRhdGEvY29uc3VtaW5nLXdlYi1zZXJ2aWNlcy5odG1sfVxuKiBpbiB0aGUgRW55byBEZXZlbG9wZXIgR3VpZGUuXG4qXG4qIEBjbGFzcyBlbnlvLkpzb25wUmVxdWVzdFxuKiBAZXh0ZW5kcyBlbnlvLkFzeW5jXG4qIEBwdWJsaWNcbiovXG52YXIgSnNvbnBSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uSnNvbnBSZXF1ZXN0LnByb3RvdHlwZSAqLyB7XG5cdFxuXHRuYW1lOiAnZW55by5Kc29ucFJlcXVlc3QnLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQXN5bmMsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IHtcblx0XHRcblx0XHQvKipcblx0XHQqIFRoZSBVUkwgZm9yIHRoZSBzZXJ2aWNlLlxuXHRcdCpcblx0XHQqIEBtZW1iZXJvZiBlbnlvLkpzb25wUmVxdWVzdC5wcm90b3R5cGVcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dXJsOiAnJyxcblx0XHRcblx0XHQvKipcblx0XHQqIFRoZSBvcHRpb25hbCBjaGFyYWN0ZXIgc2V0IHRvIHVzZSB0byBpbnRlcnByZXQgdGhlIHJldHVybiBkYXRhLlxuXHRcdCpcblx0XHQqIEBtZW1iZXJvZiBlbnlvLkpzb25wUmVxdWVzdC5wcm90b3R5cGVcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCBudWxsXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRjaGFyc2V0OiBudWxsLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCogVGhlIG5hbWUgb2YgdGhlIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSB0aGF0IGlzIGluY2x1ZGVkIGluIHRoZVxuXHRcdCogZW5jb2RlZCBhcmd1bWVudHMgYW5kIHVzZWQgdG8gd3JhcCB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIHNlcnZlci5cblx0XHQqIFRoaXMgbWF5IGFsc28gYmUgc2V0IHRvIGBudWxsYCBpbiBzb21lIGNhc2VzLlxuXHRcdCpcblx0XHQqIEBzZWUgZW55by5Kc29ucFJlcXVlc3Qub3ZlcnJpZGVDYWxsYmFja1xuXHRcdCogQG1lbWJlcm9mIGVueW8uSnNvbnBSZXF1ZXN0LnByb3RvdHlwZVxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdjYWxsYmFjaydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGNhbGxiYWNrTmFtZTogJ2NhbGxiYWNrJyxcblx0XHRcblx0XHQvKipcblx0XHQqIFdoZW4gYHRydWVgLCBhIHJhbmRvbSBudW1iZXIgaXMgYXBwZW5kZWQgYXMgYSBwYXJhbWV0ZXIgZm9yIEdFVCByZXF1ZXN0c1xuXHRcdCogdG8gKGF0dGVtcHQgdG8pIGZvcmNlIGEgbmV3IGZldGNoIG9mIHRoZSByZXNvdXJjZSBpbnN0ZWFkIG9mIHJldXNpbmcgYVxuXHRcdCogbG9jYWwgY2FjaGUuXG5cdFx0KlxuXHRcdCogQG1lbWJlcm9mIGVueW8uSnNvbnBSZXF1ZXN0LnByb3RvdHlwZVxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCB0cnVlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRjYWNoZUJ1c3Q6IHRydWUsXG5cdFx0XG5cdFx0LyoqXG5cdFx0KiBJbiBjYXNlcyB3aGVyZSBhIGJhY2tlbmQgaXMgaW5mbGV4aWJsZSB3aXRoIHJlZ2FyZCB0b1xuXHRcdCogW2NhbGxiYWNrXXtAbGluayBlbnlvLkpzb25wUmVxdWVzdCNjYWxsYmFja30gbmFtZXMsIHRoaXMgcHJvcGVydHkgbWF5IGJlIHVzZWQgdG9cblx0XHQqIHNwZWNpZnkgYSBnbG9iYWwgW2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IGluc3RlYWQuIE5vdGUgdGhhdCB3aGVuIHVzaW5nXG5cdFx0KiB0aGlzLCBpdCB3aWxsIHJlcGxhY2UgYW55IGV4aXN0aW5nIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuXG5cdFx0KiBuYW1lIGFuZCBvbmx5IG9uZSBbSnNvbnBSZXF1ZXN0XXtAbGluayBlbnlvLkpzb25wUmVxdWVzdH0gdXNpbmcgdGhpcyBwcm9wZXJ0eSBtYXlcblx0XHQqIGJlIGFjdGl2ZSBhdCBhIHRpbWUuXG5cdFx0KlxuXHRcdCogQG1lbWJlcm9mIGVueW8uSnNvbnBSZXF1ZXN0LnByb3RvdHlwZVxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0IG51bGxcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG92ZXJyaWRlQ2FsbGJhY2s6IG51bGxcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHByb3RlY3RlZFN0YXRpY3M6IHtcblx0XHQvLyBDb3VudGVyIHRvIGFsbG93IGNyZWF0aW9uIG9mIHVuaXF1ZSBuYW1lIGZvciBlYWNoIEpTT05QIHJlcXVlc3Rcblx0XHRuZXh0Q2FsbGJhY2tJRDogMFxuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YWRkU2NyaXB0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRzY3JpcHQuc3JjID0gdGhpcy5zcmM7XG5cdFx0c2NyaXB0LmFzeW5jID0gJ2FzeW5jJztcblx0XHRpZiAodGhpcy5jaGFyc2V0KSB7XG5cdFx0XHRzY3JpcHQuY2hhcnNldCA9IHRoaXMuY2hhcnNldDtcblx0XHR9XG5cdFx0Ly8gbW9zdCBtb2Rlcm4gYnJvd3NlcnMgYWxzbyBoYXZlIGFuIG9uZXJyb3IgaGFuZGxlclxuXHRcdHNjcmlwdC5vbmVycm9yID0gdGhpcy5iaW5kU2FmZWx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGNvZGUsIHNvIHdlJ2xsIGp1c3QgdXNlIHRoZSBnZW5lcmljIDQwMCBlcnJvciBzdGF0dXNcblx0XHRcdHRoaXMuZmFpbCg0MDApO1xuXHRcdH0pO1xuXHRcdC8vIGFkZCBzY3JpcHQgYmVmb3JlIGV4aXN0aW5nIHNjcmlwdCB0byBtYWtlIHN1cmUgaXQncyBpbiBhIHZhbGlkIHBhcnQgb2YgZG9jdW1lbnRcblx0XHQvLyBodHRwOi8vd3d3LmpzcGF0dGVybnMuY29tL3RoZS1yaWRpY3Vsb3VzLWNhc2Utb2YtYWRkaW5nLWEtc2NyaXB0LWVsZW1lbnQvXG5cdFx0dmFyIGZpcnN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuXHRcdGZpcnN0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgZmlyc3QpO1xuXHRcdHRoaXMuc2NyaXB0VGFnID0gc2NyaXB0O1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVtb3ZlU2NyaXB0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdFRhZztcblx0XHR0aGlzLnNjcmlwdFRhZyA9IG51bGw7XG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuXHRcdGlmIChzY3JpcHQucGFyZW50Tm9kZSkge1xuXHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3Rvcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHBhcmFtcykge1xuXHRcdFx0dXRpbHMubWl4aW4odGhpcywgcGFyYW1zKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogSW5pdGlhdGVzIHRoZSBhc3luY2hyb25vdXMgcm91dGluZSBhbmQgd2lsbCBzdXBwbHkgdGhlIGdpdmVuIHZhbHVlIGlmIGl0IGNvbXBsZXRlc1xuXHQqIHN1Y2Nlc3NmdWxseS4gT3ZlcmxvYWRlZCBmcm9tIFtlbnlvLkFzeW5jLmdvKClde0BsaW5rIGVueW8uQXN5bmMjZ299LlxuXHQqXG5cdCogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwYXNzIHRvIHJlc3BvbmRlcnMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z286IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuc3RhcnRUaW1lcigpO1xuXHRcdHRoaXMuanNvbnAodmFsdWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0anNvbnA6IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0XHR2YXIgY2FsbGJhY2tGdW5jdGlvbk5hbWUgPSB0aGlzLm92ZXJyaWRlQ2FsbGJhY2sgfHxcblx0XHRcdCdlbnlvX2pzb25wX2NhbGxiYWNrXycgKyAoSnNvbnBSZXF1ZXN0Lm5leHRDYWxsYmFja0lEKyspO1xuXHRcdC8vXG5cdFx0dGhpcy5zcmMgPSB0aGlzLmJ1aWxkVXJsKHBhcmFtcywgY2FsbGJhY2tGdW5jdGlvbk5hbWUpO1xuXHRcdHRoaXMuYWRkU2NyaXB0RWxlbWVudCgpO1xuXHRcdC8vXG5cdFx0Z2xvYmFsW2NhbGxiYWNrRnVuY3Rpb25OYW1lXSA9IHRoaXMuYmluZFNhZmVseSh0aGlzLnJlc3BvbmQpO1xuXHRcdC8vXG5cdFx0Ly8gc2V0dXAgY2xlYW51cCBoYW5kbGVycyBmb3IgSlNPTlAgY29tcGxldGlvbiBhbmQgZmFpbHVyZVxuXHRcdHZhciBjbGVhbnVwID0gdGhpcy5iaW5kU2FmZWx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZW1vdmVTY3JpcHRFbGVtZW50KCk7XG5cdFx0XHRnbG9iYWxbY2FsbGJhY2tGdW5jdGlvbk5hbWVdID0gbnVsbDtcblx0XHR9KTtcblx0XHR0aGlzLnJlc3BvbnNlKGNsZWFudXApO1xuXHRcdHRoaXMuZXJyb3IoY2xlYW51cCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRidWlsZFVybDogZnVuY3Rpb24ocGFyYW1zLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMudXJsLnNwbGl0KCc/Jyk7XG5cdFx0dmFyIHVyaSA9IHBhcnRzLnNoaWZ0KCkgfHwgJyc7XG5cdFx0dmFyIGFyZ3MgPSBwYXJ0cy5sZW5ndGg/IHBhcnRzLmpvaW4oJz8nKS5zcGxpdCgnJicpOiBbXTtcblx0XHQvL1xuXHRcdHZhciBib2R5QXJncyA9IHRoaXMuYm9keUFyZ3NGcm9tUGFyYW1zKHBhcmFtcywgZm4pO1xuXHRcdGFyZ3MucHVzaChib2R5QXJncyk7XG5cdFx0aWYgKHRoaXMuY2FjaGVCdXN0KSB7XG5cdFx0XHRhcmdzLnB1c2goTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHRcdC8vXG5cdFx0cmV0dXJuIFt1cmksIGFyZ3Muam9pbignJicpXS5qb2luKCc/Jyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBJZiBgcGFyYW1zYCBpcyBhIHN0cmluZywgd2UgZm9sbG93IHRoZSBjb252ZW50aW9uIG9mIHJlcGxhY2luZyB0aGUgc3RyaW5nXG5cdCogYCc9PydgIHdpdGggdGhlIGNhbGxiYWNrIG5hbWUuIElmIGBwYXJhbXNgIGlzIGFuIG9iamVjdCAodGhlIG1vcmUgY29tbW9uXG5cdCogY2FzZSksIHdlIGFkZCBhbiBhcmd1bWVudCB1c2luZyB0aGUgYGNhbGxiYWNrTmFtZWAgcHVibGlzaGVkIHByb3BlcnR5LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Ym9keUFyZ3NGcm9tUGFyYW1zOiBmdW5jdGlvbihwYXJhbXMsIGZuKSB7XG5cdFx0aWYgKHV0aWxzLmlzU3RyaW5nKHBhcmFtcykpIHtcblx0XHRcdHJldHVybiBwYXJhbXMucmVwbGFjZSgnPT8nLCAnPScgKyBmbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyA/IHV0aWxzLmNsb25lKHBhcmFtcywgdHJ1ZSkgOiB7fTtcblx0XHRcdGlmICh0aGlzLmNhbGxiYWNrTmFtZSkge1xuXHRcdFx0XHRwYXJhbXNbdGhpcy5jYWxsYmFja05hbWVdID0gZm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQWpheC5vYmplY3RUb1F1ZXJ5KHBhcmFtcyk7XG5cdFx0fVxuXHR9XG59KTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQWpheFwiOjIsXCIuL0FzeW5jXCI6NyxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuXHRhbmltYXRpb24gPSByZXF1aXJlKCcuL2FuaW1hdGlvbicpO1xuXG52YXJcblx0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKSxcblx0Sm9icyA9IHJlcXVpcmUoJy4vam9icycpO1xuXG4vKipcbiogRmlyZXMgd2hlbiBhbiBhbmltYXRpb24gc3RlcCBvY2N1cnMuXG4qXG4qIEBldmVudCBlbnlvLkFuaW1hdG9yI29uU3RlcFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzIG5vcm1hbGx5LlxuKlxuKiBAZXZlbnQgZW55by5BbmltYXRvciNvbkVuZFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIHByZW1hdHVyZWx5IHN0b3BwZWQuXG4qXG4qIEBldmVudCBlbnlvLkFuaW1hdG9yI29uU3RvcFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uQW5pbWF0b3J9IGlzIGEgYmFzaWMgYW5pbWF0aW9uIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fS4gIENhbGxcbiogW3BsYXkoKV17QGxpbmsgZW55by5BbmltYXRvciNwbGF5fSB0byBzdGFydCB0aGUgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIHdpbGwgcnVuIGZvclxuKiB0aGUgcGVyaW9kIChpbiBtaWxsaXNlY29uZHMpIHNwZWNpZmllZCBieSBpdHMgW2R1cmF0aW9uXXtAbGluayBlbnlvLkFuaW1hdG9yI2R1cmF0aW9ufVxuKiBwcm9wZXJ0eS4gW29uU3RlcF17QGxpbmsgZW55by5BbmltYXRvciNvblN0ZXB9IFtldmVudHNde0BnbG9zc2FyeSBldmVudH0gd2lsbFxuKiBmaXJlIGluIHF1aWNrIHN1Y2Nlc3Npb24gYW5kIHNob3VsZCBiZSBoYW5kbGVkIHRvIGRvIHNvbWV0aGluZyBiYXNlZCBvbiB0aGVcbiogW3ZhbHVlXXtAbGluayBlbnlvLkFuaW1hdG9yI3ZhbHVlfSBwcm9wZXJ0eS5cbipcbiogVGhlIGB2YWx1ZWAgcHJvcGVydHkgd2lsbCBwcm9ncmVzcyBmcm9tIFtzdGFydFZhbHVlXXtAbGluayBlbnlvLkFuaW1hdG9yI3N0YXJ0VmFsdWV9XG4qIHRvIFtlbmRWYWx1ZV17QGxpbmsgZW55by5BbmltYXRvciNlbmRWYWx1ZX0gZHVyaW5nIHRoZSBhbmltYXRpb24sIGJhc2VkIG9uIHRoZVxuKiBbZnVuY3Rpb25de0BnbG9zc2FyeSBGdW5jdGlvbn0gcmVmZXJlbmNlZCBieSB0aGVcbiogW2Vhc2luZ0Z1bmN0aW9uXXtAbGluayBlbnlvLkFuaW1hdG9yI2Vhc2luZ0Z1bmN0aW9ufSBwcm9wZXJ0eS5cbiogXG4qIEV2ZW50IGhhbmRsZXJzIG1heSBiZSBzcGVjaWZpZWQgYXMgZnVuY3Rpb25zLiBJZiBzcGVjaWZpZWQsIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIHdpbGxcbiogYmUgdXNlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGRpcmVjdGx5LCB3aXRob3V0IHNlbmRpbmcgdGhlIGV2ZW50IHRvIGl0c1xuKiBbb3duZXJde0BsaW5rIGVueW8uQ29tcG9uZW50I293bmVyfSBvciBbYnViYmxpbmdde0BsaW5rIGVueW8uQ29tcG9uZW50I2J1YmJsZX0gaXQuXG4qIFRoZSBbY29udGV4dF17QGxpbmsgZW55by5BbmltYXRvciNjb250ZXh0fSBwcm9wZXJ0eSBtYXkgYmUgdXNlZCB0byBjYWxsIHRoZSBzdXBwbGllZFxuKiBldmVudCBmdW5jdGlvbnMgaW4gYSBwYXJ0aWN1bGFyIGB0aGlzYCBjb250ZXh0LlxuKiBcbiogRHVyaW5nIGFuaW1hdGlvbiwgYW4ge0BsaW5rIGVueW8uam9ic30gcHJpb3JpdHkgb2YgNSBpcyByZWdpc3RlcmVkIHRvIGRlZmVyIGxvdyBwcmlvcml0eSBcbiogdGFza3MuXG4qXG4qIEBjbGFzcyBlbnlvLkFuaW1hdG9yXG4qIEBleHRlbmRzIGVueW8uQ29tcG9uZW50XG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5BbmltYXRvci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEEgY29udGV4dCBpbiB3aGljaCB0byBydW4gdGhlIHNwZWNpZmllZCB7QGdsb3NzYXJ5IGV2ZW50fSBoYW5kbGVycy4gSWYgdGhpcyBpc1xuXHQqIG5vdCBzcGVjaWZpZWQgb3IgaXMgZmFsc3ksIHRoZW4gdGhlIFtnbG9iYWwgb2JqZWN0XXtAZ2xvc3NhcnkgZ2xvYmFsfSBpcyB1c2VkLlxuXHQqIFxuXHQqIEBuYW1lIGNvbnRleHRcblx0KiBAdHlwZSB7T2JqZWN0fVxuXHQqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHQqIEBtZW1iZXJPZiBlbnlvLkFuaW1hdG9yLnByb3RvdHlwZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0XHRcblx0bmFtZTogJ2VueW8uQW5pbWF0b3InLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbXBvbmVudCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgZW55by5BbmltYXRvci5wcm90b3R5cGUgKi8ge1xuXHRcdFxuXHRcdC8qKiBcblx0XHQqIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMzUwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRkdXJhdGlvbjogMzUwLFxuXG5cdFx0LyoqIFxuXHRcdCogVmFsdWUgb2YgW3ZhbHVlXXtAbGluayBlbnlvLkFuaW1hdG9yI3ZhbHVlfSBwcm9wZXJ0eSBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGFuaW1hdGlvbi5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c3RhcnRWYWx1ZTogMCxcblxuXHRcdC8qKiBcblx0XHQqIFZhbHVlIG9mIFt2YWx1ZV17QGxpbmsgZW55by5BbmltYXRvciN2YWx1ZX0gcHJvcGVydHkgYXQgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IDFcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGVuZFZhbHVlOiAxLFxuXG5cdFx0LyoqIFxuXHRcdCogTm9kZSB0aGF0IG11c3QgYmUgdmlzaWJsZSBpbiBvcmRlciBmb3IgdGhlIGFuaW1hdGlvbiB0byBjb250aW51ZS4gVGhpcyByZWZlcmVuY2UgaXMgXG5cdFx0KiBkZXN0cm95ZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGNlYXNlcy5cblx0XHQqXG5cdFx0KiBAdHlwZSB7T2JqZWN0fVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0bm9kZTogbnVsbCxcblxuXHRcdC8qKiBcblx0XHQqIFtGdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSB0aGF0IGRldGVybWluZXMgaG93IHRoZSBhbmltYXRpb24gcHJvZ3Jlc3NlcyBmcm9tIFxuXHRcdCogW3N0YXJ0VmFsdWVde0BsaW5rIGVueW8uQW5pbWF0b3Ijc3RhcnRWYWx1ZX0gdG8gW2VuZFZhbHVlXXtAbGluayBlbnlvLkFuaW1hdG9yI2VuZFZhbHVlfS5cblx0XHQqIFxuXHRcdCogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCogQGRlZmF1bHQgZW55by5lYXNpbmcuY3ViaWNPdXRcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGVhc2luZ0Z1bmN0aW9uOiBhbmltYXRpb24uZWFzaW5nLmN1YmljT3V0XG5cdH0sXG5cdFxuXHQvKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uU3RlcDogJycsXG5cdFx0b25FbmQ6ICcnLFxuXHRcdG9uU3RvcDogJydcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0ZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9uZXh0ID0gdGhpcy5iaW5kU2FmZWx5KCduZXh0Jyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKiogXG5cdCogUGxheXMgdGhlIGFuaW1hdGlvbi5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEFzIGEgY29udmVuaWVuY2UsIHRoaXMgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9IHdpbGwgYmUgbWl4ZWRcblx0Klx0ZGlyZWN0bHkgaW50byB0aGlzIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cGxheTogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cdFx0dGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dXRpbHMubWl4aW4odGhpcywgcHJvcHMpO1xuXHRcdH1cblx0XHR0aGlzLnQwID0gdGhpcy50MSA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHR0aGlzLnZhbHVlID0gdGhpcy5zdGFydFZhbHVlO1xuXG5cdFx0Ly8gcmVnaXN0ZXIgdGhpcyBqb2JQcmlvcml0eSB0byBibG9jayBsZXNzIHVyZ2VudCB0YXNrcyBmcm9tIGV4ZWN1dGluZ1xuXHRcdEpvYnMucmVnaXN0ZXJQcmlvcml0eSg1LCB0aGlzLmlkKTtcblxuXHRcdHRoaXMuam9iID0gdHJ1ZTtcblx0XHR0aGlzLm5leHQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiogXG5cdCogU3RvcHMgdGhlIGFuaW1hdGlvbiBhbmQgZmlyZXMgdGhlIGFzc29jaWF0ZWQge0BnbG9zc2FyeSBldmVudH0uXG5cdCpcblx0KiBAZmlyZXMgZW55by5BbmltYXRvciNvblN0b3Bcblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuaXNBbmltYXRpbmcoKSkge1xuXHRcdFx0dGhpcy5jYW5jZWwoKTtcblx0XHRcdHRoaXMuZmlyZSgnb25TdG9wJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU3RvcHMgdGhlIGFuaW1hdGlvbiBhZnRlciBhIGZpbmFsIHN0ZXBcblx0KlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5pc0FuaW1hdGluZygpKSB7XG5cdFx0XHQvLyBzZXQgdGhlIHN0YXJ0IHRpbWUgc3VjaCB0aGF0IHRoZSBkZWx0YSB3aWxsIGFsd2F5cyBiZSBncmVhdGVyIHRoYW4gdGhlIGR1cmF0aW9uXG5cdFx0XHQvLyBjYXVzaW5nIHRoZSBhbmltYXRpb24gdG8gY29tcGxldGUgaW1tZWRpYXRlbHlcblx0XHRcdHRoaXMudDAgPSAtdGhpcy5kdXJhdGlvbiAtIDE7XG5cdFx0XHR0aGlzLm5leHQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiogXG5cdCogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBhIHJ1bm5pbmcgYW5pbWF0aW9uLlxuXHQqIFxuXHQqIEByZXR1cm4ge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmV2ZXJzZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmlzQW5pbWF0aW5nKCkpIHtcblx0XHRcdHRoaXMucmV2ZXJzZWQgPSAhdGhpcy5yZXZlcnNlZDtcblx0XHRcdHZhciBub3cgPSB0aGlzLnQxID0gdXRpbHMucGVyZk5vdygpO1xuXHRcdFx0Ly8gYWRqdXN0IHN0YXJ0IHRpbWUgKHQwKSB0byBhbGxvdyBmb3IgYW5pbWF0aW9uIGRvbmUgc28gZmFyIHRvIHJlcGxheVxuXHRcdFx0dmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLnQwO1xuXHRcdFx0dGhpcy50MCA9IG5vdyArIGVsYXBzZWQgLSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0Ly8gc3dhcCBzdGFydCBhbmQgZW5kIHZhbHVlc1xuXHRcdFx0dmFyIHN0YXJ0VmFsdWUgPSB0aGlzLnN0YXJ0VmFsdWU7XG5cdFx0XHR0aGlzLnN0YXJ0VmFsdWUgPSB0aGlzLmVuZFZhbHVlO1xuXHRcdFx0dGhpcy5lbmRWYWx1ZSA9IHN0YXJ0VmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cblx0KlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGN1cnJlbnRseSBydW5uaW5nOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNBbmltYXRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmpvYik7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVxdWVzdE5leHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmpvYiA9IGFuaW1hdGlvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fbmV4dCwgdGhpcy5ub2RlKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcblx0XHRhbmltYXRpb24uY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuam9iKTtcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xuXHRcdHRoaXMuam9iID0gbnVsbDtcblxuXHRcdC8vIHVuYmxvY2sgam9iIHF1ZXVlXG5cdFx0Sm9icy51bnJlZ2lzdGVyUHJpb3JpdHkodGhpcy5pZCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvdWxkRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLmR0ID49IHRoaXMuZHVyYXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJ1bnMgdGhlIG5leHQgc3RlcCBvZiB0aGUgYW5pbWF0aW9uLlxuXHQqXG5cdCogQGZpcmVzIGVueW8uQW5pbWF0b3Ijb25TdGVwXG5cdCogQGZpcmVzIGVueW8uQW5pbWF0b3Ijb25FbmRcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy50MSA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHR0aGlzLmR0ID0gdGhpcy50MSAtIHRoaXMudDA7XG5cdFx0dmFyIGFyZ3MgPSB0aGlzLmVhc2luZ0Z1bmN0aW9uLmxlbmd0aDtcblx0XHR2YXIgZjtcblxuXHRcdGlmIChhcmdzID09PSAxKSB7XG5cdFx0XHQvLyB0aW1lIGluZGVwZW5kZW50XG5cdFx0XHRmID0gdGhpcy5mcmFjdGlvbiA9IGFuaW1hdGlvbi5lYXNlZExlcnAodGhpcy50MCwgdGhpcy5kdXJhdGlvbiwgdGhpcy5lYXNpbmdGdW5jdGlvbiwgdGhpcy5yZXZlcnNlZCk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5zdGFydFZhbHVlICsgZiAqICh0aGlzLmVuZFZhbHVlIC0gdGhpcy5zdGFydFZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52YWx1ZSA9IGFuaW1hdGlvbi5lYXNlZENvbXBsZXhMZXJwKHRoaXMudDAsIHRoaXMuZHVyYXRpb24sIHRoaXMuZWFzaW5nRnVuY3Rpb24sIHRoaXMucmV2ZXJzZWQsXG5cdFx0XHRcdHRoaXMuZHQsIHRoaXMuc3RhcnRWYWx1ZSwgKHRoaXMuZW5kVmFsdWUgLSB0aGlzLnN0YXJ0VmFsdWUpKTtcblx0XHR9XG5cdFx0aWYgKCgoZiA+PSAxKSAmJiAoYXJncyA9PT0gMSkpIHx8IHRoaXMuc2hvdWxkRW5kKCkpIHtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmVuZFZhbHVlO1xuXHRcdFx0dGhpcy5mcmFjdGlvbiA9IDE7XG5cdFx0XHR0aGlzLmZpcmUoJ29uU3RlcCcpO1xuXHRcdFx0dGhpcy5jYW5jZWwoKTtcblx0XHRcdHV0aWxzLmFzeW5jTWV0aG9kKHRoaXMuYmluZFNhZmVseShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5maXJlKCdvbkVuZCcpO1xuXHRcdFx0fSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZpcmUoJ29uU3RlcCcpO1xuXHRcdFx0dGhpcy5yZXF1ZXN0TmV4dCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaXJlOiBmdW5jdGlvbiAobm9tKSB7XG5cdFx0dmFyIGZuID0gdGhpc1tub21dO1xuXHRcdGlmICh1dGlscy5pc1N0cmluZyhmbikpIHtcblx0XHRcdHRoaXMuYnViYmxlKG5vbSk7XG5cdFx0fSBlbHNlIGlmIChmbikge1xuXHRcdFx0Zm4uY2FsbCh0aGlzLmNvbnRleHQgfHwgZ2xvYmFsLCB0aGlzKTtcblx0XHR9XG5cdH1cbn0pO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db21wb25lbnRcIjoxMyxcIi4vYW5pbWF0aW9uXCI6NTYsXCIuL2pvYnNcIjo2NCxcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50JyksXG5cdEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vRXZlbnRFbWl0dGVyJyksXG5cdE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpLFxuXHRNb2RlbExpc3QgPSByZXF1aXJlKCcuL01vZGVsTGlzdCcpLFxuXHRTdGF0ZVN1cHBvcnQgPSByZXF1aXJlKCcuL1N0YXRlU3VwcG9ydCcpLFxuXHRTb3VyY2UgPSByZXF1aXJlKCcuL1NvdXJjZScpLFxuXHRTdG9yZSA9IHJlcXVpcmUoJy4vU3RvcmUnKSxcblx0U3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0ZXMnKTtcblxuLyoqXG4qIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgYmVjYXVzZSBvZiB0aGUgb3JkZXIgaW4gd2hpY2ggbWl4aW5zIGFyZSBhcHBsaWVkLlxuKlxuKiBAY2xhc3NcbiogQHByaXZhdGVcbiovXG52YXIgQmFzZUNvbGxlY3Rpb24gPSBraW5kKHtcblx0a2luZDogQ29tcG9uZW50LFxuXHRtaXhpbnM6IFtFdmVudEVtaXR0ZXIsIFN0YXRlU3VwcG9ydF1cbn0pO1xuXG4vKipcbiogRmlyZXMgd2hlbiBbbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfSBoYXZlIGJlZW4gW2FkZGVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jYWRkfVxuKiB0byB0aGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG4qXG4qIEBldmVudCBlbnlvLkNvbGxlY3Rpb24jYWRkXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7ZW55by5Nb2RlbFtdfSBtb2RlbHMgLSBBbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2ZcbipcdFttb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9IHRoYXQgd2VyZSBbYWRkZWRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNhZGR9IHRvIHRoZVxuKlx0W2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG4qIEBwcm9wZXJ0eSB7ZW55by5Db2xsZWN0aW9ufSBjb2xsZWN0aW9uIC0gQSByZWZlcmVuY2UgdG8gdGhlXG4qXHRjb2xsZWN0aW9uIHRoYXQgW2VtaXR0ZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyLmVtaXR9IHRoZSBldmVudC5cbiogQHByb3BlcnR5IHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uIHdoZXJlIHRoZSBtb2RlbHMgd2VyZSBpbnNlcnRlZC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gW21vZGVsc117QGxpbmsgZW55by5Nb2RlbH0gaGF2ZSBiZWVuIFtyZW1vdmVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jcmVtb3ZlfVxuKiBmcm9tIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufS5cbipcbiogQGV2ZW50IGVueW8uQ29sbGVjdGlvbiNyZW1vdmVcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtlbnlvLk1vZGVsW119IG1vZGVscyAtIEFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZlxuKlx0W21vZGVsc117QGxpbmsgZW55by5Nb2RlbH0gdGhhdCB3ZXJlIFtyZW1vdmVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jcmVtb3ZlfSBmcm9tIHRoZVxuKlx0W2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG4qIEBwcm9wZXJ0eSB7ZW55by5Db2xsZWN0aW9ufSBjb2xsZWN0aW9uIC0gQSByZWZlcmVuY2UgdG8gdGhlXG4qXHRjb2xsZWN0aW9uIHRoYXQgW2VtaXR0ZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyLmVtaXR9IHRoZSBldmVudC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259IGhhcyBiZWVuXG4qIFtzb3J0ZWRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3J0fS5cbipcbiogQGV2ZW50IGVueW8uQ29sbGVjdGlvbiNzb3J0XG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7ZW55by5Nb2RlbFtdfSBtb2RlbHMgLSBBbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgYWxsXG4qXHRbbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfSBpbiB0aGUgY29ycmVjdCwgW3NvcnRlZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI3NvcnR9IG9yZGVyLlxuKiBAcHJvcGVydHkge2VueW8uQ29sbGVjdGlvbn0gY29sbGVjdGlvbiAtIEEgcmVmZXJlbmNlIHRvIHRoZVxuKlx0W2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdGhhdCBbZW1pdHRlZF17QGxpbmsgZW55by5FdmVudEVtaXR0ZXIuZW1pdH0gdGhlIGV2ZW50LlxuKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjb21wYXJhdG9yIC0gQSByZWZlcmVuY2UgdG8gdGhlXG4qXHRbY29tcGFyYXRvcl17QGxpbmsgZW55by5Db2xsZWN0aW9uI2NvbXBhcmF0b3J9IHRoYXQgd2FzIHVzZWQgd2hlblxuKlx0c29ydGluZyB0aGUgY29sbGVjdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259IGhhcyBiZWVuIHJlc2V0IGFuZCBpdHNcbiogY29udGVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYXJiaXRyYXJpbHkuXG4qXG4qIEBldmVudCBlbnlvLkNvbGxlY3Rpb24jcmVzZXRcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtlbnlvLk1vZGVsW119IG1vZGVscyAtIEFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBhbGxcbipcdFttb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9IGFzIHRoZXkgYXJlIGN1cnJlbnRseS5cbiogQHByb3BlcnR5IHtlbnlvLkNvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSBBIHJlZmVyZW5jZSB0byB0aGVcbipcdFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259IHRoYXQgW2VtaXR0ZWRde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyLmVtaXR9IHRoZSBldmVudC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYWJsZSBbb3B0aW9uc117QGxpbmsgZW55by5Db2xsZWN0aW9uI29wdGlvbnN9IHVzZWQgYnkgY2VydGFpbiBBUElcbiogbWV0aG9kcyBvZiB7QGxpbmsgZW55by5Db2xsZWN0aW9ufS5cbipcbiogQHR5cGVkZWYge09iamVjdH0gZW55by5Db2xsZWN0aW9ufk9wdGlvbnNcbiogQHByb3BlcnR5IHtCb29sZWFufSBtZXJnZT10cnVlIC0gSWYgYHRydWVgLCB3aGVuIGRhdGEgaXMgYmVpbmcgYWRkZWQgdG8gdGhlXG4qXHRbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSB0aGF0IGFscmVhZHkgZXhpc3RzIChpLmUuLCBpcyBtYXRjaGVkIGJ5XG4qXHRbcHJpbWFyeUtleV17QGxpbmsgZW55by5Nb2RlbCNwcmltYXJ5S2V5fSksIHRoZSBuZXcgZGF0YSB2YWx1ZXMgd2lsbCBiZSBzZXRcbiogd2l0aCB0aGUgY3VycmVudCBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IGluc3RhbmNlLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG4qIGV4aXN0aW5nIHZhbHVlcyB3aWxsIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IG9uZXMgYnkgY2FsbGluZ1xuKiBbc2V0KClde0BsaW5rIGVueW8uTW9kZWwjc2V0fSBvbiB0aGUgbW9kZWwuXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlIC0gTWFueSBhY2Nlc3NvciBtZXRob2RzIG9mIHRoZSBjb2xsZWN0aW9uXG4qXHR3aWxsIGVtaXQgZXZlbnRzIGFuZC9vciBub3RpZmljYXRpb25zLiBUaGlzIHZhbHVlIGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdFxuKlx0dGhvc2UgZXZlbnRzIG9yIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBzdXBwcmVzc2VkIGF0IHRpbWVzIHdoZW4gdGhhdCBiZWhhdmlvclxuKlx0aXMgbmVjZXNzYXJ5LiBUeXBpY2FsbHksIHlvdSB3aWxsIG5vdCB3YW50IHRvIG1vZGlmeSB0aGlzIHZhbHVlLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IHB1cmdlPWZhbHNlIC0gV2hlbiBbYWRkaW5nXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jYWRkfVxuKlx0bW9kZWxzLCB0aGlzIGZsYWcgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIFtyZW1vdmVde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNyZW1vdmV9XG4qIChwdXJnZSkgdGhlIGV4aXN0aW5nIG1vZGVscyB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIG5ldyBkYXRhc2V0LlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IHBhcnNlPWZhbHNlIC0gVGhlIGNvbGxlY3Rpb24ncyBbcGFyc2UoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3BhcnNlfVxuKlx0bWV0aG9kIGNhbiBiZSBleGVjdXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gaW5jb21pbmcgZGF0YSBpcyBhZGRlZCB2aWEgdGhlXG4qXHRbY29uc3RydWN0b3IoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI2NvbnN0cnVjdG9yfSBtZXRob2QsIG9yLCBsYXRlciwgdmlhIGFcbipcdFtmZXRjaF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2ZldGNofS4gWW91IG1heSBuZWVkIHRvIGV4YW1pbmUgdGhlIHJ1bnRpbWVcbiogY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBtZXRob2QocykgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgcGFyc2luZyBpcyBuZWVkZWQuXG4qIEluIGNhc2VzIHdoZXJlIHBhcnNpbmcgd2lsbCBhbHdheXMgYmUgbmVjZXNzYXJ5LCB0aGlzIG1heSBiZSBzZXQgdG8gYHRydWVgLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGNyZWF0ZT10cnVlIC0gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIHdoZXRoZXIgYSBuZXdcbipcdG1vZGVsIHdpbGwgYmUgY3JlYXRlZCB3aGVuIGRhdGEgYmVpbmcgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24gY2Fubm90IGJlIGZvdW5kXG4qIChvciB0aGUgW2ZpbmRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNvcHRpb25zI2ZpbmR9IGZsYWcgaXMgYGZhbHNlYCkuIE1vZGVsc1xuKiB0aGF0IGFyZSBjcmVhdGVkIGJ5IGEgY29sbGVjdGlvbiBoYXZlIHRoZWlyIFtvd25lcl17QGxpbmsgZW55by5Nb2RlbCNvd25lcn1cbiogcHJvcGVydHkgc2V0IHRvIHRoZSBjb2xsZWN0aW9uIHRoYXQgaW5zdGFuY2VkIHRoZW0uXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZmluZD10cnVlIC0gV2hlbiBkYXRhIGJlaW5nIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uIGlzIG5vdFxuKiBhbHJlYWR5IGEgbW9kZWwgaW5zdGFuY2UsIHRoZSBjb2xsZWN0aW9uIHdpbGwgYXR0ZW1wdCB0byBmaW5kIGFuIGV4aXN0aW5nIG1vZGVsXG4qIGJ5IGl0cyBgcHJpbWFyeUtleWAsIGlmIGl0IGV4aXN0cy4gSW4gbW9zdCBjYXNlcywgdGhpcyBpcyB0aGUgcHJlZmVycmVkIGJlaGF2aW9yLFxuKiBidXQgaWYgdGhlIG1vZGVsIFtraW5kXXtAZ2xvc3Nhcnkga2luZH0gYmVpbmcgIGluc3RhbmNlZCBkb2VzIG5vdCBoYXZlIGFcbiogYHByaW1hcnlLZXlgLCBpdCBpcyB1bm5lY2Vzc2FyeSBhbmQgdGhpcyB2YWx1ZSBtYXkgYmUgc2V0IHRvIGBmYWxzZWAuXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc29ydD1mYWxzZSAtIFdoZW4gYWRkaW5nIG1vZGVscyB0byB0aGUgY29sbGVjdGlvbiwgdGhlXG4qIGNvbGxlY3Rpb24gY2FuIGFsc28gYmUgc29ydGVkLiBJZiB0aGUgW2NvbXBhcmF0b3Jde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNjb21wYXJhdG9yfVxuKiBpcyBhIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSBhbmQgdGhpcyB2YWx1ZSBpcyBgdHJ1ZWAsIHRoZSBjb21wYXJhdG9yXG4qXHR3aWxsIGJlIHVzZWQgdG8gc29ydCB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIEl0IG1heSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdFxuKiB3aWxsIGJlIHVzZWQgdG8gc29ydCB0aGUgY29sbGVjdGlvbiwgaW5zdGVhZCBvZiAob3IgaW4gdGhlIHBsYWNlIG9mKSBhIGRlZmluZWRcbipcdGNvbXBhcmF0b3IuXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29tbWl0PWZhbHNlIC0gV2hlbiBtb2RpZmljYXRpb25zIGFyZSBtYWRlIHRvIHRoZVxuKlx0Y29sbGVjdGlvbiwgdGhpcyBmbGFnIGVuc3VyZXMgdGhhdCB0aG9zZSBjaGFuZ2VzIGFyZVxuKlx0W2NvbW1pdHRlZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2NvbW1pdH0gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGFuZFxuKlx0YXZhaWxhYmlsaXR5IG9mIGEgW3NvdXJjZV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3NvdXJjZX0uIFRoaXMgbWF5IGFsc28gYmVcbiogY29uZmlndXJlZCBwZXItY2FsbCB0byBtZXRob2RzIHRoYXQgdXNlIGl0LlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlc3Ryb3k9ZmFsc2UgLSBXaGVuIG1vZGVscyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLFxuKlx0dGhpcyBmbGFnIGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGV5IHdpbGwgYmUgW2Rlc3Ryb3llZF17QGxpbmsgZW55by5Nb2RlbCNkZXN0cm95fVxuKiBhcyB3ZWxsLiBOb3RlIHRoYXQgdGhpcyBjb3VsZCBoYXZlIGEgc2lnbmlmaWNhbnQgaW1wYWN0IGlmIHRoZSBzYW1lIG1vZGVscyBhcmVcbiogdXNlZCBpbiBvdGhlciBjb2xsZWN0aW9ucy5cbiogQHByb3BlcnR5IHtCb29sZWFufSBjb21wbGV0ZT1mYWxzZSAtIFdoZW4gbW9kZWxzIGFyZSByZW1vdmVkIGZyb20gdGhlXG4qIGNvbGxlY3Rpb24sIHRoaXMgZmxhZyBpbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhleSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBmcm9tXG4qIHRoZSBbc3RvcmVde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzdG9yZX0uIFRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeSBhbmQgY2FuXG4qIGNhdXNlIHByb2JsZW1zIGlmIHRoZSBtb2RlbHMgYXJlIHVzZWQgaW4gb3RoZXIgY29sbGVjdGlvbnMuIEluIGFkZGl0aW9uLCB0aGlzXG4qIHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpZiB0aGUgW2Rlc3Ryb3lde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNvcHRpb25zI2Rlc3Ryb3l9XG4qIGZsYWcgaXMgYHRydWVgLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGZldGNoPWZhbHNlIC0gSWYgYHRydWVgLCB3aGVuIHRoZSBjb2xsZWN0aW9uIGlzIGluaXRpYWxpemVkLFxuKiBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0ZW1wdCB0byBmZXRjaCBkYXRhIGlmIHRoZVxuKiBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfSBhbmQgW3VybF17QGxpbmsgZW55by5Db2xsZWN0aW9uI3VybH1cbipcdG9yIFtnZXRVcmxde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNnZXRVcmx9IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5IGNvbmZpZ3VyZWQuXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW9kZWxFdmVudHM9dHJ1ZSAtIElmIGBmYWxzZWAsIHRoaXMgd2lsbCBrZWVwIHRoZSBjb2xsZWN0aW9uIGZyb21cbipcdHJlZ2lzdGVyaW5nIHdpdGggZWFjaCBtb2RlbCBmb3IgaW5kaXZpZHVhbCBtb2RlbCBldmVudHMuXG4qL1xuXG4vKipcbiogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgW2FkZCgpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jYWRkfS4gRm9yIGNvbXBsZXRlXG4qIGRlc2NyaXB0aW9ucyBvZiB0aGUgb3B0aW9ucyBhbmQgdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIHNlZVxuKiB7QGxpbmsgZW55by5Db2xsZWN0aW9uI29wdGlvbnN9LiBOb3RlIHRoYXQgc29tZSBwcm9wZXJ0aWVzIGhhdmUgZGlmZmVyZW50XG4qIG1lYW5pbmdzIGluIGRpZmZlcmVudCBjb250ZXh0cy4gUGxlYXNlIHJldmlldyB0aGUgZGVzY3JpcHRpb25zIGJlbG93IHRvIHNlZVxuKiBob3cgZWFjaCBwcm9wZXJ0eSBpcyB1c2VkIGluIHRoaXMgY29udGV4dC5cbiogXG4qIEB0eXBlZGVmIHtlbnlvLkNvbGxlY3Rpb25+T3B0aW9uc30gZW55by5Db2xsZWN0aW9ufkFkZE9wdGlvbnNcbiogQHByb3BlcnR5IHtCb29sZWFufSBtZXJnZSAtIFVwZGF0ZSBleGlzdGluZyBbbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfSB3aGVuIGZvdW5kLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IHB1cmdlIC0gUmVtb3ZlIGV4aXN0aW5nIG1vZGVscyBub3QgaW4gdGhlIG5ldyBkYXRhc2V0LlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IHNpbGVudCAtIEVtaXQgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fSBhbmQgbm90aWZpY2F0aW9ucy5cbiogQHByb3BlcnR5IHtCb29sZWFufSBwYXJzZSAtIFBhcnNlIHRoZSBpbmNvbWluZyBkYXRhc2V0IGJlZm9yZSBldmFsdWF0aW5nLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGZpbmQgLSBMb29rIGZvciBhbiBleGlzdGluZyBtb2RlbC5cbiogQHByb3BlcnR5IHsoQm9vbGVhbnxGdW5jdGlvbil9IHNvcnQgLSBTb3J0IHRoZSBmaW5hbGl6ZWQgZGF0YXNldC5cbiogQHByb3BlcnR5IHtCb29sZWFufSBjb21taXQgLSBbQ29tbWl0XXtAbGluayBlbnlvLkNvbGxlY3Rpb24jY29tbWl0fSBjaGFuZ2VzIHRvIHRoZVxuKlx0e0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gYWZ0ZXIgY29tcGxldGluZyB0aGUgW2FkZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2FkZH1cbiogb3BlcmF0aW9uLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGNyZWF0ZSAtIFdoZW4gYW4gZXhpc3Rpbmcge0BsaW5rIGVueW8uTW9kZWx9IGluc3RhbmNlIGNhbm5vdCBiZVxuKlx0cmVzb2x2ZWQsIGEgbmV3IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkLlxuKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gYWRkIHRoZSBuZXcgZGF0YXNldC4gRGVmYXVsdHMgdG8gdGhlXG4qXHRlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YXNldCBpZiBub3QgZXhwbGljaXRseSBzZXQgb3IgaW52YWxpZC5cbiogQHByb3BlcnR5IHtCb29sZWFufSBkZXN0cm95IC0gSWYgYHB1cmdlYCBpcyBgdHJ1ZWAsIHRoaXMgd2lsbFxuKiBbZGVzdHJveV17QGxpbmsgZW55by5Nb2RlbCNkZXN0cm95fSBhbnkgbW9kZWxzIHRoYXQgYXJlXG4qIFtyZW1vdmVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jcmVtb3ZlfS5cbiogQHByb3BlcnR5IHtPYmplY3R9IG1vZGVsT3B0aW9ucyAtIFdoZW4gaW5zdGFuY2luZyBhIG1vZGVsLCB0aGlzXG4qXHRbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IgYXMgaXRzIGBvcHRpb25zYFxuKlx0cGFyYW1ldGVyLlxuKi9cblxuLyoqXG4qIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIFtyZW1vdmUoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3JlbW92ZX0uIEZvclxuKiBjb21wbGV0ZSBkZXNjcmlwdGlvbnMgb2YgdGhlIG9wdGlvbnMgYW5kIHRoZWlyIGRlZmF1bHRzLCBzZWVcbioge0BsaW5rIGVueW8uQ29sbGVjdGlvbn5PcHRpb25zfS4gTm90ZSB0aGF0IHNvbWUgcHJvcGVydGllcyBoYXZlIGRpZmZlcmVudFxuKiBtZWFuaW5ncyBpbiBkaWZmZXJlbnQgY29udGV4dHMuIFBsZWFzZSByZXZpZXcgdGhlIGRlc2NyaXB0aW9ucyBiZWxvdyB0byBzZWVcbiogaG93IGVhY2ggcHJvcGVydHkgaXMgdXNlZCBpbiB0aGlzIGNvbnRleHQuXG4qIFxuKiBAdHlwZWRlZiB7ZW55by5Db2xsZWN0aW9ufk9wdGlvbnN9IGVueW8uQ29sbGVjdGlvbn5SZW1vdmVPcHRpb25zXG4qIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2lsZW50IC0gRW1pdCBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IGFuZCBub3RpZmljYXRpb25zLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbW1pdCAtIFtDb21taXRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNjb21taXR9IGNoYW5nZXMgdG8gdGhlXG4qXHRbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSBhZnRlciBjb21wbGV0aW5nIHRoZVxuKlx0W3JlbW92ZV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3JlbW92ZX0gb3BlcmF0aW9uLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbXBsZXRlIC0gUmVtb3ZlIHRoZSBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IGZyb20gdGhlXG4qXHRbc3RvcmVde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzdG9yZX0gYXMgd2VsbCBhcyB0aGUgY29sbGVjdGlvbi5cbiogQHByb3BlcnR5IHtCb29sZWFufSBkZXN0cm95IC0gW0Rlc3Ryb3lde0BsaW5rIGVueW8uTW9kZWwjZGVzdHJveX0gbW9kZWxzXG4qXHR0aGF0IGFyZSByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4qL1xuXG4vKipcbiogVGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBbZmV0Y2goKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI2ZldGNofSxcbiogW2NvbW1pdCgpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jY29tbWl0fSwgYW5kIFtkZXN0cm95KClde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNkZXN0cm95fS5cbipcbiogQHR5cGVkZWYge2VueW8uQ29sbGVjdGlvbn5PcHRpb25zfSBlbnlvLkNvbGxlY3Rpb25+QWN0aW9uT3B0aW9uc1xuKiBAcHJvcGVydHkge2VueW8uQ29sbGVjdGlvbn5TdWNjZXNzfSBzdWNjZXNzIC0gVGhlIGNhbGxiYWNrIGV4ZWN1dGVkIHVwb24gc3VjY2Vzc2Z1bFxuKlx0Y29tcGxldGlvbi5cbiogQHByb3BlcnR5IHtlbnlvLkNvbGxlY3Rpb25+RXJyb3J9IGVycm9yIC0gVGhlIGNhbGxiYWNrIGV4ZWN1dGVkIHVwb24gYSBmYWlsZWQgYXR0ZW1wdC5cbiovXG5cbi8qKlxuKiBAY2FsbGJhY2sgZW55by5Db2xsZWN0aW9uflN1Y2Nlc3NcbiogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSBUaGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn1cbiogdGhhdCBpcyByZXR1cm5pbmcgc3VjY2Vzc2Z1bGx5LlxuKiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn5BY3Rpb25PcHRpb25zfSAtIG9wdHMgVGhlIG9yaWdpbmFsIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhY3Rpb24gbWV0aG9kXG4qXHR0aGF0IGlzIHJldHVybmluZyBzdWNjZXNzZnVsbHkuXG4qIEBwYXJhbSB7Kn0gLSByZXMgVGhlIHJlc3VsdCwgaWYgYW55LCByZXR1cm5lZCBieSB0aGUgW3NvdXJjZV17QGxpbmsgZW55by5Tb3VyY2V9IHRoYXRcbipcdGV4ZWN1dGVkIGl0LlxuKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIFtzb3VyY2Vde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IHRoYXQgaGFzXG4qXHRyZXR1cm5lZCBzdWNjZXNzZnVsbHkuXG4qL1xuXG4vKipcbiogQGNhbGxiYWNrIGVueW8uQ29sbGVjdGlvbn5FcnJvclxuKiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn0gY29sbGVjdGlvbiAtIFRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufVxuKiB0aGF0IGlzIHJldHVybmluZyBhbiBlcnJvci5cbiogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gdGhhdCBmYWlsZWQsIG9uZSBvZiBgJ0ZFVENISU5HJ2AsXG4qXHRgJ0NPTU1JVFRJTkcnYCwgb3IgYCdERVNUUk9ZSU5HJ2AuXG4qIEBwYXJhbSB7ZW55by5Db2xsZWN0aW9ufkFjdGlvbk9wdGlvbnN9IG9wdHMgLSBUaGUgb3JpZ2luYWwgb3B0aW9ucyBwYXNzZWQgdG8gdGhlXG4qXHRhY3Rpb24gbWV0aG9kIHRoYXQgaXMgcmV0dXJuaW5nIGFuIGVycm9yLlxuKiBAcGFyYW0geyp9IHJlcyAtIFRoZSByZXN1bHQsIGlmIGFueSwgcmV0dXJuZWQgYnkgdGhlIFtzb3VyY2Vde0BsaW5rIGVueW8uU291cmNlfVxuKlx0dGhhdCBleGVjdXRlZCBpdC5cbiogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBuYW1lIG9mIHRoZSBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfVxuKlx0dGhhdCBoYXMgcmV0dXJuZWQgYW4gZXJyb3IuXG4qL1xuXG4vKipcbiogQSBtZXRob2QgdXNlZCB0byBjb21wYXJlIHR3byBlbGVtZW50cyBpbiBhbiB7QGxpbmsgZW55by5Db2xsZWN0aW9ufS4gU2hvdWxkIGJlXG4qIGltcGxlbWVudGVkIGxpa2UgY2FsbGJhY2tzIHVzZWQgd2l0aCBbQXJyYXkuc29ydCgpXXtAZ2xvc3NhcnkgQXJyYXkuc29ydH0uXG4qXG4qIEBzZWUge0BnbG9zc2FyeSBBcnJheS5zb3J0fVxuKiBAc2VlIGVueW8uQ29sbGVjdGlvbi5zb3J0XG4qIEBzZWUgZW55by5Db2xsZWN0aW9uLmNvbXBhcmF0b3JcbiogQGNhbGxiYWNrIGVueW8uQ29sbGVjdGlvbn5Db21wYXJhdG9yXG4qIEBwYXJhbSB7ZW55by5Nb2RlbH0gYSAtIFRoZSBmaXJzdCBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IHRvIGNvbXBhcmUuXG4qIEBwYXJhbSB7ZW55by5Nb2RlbH0gYiAtIFRoZSBzZWNvbmQgbW9kZWwgdG8gY29tcGFyZS5cbiogQHJldHVybnMge051bWJlcn0gYC0xYCBpZiBgYWAgc2hvdWxkIGhhdmUgdGhlIGxvd2VyIGluZGV4LCBgMGAgaWYgdGhleSBhcmUgdGhlIHNhbWUsXG4qIG9yIGAxYCBpZiBgYmAgc2hvdWxkIGhhdmUgdGhlIGxvd2VyIGluZGV4LlxuKi9cblxuLyoqXG4qIEFuIGFycmF5LWxpa2Ugc3RydWN0dXJlIGRlc2lnbmVkIHRvIHN0b3JlIGluc3RhbmNlcyBvZiB7QGxpbmsgZW55by5Nb2RlbH0uXG4qIFxuKiBAY2xhc3MgZW55by5Db2xsZWN0aW9uXG4qIEBleHRlbmRzIGVueW8uQ29tcG9uZW50XG4qIEBtaXhlcyBlbnlvLlN0YXRlU3VwcG9ydFxuKiBAbWl4ZXMgZW55by5FdmVudEVtaXR0ZXJcbiogQHB1YmxpY1xuKi9cbnZhciBDb2xsZWN0aW9uID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uQ29sbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXHRcblx0bmFtZTogJ2VueW8uQ29sbGVjdGlvbicsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBCYXNlQ29sbGVjdGlvbixcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblx0XG5cdC8qKlxuXHQqIFVzZWQgYnkgdmFyaW91cyBbc291cmNlc117QGxpbmsgZW55by5Db2xsZWN0aW9uI3NvdXJjZX0gYXMgcGFydCBvZiB0aGVcblx0KiBbVVJJXXtAZ2xvc3NhcnkgVVJJfSBmcm9tIHdoaWNoIHRoZXkgbWF5IGJlIFtmZXRjaGVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZmV0Y2h9LFxuXHQqIFtjb21taXR0ZWRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNjb21taXR9LCBvciBbZGVzdHJveWVkXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZGVzdHJveX0uXG5cdCogU29tZSBzb3VyY2VzIG1heSB1c2UgdGhpcyBwcm9wZXJ0eSBpbiBvdGhlciB3YXlzLlxuXHQqXG5cdCogQHNlZSBlbnlvLkNvbGxlY3Rpb24uZ2V0VXJsXG5cdCogQHNlZSBlbnlvLlNvdXJjZVxuXHQqIEBzZWUgZW55by5BamF4U291cmNlXG5cdCogQHNlZSBlbnlvLkpzb25wU291cmNlXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0dXJsOiAnJyxcblx0XG5cdC8qKlxuXHQqIEltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBiZSB1c2VkIGJ5IFtzb3VyY2VzXXtAbGluayBlbnlvLk1vZGVsI3NvdXJjZX0gdG9cblx0KiBkeW5hbWljYWxseSBkZXJpdmUgdGhlIFtVUklde0BnbG9zc2FyeSBVUkl9IGZyb20gd2hpY2ggdGhleSBtYXkgYmVcblx0KiBbZmV0Y2hlZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2ZldGNofSwgW2NvbW1pdHRlZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2NvbW1pdH0sXG5cdCogb3IgW2Rlc3Ryb3llZF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2Rlc3Ryb3l9LiBTb21lXG5cdCogW3NvdXJjZXNde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IG1heSB1c2UgdGhpcyBwcm9wZXJ0eSBpbiBvdGhlciB3YXlzLlxuXHQqIE5vdGUgdGhhdCBpZiB0aGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCwgdGhlIFt1cmxde0BsaW5rIGVueW8uQ29sbGVjdGlvbiN1cmx9XG5cdCogcHJvcGVydHkgd2lsbCBub3QgYmUgdXNlZC5cblx0KlxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLnVybFxuXHQqIEBzZWUgZW55by5Tb3VyY2Vcblx0KiBAc2VlIGVueW8uQWpheFNvdXJjZVxuXHQqIEBzZWUgZW55by5Kc29ucFNvdXJjZVxuXHQqIEB0eXBlIHtGdW5jdGlvbn1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHZpcnR1YWxcblx0KiBAcHVibGljXG5cdCovXG5cdGdldFVybDogbnVsbCxcblx0XG5cdC8qKlxuXHQqIFRoZSBba2luZF17QGdsb3NzYXJ5IGtpbmQpIG9mIHtAbGluayBlbnlvLk1vZGVsfSB0aGF0IHRoaXNcblx0KiBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSB3aWxsIGNvbnRhaW4uIFRoaXMgaXMgaW1wb3J0YW50IHRvIHNldCBwcm9wZXJseSBzb1xuXHQqIHRoYXQgd2hlbiBbZmV0Y2hpbmdde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNmZXRjaH0sIHRoZSByZXR1cm5lZCBkYXRhIHdpbGwgYmUgaW5zdGFuY2VkXG5cdCogYXMgdGhlIGNvcnJlY3QgbW9kZWwgW3N1YmtpbmRde0BnbG9zc2FyeSBzdWJraW5kfS5cblx0KiBcblx0KiBAdHlwZSB7KGVueW8uTW9kZWx8U3RyaW5nKX1cblx0KiBAZGVmYXVsdCBlbnlvLk1vZGVsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRtb2RlbDogTW9kZWwsXG5cdFxuXHQvKipcblx0KiBBIHNwZWNpYWwgdHlwZSBvZiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gdXNlZCBpbnRlcm5hbGx5IGJ5XG5cdCoge0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uIFRoZSBhcnJheSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGRpcmVjdGx5LCBub3Jcblx0KiBzaG91bGQgdGhlIHByb3BlcnR5IGJlIHNldCBkaXJlY3RseS4gSXQgaXMgdXNlZCBhcyBhIGNvbnRhaW5lciBieSB0aGVcblx0KiBjb2xsZWN0aW9uLiBJZiBbc2V0XXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc2V0fSBkaXJlY3RseSwgaXQgd2lsbFxuXHQqIFtlbWl0XXtAbGluayBlbnlvLkV2ZW50RW1pdHRlci5lbWl0fSBhIFtyZXNldF17QGxpbmsgZW55by5Db2xsZWN0aW9uI3Jlc2V0fVxuXHQqIGV2ZW50LlxuXHQqXG5cdCogQHNlZSBlbnlvLkNvbGxlY3Rpb24ubW9kZWxzQ2hhbmdlZFxuXHQqIEB0eXBlIGVueW8uTW9kZWxMaXN0XG5cdCogQGRlZmF1bHQgbnVsbFxuXHQqIEByZWFkb25seVxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0bW9kZWxzOiBudWxsLFxuXHRcblx0LyoqXG5cdCogVGhlIGN1cnJlbnQgW3N0YXRlXXtAbGluayBlbnlvLlN0YXRlc30gb2YgdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LlxuXHQqIFRoaXMgdmFsdWUgY2hhbmdlcyBhdXRvbWF0aWNhbGx5IGFuZCBtYXkgYmUgb2JzZXJ2ZWQgZm9yIG1vcmUgY29tcGxleCBzdGF0ZVxuXHQqIG1vbml0b3JpbmcuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFtSRUFEWV17QGxpbmsgZW55b35TdGF0ZXMuUkVBRFl9LlxuXHQqIChBbmQgbGV0J3MgdHJ5IHtAbGluayBlbnlvflN0YXRlcyNSRUFEWX0gd2hpbGUgd2UncmUgYXQgaXQuKVxuXHQqIEBzZWUgZW55by5TdGF0ZXNcblx0KiBAc2VlIGVueW8uU3RhdGVTdXBwb3J0XG5cdCogQHR5cGUgZW55by5TdGF0ZXNcblx0KiBAZGVmYXVsdCBlbnlvLlN0YXRlcy5SRUFEWVxuXHQqIEByZWFkb25seVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c3RhdHVzOiBTdGF0ZXMuUkVBRFksXG5cdFxuXHQvKipcblx0KiBUaGUgY29uZmlndXJhYmxlIGRlZmF1bHQgW29wdGlvbnNde0BsaW5rIGVueW8uQ29sbGVjdGlvbn5PcHRpb25zfS4gVGhlc2UgdmFsdWVzIHdpbGwgYmVcblx0KiB1c2VkIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2YgdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259IHVubGVzcyBhZGRpdGlvbmFsXG5cdCogb3B0aW9ucyBhcmUgcGFzc2VkIGludG8gdGhlIG1ldGhvZHMgdGhhdCB1c2UgdGhlbS4gV2hlbiBtb2RpZnlpbmcgdGhlc2UgdmFsdWVzIGluIGFcblx0KiBbc3Via2luZF17QGdsb3NzYXJ5IHN1YmtpbmR9IG9mIHtAbGluayBlbnlvLkNvbGxlY3Rpb259LCB0aGV5IHdpbGwgYmUgbWVyZ2VkIHdpdGhcblx0KiBleGlzdGluZyB2YWx1ZXMuXG5cdCogXG5cdCogQHR5cGUge2VueW8uQ29sbGVjdGlvbn5PcHRpb25zfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0b3B0aW9uczoge1xuXHRcdG1lcmdlOiB0cnVlLFxuXHRcdHNpbGVudDogZmFsc2UsXG5cdFx0cHVyZ2U6IGZhbHNlLFxuXHRcdHBhcnNlOiBmYWxzZSxcblx0XHRjcmVhdGU6IHRydWUsXG5cdFx0ZmluZDogdHJ1ZSxcblx0XHRzb3J0OiBmYWxzZSxcblx0XHRjb21taXQ6IGZhbHNlLFxuXHRcdGRlc3Ryb3k6IGZhbHNlLFxuXHRcdGNvbXBsZXRlOiBmYWxzZSxcblx0XHRmZXRjaDogZmFsc2UsXG5cdFx0bW9kZWxFdmVudHM6IHRydWVcblx0fSxcblx0XG5cdC8qKlxuXHQqIE1vZGlmaWVzIHRoZSBzdHJ1Y3R1cmUgb2YgZGF0YSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGJ5IHRoZVxuXHQqIFthZGQoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI2FkZH0gbWV0aG9kLiBUaGlzIG1ldGhvZCB3aWxsIG9ubHkgYmUgdXNlZFxuXHQqIGR1cmluZyBpbml0aWFsaXphdGlvbiBvciBhZnRlciBhIHN1Y2Nlc3NmdWwgW2ZldGNoXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZmV0Y2h9XG5cdCogaWYgdGhlIFtwYXJzZV17QGxpbmsgZW55by5Db2xsZWN0aW9ufk9wdGlvbnMucGFyc2V9IGZsYWcgaXMgc2V0IHRvIGB0cnVlYC5cblx0KiBJdCBtYXkgYmUgdXNlZCBmb3Igc2ltcGxlIHJlbWFwcGluZywgcmVuYW1pbmcsIG9yIGNvbXBsZXggcmVzdHJ1Y3R1cmluZyBvZlxuXHQqIGRhdGEgY29taW5nIGZyb20gYSBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfSB0aGF0IHJlcXVpcmVzXG5cdCogbW9kaWZpY2F0aW9uIGJlZm9yZSBpdCBjYW4gYmUgYWRkZWQgdG8gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LlxuXHQqIFRoaXMgaXMgYSB2aXJ0dWFsIG1ldGhvZCBhbmQgbXVzdCBiZSBpbXBsZW1lbnRlZC5cblx0KiBcblx0KiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgaW5jb21pbmcgZGF0YSBwYXNzZWQgdG8gdGhlXG5cdCpcdFtjb25zdHJ1Y3Rvcl17QGxpbmsgZW55by5Db2xsZWN0aW9uI2NvbnN0cnVjdG9yfSBvciByZXR1cm5lZCBieSBhIHN1Y2Nlc3NmdWxcblx0Klx0W2ZldGNoXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZmV0Y2h9LlxuXHQqIEByZXR1cm5zIHtBcnJheX0gVGhlIHByb3Blcmx5IGZvcm1hdHRlZCBkYXRhIHRvIGJlIGFjY2VwdGVkIGJ5IHRoZVxuXHQqXHRbYWRkKClde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNhZGR9IG1ldGhvZC5cblx0KiBAdmlydHVhbFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cGFyc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBBZGRzIGRhdGEgdG8gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LiBUaGlzIG1ldGhvZCBjYW4gYWRkIGFuXG5cdCogaW5kaXZpZHVhbCBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IG9yIGFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBtb2RlbHMuXG5cdCogSXQgY2FuIHNwbGljZSB0aGVtIGludG8gdGhlIGRhdGFzZXQgYXQgYSBkZXNpZ25hdGVkIGluZGV4IG9yIHJlbW92ZSBtb2RlbHNcblx0KiBmcm9tIHRoZSBleGlzdGluZyBkYXRhc2V0IHRoYXQgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgbmV3IG9uZS5cblx0KiBTZWUge0BsaW5rIGVueW8uQ29sbGVjdGlvbn5BZGRPcHRpb25zfSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gdGhlXG5cdCogY29uZmlndXJhdGlvbiBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhpcyBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGhlYXZpbHlcblx0KiBvcHRpbWl6ZWQgZm9yIGJhdGNoIG9wZXJhdGlvbnMgb24gYXJyYXlzIG9mIG1vZGVscy4gRm9yIGJldHRlciBwZXJmb3JtYW5jZSxcblx0KiBlbnN1cmUgdGhhdCBsb29wcyBkbyBub3QgY29uc2VjdXRpdmVseSBjYWxsIHRoaXMgbWV0aG9kIGJ1dCBpbnN0ZWFkXG5cdCogYnVpbGQgYW4gYXJyYXkgdG8gcGFzcyBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxuXHQqIFxuXHQqIEBmaXJlcyBlbnlvLkNvbGxlY3Rpb24jYWRkXG5cdCogQHBhcmFtIHsoT2JqZWN0fE9iamVjdFtdfGVueW8uTW9kZWx8ZW55by5Nb2RlbFtdKX0gbW9kZWxzIFRoZSBkYXRhIHRvIGFkZCB0byB0aGVcblx0Klx0e0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdGhhdCBjYW4gYmUgYSBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0sIGFuIGFycmF5IG9mXG5cdCpcdGhhc2hlcywgYW4ge0BsaW5rIGVueW8uTW9kZWx9IGluc3RhbmNlLCBvciBhbmQgYXJyYXkgb2YgYGVueW8uTW9kZWxgIGluc3RhbmNlcy5cblx0KiBOb3RlIHRoYXQgaWYgdGhlIFtwYXJzZV17QGxpbmsgZW55by5Db2xsZWN0aW9uI29wdGlvbnMjcGFyc2V9IGNvbmZpZ3VyYXRpb25cblx0KiBvcHRpb24gaXMgYHRydWVgLCBpdCB3aWxsIHVzZSB0aGUgcmV0dXJuZWQgdmFsdWUgYXMgdGhpcyBwYXJhbWV0ZXIuXG5cdCogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb25+QWRkT3B0aW9uc30gW29wdHNdIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IG1vZGlmeVxuXHQqXHR0aGUgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QuIFRoZSBkZWZhdWx0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZXNlIG9wdGlvbnNcblx0KiBiZWZvcmUgZXZhbHVhdGluZy5cblx0KiBAcmV0dXJucyB7ZW55by5Nb2RlbFtdfSBUaGUgbW9kZWxzIHRoYXQgd2VyZSBhZGRlZCwgaWYgYW55LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRzKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMubW9kZWxzXG5cdFx0XHQsIGxlbiA9IHRoaXMubGVuZ3RoXG5cdFx0XHQsIGN0b3IgPSB0aGlzLm1vZGVsXG5cdFx0XHQsIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblx0XHRcdCwgcGtleSA9IGN0b3IucHJvdG90eXBlLnByaW1hcnlLZXlcblx0XHRcdCwgaWR4ID0gbGVuXG5cdFx0XHQsIHJlbW92ZWRCZWZvcmVJZHggPSAwXG5cdFx0XHQsIGFkZGVkLCBrZWVwLCByZW1vdmVkLCBtb2RlbCwgYXR0cnMsIGZvdW5kLCBpZDtcblx0XHRcdFxuXHRcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGVhcmxpZXIgYXBpIHN0YW5kYXJkcyB3ZSBhbGxvdyB0aGVcblx0XHQvLyBzZWNvbmQgcGFyYW10ZXIgdG8gYmUgdGhlIGluZGV4IGFuZCB0aGlyZCBwYXJhbSBvcHRpb25zIHdoZW5cblx0XHQvLyBuZWNlc3Nhcnlcblx0XHQhaXNOYU4ob3B0cykgJiYgKGlkeCA9IG9wdHMpO1xuXHRcdGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIChvcHRzID0gYXJndW1lbnRzWzJdKTtcblx0XHRcblx0XHQvLyBub3JtYWxpemUgb3B0aW9ucyBzbyB3ZSBoYXZlIHZhbHVlc1xuXHRcdG9wdHMgPSBvcHRzPyB1dGlscy5taXhpbih7fSwgW29wdGlvbnMsIG9wdHNdKTogb3B0aW9ucztcblx0XHRcblx0XHQvLyBvdXIgZmxhZ3Ncblx0XHR2YXIgbWVyZ2UgPSBvcHRzLm1lcmdlXG5cdFx0XHQsIHB1cmdlID0gb3B0cy5wdXJnZVxuXHRcdFx0LCBzaWxlbnQgPSBvcHRzLnNpbGVudFxuXHRcdFx0LCBwYXJzZSA9IG9wdHMucGFyc2Vcblx0XHRcdCwgZmluZCA9IG9wdHMuZmluZFxuXHRcdFx0LCBzb3J0ID0gb3B0cy5zb3J0XG5cdFx0XHQsIGNvbW1pdCA9IG9wdHMuY29tbWl0XG5cdFx0XHQsIGNyZWF0ZSA9IG9wdHMuY3JlYXRlICE9PSBmYWxzZVxuXHRcdFx0LCBtb2RlbE9wdHMgPSBvcHRzLm1vZGVsT3B0aW9uc1xuXHRcdFx0LCBpbmRleCA9IG9wdHMuaW5kZXg7XG5cdFx0XHRcblx0XHRpZHggPSAhaXNOYU4oaW5kZXgpID8gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuLCBpbmRleCkpIDogaWR4O1xuXG5cdFx0Lypqc2hpbnQgLVcwMTggKi9cblx0XHRzb3J0ICYmICEodHlwZW9mIHNvcnQgPT0gJ2Z1bmN0aW9uJykgJiYgKHNvcnQgPSB0aGlzLmNvbXBhcmF0b3IpO1xuXHRcdC8qanNoaW50ICtXMDE4ICovXG5cdFx0XG5cdFx0Ly8gZm9yIGEgc3BlY2lhbCBjYXNlIHB1cmdlIHRvIHJlbW92ZSByZWNvcmRzIHRoYXQgYXJlbid0IGluIHRoZSBjdXJyZW50XG5cdFx0Ly8gc2V0IGJlaW5nIGFkZGVkXG5cdFx0XG5cdFx0aWYgKHBhcnNlKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscyk7XG5cdFx0XHRcblx0XHQvLyB3ZSB0cmVhdCBhbGwgYWRkaXRpb25zIGFzIGFuIGFycmF5IG9mIGFkZGl0aW9uc1xuXHRcdCEobW9kZWxzIGluc3RhbmNlb2YgQXJyYXkpICYmIChtb2RlbHMgPSBbbW9kZWxzXSk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaT0wLCBlbmQ9bW9kZWxzLmxlbmd0aDsgaTxlbmQ7ICsraSkge1xuXHRcdFx0bW9kZWwgPSBtb2RlbHNbaV07XG5cdFx0XHRhdHRycyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICghbW9kZWwgJiYgaXNOYU4obW9kZWwpKSBjb250aW51ZTtcblx0XHRcdFxuXHRcdFx0Ly8gZmlyc3QgZGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBtb2RlbCBzaW5jZVxuXHRcdFx0Ly8gZXZlcnl0aGluZyBlbHNlIGhpbmdlcyBvbiB0aGlzXG5cdFx0XHRpZiAoIShtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSkge1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGRldGVybWluZSBob3cgdG8gaGFuZGxlIHRoaXNcblx0XHRcdFx0YXR0cnMgPSBtb2RlbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBhdHRycyA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXR0cnMgPT0gJ251bWJlcicpIHtcblx0XHRcdFx0aWQgPSBhdHRycztcblx0XHRcdFx0YXR0cnMgPSB7fTtcblx0XHRcdFx0YXR0cnNbcGtleV0gPSBpZDtcblx0XHRcdH0gZWxzZSBpZCA9IGF0dHJzPyBhdHRyc1twa2V5XTogbW9kZWw7XG5cdFx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBzZWUgaWYgd2UgaGF2ZSBhbiBleGlzdGluZyBlbnRyeSBmb3IgdGhpcyBtb2RlbC9oYXNoXG5cdFx0XHRpZiAoZmluZCkgZm91bmQgPSBsb2MuaGFzKGlkKTtcblx0XHRcdFxuXHRcdFx0Ly8gaWYgaXQgYWxyZWFkeSBleGlzdGVkLi4uXG5cdFx0XHRpZiAoZm91bmQpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gZW5zdXJlIHdlJ3ZlIHJlc29sdmVkIHRoZSBtb2RlbCAoaWYgbmVjZXNzYXJ5KVxuXHRcdFx0XHRmb3VuZCA9IGxvYy5yZXNvbHZlKGlkKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtZXJnZSkge1xuXHRcdFx0XHRcdGF0dHJzIHx8IChhdHRycyA9IG1vZGVsLmF0dHJpYnV0ZXMpO1xuXHRcdFx0XHRcdGZvdW5kLnNldChhdHRycywgb3B0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gd2l0aCB0aGUgcHVyZ2UgZmxhZyB3ZSBlbmRlYXZvciBvbiB0aGUgZXhwZW5zaXZlIHRyYWNrIG9mIHJlbW92aW5nXG5cdFx0XHRcdC8vIHRob3NlIG1vZGVscyBjdXJyZW50bHkgaW4gdGhlIGNvbGxlY3Rpb24gdGhhdCBhcmVuJ3QgaW4gdGhlIGluY29taW5nXG5cdFx0XHRcdC8vIGRhdGFzZXQgYW5kIGFyZW4ndCBiZWluZyBjcmVhdGVkXG5cdFx0XHRcdGlmIChwdXJnZSkge1xuXHRcdFx0XHRcdGtlZXAgfHwgKGtlZXAgPSB7bGVuZ3RoOiAwfSk7XG5cdFx0XHRcdFx0a2VlcFtmb3VuZC5ldWlkXSA9IG1vZGVsO1xuXHRcdFx0XHRcdGtlZXAubGVuZ3RoKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXR0cnMgJiYgZmluZCAmJiAoZm91bmQgPSB0aGlzLnN0b3JlLnJlc29sdmUoY3RvciwgaWQpKSkge1xuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2Ugd2VyZSBhc2tlZCB0byBzZWFyY2ggb3VyIHN0b3JlIGZvciBhbiBleGlzdGluZyByZWNvcmRcblx0XHRcdFx0Ly8gYW5kIHdlIGZvdW5kIG9uZSBidXQgd2UgZGlkbid0IHByZXZpb3VzbHkgaGF2ZSBpdCBzbyB3ZSBhcmUgdGVjaG5pY2FsbHlcblx0XHRcdFx0Ly8gYWRkaW5nIGl0XG5cdFx0XHRcdC8vIEBOT1RFOiBTZXR0aW5nIHRoZSBfZmluZF8gb3B0aW9uIGFsd2F5cyBhc3N1bWVzIF9tZXJnZV9cblx0XHRcdFx0YXR0cnMgfHwgKGF0dHJzID0gbW9kZWwuYXR0cmlidXRlcyk7XG5cdFx0XHRcdHBhcnNlICYmIChhdHRycyA9IGZvdW5kLnBhcnNlKGF0dHJzKSk7XG5cdFx0XHRcdGFkZGVkIHx8IChhZGRlZCA9IFtdKTtcblx0XHRcdFx0YWRkZWQucHVzaChmb3VuZCk7XG5cdFx0XHRcdHRoaXMucHJlcGFyZU1vZGVsKGZvdW5kLCBvcHRzKTtcblx0XHRcdFx0bWVyZ2UgJiYgZm91bmQuc2V0KGF0dHJzLCBvcHRzKTtcblx0XHRcdH0gZWxzZSBpZiAoIWF0dHJzKSB7XG5cdFx0XHRcdGFkZGVkIHx8IChhZGRlZCA9IFtdKTtcblx0XHRcdFx0YWRkZWQucHVzaChtb2RlbCk7XG5cdFx0XHRcdHRoaXMucHJlcGFyZU1vZGVsKG1vZGVsKTtcblx0XHRcdH0gZWxzZSBpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdG1vZGVsID0gdGhpcy5wcmVwYXJlTW9kZWwoYXR0cnMgfHwgbW9kZWwsIG1vZGVsT3B0cyk7XG5cdFx0XHRcdGFkZGVkIHx8IChhZGRlZCA9IFtdKTtcblx0XHRcdFx0YWRkZWQucHVzaChtb2RlbCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB3aXRoIHRoZSBwdXJnZSBmbGFnIHdlIGVuZGVhdm9yIG9uIHRoZSBleHBlbnNpdmUgdHJhY2sgb2YgcmVtb3Zpbmdcblx0XHRcdFx0Ly8gdGhvc2UgbW9kZWxzIGN1cnJlbnRseSBpbiB0aGUgY29sbGVjdGlvbiB0aGF0IGFyZW4ndCBpbiB0aGUgaW5jb21pbmdcblx0XHRcdFx0Ly8gZGF0YXNldCBhbmQgYXJlbid0IGJlaW5nIGNyZWF0ZWRcblx0XHRcdFx0aWYgKHB1cmdlKSB7XG5cdFx0XHRcdFx0a2VlcCB8fCAoa2VlcCA9IHtsZW5ndGg6IDB9KTtcblx0XHRcdFx0XHRrZWVwW21vZGVsLmV1aWRdID0gbW9kZWw7XG5cdFx0XHRcdFx0a2VlcC5sZW5ndGgrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBoZXJlIHdlIHByb2Nlc3MgdGhvc2UgbW9kZWxzIHRvIGJlIHJlbW92ZWQgaWYgcHVyZ2Ugd2FzIHRydWVcblx0XHQvLyB0aGUgb3RoZXIgZ3VhcmQgaXMganVzdCBpbiBjYXNlIHdlIGFjdHVhbGx5IGdldCB0byBrZWVwIGV2ZXJ5dGhpbmdcblx0XHQvLyBzbyB3ZSBkb24ndCBkbyB0aGlzIHVubmVjZXNzYXJ5IHBhc3Ncblx0XHRpZiAocHVyZ2UgJiYgKGtlZXAgJiYga2VlcC5sZW5ndGgpKSB7XG5cdFx0XHRyZW1vdmVkIHx8IChyZW1vdmVkID0gW10pO1xuXHRcdFx0a2VlcCB8fCAoa2VlcCA9IHt9KTtcblx0XHRcdGZvciAoaT0wOyBpPGxlbjsgKytpKSB7XG5cdFx0XHRcdGlmICgha2VlcFsobW9kZWwgPSBsb2NbaV0pLmV1aWRdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlZC5wdXNoKG1vZGVsKTtcblx0XHRcdFx0XHRpZiAoaSA8IGlkeCkgcmVtb3ZlZEJlZm9yZUlkeCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IFxuXHRcdFx0Ly8gaWYgd2UgcmVtb3ZlZCBhbnkgd2UgcHJvY2VzcyB0aGF0IG5vd1xuXHRcdFx0cmVtb3ZlZC5sZW5ndGggJiYgdGhpcy5yZW1vdmUocmVtb3ZlZCwgb3B0cyk7XG5cdFx0XHRpZHggPSBpZHggLSByZW1vdmVkQmVmb3JlSWR4O1xuXHRcdH1cblx0XHRcblx0XHQvLyBhZGRlZCAmJiBsb2Muc3RvcE5vdGlmaWNhdGlvbnMoKS5hZGQoYWRkZWQsIGlkeCkuc3RhcnROb3RpZmljYXRpb25zKCk7XG5cdFx0aWYgKGFkZGVkKSB7XG5cdFx0XHRsb2MuYWRkKGFkZGVkLCBpZHgpO1xuXHRcdFx0c29ydCAmJiB0aGlzLnNvcnQoc29ydCwge3NpbGVudDogdHJ1ZX0pO1xuXHRcdFx0XG5cdFx0XHQvLyB3ZSBiYXRjaCB0aGlzIG9wZXJhdGlvbiB0byBtYWtlIHVzZSBvZiBpdHMgfmVmZmljaWVudCBhcnJheSBvcGVyYXRpb25zXG5cdFx0XHR0aGlzLnN0b3JlLmFkZChhZGRlZCk7IFxuXHRcdH1cblx0XHR0aGlzLmxlbmd0aCA9IGxvYy5sZW5ndGg7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdC8vIG5vdGlmeSBvYnNlcnZlcnMgb2YgdGhlIGxlbmd0aCBjaGFuZ2Vcblx0XHRcdGxlbiAhPSB0aGlzLmxlbmd0aCAmJiB0aGlzLm5vdGlmeSgnbGVuZ3RoJywgbGVuLCB0aGlzLmxlbmd0aCk7XG5cdFx0XHQvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHRoZSBhZGRpdGlvbiBvZiByZWNvcmRzXG5cdFx0XHRpZiAoYWRkZWQpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCdhZGQnLCB7bW9kZWxzOiBhZGRlZCwgY29sbGVjdGlvbjogdGhpcywgaW5kZXg6IGlkeH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBub3RlIHRoYXQgaWYgY29tbWl0IGlzIHNldCBidXQgdGhpcyB3YXMgY2FsbGVkIGZyb20gYSBzdWNjZXNzZnVsIGZldGNoIHRoaXMgd2lsbCBiZVxuXHRcdC8vIGEgbm9wIChhcyBpbnRlbmRlZClcblx0XHRjb21taXQgJiYgYWRkZWQgJiYgdGhpcy5jb21taXQob3B0cyk7XG5cdFx0XG5cdFx0cmV0dXJuIGFkZGVkIHx8IFtdO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVtb3ZlcyBkYXRhIGZyb20gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LiBJdCBjYW4gdGFrZSBhXG5cdCogW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBvciBhbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgbW9kZWxzLlxuXHQqIElmIGFueSBvZiB0aGUgaW5zdGFuY2VzIGFyZSBwcmVzZW50IGluIHRoZSBjb2xsZWN0aW9uLCB0aGV5IHdpbGwgYmVcblx0KiByZW1vdmVkIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZSBlbmNvdW50ZXJlZC4gRW1pdHMgdGhlXG5cdCogW3JlbW92ZV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3JlbW92ZX0gZXZlbnQgaWYgYW55IG1vZGVscyB3ZXJlIGZvdW5kIGFuZFxuXHQqIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbiAoYW5kIHRoZSBgc2lsZW50YCBvcHRpb24gaXMgbm90IGB0cnVlYCkuXG5cdCogXG5cdCogQGZpcmVzIGVueW8uQ29sbGVjdGlvbiNyZW1vdmVcblx0KiBAcGFyYW0geyhlbnlvLk1vZGVsfGVueW8uTW9kZWxbXSl9IG1vZGVscyBUaGUgW21vZGVsc117QGxpbmsgZW55by5Nb2RlbH0gdG8gcmVtb3ZlXHRcdFxuXHQqXHRpZiB0aGV5IGV4aXN0IGluIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufS5cblx0KiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn5SZW1vdmVPcHRpb25zfSBbb3B0c10gLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgbW9kaWZ5XG5cdCpcdHRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZC5cblx0KiBAcmV0dXJucyB7ZW55by5Nb2RlbFtdfSBUaGUgbW9kZWxzIHRoYXQgd2VyZSByZW1vdmVkLCBpZiBhbnkuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdHMpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5tb2RlbHNcblx0XHRcdCwgbGVuID0gbG9jLmxlbmd0aFxuXHRcdFx0LCBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cdFx0XHQsIHJlbW92ZWQsIG1vZGVsO1xuXHRcdFxuXHRcdC8vIG5vcm1hbGl6ZSBvcHRpb25zIHNvIHdlIGhhdmUgdmFsdWVzXG5cdFx0b3B0cyA9IG9wdHM/IHV0aWxzLm1peGluKHt9LCBbb3B0aW9ucywgb3B0c10pOiBvcHRpb25zO1xuXHRcdFxuXHRcdC8vIG91ciBmbGFnc1xuXHRcdHZhciBzaWxlbnQgPSBvcHRzLnNpbGVudFxuXHRcdFx0LCBkZXN0cm95ID0gb3B0cy5kZXN0cm95XG5cdFx0XHQsIGNvbXBsZXRlID0gb3B0cy5jb21wbGV0ZVxuXHRcdFx0LCBjb21taXQgPSBvcHRzLmNvbW1pdDtcblx0XHRcblx0XHQvLyB3ZSB0cmVhdCBhbGwgYWRkaXRpb25zIGFzIGFuIGFycmF5IG9mIGFkZGl0aW9uc1xuXHRcdCEobW9kZWxzIGluc3RhbmNlb2YgQXJyYXkpICYmIChtb2RlbHMgPSBbbW9kZWxzXSk7XG5cdFx0XG5cdFx0cmVtb3ZlZCA9IGxvYy5yZW1vdmUobW9kZWxzKTtcblx0XHRcblx0XHRpZiAocmVtb3ZlZC5sZW5ndGgpIHtcblx0XHRcdFxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgd2UgY2FuIGJhdGNoIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuXHRcdFx0b3B0cy5iYXRjaGluZyA9IHRydWU7XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGk9MCwgZW5kPXJlbW92ZWQubGVuZ3RoOyBpPGVuZDsgKytpKSB7XG5cdFx0XHRcdG1vZGVsID0gcmVtb3ZlZFtpXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGl0IGlzIHBvc3NpYmxlIGJ1dCBoaWdobHksIGhpZ2hseSB1bmxpa2VseSB0aGF0IHRoaXMgd291bGQgaGF2ZSBiZWVuIHNldFxuXHRcdFx0XHQvLyB0byBmYWxzZSBieSBkZWZhdWx0IGFuZCB0cnVlIGF0IHJ1bnRpbWUuLi5zbyB3ZSB0YWtlIG91ciBjaGFuY2VzIGZvciB0aGVcblx0XHRcdFx0Ly8gc21hbGwgcGVyZm9ybWFuY2UgZ2FpbiBpbiB0aG9zZSBzaXR1YXRpb25zIHdoZXJlIGl0IHdhcyBkZWZhdWx0ZWQgdG8gZmFsc2Vcblx0XHRcdFx0aWYgKG9wdGlvbnMubW9kZWxFdmVudHMpIG1vZGVsLm9mZignKicsIHRoaXMuX21vZGVsRXZlbnQsIHRoaXMpO1xuXHRcdFx0XHRpZiAoZGVzdHJveSkgbW9kZWwuZGVzdHJveShvcHRzKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gaWYgY29tcGxldGUgb3IgZGVzdHJveSB3YXMgc2V0IHdlIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN0b3JlIChiYXRjaGVkIG9wKVxuXHRcdFx0aWYgKGNvbXBsZXRlIHx8IGRlc3Ryb3kpIHRoaXMuc3RvcmUucmVtb3ZlKHJlbW92ZWQpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmxlbmd0aCA9IGxvYy5sZW5ndGg7XG5cdFx0XG5cdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdGxlbiAhPSB0aGlzLmxlbmd0aCAmJiB0aGlzLm5vdGlmeSgnbGVuZ3RoJywgbGVuLCB0aGlzLmxlbmd0aCk7XG5cdFx0XHRpZiAocmVtb3ZlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCdyZW1vdmUnLCB7bW9kZWxzOiByZW1vdmVkLCBjb2xsZWN0aW9uOiB0aGlzfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGlmIHRoaXMgaXMgY2FsbGVkIGZyb20gYW4gb3ZlcmxvYWRlZCBtZXRob2QgKHN1Y2ggYXMgZmV0Y2ggb3IgY29tbWl0KSBvciBzb21lIFxuXHRcdC8vIHN1Y2Nlc3MgY2FsbGJhY2sgdGhpcyB3aWxsIGJlIGEgbm9wIChhcyBpbnRlbmRlZClcblx0XHRjb21taXQgJiYgcmVtb3ZlZC5sZW5ndGggJiYgdGhpcy5jb21taXQoKTtcblx0XHRcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblx0XG5cdC8qKlxuXHQqIFJldHJpZXZlcyBhIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gZm9yIHRoZSBwcm92aWRlZCBpbmRleC5cblx0KiBcblx0KiBAcGFyYW0ge051bWJlcn0gaWR4IC0gVGhlIGluZGV4IHRvIHJldHVybiBmcm9tIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufS5cblx0KiBAcmV0dXJucyB7KGVueW8uTW9kZWx8dW5kZWZpbmVkKX0gVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gYXQgdGhlIGdpdmVuIGluZGV4IG9yXG5cdCpcdGB1bmRlZmluZWRgIGlmIGl0IGNhbm5vdCBiZSBmb3VuZC5cblx0KiBAcHVibGljXG5cdCovXG5cdGF0OiBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0cmV0dXJuIHRoaXMubW9kZWxzW2lkeF07XG5cdH0sXG5cdFxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBKU09OIHNlcmlhbGl6YWJsZSBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgW21vZGVsc117QGxpbmsgZW55by5Nb2RlbH1cblx0KiBhY2NvcmRpbmcgdG8gdGhlaXIgb3duIFtyYXcoKV17QGxpbmsgZW55by5Nb2RlbCNyYXd9IG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm5zIHtlbnlvLk1vZGVsW119IFRoZSBbbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfSBhY2NvcmRpbmcgdG8gdGhlaXJcblx0Klx0W3JhdygpXXtAbGluayBlbnlvLk1vZGVsI3Jhd30gb3V0cHV0LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMubW9kZWxzLm1hcChmdW5jdGlvbiAobW9kZWwpIHtcblx0XHRcdHJldHVybiBtb2RlbC5yYXcoKTtcblx0XHR9KTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIERldGVybWluZXMgaWYgdGhlIHNwZWNpZmllZCBbbW9kZWxde0BsaW5rIGVueW8uTW9kZWx9IGlzIGNvbnRhaW5lZCBieSB0aGlzXG5cdCogW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uTW9kZWx9IG1vZGVsIC0gVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gdG8gY2hlY2suXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBtb2RlbCBiZWxvbmdzIHRvIHRoZVxuXHQqXHRbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufS5cblx0KiBAcHVibGljXG5cdCovXG5cdGhhczogZnVuY3Rpb24gKG1vZGVsKSB7XG5cdFx0cmV0dXJuIHRoaXMubW9kZWxzLmhhcyhtb2RlbCk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAc2VlIHtAZ2xvc3NhcnkgQXJyYXkuZm9yRWFjaH1cblx0KiBAcHVibGljXG5cdCovXG5cdGZvckVhY2g6IGZ1bmN0aW9uIChmbiwgY3R4KSB7XG5cdFx0XG5cdFx0Ly8gZW5zdXJlIHRoYXQgdGhpcyBpcyBhbiBpbW11dGFibGUgcmVmZXJlbmNlIHRvIHRoZSBtb2RlbHMgc3VjaCB0aGF0IGNoYW5nZXMgd2lsbFxuXHRcdC8vIG5vdCBhZmZlY3QgdGhlIGVudGlyZSBsb29wIC0gZS5nLiBjYWxsaW5nIGRlc3Ryb3kgb24gbW9kZWxzIHdvbid0IGtlZXAgdGhpcyBmcm9tXG5cdFx0Ly8gY29tcGxldGluZ1xuXHRcdHJldHVybiB0aGlzLm1vZGVscy5zbGljZSgpLmZvckVhY2goZm4sIGN0eCB8fCB0aGlzKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBzZWUge0BnbG9zc2FyeSBBcnJheS5maWx0ZXJ9XG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmaWx0ZXI6IGZ1bmN0aW9uIChmbiwgY3R4KSB7XG5cdFx0XG5cdFx0Ly8gZW5zdXJlIHRoYXQgdGhpcyBpcyBhbiBpbW11dGFibGUgcmVmZXJlbmNlIHRvIHRoZSBtb2RlbHMgc3VjaCB0aGF0IGNoYW5nZXMgd2lsbFxuXHRcdC8vIG5vdCBhZmZlY3QgdGhlIGVudGlyZSBsb29wIC0gZS5nLiBjYWxsaW5nIGRlc3Ryb3kgb24gbW9kZWxzIHdvbid0IGtlZXAgdGhpcyBmcm9tXG5cdFx0Ly8gY29tcGxldGluZ1xuXHRcdHJldHVybiB0aGlzLm1vZGVscy5zbGljZSgpLmZpbHRlcihmbiwgY3R4IHx8IHRoaXMpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHNlZSB7QGdsb3NzYXJ5IEFycmF5LmZpbmR9XG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmaW5kOiBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHRcdFxuXHRcdC8vIGVuc3VyZSB0aGF0IHRoaXMgaXMgYW4gaW1tdXRhYmxlIHJlZmVyZW5jZSB0byB0aGUgbW9kZWxzIHN1Y2ggdGhhdCBjaGFuZ2VzIHdpbGxcblx0XHQvLyBub3QgYWZmZWN0IHRoZSBlbnRpcmUgbG9vcCAtIGUuZy4gY2FsbGluZyBkZXN0cm95IG9uIG1vZGVscyB3b24ndCBrZWVwIHRoaXMgZnJvbVxuXHRcdC8vIGNvbXBsZXRpbmdcblx0XHRyZXR1cm4gdGhpcy5tb2RlbHMuc2xpY2UoKS5maW5kKGZuLCBjdHggfHwgdGhpcyk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAc2VlIHtAZ2xvc3NhcnkgQXJyYXkubWFwfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bWFwOiBmdW5jdGlvbiAoZm4sIGN0eCkge1xuXHRcdFxuXHRcdC8vIGVuc3VyZSB0aGF0IHRoaXMgaXMgYW4gaW1tdXRhYmxlIHJlZmVyZW5jZSB0byB0aGUgbW9kZWxzIHN1Y2ggdGhhdCBjaGFuZ2VzIHdpbGxcblx0XHQvLyBub3QgYWZmZWN0IHRoZSBlbnRpcmUgbG9vcCAtIGUuZy4gY2FsbGluZyBkZXN0cm95IG9uIG1vZGVscyB3b24ndCBrZWVwIHRoaXMgZnJvbVxuXHRcdC8vIGNvbXBsZXRpbmdcblx0XHRyZXR1cm4gdGhpcy5tb2RlbHMuc2xpY2UoKS5tYXAoZm4sIGN0eCB8fCB0aGlzKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBzZWUge0BnbG9zc2FyeSBBcnJheS5pbmRleE9mfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aW5kZXhPZjogZnVuY3Rpb24gKG1vZGVsLCBvZmZzZXQpIHtcblx0XHRyZXR1cm4gdGhpcy5tb2RlbHMuaW5kZXhPZihtb2RlbCwgb2Zmc2V0KTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIFJlbW92ZXMgYWxsIFttb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9IGZyb20gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LlxuXHQqIE9wdGlvbmFsbHksIGEgbW9kZWwgKG9yIG1vZGVscykgbWF5IGJlIHByb3ZpZGVkIHRvIHJlcGxhY2UgdGhlIHJlbW92ZWQgbW9kZWxzLlxuXHQqIElmIHRoaXMgb3BlcmF0aW9uIGlzIG5vdCBgc2lsZW50YCwgaXQgd2lsbCBlbWl0IGEgYHJlc2V0YCBldmVudC4gUmV0dXJucyB0aGVcblx0KiByZW1vdmVkIG1vZGVscywgYnV0IGJlIGF3YXJlIHRoYXQsIGlmIHRoZSBgZGVzdHJveWAgY29uZmlndXJhdGlvbiBvcHRpb24gaXMgc2V0LFxuXHQqIHRoZSByZXR1cm5lZCBtb2RlbHMgd2lsbCBoYXZlIGxpbWl0ZWQgdXNlZnVsbmVzcy5cblx0KiBcblx0KiBAcGFyYW0geyhlbnlvLk1vZGVsfGVueW8uTW9kZWxbXSl9IFttb2RlbHNdIFRoZSBbbW9kZWwgb3IgbW9kZWxzXXtAbGluayBlbnlvLk1vZGVsfVxuXHQqXHR0byB1c2UgYXMgYSByZXBsYWNlbWVudCBmb3IgdGhlIGN1cnJlbnQgc2V0IG9mIG1vZGVscyBpbiB0aGVcblx0Klx0e0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG5cdCogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb25+T3B0aW9uc30gW29wdHNdIC0gVGhlIG9wdGlvbnMgdGhhdCB3aWxsIG1vZGlmeSB0aGUgYmVoYXZpb3Jcblx0Klx0b2YgdGhpcyBtZXRob2QuXG5cdCogQHJldHVybnMge2VueW8uTW9kZWxbXX0gVGhlIG1vZGVscyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZW1wdHk6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdHMpIHtcblx0XHR2YXIgc2lsZW50LFxuXHRcdFx0cmVtb3ZlZCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXHRcdFxuXHRcdGlmIChtb2RlbHMgJiYgIShtb2RlbHMgaW5zdGFuY2VvZiBBcnJheSB8fCBtb2RlbHMgaW5zdGFuY2VvZiBNb2RlbCkpIHtcblx0XHRcdC8vIHRoZXJlIHdlcmUgbm8gbW9kZWxzIGJ1dCBpbnN0ZWFkIHNvbWUgb3B0aW9ucyBvbmx5XG5cdFx0XHRvcHRzID0gbW9kZWxzO1xuXHRcdFx0bW9kZWxzID0gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0XG5cdFx0Ly8ganVzdCBpbiBjYXNlIHRoZSBlbnRpcmUgdGhpbmcgd2FzIHN1cHBvc2VkIHRvIGJlIHNpbGVudFxuXHRcdHNpbGVudCA9IG9wdHMuc2lsZW50O1xuXHRcdG9wdHMuc2lsZW50ID0gdHJ1ZTtcblx0XHRcblx0XHRyZW1vdmVkID0gdGhpcy5yZW1vdmUodGhpcy5tb2RlbHMsIG9wdHMpO1xuXHRcdFxuXHRcdC8vIGlmIHRoZXJlIGFyZSBtb2RlbHMgd2UgYXJlIGdvaW5nIHRvIHByb3BhZ2F0ZSB0aGUgcmVtb3ZlIHF1aWV0bHkgYW5kIGluc3RlYWQgaXNzdWVcblx0XHQvLyBhIHNpbmdsZSByZXNldCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdGlmIChtb2RlbHMpIHRoaXMuYWRkKG1vZGVscywgb3B0cyk7XG5cdFx0XG5cdFx0Ly8gbm93IGlmIHRoZSBlbnRpcmUgdGhpbmcgd2Fzbid0IHN1cHBvc2VkIHRvIGhhdmUgYmVlbiBkb25lIHNpbGVudGx5IHdlIGlzc3VlXG5cdFx0Ly8gYSByZXNldFxuXHRcdGlmICghc2lsZW50KSB7XG5cdFx0XHRpZiAobGVuICE9IHRoaXMubGVuZ3RoKSB0aGlzLm5vdGlmeSgnbGVuZ3RoJywgbGVuLCB0aGlzLmxlbmd0aCk7XG5cdFx0XHR0aGlzLmVtaXQoJ3Jlc2V0Jywge21vZGVsczogdGhpcy5tb2RlbHMuY29weSgpLCBjb2xsZWN0aW9uOiB0aGlzfSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogUmV0dXJucyB0aGUgW0pTT05de0BnbG9zc2FyeSBKU09OfSBzZXJpYWxpemFibGUgW3JhdygpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jcmF3fVxuXHQqIG91dHB1dCBvZiB0aGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uIFdpbGwgYXV0b21hdGljYWxseSBiZSBleGVjdXRlZCBieVxuXHQqIFtKU09OLnBhcnNlKClde0BnbG9zc2FyeSBKU09OLnBhcnNlfS5cblx0KlxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLnJhd1xuXHQqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXR1cm4gdmFsdWUgb2YgW3JhdygpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jcmF3fS5cblx0KiBAcHVibGljXG5cdCovXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJhdygpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgdGhlIHNhbWUgYXMge0BnbG9zc2FyeSBBcnJheS5zb3J0fS4gSWYgdGhlXG5cdCogW2Z1bmN0aW9uXXtAZ2xvc3NhcnkgRnVuY3Rpb259IHBhcmFtZXRlciBpcyBvbWl0dGVkLCBpdCB3aWxsIGF0dGVtcHQgdG8gdXNlIHRoZVxuXHQqIFtjb21wYXJhdG9yXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jY29tcGFyYXRvcn0gKGlmIGFueSkgZnJvbSB0aGVcblx0KiBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufS4gTm90ZSB0aGF0IHRoZSBjb2xsZWN0aW9uIGlzIHNvcnRlZCBpbi1wbGFjZVxuXHQqIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi4gVGhlIGNvbGxlY3Rpb25cblx0KiBbZW1pdHNde0BsaW5rIGVueW8uRXZlbnRFbWl0dGVyLmVtaXR9IHRoZSBbc29ydF17QGxpbmsgZW55by5Db2xsZWN0aW9uI3NvcnR9XG5cdCogZXZlbnQuXG5cdCpcblx0KiBAZmlyZXMgZW55by5Db2xsZWN0aW9uI3NvcnRcblx0KiBAc2VlIHtAZ2xvc3NhcnkgQXJyYXkuc29ydH1cblx0KiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn5Db21wYXJhdG9yfSBbZm5dIC0gVGhlIFtjb21wYXJhdG9yXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jY29tcGFyYXRvcn1cblx0KiBtZXRob2QuXG5cdCogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb25+T3B0aW9uc30gW29wdHNdIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzb3J0OiBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcblx0XHRpZiAoZm4gfHwgdGhpcy5jb21wYXJhdG9yKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHtzaWxlbnQ6IGZhbHNlfSwgc2lsZW50O1xuXHRcdFxuXHRcdFx0b3B0cyA9IG9wdHM/IHV0aWxzLm1peGluKHt9LCBbb3B0aW9ucywgb3B0c10pOiBvcHRpb25zO1xuXHRcdFx0c2lsZW50ID0gb3B0cy5zaWxlbnQ7XG5cdFx0XHR0aGlzLm1vZGVscy5zb3J0KGZuIHx8IHRoaXMuY29tcGFyYXRvcik7XG5cdFx0XHQhc2lsZW50ICYmIHRoaXMuZW1pdCgnc29ydCcsIHtcblx0XHRcdFx0Y29tcGFyYXRvcjogZm4gfHwgdGhpcy5jb21wYXJhdG9yLFxuXHRcdFx0XHRtb2RlbHM6IHRoaXMubW9kZWxzLmNvcHkoKSxcblx0XHRcdFx0Y29sbGVjdGlvbjogdGhpc1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQ29tbWl0cyB0aGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdG8gYVxuXHQqIFtzb3VyY2Vde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IG9yIHNvdXJjZXMuIEFuIHtAbGluayBlbnlvLkNvbGxlY3Rpb259XG5cdCogY2Fubm90IGJlIGNvbW1pdHRlZCBpZiBpdCBpcyBpbiBhbiBbZXJyb3Jde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfVxuXHQqICh7QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuaXNFcnJvcn0pIG9yIFtidXN5XXtAbGluayBlbnlvLlN0YXRlcy5CVVNZfVxuXHQqICh7QGxpbmsgZW55by5TdGF0ZVN1cHBvcnQuaXNCdXN5fSkgW3N0YXRlXXtAbGluayBlbnlvLk1vZGVsI3N0YXR1c30uIFdoaWxlXG5cdCogZXhlY3V0aW5nLCBpdCB3aWxsIGFkZCB0aGUgW0NPTU1JVFRJTkdde0BsaW5rIGVueW8uU3RhdGVzLkNPTU1JVFRJTkd9IGZsYWdcblx0KiB0byB0aGUgY29sbGVjdGlvbidzIFtzdGF0dXNde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzdGF0dXN9LiBPbmNlIGl0IGhhc1xuXHQqIGNvbXBsZXRlZCBleGVjdXRpb24sIGl0IHdpbGwgcmVtb3ZlIHRoaXMgZmxhZyAoZXZlbiBpZiBpdCBmYWlscykuXG5cdCpcblx0KiBAc2VlIGVueW8uQ29sbGVjdGlvbi5jb21taXR0ZWRcblx0KiBAc2VlIGVueW8uQ29sbGVjdGlvbi5zdGF0dXNcblx0KiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn5BY3Rpb25PcHRpb25zfSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29tbWl0OiBmdW5jdGlvbiAob3B0cykge1xuXHRcdHZhciBvcHRpb25zLFxuXHRcdFx0c291cmNlLFxuXHRcdFx0aXQgPSB0aGlzO1xuXHRcdFxuXHRcdC8vIGlmIHRoZSBjdXJyZW50IHN0YXR1cyBpcyBub3Qgb25lIG9mIHRoZSBlcnJvciBzdGF0ZXMgd2UgY2FuIGNvbnRpbnVlXG5cdFx0aWYgKCEodGhpcy5zdGF0dXMgJiAoU3RhdGVzLkVSUk9SIHwgU3RhdGVzLkJVU1kpKSkge1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB0aGVyZSB3ZXJlIG9wdGlvbnMgcGFzc2VkIGluIHdlIGNvcHkgdGhlbSBxdWlja2x5IHNvIHRoYXQgd2UgY2FuIGhpamFja1xuXHRcdFx0Ly8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIG1ldGhvZHMgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWxzIHRvIHVzZSBsYXRlclxuXHRcdFx0b3B0aW9ucyA9IG9wdHMgPyB1dGlscy5jbG9uZShvcHRzLCB0cnVlKSA6IHt9O1xuXHRcdFx0XG5cdFx0XHQvLyBtYWtlIHN1cmUgd2Uga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VyY2VzIHdlJ3JlIHJlcXVlc3Rpbmdcblx0XHRcdHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IHRoaXMuc291cmNlO1xuXHRcdFx0aWYgKHNvdXJjZSAmJiAoKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB8fCBzb3VyY2UgPT09IHRydWUpKSB7XG5cdFx0XHRcdHRoaXMuX3dhaXRpbmcgPSBzb3VyY2UubGVuZ3RoID8gc291cmNlLnNsaWNlKCkgOiBPYmplY3Qua2V5cyhlbnlvLnNvdXJjZXMpO1xuXHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlcykge1xuXHRcdFx0XHRpdC5jb21taXR0ZWQob3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0b3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlcykge1xuXHRcdFx0XHRpdC5lcnJvcmVkKCdDT01NSVRUSU5HJywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0IHRoZSBzdGF0ZVxuXHRcdFx0dGhpcy5zZXQoJ3N0YXR1cycsICh0aGlzLnN0YXR1cyB8IFN0YXRlcy5DT01NSVRUSU5HKSAmIH5TdGF0ZXMuUkVBRFkpO1xuXHRcdFx0XG5cdFx0XHQvLyBub3cgcGFzcyB0aGlzIG9uIHRvIHRoZSBzb3VyY2UgdG8gZXhlY3V0ZSBhcyBpdCBzZWVzIGZpdFxuXHRcdFx0U291cmNlLmV4ZWN1dGUoJ2NvbW1pdCcsIHRoaXMsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgJiBTdGF0ZXMuRVJST1IpIHRoaXMuZXJyb3JlZCh0aGlzLnN0YXR1cywgb3B0cyk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBGZXRjaGVzIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSBmcm9tIGFcblx0KiBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfSBvciBzb3VyY2VzLiBBbiB7QGxpbmsgZW55by5Db2xsZWN0aW9ufVxuXHQqIGNhbm5vdCBiZSBmZXRjaGVkIGlmIGl0IGlzIGluIGFuIFtlcnJvcl17QGxpbmsgZW55by5TdGF0ZXMuRVJST1J9XG5cdCogKHtAbGluayBlbnlvLlN0YXRlU3VwcG9ydC5pc0Vycm9yfSkgb3IgW2J1c3lde0BsaW5rIGVueW8uU3RhdGVzLkJVU1l9XG5cdCogKHtAbGluayBlbnlvLlN0YXRlU3VwcG9ydC5pc0J1c3l9KSBbc3RhdGVde0BsaW5rIGVueW8uTW9kZWwjc3RhdHVzfS4gV2hpbGVcblx0KiBleGVjdXRpbmcsIGl0IHdpbGwgYWRkIHRoZSBbRkVUQ0hJTkdde0BsaW5rIGVueW8uU3RhdGVzLkZFVENISU5HfSBmbGFnIHRvXG5cdCogdGhlIGNvbGxlY3Rpb24ncyBbc3RhdHVzXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc3RhdHVzfS4gT25jZSBpdCBoYXNcblx0KiBjb21wbGV0ZWQgZXhlY3V0aW9uLCBpdCB3aWxsIHJlbW92ZSB0aGlzIGZsYWcgKGV2ZW4gaWYgaXQgZmFpbHMpLlxuXHQqXG5cdCogQHNlZSBlbnlvLkNvbGxlY3Rpb24uZmV0Y2hlZFxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLnN0YXR1c1xuXHQqIEBwYXJhbSB7ZW55by5Db2xsZWN0aW9ufkFjdGlvbk9wdGlvbnN9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmZXRjaDogZnVuY3Rpb24gKG9wdHMpIHtcblx0XHR2YXIgb3B0aW9ucyxcblx0XHRcdHNvdXJjZSxcblx0XHRcdGl0ID0gdGhpcztcblx0XHRcdFxuXHRcdC8vIGlmIHRoZSBjdXJyZW50IHN0YXR1cyBpcyBub3Qgb25lIG9mIHRoZSBlcnJvciBzdGF0ZXMgd2UgY2FuIGNvbnRpbnVlXG5cdFx0aWYgKCEodGhpcy5zdGF0dXMgJiAoU3RhdGVzLkVSUk9SIHwgU3RhdGVzLkJVU1kpKSkge1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB0aGVyZSB3ZXJlIG9wdGlvbnMgcGFzc2VkIGluIHdlIGNvcHkgdGhlbSBxdWlja2x5IHNvIHRoYXQgd2UgY2FuIGhpamFja1xuXHRcdFx0Ly8gdGhlIHN1Y2Nlc3MgYW5kIGVycm9yIG1ldGhvZHMgd2hpbGUgcHJlc2VydmluZyB0aGUgb3JpZ2luYWxzIHRvIHVzZSBsYXRlclxuXHRcdFx0b3B0aW9ucyA9IG9wdHMgPyB1dGlscy5jbG9uZShvcHRzLCB0cnVlKSA6IHt9O1xuXHRcdFx0XG5cdFx0XHQvLyBtYWtlIHN1cmUgd2Uga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VyY2VzIHdlJ3JlIHJlcXVlc3Rpbmdcblx0XHRcdHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IHRoaXMuc291cmNlO1xuXHRcdFx0aWYgKHNvdXJjZSAmJiAoKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB8fCBzb3VyY2UgPT09IHRydWUpKSB7XG5cdFx0XHRcdHRoaXMuX3dhaXRpbmcgPSBzb3VyY2UubGVuZ3RoID8gc291cmNlLnNsaWNlKCkgOiBPYmplY3Qua2V5cyhlbnlvLnNvdXJjZXMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoc291cmNlLCByZXMpIHtcblx0XHRcdFx0aXQuZmV0Y2hlZChvcHRzLCByZXMsIHNvdXJjZSk7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRvcHRpb25zLmVycm9yID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVzKSB7XG5cdFx0XHRcdGl0LmVycm9yZWQoJ0ZFVENISU5HJywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0IHRoZSBzdGF0ZVxuXHRcdFx0dGhpcy5zZXQoJ3N0YXR1cycsICh0aGlzLnN0YXR1cyB8IFN0YXRlcy5GRVRDSElORykgJiB+U3RhdGVzLlJFQURZKTtcblx0XHRcdFxuXHRcdFx0Ly8gbm93IHBhc3MgdGhpcyBvbiB0byB0aGUgc291cmNlIHRvIGV4ZWN1dGUgYXMgaXQgc2VlcyBmaXRcblx0XHRcdFNvdXJjZS5leGVjdXRlKCdmZXRjaCcsIHRoaXMsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgJiBTdGF0ZXMuRVJST1IpIHRoaXMuZXJyb3JlZCh0aGlzLnN0YXR1cywgb3B0cyk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBEZXN0cm95cyB0aGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uIEJ5IGRlZmF1bHQsIHRoZVxuXHQqIGNvbGxlY3Rpb24gd2lsbCBvbmx5IGJlIFtkZXN0cm95ZWRde0BnbG9zc2FyeSBkZXN0cm95fSBpbiB0aGUgY2xpZW50LiBUb1xuXHQqIGV4ZWN1dGUgd2l0aCBhIFtzb3VyY2Vde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IG9yIHNvdXJjZXMsIHRoZVxuXHQqIFtjb21taXQgZGVmYXVsdCBvcHRpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbiNvcHRpb25zfSBtdXN0IGJlIGB0cnVlYCBvciBhXG5cdCogYHNvdXJjZWAgcHJvcGVydHkgbXVzdCBiZSBleHBsaWNpdGx5IHByb3ZpZGVkIGluIHRoZSBgb3B0c2AgcGFyYW1ldGVyLiBBXG5cdCogY29sbGVjdGlvbiBjYW5ub3QgYmUgZGVzdHJveWVkICh1c2luZyBhIHNvdXJjZSkgaWYgaXQgaXMgaW4gYW5cblx0KiBbZXJyb3Jde0BsaW5rIGVueW8uU3RhdGVzLkVSUk9SfSAoe0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LmlzRXJyb3J9KSBvclxuXHQqIFtidXN5XXtAbGluayBlbnlvLlN0YXRlcy5CVVNZfSAoe0BsaW5rIGVueW8uU3RhdGVTdXBwb3J0LmlzQnVzeX0pXG5cdCogW3N0YXRlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc3RhdHVzfS4gV2hpbGUgZXhlY3V0aW5nLCBpdCB3aWxsIGFkZCB0aGVcblx0KiBbREVTVFJPWUlOR117QGxpbmsgZW55by5TdGF0ZXMuREVTVFJPWUlOR30gZmxhZyB0byB0aGUgY29sbGVjdGlvbidzXG5cdCogW3N0YXR1c117QGxpbmsgZW55by5Db2xsZWN0aW9uI3N0YXR1c30uIE9uY2UgaXQgaGFzIGNvbXBsZXRlZCBleGVjdXRpb24sXG5cdCogaXQgd2lsbCByZW1vdmUgdGhpcyBmbGFnIChldmVuIGlmIGl0IGZhaWxzKS5cblx0KlxuXHQqIEBzZWUgZW55by5Db2xsZWN0aW9uLnN0YXR1c1xuXHQqIEBwYXJhbSB7ZW55by5Db2xsZWN0aW9ufkFjdGlvbk9wdGlvbnN9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLm1peGluKHt9LCBbdGhpcy5vcHRpb25zLCBvcHRzXSkgOiB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGl0ID0gdGhpcyxcblx0XHRcdFx0aWR4O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHQvLyB0aGlzIGJlY29tZXMgYW4gKHBvdGVudGlhbGx5KSBhc3luYyBvcGVyYXRpb24gaWYgd2UgYXJlIGNvbW1pdHRpbmcgdGhpcyBkZXN0cm95XG5cdFx0XHQvLyB0byBhIHNvdXJjZSBhbmQgaXRzIGtpbmQgb2YgdHJpY2t5IHRvIGZpZ3VyZSBvdXQgYmVjYXVzZSB0aGVyZSBhcmUgc2V2ZXJhbCB3YXlzXG5cdFx0XHQvLyBpdCBjb3VsZCBiZSBmbGFnZ2VkIHRvIGRvIHRoaXNcblx0XHRcdFx0XHRcdFxuXHRcdFx0aWYgKG9wdGlvbnMuY29tbWl0IHx8IG9wdGlvbnMuc291cmNlKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiB0aGUgY3VycmVudCBzdGF0dXMgaXMgbm90IG9uZSBvZiB0aGUgZXJyb3Igc3RhdGVzIHdlIGNhbiBjb250aW51ZVxuXHRcdFx0XHRpZiAoISh0aGlzLnN0YXR1cyAmIChTdGF0ZXMuRVJST1IgfCBTdGF0ZXMuQlVTWSkpKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHJlbWFwIHRvIHRoZSBvcmlnaW5hbHNcblx0XHRcdFx0XHRvcHRpb25zID0gb3B0cyA/IHV0aWxzLmNsb25lKG9wdHMsIHRydWUpIDoge307XG5cdFx0XHRcdFxuXHRcdFx0XHRcdG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlcykge1xuXHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChpdC5fd2FpdGluZykge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpdC5fd2FpdGluZy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChsbiBpbnN0YW5jZW9mIFNvdXJjZSA/IGxuLm5hbWUgOiBsbikgPT0gc291cmNlO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+IC0xKSBpdC5fd2FpdGluZy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFpdC5fd2FpdGluZy5sZW5ndGgpIGl0Ll93YWl0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZSB0aGUgb3BlcmF0aW9uIHRoaXMgdGltZSB3aXRoIGNvbW1pdCBmYWxzZSBleHBsaWNpdGx5XG5cdFx0XHRcdFx0XHRpZiAoIWl0Ll93YWl0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuY29tbWl0ID0gb3B0aW9ucy5zb3VyY2UgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRpdC5kZXN0cm95KG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9wdHMgJiYgb3B0cy5zdWNjZXNzKSBvcHRzLnN1Y2Nlc3ModGhpcywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdFx0XHRvcHRpb25zLmVycm9yID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVzKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKGl0Ll93YWl0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGl0Ll93YWl0aW5nLmZpbmRJbmRleChmdW5jdGlvbiAobG4pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKGxuIGluc3RhbmNlb2YgU291cmNlID8gbG4ubmFtZSA6IGxuKSA9PSBzb3VyY2U7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoaWR4ID4gLTEpIGl0Ll93YWl0aW5nLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWl0Ll93YWl0aW5nLmxlbmd0aCkgaXQuX3dhaXRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlIHRoZSBvcGVyYXRpb24gdGhpcyB0aW1lIHdpdGggY29tbWl0IGZhbHNlIGV4cGxpY2l0bHlcblx0XHRcdFx0XHRcdGlmICghaXQuX3dhaXRpbmcpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jb21taXQgPSBvcHRpb25zLnNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGl0LmRlc3Ryb3kob3B0aW9ucyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gd2UgZG9uJ3QgYm90aGVyIHNldHRpbmcgdGhlIGVycm9yIHN0YXRlIGlmIHdlIGFyZW4ndCB3YWl0aW5nIGJlY2F1c2UgXG5cdFx0XHRcdFx0XHQvLyBpdCB3aWxsIGJlIGNsZWFyZWQgdG8gREVTVFJPWUVEIGFuZCBpdCB3b3VsZCBiZSBwb2ludGxlc3Ncblx0XHRcdFx0XHRcdGVsc2UgdGhpcy5lcnJvcmVkKCdERVNUUk9ZSU5HJywgb3B0cywgcmVzLCBzb3VyY2UpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMuc2V0KCdzdGF0dXMnLCAodGhpcy5zdGF0dXMgfCBTdGF0ZXMuREVTVFJPWUlORykgJiB+U3RhdGVzLlJFQURZKTtcblx0XHRcdFxuXHRcdFx0XHRcdFNvdXJjZS5leGVjdXRlKCdkZXN0cm95JywgdGhpcywgb3B0aW9ucyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgJiBTdGF0ZXMuRVJST1IpIHRoaXMuZXJyb3JlZCh0aGlzLnN0YXR1cywgb3B0cyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB3ZSBkb24ndCBhbGxvdyB0aGUgZGVzdHJveSB0byB0YWtlIHBsYWNlIGFuZCB3ZSBkb24ndCBmb3JjaWJseSBicmVhay1kb3duXG5cdFx0XHRcdC8vIHRoZSBjb2xsZWN0aW9uIGVycmFudGx5IHNvIHRoZXJlIGlzIGFuIG9wcG9ydHVuaXkgdG8gcmVzb2x2ZSB0aGUgaXNzdWVcblx0XHRcdFx0Ly8gYmVmb3JlIHdlIGxvc2UgYWNjZXNzIHRvIHRoZSBjb2xsZWN0aW9uJ3MgY29udGVudCFcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmxlbmd0aCAmJiBvcHRpb25zLmRlc3Ryb3kpIHRoaXMuZW1wdHkob3B0aW9ucyk7XG5cdFx0XHRcblx0XHRcdC8vIHNldCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiB0aGlzIGNvbGxlY3Rpb25cblx0XHRcdHRoaXMuc2V0KCdzdGF0dXMnLCBTdGF0ZXMuREVTVFJPWUVEKTtcblx0XHRcdFxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBUaGlzIGlzIGEgdmlydHVhbCBtZXRob2QgdGhhdCwgd2hlbiBwcm92aWRlZCwgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIGR1cmluZ1xuXHQqIFthZGQoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI2FkZH0gd2hlbiB0aGUgYHNvcnRgIGZsYWcgaXMgYHRydWVgIG9yIHdoZW4gdGhlXG5cdCogW3NvcnQoKV17QGxpbmsgZW55by5Db2xsZWN0aW9uI3NvcnR9IG1ldGhvZCBpcyBjYWxsZWQgd2l0aG91dCBhIHBhc3NlZC1pblxuXHQqIFtmdW5jdGlvbl17QGdsb3NzYXJ5IEZ1bmN0aW9ufSBwYXJhbWV0ZXIuXG5cdCpcblx0KiBAc2VlIGVueW8uQ29sbGVjdGlvbn5Db21wYXJhdG9yXG5cdCogQHR5cGUge2VueW8uQ29sbGVjdGlvbn5Db21wYXJhdG9yfVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAdmlydHVhbFxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdGNvbXBhcmF0b3I6IG51bGwsXG5cdFxuXHQvKipcblx0KiBVc2VkIGR1cmluZyBbYWRkKClde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNhZGR9IHdoZW4gYGNyZWF0ZWAgaXMgYHRydWVgIGFuZFxuXHQqIHRoZSBkYXRhIGlzIGEgW2hhc2hde0BnbG9zc2FyeSBPYmplY3R9LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHJlcGFyZU1vZGVsOiBmdW5jdGlvbiAoYXR0cnMsIG9wdHMpIHtcblx0XHR2YXIgQ3RvciA9IHRoaXMubW9kZWxcblx0XHRcdCwgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXHRcdFx0LCBtb2RlbDtcblx0XHRcblx0XHRhdHRycyBpbnN0YW5jZW9mIEN0b3IgJiYgKG1vZGVsID0gYXR0cnMpO1xuXHRcdGlmICghbW9kZWwpIHtcblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0b3B0cy5ub0FkZCA9IHRydWU7XG5cdFx0XHRtb2RlbCA9IG5ldyBDdG9yKGF0dHJzLCBudWxsLCBvcHRzKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG9wdGlvbnMubW9kZWxFdmVudHMpIG1vZGVsLm9uKCcqJywgdGhpcy5fbW9kZWxFdmVudCwgdGhpcyk7XG5cdFx0XG5cdFx0cmV0dXJuIG1vZGVsO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogV2hlbiBhIFtjb21taXRde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNjb21taXR9IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBpdCBpcyByZXR1cm5lZFxuXHQqIHRvIHRoaXMgbWV0aG9kLiBUaGlzIG1ldGhvZCBoYW5kbGVzIHNwZWNpYWwgYW5kIGltcG9ydGFudCBiZWhhdmlvcjsgaXQgc2hvdWxkIG5vdCBiZVxuXHQqIGNhbGxlZCBkaXJlY3RseSBhbmQsIHdoZW4gb3ZlcmxvYWRpbmcsIGNhcmUgbXVzdCBiZSB0YWtlbiB0byBlbnN1cmUgdGhhdCB0aGVcblx0KiBzdXBlci1tZXRob2QgaXMgY2FsbGVkLiBUaGlzIGNvcnJlY3RseSBzZXRzIHRoZSBbc3RhdHVzXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc3RhdHVzfVxuXHQqIGFuZCwgaW4gY2FzZXMgd2hlcmUgbXVsdGlwbGUgW3NvdXJjZXNde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IHdlcmUgdXNlZCwgaXQgd2FpdHNcblx0KiB1bnRpbCBhbGwgaGF2ZSByZXNwb25kZWQgYmVmb3JlIGNsZWFyaW5nIHRoZSBbQ09NTUlUVElOR117QGxpbmsgZW55by5TdGF0ZXMuQ09NTUlUVElOR31cblx0KiBmbGFnLiBJZiBhIFtzdWNjZXNzXXtAbGluayBlbnlvLkNvbGxlY3Rpb25+U3VjY2Vzc30gY2FsbGJhY2sgd2FzIHByb3ZpZGVkLCBpdCB3aWxsIGJlXG5cdCogY2FsbGVkIG9uY2UgZm9yIGVhY2ggc291cmNlLlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb25+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcmlnaW5hbCBvcHRpb25zIHBhc3NlZCB0b1xuXHQqXHRbY29tbWl0KClde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNjb21taXR9LCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHMuXG5cdCogQHBhcmFtIHsqfSBbcmVzXSAtIFRoZSByZXN1bHQgcHJvdmlkZWQgZnJvbSB0aGUgZ2l2ZW5cblx0KiBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfSwgaWYgYW55LiBUaGlzIHdpbGwgdmFyeSBkZXBlbmRpbmdcblx0KiBvbiB0aGUgc291cmNlLlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIHRoYXQgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb21taXR0ZWQ6IGZ1bmN0aW9uIChvcHRzLCByZXMsIHNvdXJjZSkge1xuXHRcdHZhciBpZHg7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX3dhaXRpbmcpIHtcblx0XHRcdGlkeCA9IHRoaXMuX3dhaXRpbmcuZmluZEluZGV4KGZ1bmN0aW9uIChsbikge1xuXHRcdFx0XHRyZXR1cm4gKGxuIGluc3RhbmNlb2YgU291cmNlID8gbG4ubmFtZSA6IGxuKSA9PSBzb3VyY2U7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpZHggPiAtMSkgdGhpcy5fd2FpdGluZy5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdGlmICghdGhpcy5fd2FpdGluZy5sZW5ndGgpIHRoaXMuX3dhaXRpbmcgPSBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRpZiAob3B0cyAmJiBvcHRzLnN1Y2Nlc3MpIG9wdHMuc3VjY2Vzcyh0aGlzLCBvcHRzLCByZXMsIHNvdXJjZSk7XG5cdFx0XG5cdFx0Ly8gY2xlYXIgdGhlIHN0YXRlXG5cdFx0aWYgKCF0aGlzLl93YWl0aW5nKSB7XG5cdFx0XHR0aGlzLnNldCgnc3RhdHVzJywgKHRoaXMuc3RhdHVzIHwgU3RhdGVzLlJFQURZKSAmIH5TdGF0ZXMuQ09NTUlUVElORyk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogV2hlbiBhIFtmZXRjaF17QGxpbmsgZW55by5Db2xsZWN0aW9uI2ZldGNofSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgaXQgaXMgcmV0dXJuZWRcblx0KiB0byB0aGlzIG1ldGhvZC4gVGhpcyBtZXRob2QgaGFuZGxlcyBzcGVjaWFsIGFuZCBpbXBvcnRhbnQgYmVoYXZpb3I7IGl0IHNob3VsZCBub3QgYmVcblx0KiBjYWxsZWQgZGlyZWN0bHkgYW5kLCB3aGVuIG92ZXJsb2FkaW5nLCBjYXJlIG11c3QgYmUgdGFrZW4gdG8gZW5zdXJlIHRoYXQgeW91IGNhbGwgdGhlXG5cdCogc3VwZXItbWV0aG9kLiBUaGlzIGNvcnJlY3RseSBzZXRzIHRoZSBbc3RhdHVzXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc3RhdHVzfSBhbmQsIGluXG5cdCogY2FzZXMgd2hlcmUgbXVsdGlwbGUgW3NvdXJjZXNde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9IHdlcmUgdXNlZCwgaXQgd2FpdHMgdW50aWxcblx0KiBhbGwgaGF2ZSByZXNwb25kZWQgYmVmb3JlIGNsZWFyaW5nIHRoZSBbRkVUQ0hJTkdde0BsaW5rIGVueW8uU3RhdGVzLkZFVENISU5HfSBmbGFnLiBJZlxuXHQqIGEgW3N1Y2Nlc3Nde0BsaW5rIGVueW8uQ29sbGVjdGlvbn5TdWNjZXNzfSBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkXG5cdCogb25jZSBmb3IgZWFjaCBzb3VyY2UuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29sbGVjdGlvbn5BY3Rpb25PcHRpb25zfSBvcHRzIC0gVGhlIG9yaWdpbmFsIG9wdGlvbnMgcGFzc2VkIHRvXG5cdCpcdFtmZXRjaCgpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZmV0Y2h9LCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHMuXG5cdCogQHBhcmFtIHsqfSBbcmVzXSAtIFRoZSByZXN1bHQgcHJvdmlkZWQgZnJvbSB0aGUgZ2l2ZW5cblx0KiBbc291cmNlXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc291cmNlfSwgaWYgYW55LiBUaGlzIHdpbGwgdmFyeSBkZXBlbmRpbmdcblx0Klx0b24gdGhlIHNvdXJjZS5cblx0KiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIHNvdXJjZSB0aGF0IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZmV0Y2hlZDogZnVuY3Rpb24gKG9wdHMsIHJlcywgc291cmNlKSB7XG5cdFx0dmFyIGlkeDtcblx0XHRcblx0XHRpZiAodGhpcy5fd2FpdGluZykge1xuXHRcdFx0aWR4ID0gdGhpcy5fd2FpdGluZy5maW5kSW5kZXgoZnVuY3Rpb24gKGxuKSB7XG5cdFx0XHRcdHJldHVybiAobG4gaW5zdGFuY2VvZiBTb3VyY2UgPyBsbi5uYW1lIDogbG4pID09IHNvdXJjZTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlkeCA+IC0xKSB0aGlzLl93YWl0aW5nLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0aWYgKCF0aGlzLl93YWl0aW5nLmxlbmd0aCkgdGhpcy5fd2FpdGluZyA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGlmIHRoZXJlIGlzIGEgcmVzdWx0IHdlIGFkZCBpdCB0byB0aGUgY29sbGVjdGlvbiBwYXNzaW5nIGl0IGFueSBwZXItZmV0Y2ggb3B0aW9uc1xuXHRcdC8vIHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdHMgKGUuZy4gcGFyc2UpIHdlIGRvbid0IGRvIHRoYXQgaGVyZSBhcyBpdCB3aWxsXG5cdFx0Ly8gYmUgZG9uZSBpbiB0aGUgYWRkIG1ldGhvZCAtLSBhbHNvIG5vdGUgd2UgcmVhc3NpZ24gdGhlIHJlc3VsdCB0byB3aGF0ZXZlciB3YXNcblx0XHQvLyBhY3R1YWxseSBhZGRlZCBhbmQgcGFzcyB0aGF0IHRvIGFueSBvdGhlciBzdWNjZXNzIGNhbGxiYWNrIGlmIHRoZXJlIGlzIG9uZVxuXHRcdGlmIChyZXMpIHJlcyA9IHRoaXMuYWRkKHJlcywgb3B0cyk7XG5cdFx0XG5cdFx0Ly8gbm93IGxvb2sgZm9yIGFuIGFkZGl0aW9uYWwgc3VjY2VzcyBjYWxsYmFja1xuXHRcdGlmIChvcHRzICYmIG9wdHMuc3VjY2Vzcykgb3B0cy5zdWNjZXNzKHRoaXMsIG9wdHMsIHJlcywgc291cmNlKTtcblx0XHRcblx0XHQvLyBjbGVhciB0aGUgc3RhdGVcblx0XHRpZiAoIXRoaXMuX3dhaXRpbmcpIHtcblx0XHRcdHRoaXMuc2V0KCdzdGF0dXMnLCAodGhpcy5zdGF0dXMgfCBTdGF0ZXMuUkVBRFkpICYgflN0YXRlcy5GRVRDSElORyk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogSWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hpbGUgW2ZldGNoaW5nXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jZmV0Y2h9LFxuXHQqIFtjb21taXR0aW5nXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jY29tbWl0fSwgb3IgW2Rlc3Ryb3lpbmdde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNkZXN0cm95fVxuXHQqIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSwgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuIEJ5XG5cdCogZGVmYXVsdCwgaXQgdXBkYXRlcyB0aGUgY29sbGVjdGlvbidzIFtzdGF0dXNde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzdGF0dXN9XG5cdCogcHJvcGVydHkgYW5kIHRoZW4gY2hlY2tzIHRvIHNlZSBpZiB0aGVyZSBpcyBhIHByb3ZpZGVkXG5cdCogW2Vycm9yIGhhbmRsZXJde0BsaW5rIGVueW8uQ29sbGVjdGlvbn5FcnJvckNhbGxiYWNrfS4gSWYgdGhlIGVycm9yIGhhbmRsZXJcblx0KiBleGlzdHMsIGl0IHdpbGwgYmUgY2FsbGVkLlxuXHQqIFxuXHQqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gLSBUaGUgbmFtZSBvZiB0aGUgYWN0aW9uIHRoYXQgZmFpbGVkLFxuXHQqIG9uZSBvZiBgJ0ZFVENISU5HJ2Agb3IgYCdDT01NSVRUSU5HJ2AuXG5cdCogQHBhcmFtIHtlbnlvLkNvbGxlY3Rpb25+QWN0aW9uT3B0aW9uc30gb3B0cyAtIFRoZSBvcHRpb25zIGhhc2ggb3JpZ2luYWxseVxuXHQqIHBhc3NlZCBhbG9uZyB3aXRoIHRoZSBvcmlnaW5hbCBhY3Rpb24uXG5cdCogQHBhcmFtIHsqfSBbcmVzXSAtIFRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3RlZCBgYWN0aW9uYDsgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGVcblx0Klx0cmVxdWVzdGVkIFtzb3VyY2Vde0BsaW5rIGVueW8uQ29sbGVjdGlvbiNzb3VyY2V9LlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIHRoYXQgaGFzIHJldHVybmVkIGFuIGVycm9yLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZXJyb3JlZDogZnVuY3Rpb24gKGFjdGlvbiwgb3B0cywgcmVzLCBzb3VyY2UpIHtcblx0XHR2YXIgc3RhdDtcblx0XHRcblx0XHQvLyBpZiB0aGUgZXJyb3IgYWN0aW9uIGlzIGEgc3RhdHVzIG51bWJlciB0aGVuIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIGl0IG90aGVyd2lzZVxuXHRcdC8vIHdlIHNldCBpdCB0byB0aGUga25vd24gc3RhdGUgdmFsdWVcblx0XHRpZiAodHlwZW9mIGFjdGlvbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XG5cdFx0XHQvLyBhbGwgYnVpbHQtaW4gZXJyb3JzIHdpbGwgcGFzcyB0aGlzIGFzIHRoZWlyIHZhbHVlcyBhcmUgPiAwIGJ1dCB3ZSBnbyBhaGVhZCBhbmRcblx0XHRcdC8vIGVuc3VyZSB0aGF0IG5vIGRldmVsb3BlciB1c2VkIHRoZSAweDAwIGZvciBhbiBlcnJvciBjb2RlXG5cdFx0XHRzdGF0ID0gU1RBVEVTWydFUlJPUl8nICsgYWN0aW9uXTtcblx0XHR9IGVsc2Ugc3RhdCA9IGFjdGlvbjtcblx0XHRcblx0XHRpZiAoaXNOYU4oc3RhdCkgfHwgIShzdGF0ICYgU3RhdGVzLkVSUk9SKSkgc3RhdCA9IFN0YXRlcy5FUlJPUl9VTktOT1dOO1xuXHRcdFxuXHRcdC8vIGlmIGl0IGhhcyBjaGFuZ2VkIGdpdmUgb2JzZXJ2ZXJzIHRoZSBvcHBvcnR1bml0eSB0byByZXNwb25kXG5cdFx0dGhpcy5zZXQoJ3N0YXR1cycsICh0aGlzLnN0YXR1cyB8IHN0YXQpICYgflN0YXRlcy5SRUFEWSk7XG5cdFx0XG5cdFx0Ly8gd2UgbmVlZCB0byBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYW4gb3B0aW9ucyBoYW5kbGVyIGZvciB0aGlzIGVycm9yXG5cdFx0aWYgKG9wdHMgJiYgb3B0cy5lcnJvcikgb3B0cy5lcnJvcih0aGlzLCBhY3Rpb24sIG9wdHMsIHJlcywgc291cmNlKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIE92ZXJsb2FkZWQgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIHRvIGNhbGwgW3NldCgpXXtAbGluayBlbnlvLkNvbGxlY3Rpb24jc2V0fVxuXHQqIGluc3RlYWQgb2Ygc2ltcGx5IGFzc2lnbmluZyB0aGUgdmFsdWUuIFRoaXMgYWxsb3dzIGl0IHRvXG5cdCogW25vdGlmeSBvYnNlcnZlcnNde0BsaW5rIGVueW8uT2JzZXJ2ZXJTdXBwb3J0Lm5vdGlmeX0gYW5kIHRodXMgdXBkYXRlXG5cdCogW2JpbmRpbmdzXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0LmJpbmRpbmdzfSBhcyB3ZWxsLlxuXHQqXG5cdCogQHNlZSBlbnlvLlN0YXRlU3VwcG9ydC5jbGVhckVycm9yXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjbGVhckVycm9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KCdzdGF0dXMnLCBTdGF0ZXMuUkVBRFkpO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X21vZGVsRXZlbnQ6IGZ1bmN0aW9uIChtb2RlbCwgZSkge1xuXHRcdHN3aXRjaCAoZSkge1xuXHRcdGNhc2UgJ2NoYW5nZSc6XG5cdFx0XHR0aGlzLmVtaXQoJ2NoYW5nZScsIHttb2RlbDogbW9kZWx9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Rlc3Ryb3knOlxuXHRcdFx0dGhpcy5yZW1vdmUobW9kZWwpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogUmVzcG9uZHMgdG8gY2hhbmdlcyB0byB0aGUgW21vZGVsc117QGxpbmsgZW55by5Db2xsZWN0aW9uI21vZGVsc30gcHJvcGVydHkuXG5cdCpcblx0KiBAc2VlIGVueW8uQ29sbGVjdGlvbi5tb2RlbHNcblx0KiBAZmlyZXMgZW55by5Db2xsZWN0aW9uI3Jlc2V0XG5cdCogQHR5cGUge2VueW8uT2JzZXJ2ZXJTdXBwb3J0fk9ic2VydmVyfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bW9kZWxzQ2hhbmdlZDogZnVuY3Rpb24gKHdhcywgaXMsIHByb3ApIHtcblx0XHR2YXIgbW9kZWxzID0gdGhpcy5tb2RlbHMuY29weSgpLFxuXHRcdFx0bGVuID0gbW9kZWxzLmxlbmd0aDtcblx0XHRcblx0XHRpZiAobGVuICE9IHRoaXMubGVuZ3RoKSB0aGlzLnNldCgnbGVuZ3RoJywgbGVuKTtcblx0XHRcblx0XHR0aGlzLmVtaXQoJ3Jlc2V0Jywge21vZGVsczogbW9kZWxzLCBjb2xsZWN0aW9uOiB0aGlzfSk7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBJbml0aWFsaXplcyB0aGUgW2NvbGxlY3Rpb25de0BsaW5rIGVueW8uQ29sbGVjdGlvbn0uXG5cdCpcblx0KiBAcGFyYW0geyhPYmplY3R8T2JqZWN0W118ZW55by5Nb2RlbFtdKX0gW3JlY3NdIE1heSBiZSBhbiBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX1cblx0Klx0b2YgZWl0aGVyIFttb2RlbHNde0BsaW5rIGVueW8uTW9kZWx9IG9yIFtoYXNoZXNde0BnbG9zc2FyeSBPYmplY3R9IHVzZWQgdG9cblx0KiBpbml0aWFsaXplIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSwgb3IgYW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH1cblx0Klx0ZXF1aXZhbGVudCB0byB0aGUgYHByb3BzYCBwYXJhbWV0ZXIuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gLSBBIGhhc2ggb2YgcHJvcGVydGllcyB0byBhcHBseSBkaXJlY3RseSB0byB0aGVcblx0KiBjb2xsZWN0aW9uLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBBIGhhc2guXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29uc3RydWN0b3I6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChyZWNzLCBwcm9wcywgb3B0cykge1xuXHRcdFx0Ly8gb3B0cyA9IG9wdHM/ICh0aGlzLm9wdGlvbnMgPSBlbnlvLm1peGluKHt9LCBbdGhpcy5vcHRpb25zLCBvcHRzXSkpOiB0aGlzLm9wdGlvbnM7XG5cdFx0XHRcblx0XHRcdC8vIGlmIHByb3BlcnRpZXMgd2VyZSBwYXNzZWQgaW4gYnV0IG5vdCBhIHJlY29yZHMgYXJyYXlcblx0XHRcdHByb3BzID0gcmVjcyAmJiAhKHJlY3MgaW5zdGFuY2VvZiBBcnJheSk/IHJlY3M6IHByb3BzO1xuXHRcdFx0aWYgKHByb3BzID09PSByZWNzKSByZWNzID0gbnVsbDtcblx0XHRcdC8vIGluaXRpYWxpemUgb3VyIGNvcmUgcmVjb3Jkc1xuXHRcdFx0Ly8gdGhpcy5tb2RlbHMgPSB0aGlzLm1vZGVscyB8fCBuZXcgTW9kZWxMaXN0KCk7XG5cdFx0XHQhdGhpcy5tb2RlbHMgJiYgKHRoaXMuc2V0KCdtb2RlbHMnLCBuZXcgTW9kZWxMaXN0KCkpKTtcblx0XHRcdFxuXHRcdFx0Ly8gdGhpcyBpcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0aWYgKHByb3BzICYmIHByb3BzLnJlY29yZHMpIHtcblx0XHRcdFx0cmVjcyA9IHJlY3M/IHJlY3MuY29uY2F0KHByb3BzLnJlY29yZHMpOiBwcm9wcy5yZWNvcmRzLnNsaWNlKCk7XG5cdFx0XHRcdGRlbGV0ZSBwcm9wcy5yZWNvcmRzO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAocHJvcHMgJiYgcHJvcHMubW9kZWxzKSB7XG5cdFx0XHRcdHJlY3MgPSByZWNzPyByZWNzLmNvbmNhdChwcm9wcy5tb2RlbHMpOiBwcm9wcy5tb2RlbHMuc2xpY2UoKTtcblx0XHRcdFx0ZGVsZXRlIHByb3BzLm1vZGVscztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHByb3BzICYmIHByb3BzLm9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gdXRpbHMubWl4aW4oe30sIFt0aGlzLm9wdGlvbnMsIHByb3BzLm9wdGlvbnNdKTtcblx0XHRcdFx0ZGVsZXRlIHByb3BzLm9wdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdG9wdHMgPSBvcHRzPyB1dGlscy5taXhpbih7fSwgW3RoaXMub3B0aW9ucywgb3B0c10pOiB0aGlzLm9wdGlvbnM7XG5cdFx0XHRcblx0XHRcdC8vIEBUT0RPOiBGb3Igbm93LCB3aGlsZSB0aGVyZSBpcyBvbmx5IG9uZSBwcm9wZXJ0eSB3ZSBtYW51YWxseSBjaGVjayBmb3IgaXRcblx0XHRcdC8vIGlmIG1vcmUgb3B0aW9ucyBhcnJpc2UgdGhhdCBzaG91bGQgYmUgY29uZmlndXJhYmxlIHRoaXMgd2F5IGl0IG1heSBuZWVkIHRvXG5cdFx0XHQvLyBiZSBtb2RpZmllZFxuXHRcdFx0b3B0cy5mZXRjaCAmJiAodGhpcy5vcHRpb25zLmZldGNoID0gb3B0cy5mZXRjaCk7XG5cdFx0XHRcblx0XHRcdHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuXHRcdFx0dGhpcy5ldWlkID0gdXRpbHMudWlkKCdjJyk7XG5cdFx0XHRcblx0XHRcdHN1cC5jYWxsKHRoaXMsIHByb3BzKTtcblx0XHRcdFxuXHRcdFx0dHlwZW9mIHRoaXMubW9kZWwgPT0gJ3N0cmluZycgJiYgKHRoaXMubW9kZWwgPSBraW5kLmNvbnN0cnVjdG9yRm9yS2luZCh0aGlzLm1vZGVsKSk7XG5cdFx0XHR0aGlzLnN0b3JlID0gdGhpcy5zdG9yZSB8fCBTdG9yZTtcblx0XHRcdHJlY3MgJiYgcmVjcy5sZW5ndGggJiYgdGhpcy5hZGQocmVjcywgb3B0cyk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29uc3RydWN0ZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGF0dGVtcHQgYSBmZXRjaCBhZnRlciBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZVxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5mZXRjaCkgdGhpcy5mZXRjaCgpO1xuXHRcdH07XG5cdH0pXG5cdFxufSk7XG5cbi8qKlxuKiBAbmFtZSBlbnlvLkNvbGxlY3Rpb24uY29uY2F0XG4qIEBzdGF0aWNcbiogQHByaXZhdGVcbiovXG5Db2xsZWN0aW9uLmNvbmNhdCA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcykge1xuXHR2YXIgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSB8fCBjdG9yO1xuXHRcblx0aWYgKHByb3BzLm9wdGlvbnMpIHtcblx0XHRwcm90by5vcHRpb25zID0gdXRpbHMubWl4aW4oe30sIFtwcm90by5vcHRpb25zLCBwcm9wcy5vcHRpb25zXSk7XG5cdFx0ZGVsZXRlIHByb3BzLm9wdGlvbnM7XG5cdH1cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db21wb25lbnRcIjoxMyxcIi4vRXZlbnRFbWl0dGVyXCI6MTksXCIuL01vZGVsXCI6MzAsXCIuL01vZGVsTGlzdFwiOjMxLFwiLi9Tb3VyY2VcIjo0OCxcIi4vU3RhdGVTdXBwb3J0XCI6NDksXCIuL1N0YXRlc1wiOjUwLFwiLi9TdG9yZVwiOjUxLFwiLi9raW5kXCI6NjYsXCIuL3V0aWxzXCI6NzV9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vcGxhdGZvcm0nKSxcblx0YW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24nKTtcblxudmFyXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIGEgc2Nyb2xsaW5nIGFjdGlvbiBzdGFydHMuXG4qXG4qIEBldmVudCBlbnlvLlNjcm9sbE1hdGgjb25TY3JvbGxTdGFydFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHkgXG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtlbnlvLlNjcm9sbGVyflNjcm9sbEV2ZW50fSBldmVudCAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGNvbnRhaW5pbmcgXG4qXHRldmVudCBpbmZvcm1hdGlvbi5cbiogQHByaXZhdGVcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGlsZSBhIHNjcm9sbGluZyBhY3Rpb24gaXMgaW4gcHJvZ3Jlc3MuXG4qXG4qIEBldmVudCBlbnlvLlNjcm9sbE1hdGgjb25TY3JvbGxcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5IFxuKlx0cHJvcGFnYXRlZCB0aGUge0BnbG9zc2FyeSBldmVudH0uXG4qIEBwcm9wZXJ0eSB7ZW55by5TY3JvbGxlcn5TY3JvbGxFdmVudH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIFxuKlx0ZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwcml2YXRlXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBhIHNjcm9sbGluZyBhY3Rpb24gc3RvcHMuXG4qXG4qIEBldmVudCBlbnlvLlNjcm9sbE1hdGgjb25TY3JvbGxTdG9wXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseSBcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge2VueW8uU2Nyb2xsZXJ+U2Nyb2xsRXZlbnR9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBcbipcdGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHJpdmF0ZVxuKi9cblxuLyoqXG4qIHtAbGluayBlbnlvLlNjcm9sbE1hdGh9IGltcGxlbWVudHMgYSBzY3JvbGxpbmcgZHluYW1pY3Mgc2ltdWxhdGlvbi4gSXQgaXMgYVxuKiBoZWxwZXIgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB1c2VkIGJ5IG90aGVyIFtzY3JvbGxlcl17QGxpbmsgZW55by5TY3JvbGxlcn1cbioga2luZHMsIHN1Y2ggYXMge0BsaW5rIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneX0uXG4qIFxuKiBgZW55by5TY3JvbGxNYXRoYCBpcyBub3QgdHlwaWNhbGx5IGNyZWF0ZWQgaW4gYXBwbGljYXRpb24gY29kZS5cbipcbiogQGNsYXNzIGVueW8uU2Nyb2xsTWF0aFxuKiBAcHJvdGVjdGVkXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uU2Nyb2xsTWF0aC5wcm90b3R5cGUgKi8ge1xuXG5cdG5hbWU6ICdlbnlvLlNjcm9sbE1hdGgnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbXBvbmVudCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgZW55by5TY3JvbGxNYXRoLnByb3RvdHlwZSAqLyB7XG5cblx0XHQvKiogXG5cdFx0KiBTZXQgdG8gYHRydWVgIHRvIGVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCB0cnVlXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0dmVydGljYWw6IHRydWUsXG5cblx0XHQvKiogXG5cdFx0KiBTZXQgdG8gYHRydWVgIHRvIGVuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZy5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRob3Jpem9udGFsOiB0cnVlXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiB7XG5cdFx0b25TY3JvbGxTdGFydDogJycsXG5cdFx0b25TY3JvbGw6ICcnLFxuXHRcdG9uU2Nyb2xsU3RvcDogJycsXG5cdFx0b25TdGFiaWxpemU6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogXCJTcHJpbmdcIiBkYW1waW5nIHJldHVybnMgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byBhIHZhbHVlIGluc2lkZSB0aGUgYm91bmRhcmllcy4gTG93ZXIgXG5cdCogdmFsdWVzIHByb3ZpZGUgZmFzdGVyIHNuYXBiYWNrLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a1NwcmluZ0RhbXBpbmc6IDAuOTMsXG5cblx0LyoqIFxuXHQqIFwiRHJhZ1wiIGRhbXBpbmcgcmVzaXN0cyBkcmFnZ2luZyB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJleW9uZCB0aGUgYm91bmRhcmllcy4gTG93ZXIgdmFsdWVzIFxuXHQqIHByb3ZpZGUgbW9yZSByZXNpc3RhbmNlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a0RyYWdEYW1waW5nOiAwLjUsXG5cdFxuXHQvKiogXG5cdCogXCJGcmljdGlvblwiIGRhbXBpbmcgcmVkdWNlcyBtb21lbnR1bSBvdmVyIHRpbWUuIExvd2VyIHZhbHVlcyBwcm92aWRlIG1vcmUgZnJpY3Rpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRrRnJpY3Rpb25EYW1waW5nOiAwLjk3LFxuXG5cdC8qKiBcblx0KiBBZGRpdGlvbmFsIFwiZnJpY3Rpb25cIiBkYW1waW5nIGFwcGxpZWQgd2hlbiBtb21lbnR1bSBjYXJyaWVzIHRoZSB2aWV3cG9ydCBpbnRvIG92ZXJzY3JvbGwuIFxuXHQqIExvd2VyIHZhbHVlcyBwcm92aWRlIG1vcmUgZnJpY3Rpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRrU25hcEZyaWN0aW9uOiAwLjksXG5cdFxuXHQvKiogXG5cdCogU2NhbGFyIGFwcGxpZWQgdG8gYGZsaWNrYCBldmVudCB2ZWxvY2l0eS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtGbGlja1NjYWxhcjogMTUsXG5cblx0LyoqIFxuXHQqIExpbWl0cyB0aGUgbWF4aW11bSBhbGxvd2FibGUgZmxpY2suIE9uIEFuZHJvaWQgPiAyLCB3ZSBsaW1pdCB0aGlzIHRvIHByZXZlbnQgY29tcG9zaXRpbmcgXG5cdCogYXJ0aWZhY3RzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a01heEZsaWNrOiBwbGF0Zm9ybS5hbmRyb2lkID4gMiA/IDIgOiAxZTksXG5cdFxuXHQvKiogXG5cdCogVGhlIHZhbHVlIHVzZWQgaW4gW2ZyaWN0aW9uKClde0BsaW5rIGVueW8uU2Nyb2xsTWF0aCNmcmljdGlvbn0gdG8gZGV0ZXJtaW5lIGlmIHRoZSBkZWx0YSBcblx0KiAoZS5nLiwgeSAtIHkwKSBpcyBjbG9zZSBlbm91Z2ggdG8gemVybyB0byBjb25zaWRlciBhcyB6ZXJvLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a0ZyaWN0aW9uRXBzaWxvbjogcGxhdGZvcm0ud2Vib3MgPj0gNCA/IDFlLTEgOiAxZS0yLFxuXHRcblx0LyoqIFxuXHQqIFRvcCBzbmFwIGJvdW5kYXJ5LCBnZW5lcmFsbHkgYDBgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dG9wQm91bmRhcnk6IDAsXG5cdFxuXHQvKiogXG5cdCogUmlnaHQgc25hcCBib3VuZGFyeSwgZ2VuZXJhbGx5IGAodmlld3BvcnQgd2lkdGggLSBjb250ZW50IHdpZHRoKWAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyaWdodEJvdW5kYXJ5OiAwLFxuXHRcblx0LyoqIFxuXHQqIEJvdHRvbSBzbmFwIGJvdW5kYXJ5LCBnZW5lcmFsbHkgYCh2aWV3cG9ydCBoZWlnaHQgLSBjb250ZW50IGhlaWdodClgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Ym90dG9tQm91bmRhcnk6IDAsXG5cdFxuXHQvKiogXG5cdCogTGVmdCBzbmFwIGJvdW5kYXJ5LCBnZW5lcmFsbHkgYDBgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGVmdEJvdW5kYXJ5OiAwLFxuXHRcblx0LyoqIFxuXHQqIEFuaW1hdGlvbiB0aW1lIHN0ZXAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbnRlcnZhbDogMjAsXG5cdFxuXHQvKiogXG5cdCogRmxhZyB0byBlbmFibGUgZnJhbWUtYmFzZWQgYW5pbWF0aW9uOyBpZiBgZmFsc2VgLCB0aW1lLWJhc2VkIGFuaW1hdGlvbiBpcyB1c2VkLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Zml4ZWRUaW1lOiB0cnVlLFxuXG5cdC8qKlxuXHQqIFNpbXVsYXRpb24gc3RhdGUuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR4MDogMCxcblxuXHQvKipcblx0KiBTaW11bGF0aW9uIHN0YXRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0eDogMCxcblxuXHQvKipcblx0KiBTaW11bGF0aW9uIHN0YXRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0eTA6IDAsXG5cblx0LyoqXG5cdCogU2ltdWxhdGlvbiBzdGF0ZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHk6IDAsXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBTaW1wbGUgVmVybGV0IGludGVncmF0b3IgZm9yIHNpbXVsYXRpbmcgTmV3dG9uaWFuIG1vdGlvbi5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZlcmxldDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHRoaXMueCArPSB4IC0gdGhpcy54MDtcblx0XHR0aGlzLngwID0geDtcblx0XHQvL1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHRoaXMueSArPSB5IC0gdGhpcy55MDtcblx0XHR0aGlzLnkwID0geTtcblx0fSxcblxuXHQvKipcblx0KiBCb3VuZGFyeSBkYW1waW5nIGZ1bmN0aW9uLiBSZXR1cm5zIGRhbXBlZCBgdmFsdWVgIGJhc2VkIG9uIGBjb2VmZmAgb24gb25lIHNpZGUgb2YgXG5cdCogYG9yaWdpbmAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkYW1waW5nOiBmdW5jdGlvbiAodmFsLCBvcmlnaW4sIGNvZWZmLCBzaWduKSB7XG5cdFx0dmFyIGtFcHNpbG9uID0gMC41O1xuXHRcdC8vXG5cdFx0Ly8gdGhpcyBpcyBiYXNpY2FsbHkganVzdCB2YWx1ZSAqPSBjb2VmZiAoZ2VuZXJhbGx5LCBjb2VmZiA8IDEpXG5cdFx0Ly9cblx0XHQvLyAnc2lnbicgYW5kIHRoZSBjb25kaXRpb25hbCBpcyB0byBmb3JjZSB0aGUgZGFtcGluZyB0byBvbmx5IG9jY3VyXG5cdFx0Ly8gb24gb25lIHNpZGUgb2YgdGhlIG9yaWdpbi5cblx0XHQvL1xuXHRcdHZhciBkdiA9IHZhbCAtIG9yaWdpbjtcblx0XHQvLyBGb3JjZSBjbG9zZS10by16ZXJvIHRvIHplcm9cblx0XHRpZiAoTWF0aC5hYnMoZHYpIDwga0Vwc2lsb24pIHtcblx0XHRcdHJldHVybiBvcmlnaW47XG5cdFx0fVxuXHRcdHJldHVybiB2YWwqc2lnbiA+IG9yaWdpbipzaWduID8gY29lZmYgKiBkdiArIG9yaWdpbiA6IHZhbDtcblx0fSxcblxuXHQvKipcblx0KiBEdWFsLWJvdW5kYXJ5IGRhbXBpbmcgZnVuY3Rpb24uIFJldHVybnMgZGFtcGVkIGB2YWx1ZWAgYmFzZWQgb24gYGNvZWZmYCB3aGVuIGV4Y2VlZGluZyBcblx0KiBlaXRoZXIgYm91bmRhcnkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRib3VuZGFyeURhbXBpbmc6IGZ1bmN0aW9uICh2YWwsIGFCb3VuZGFyeSwgYkJvdW5kYXJ5LCBjb2VmZikge1xuXHRcdHJldHVybiB0aGlzLmRhbXBpbmcodGhpcy5kYW1waW5nKHZhbCwgYUJvdW5kYXJ5LCBjb2VmZiwgMSksIGJCb3VuZGFyeSwgY29lZmYsIC0xKTtcblx0fSxcblxuXHQvKipcblx0KiBTaW11bGF0aW9uIGNvbnN0cmFpbnRzIChzcHJpbmcgZGFtcGluZyBvY2N1cnMgaGVyZSkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJhaW46IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgeSA9IHRoaXMuYm91bmRhcnlEYW1waW5nKHRoaXMueSwgdGhpcy50b3BCb3VuZGFyeSwgdGhpcy5ib3R0b21Cb3VuZGFyeSwgdGhpcy5rU3ByaW5nRGFtcGluZyk7XG5cdFx0aWYgKHkgIT0gdGhpcy55KSB7XG5cdFx0XHQvLyBlbnN1cmUgc25hcHBpbmcgaW50cm9kdWNlcyBubyB2ZWxvY2l0eSwgYWRkIGFkZGl0aW9uYWwgZnJpY3Rpb25cblx0XHRcdHRoaXMueTAgPSB5IC0gKHRoaXMueSAtIHRoaXMueTApICogdGhpcy5rU25hcEZyaWN0aW9uO1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHR9XG5cdFx0dmFyIHggPSB0aGlzLmJvdW5kYXJ5RGFtcGluZyh0aGlzLngsIHRoaXMubGVmdEJvdW5kYXJ5LCB0aGlzLnJpZ2h0Qm91bmRhcnksIHRoaXMua1NwcmluZ0RhbXBpbmcpO1xuXHRcdGlmICh4ICE9IHRoaXMueCkge1xuXHRcdFx0dGhpcy54MCA9IHggLSAodGhpcy54IC0gdGhpcy54MCkgKiB0aGlzLmtTbmFwRnJpY3Rpb247XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBUaGUgZnJpY3Rpb24gZnVuY3Rpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmcmljdGlvbjogZnVuY3Rpb24gKGV4LCBleDAsIGNvZWZmKSB7XG5cdFx0Ly8gaW1wbGljaXQgdmVsb2NpdHlcblx0XHR2YXIgZHAgPSB0aGlzW2V4XSAtIHRoaXNbZXgwXTtcblx0XHQvLyBsZXQgY2xvc2UtdG8temVybyBjb2xsYXBzZSB0byB6ZXJvIChpLmUuIHNtYWxsZXIgdGhhbiBlcHNpbG9uIGlzIGNvbnNpZGVyZWQgemVybylcblx0XHR2YXIgYyA9IE1hdGguYWJzKGRwKSA+IHRoaXMua0ZyaWN0aW9uRXBzaWxvbiA/IGNvZWZmIDogMDtcblx0XHQvLyByZXBvc2l0aW9uIHVzaW5nIGRhbXBlZCB2ZWxvY2l0eVxuXHRcdHRoaXNbZXhdID0gdGhpc1tleDBdICsgYyAqIGRwO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBPbmUgdW5pdCBvZiB0aW1lIGZvciBzaW11bGF0aW9uLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZnJhbWU6IDEwLFxuXHQvLyBwaWVjZS13aXNlIGNvbnN0cmFpbnQgc2ltdWxhdGlvblxuXHRzaW11bGF0ZTogZnVuY3Rpb24gKHQpIHtcblx0XHR3aGlsZSAodCA+PSB0aGlzLmZyYW1lKSB7XG5cdFx0XHR0IC09IHRoaXMuZnJhbWU7XG5cdFx0XHRpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdFx0dGhpcy5jb25zdHJhaW4oKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudmVybGV0KCk7XG5cdFx0XHR0aGlzLmZyaWN0aW9uKCd5JywgJ3kwJywgdGhpcy5rRnJpY3Rpb25EYW1waW5nKTtcblx0XHRcdHRoaXMuZnJpY3Rpb24oJ3gnLCAneDAnLCB0aGlzLmtGcmljdGlvbkRhbXBpbmcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdDtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5TY3JvbGxNYXRoI29uU2Nyb2xsU3RvcFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnN0b3AoKTtcblx0XHQvLyB0aW1lIHRyYWNraW5nXG5cdFx0dmFyIHQwID0gdXRpbHMucGVyZk5vdygpLCB0ID0gMDtcblx0XHQvLyBkZWx0YSB0cmFja2luZ1xuXHRcdHZhciB4MCwgeTA7XG5cdFx0Ly8gYW5pbWF0aW9uIGhhbmRsZXJcblx0XHR2YXIgZm4gPSB0aGlzLmJpbmRTYWZlbHkoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB3YWxsLWNsb2NrIHRpbWVcblx0XHRcdHZhciB0MSA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHRcdC8vIHNjaGVkdWxlIG5leHQgZnJhbWVcblx0XHRcdHRoaXMuam9iID0gYW5pbWF0aW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG5cdFx0XHQvLyBkZWx0YSBmcm9tIGxhc3Qgd2FsbCBjbG9jayB0aW1lXG5cdFx0XHR2YXIgZHQgPSB0MSAtIHQwO1xuXHRcdFx0Ly8gcmVjb3JkIHRoZSB0aW1lIGZvciBuZXh0IGRlbHRhXG5cdFx0XHR0MCA9IHQxO1xuXHRcdFx0Ly8gdXNlciBkcmFncyBvdmVycmlkZSBhbmltYXRpb25cblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XG5cdFx0XHRcdHRoaXMueTAgPSB0aGlzLnkgPSB0aGlzLnV5O1xuXHRcdFx0XHR0aGlzLngwID0gdGhpcy54ID0gdGhpcy51eDtcblx0XHRcdFx0dGhpcy5lbmRYID0gdGhpcy5lbmRZID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGZyYW1lLXRpbWUgYWNjdW11bGF0b3Jcblx0XHRcdC8vIG1pbiBhY2NlcHRhYmxlIHRpbWUgaXMgMTZtcyAoNjBmcHMpXG5cdFx0XHR0ICs9IE1hdGgubWF4KDE2LCBkdCk7XG5cdFx0XHQvLyBwcmV2ZW50IHNuYXBwaW5nIHRvIG9yaWdpbmFsbHkgZGVzaXJlZCBzY3JvbGwgcG9zaXRpb24gaWYgd2UgYXJlIGluIG92ZXJzY3JvbGxcblx0XHRcdGlmICh0aGlzLmlzSW5PdmVyU2Nyb2xsKCkpIHtcblx0XHRcdFx0dGhpcy5lbmRYID0gbnVsbDtcblx0XHRcdFx0dGhpcy5lbmRZID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsdGVybmF0ZSBmaXhlZC10aW1lIHN0ZXAgc3RyYXRlZ3k6XG5cdFx0XHRlbHNlIGlmICh0aGlzLmZpeGVkVGltZSkge1xuXHRcdFx0XHR0ID0gdGhpcy5pbnRlcnZhbDtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnN1bWUgc29tZSB0IGluIHNpbXVsYXRpb25cblx0XHRcdHQgPSB0aGlzLnNpbXVsYXRlKHQpO1xuXHRcdFx0Ly8gc2Nyb2xsIGlmIHdlIGhhdmUgbW92ZWQsIG90aGVyd2lzZSB0aGUgYW5pbWF0aW9uIGlzIHN0YWxsZWQgYW5kIHdlIGNhbiBzdG9wXG5cdFx0XHRpZiAoeTAgIT0gdGhpcy55IHx8IHgwICE9IHRoaXMueCkge1xuXHRcdFx0XHR0aGlzLnNjcm9sbCgpO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5kcmFnZ2luZykge1xuXHRcdFx0XHQvLyBzZXQgZmluYWwgdmFsdWVzXG5cdFx0XHRcdGlmICh0aGlzLmVuZFggIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMueCA9IHRoaXMueDAgPSB0aGlzLmVuZFg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZW5kWSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdGhpcy55MCA9IHRoaXMuZW5kWTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc3RvcCgpO1xuXHRcdFx0XHR0aGlzLnNjcm9sbCgpO1xuXHRcdFx0XHR0aGlzLmRvU2Nyb2xsU3RvcCgpO1xuXG5cdFx0XHRcdHRoaXMuZW5kWCA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZW5kWSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR5MCA9IHRoaXMueTtcblx0XHRcdHgwID0gdGhpcy54O1xuXHRcdH0pO1xuXHRcdHRoaXMuam9iID0gYW5pbWF0aW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5qb2IpIHtcblx0XHRcdHRoaXMuZG9TY3JvbGxTdGFydCgpO1xuXHRcdFx0dGhpcy5hbmltYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0b3A6IGZ1bmN0aW9uIChmaXJlKSB7XG5cdFx0dmFyIGpvYiA9IHRoaXMuam9iO1xuXHRcdGlmIChqb2IpIHtcblx0XHRcdHRoaXMuam9iID0gYW5pbWF0aW9uLmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShqb2IpO1xuXHRcdH1cblx0XHRpZiAoZmlyZSkge1xuXHRcdFx0dGhpcy5kb1Njcm9sbFN0b3AoKTtcblxuXHRcdFx0dGhpcy5lbmRYID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5lbmRZID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBBZGp1c3RzIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gYmUgdmFsaWQsIGlmIG5lY2Vzc2FyeSAoZS5nLiwgYWZ0ZXIgdGhlIHNjcm9sbCBjb250ZW50c1xuXHQqIGhhdmUgY2hhbmdlZCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGFiaWxpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgeSA9IE1hdGgubWluKHRoaXMudG9wQm91bmRhcnksIE1hdGgubWF4KHRoaXMuYm90dG9tQm91bmRhcnksIHRoaXMueSkpO1xuXHRcdHZhciB4ID0gTWF0aC5taW4odGhpcy5sZWZ0Qm91bmRhcnksIE1hdGgubWF4KHRoaXMucmlnaHRCb3VuZGFyeSwgdGhpcy54KSk7XG5cdFx0aWYgKHkgIT0gdGhpcy55IHx8IHggIT0gdGhpcy54KSB7XG5cdFx0XHR0aGlzLnkgPSB0aGlzLnkwID0geTtcblx0XHRcdHRoaXMueCA9IHRoaXMueDAgPSB4O1xuXHRcdFx0dGhpcy5kb1N0YWJpbGl6ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGFydERyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdFx0Ly9cblx0XHR0aGlzLm15ID0gZS5wYWdlWTtcblx0XHR0aGlzLnB5ID0gdGhpcy51eSA9IHRoaXMueTtcblx0XHQvL1xuXHRcdHRoaXMubXggPSBlLnBhZ2VYO1xuXHRcdHRoaXMucHggPSB0aGlzLnV4ID0gdGhpcy54O1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdHZhciBkeSA9IHRoaXMudmVydGljYWwgPyBlLnBhZ2VZIC0gdGhpcy5teSA6IDA7XG5cdFx0XHR0aGlzLnV5ID0gZHkgKyB0aGlzLnB5O1xuXHRcdFx0Ly8gcHJvdmlkZXMgcmVzaXN0YW5jZSBhZ2FpbnN0IGRyYWdnaW5nIGludG8gb3ZlcnNjcm9sbFxuXHRcdFx0dGhpcy51eSA9IHRoaXMuYm91bmRhcnlEYW1waW5nKHRoaXMudXksIHRoaXMudG9wQm91bmRhcnksIHRoaXMuYm90dG9tQm91bmRhcnksIHRoaXMua0RyYWdEYW1waW5nKTtcblx0XHRcdC8vXG5cdFx0XHR2YXIgZHggPSB0aGlzLmhvcml6b250YWwgPyBlLnBhZ2VYIC0gdGhpcy5teCA6IDA7XG5cdFx0XHR0aGlzLnV4ID0gZHggKyB0aGlzLnB4O1xuXHRcdFx0Ly8gcHJvdmlkZXMgcmVzaXN0YW5jZSBhZ2FpbnN0IGRyYWdnaW5nIGludG8gb3ZlcnNjcm9sbFxuXHRcdFx0dGhpcy51eCA9IHRoaXMuYm91bmRhcnlEYW1waW5nKHRoaXMudXgsIHRoaXMubGVmdEJvdW5kYXJ5LCB0aGlzLnJpZ2h0Qm91bmRhcnksIHRoaXMua0RyYWdEYW1waW5nKTtcblx0XHRcdC8vXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ0Ryb3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiAhd2luZG93LlBhbG1TeXN0ZW0pIHtcblx0XHRcdHZhciBrU2ltdWxhdGVkRmxpY2tTY2FsYXIgPSAwLjU7XG5cdFx0XHR0aGlzLnkgPSB0aGlzLnV5O1xuXHRcdFx0dGhpcy55MCA9IHRoaXMueSAtICh0aGlzLnkgLSB0aGlzLnkwKSAqIGtTaW11bGF0ZWRGbGlja1NjYWxhcjtcblx0XHRcdHRoaXMueCA9IHRoaXMudXg7XG5cdFx0XHR0aGlzLngwID0gdGhpcy54IC0gKHRoaXMueCAtIHRoaXMueDApICoga1NpbXVsYXRlZEZsaWNrU2NhbGFyO1xuXHRcdH1cblx0XHR0aGlzLmRyYWdGaW5pc2goKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnRmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB2O1xuXHRcdGlmICh0aGlzLnZlcnRpY2FsKSB7XG5cdFx0XHR2ID0gZS55VmVsb2NpdHkgPiAwID8gTWF0aC5taW4odGhpcy5rTWF4RmxpY2ssIGUueVZlbG9jaXR5KSA6IE1hdGgubWF4KC10aGlzLmtNYXhGbGljaywgZS55VmVsb2NpdHkpO1xuXHRcdFx0dGhpcy55ID0gdGhpcy55MCArIHYgKiB0aGlzLmtGbGlja1NjYWxhcjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuXHRcdFx0diA9IGUueFZlbG9jaXR5ID4gMCA/IE1hdGgubWluKHRoaXMua01heEZsaWNrLCBlLnhWZWxvY2l0eSkgOiBNYXRoLm1heCgtdGhpcy5rTWF4RmxpY2ssIGUueFZlbG9jaXR5KTtcblx0XHRcdHRoaXMueCA9IHRoaXMueDAgKyB2ICogdGhpcy5rRmxpY2tTY2FsYXI7XG5cdFx0fVxuXHRcdHRoaXMuc3RhcnQoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtb3VzZXdoZWVsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkeSA9IHRoaXMudmVydGljYWwgPyBlLndoZWVsRGVsdGFZIHx8ICghZS53aGVlbERlbHRhWCA/IGUud2hlZWxEZWx0YSA6IDApIDogMCxcblx0XHRcdGR4ID0gdGhpcy5ob3Jpem9udGFsID8gZS53aGVlbERlbHRhWCA6IDAsXG5cdFx0XHRzaG91bGRTY3JvbGwgPSBmYWxzZTtcblx0XHRpZiAoKGR5ID4gMCAmJiB0aGlzLnkgPCB0aGlzLnRvcEJvdW5kYXJ5KSB8fCAoZHkgPCAwICYmIHRoaXMueSA+IHRoaXMuYm90dG9tQm91bmRhcnkpKSB7XG5cdFx0XHR0aGlzLnkgPSB0aGlzLnkwID0gdGhpcy55MCArIGR5O1xuXHRcdFx0c2hvdWxkU2Nyb2xsID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKChkeCA+IDAgJiYgdGhpcy54IDwgdGhpcy5sZWZ0Qm91bmRhcnkpIHx8IChkeCA8IDAgJiYgdGhpcy54ID4gdGhpcy5yaWdodEJvdW5kYXJ5KSkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy54MCA9IHRoaXMueDAgKyBkeDtcblx0XHRcdHNob3VsZFNjcm9sbCA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMuc3RvcCghc2hvdWxkU2Nyb2xsKTtcblx0XHRpZiAoc2hvdWxkU2Nyb2xsKSB7XG5cdFx0XHR0aGlzLnN0YXJ0KCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQGZpcmVzIGVueW8uU2Nyb2xsTWF0aCNvblNjcm9sbFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZG9TY3JvbGwoKTtcblx0fSxcblxuXHQvLyBOT1RFOiBZaXAvT3J2ZWxsIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgc2Nyb2xsZXIgaW5zdGFudGFuZW91cyB2ZWxvY2l0eVxuXHQvLyBGSVhNRTogaW5jb3JyZWN0IGlmIGNhbGxlZCB3aGVuIHNjcm9sbGVyIGlzIGluIG92ZXJzY3JvbGwgcmVnaW9uXG5cdC8vIGJlY2F1c2UgZG9lcyBub3QgYWNjb3VudCBmb3IgYWRkaXRpb25hbCBvdmVyc2Nyb2xsIGRhbXBpbmcuXG5cdFxuXHQvKipcblx0KiBBbmltYXRlcyBhIHNjcm9sbCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgYHhgIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSBgeWAgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbFRvOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICh4ID09IHRoaXMueCAmJiB5ID09IHRoaXMueSkgcmV0dXJuO1xuXHRcdGlmICh5ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmVuZFkgPSAteTtcblx0XHRcdHRoaXMueSA9IHRoaXMueTAgLSAoeSArIHRoaXMueTApICogKDEgLSB0aGlzLmtGcmljdGlvbkRhbXBpbmcpO1xuXHRcdH1cblx0XHRpZiAoeCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5lbmRYID0gLXg7XG5cdFx0XHR0aGlzLnggPSB0aGlzLngwIC0gKHggKyB0aGlzLngwKSAqICgxIC0gdGhpcy5rRnJpY3Rpb25EYW1waW5nKTtcblx0XHR9XG5cdFx0dGhpcy5zdGFydCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbG9uZyB0aGUgeC1heGlzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgeC1heGlzIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldFNjcm9sbFg6IGZ1bmN0aW9uICh4KSB7XG5cdFx0dGhpcy54ID0gdGhpcy54MCA9IHg7XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFsb25nIHRoZSB5LWF4aXMuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB5LWF4aXMgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0U2Nyb2xsWTogZnVuY3Rpb24gKHkpIHtcblx0XHR0aGlzLnkgPSB0aGlzLnkwID0geTtcblx0fSxcblxuXHQvKipcblx0KiBTZXRzIHRoZSBzY3JvbGwgcG9zaXRpb247IGRlZmF1bHRzIHRvIHNldHRpbmcgdGhpcyBwb3NpdGlvbiBhbG9uZyB0aGUgeS1heGlzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHBvcyAtIFRoZSBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHRoaXMuc2V0U2Nyb2xsWShwb3MpO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IGlzIGFjdGl2ZWx5IG1vdmluZy5cblx0KiBcblx0KiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYWN0aXZlbHkgbW92aW5nOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNTY3JvbGxpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmpvYik7XG5cdH0sXG5cblx0LyoqIFxuXHQqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIFtzY3JvbGxlcl17QGxpbmsgZW55by5TY3JvbGxlcn0gaXMgaW4gb3ZlcnNjcm9sbC5cblx0KiBcblx0KiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgaW4gb3ZlcnNjcm9sbDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzSW5PdmVyU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuam9iICYmICh0aGlzLnggPiB0aGlzLmxlZnRCb3VuZGFyeSB8fCB0aGlzLnggPCB0aGlzLnJpZ2h0Qm91bmRhcnkgfHxcblx0XHRcdHRoaXMueSA+IHRoaXMudG9wQm91bmRhcnkgfHwgdGhpcy55IDwgdGhpcy5ib3R0b21Cb3VuZGFyeSk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29tcG9uZW50XCI6MTMsXCIuL2FuaW1hdGlvblwiOjU2LFwiLi9raW5kXCI6NjYsXCIuL3BsYXRmb3JtXCI6NzEsXCIuL3V0aWxzXCI6NzV9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyk7XG52YXJcblx0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcblxuLyoqXG4qIFRoZSBleHRlbmRlZCB7QGdsb3NzYXJ5IGV2ZW50fSBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0aGF0IGlzIHByb3ZpZGVkXG4qIHdoZW4gdGhlIFtvblNlbGVjdF17QGxpbmsgZW55by5TZWxlY3Rpb24jb25TZWxlY3R9IGFuZFxuKiBbb25EZXNlbGVjdF17QGxpbmsgZW55by5TZWxlY3Rpb24jb25EZXNlbGVjdH0gZXZlbnRzIGFyZSBmaXJlZC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gZW55by5TZWxlY3Rpb25+U2VsZWN0aW9uRXZlbnRcbiogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHdhcyB1c2VkIHRvIHJlZ2lzdGVyIHRoZVxuKlx0W3NlbGVjdGlvbl17QGxpbmsgZW55by5TZWxlY3Rpb259ICh1c3VhbGx5IGEgcm93IGluZGV4KS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEgLSBSZWZlcmVuY2VzIGRhdGEgcmVnaXN0ZXJlZCB3aXRoIHRoZSBrZXkgYnkgdGhlIGNvZGVcbiogdGhhdCBtYWRlIHRoZSBvcmlnaW5hbCBzZWxlY3Rpb24uXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBhbiBpdGVtIGlzIHNlbGVjdGVkLlxuKiBcbiogYGBgamF2YXNjcmlwdFxuKiB7a2luZDogXCJTZWxlY3Rpb25cIiwgb25TZWxlY3Q6IFwic2VsZWN0Um93XCIuLi5cbiogLi4uXG4qIHNlbGVjdFJvdzogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcbiogLi4uXG4qIGBgYFxuKlxuKiBAZXZlbnQgZW55by5TZWxlY3Rpb24jb25TZWxlY3RcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtlbnlvLlNlbGVjdGlvbn5TZWxlY3Rpb25FdmVudH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fVxuKlx0Y29udGFpbmluZyBldmVudCBpbmZvcm1hdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gYW4gaXRlbSBpcyBkZXNlbGVjdGVkLlxuKiBcbiogYGBgamF2YXNjcmlwdFxuKiB7a2luZDogXCJTZWxlY3Rpb25cIiwgb25TZWxlY3Q6IFwiZGVzZWxlY3RSb3dcIi4uLlxuKiAuLi5cbiogZGVzZWxlY3RSb3c6IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KVxuKiAuLi5cbiogYGBgXG4qXG4qIEBldmVudCBlbnlvLlNlbGVjdGlvbiNvbkRlc2VsZWN0XG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseVxuKlx0cHJvcGFnYXRlZCB0aGUge0BnbG9zc2FyeSBldmVudH0uXG4qIEBwcm9wZXJ0eSB7ZW55by5TZWxlY3Rpb25+U2VsZWN0aW9uRXZlbnR9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH1cbipcdGNvbnRhaW5pbmcgZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzIChidXQgbm90IHdoZW4gc2VsZWN0aW9uIGlzIGNsZWFyZWQpLlxuKlxuKiBAZXZlbnQgZW55by5TZWxlY3Rpb24jb25DaGFuZ2VcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBldmVudCBpbmZvcm1hdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIHtAbGluayBlbnlvLlNlbGVjdGlvbn0gaXMgdXNlZCB0byBtYW5hZ2Ugcm93IHNlbGVjdGlvbiBzdGF0ZSBmb3IgbGlzdHMuIEl0IHByb3ZpZGVzXG4qIHNlbGVjdGlvbiBzdGF0ZSBtYW5hZ2VtZW50IGZvciBib3RoIHNpbmdsZS1zZWxlY3QgYW5kIG11bHRpLXNlbGVjdCBsaXN0cy5cbipcbiogYGBgamF2YXNjcmlwdFxuKiAvLyBUaGUgZm9sbG93aW5nIGlzIGFuIGV4Y2VycHQgZnJvbSBlbnlvLkZseXdlaWdodFJlcGVhdGVyLlxuKiBlbnlvLmtpbmQoe1xuKlx0bmFtZTogXCJlbnlvLkZseXdlaWdodFJlcGVhdGVyXCIsXG4qXHQuLi5cbipcdGNvbXBvbmVudHM6IFtcbipcdFx0e2tpbmQ6IFwiU2VsZWN0aW9uXCIsIG9uU2VsZWN0OiBcInNlbGVjdERlc2VsZWN0XCIsIG9uRGVzZWxlY3Q6IFwic2VsZWN0RGVzZWxlY3RcIn0sXG4qXHRcdC4uLlxuKlx0XSxcbipcdHRhcDogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcbipcdFx0Li4uXG4qXHRcdC8vIG1hcmsgdGhlIHRhcHBlZCByb3cgYXMgc2VsZWN0ZWRcbipcdFx0dGhpcy4kLnNlbGVjdGlvbi5zZWxlY3QoaW5FdmVudC5pbmRleCk7XG4qXHRcdC4uLlxuKlx0fSxcbipcdHNlbGVjdERlc2VsZWN0OiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuKlx0XHQvLyB0aGlzIGlzIHdoZXJlIGEgcm93IHNlbGVjdGlvbiBoaWdobGlnaHQgbWlnaHQgYmUgYXBwbGllZFxuKlx0XHR0aGlzLnJlbmRlclJvdyhpbkV2ZW50LmtleSk7XG4qXHR9XG4qXHQuLi5cbiogfSk7XG4qIGBgYFxuKlxuKiBAY2xhc3MgZW55by5TZWxlY3Rpb25cbiogQGV4dGVuZHMgZW55by5Db21wb25lbnRcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLlNlbGVjdGlvbicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29tcG9uZW50LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDogXG5cdFx0LyoqIEBsZW5kcyBlbnlvLlNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG5cdFx0LyoqXG5cdFx0KiBJZiBgdHJ1ZWAsIG11bHRpcGxlIHNlbGVjdGlvbnMgYXJlIGFsbG93ZWQuXG5cdFx0KiBcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG11bHRpOiBmYWxzZVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uU2VsZWN0OiAnJyxcblx0XHRvbkRlc2VsZWN0OiAnJyxcblx0XHRvbkNoYW5nZTogJydcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jbGVhcigpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bXVsdGlDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLm11bHRpKSB7XG5cdFx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0fVxuXHRcdHRoaXMuZG9DaGFuZ2UoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoaWdobGFuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLm11bHRpKSB7XG5cdFx0XHR0aGlzLmRlc2VsZWN0KHRoaXMubGFzdFNlbGVjdGVkKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUmVtb3ZlcyBhbGwgc2VsZWN0aW9ucy5cblx0KiBcblx0KiBAcHVibGljXG5cdCovXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciBhIHBhcnRpY3VsYXIgcm93IGlzIHNlbGVjdGVkLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvdy5cblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgcm93IGlzIHNlbGVjdGVkOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0ZWRba2V5XTtcblx0fSxcblxuXHQvKipcblx0KiBNYW51YWxseSBzZXRzIGEgcm93J3Mgc3RhdGUgdG8gc2VsZWN0ZWQgb3IgdW5zZWxlY3RlZC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb3cuXG5cdCogQHBhcmFtIHtCb29sZWFufSBzZWwgLSBgdHJ1ZWAgaWYgdGhlIHJvdyBzaG91bGQgYmUgc2VsZWN0ZWQ7IGBmYWxzZWAgaWYgdGhlIHJvd1xuXHQqIHNob3VsZCBiZSB1bnNlbGVjdGVkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gLSBBbiBvcHRpb25hbCBkYXRhIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHRvIHN0b3JlXG5cdCpcdGluIHRoZSBzZWxlY3Rpb24gZm9yIHRoZSBrZXkgdGhhdCB3aWxsIGJlIHNlbnQgd2l0aCB0aGVcblx0Klx0W29uU2VsZWN0XXtAbGluayBlbnlvLlNlbGVjdGlvbiNvblNlbGVjdH0gb3Jcblx0Klx0W29uRGVzZWxlY3Rde0BsaW5rIGVueW8uU2VsZWN0aW9uI29uRGVzZWxlY3R9IHtAZ2xvc3NhcnkgZXZlbnR9LiBJZlxuXHQqXHRub3QgdXNlZCwgdGhlIGBkYXRhYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuXG5cdCogQGZpcmVzIGVueW8uU2VsZWN0aW9uI29uQ2hhbmdlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRCeUtleTogZnVuY3Rpb24gKGtleSwgc2VsLCBkYXRhKSB7XG5cdFx0aWYgKHNlbCkge1xuXHRcdFx0dGhpcy5zZWxlY3RlZFtrZXldID0gKGRhdGEgfHwgdHJ1ZSk7XG5cdFx0XHR0aGlzLmxhc3RTZWxlY3RlZCA9IGtleTtcblx0XHRcdHRoaXMuZG9TZWxlY3Qoe2tleToga2V5LCBkYXRhOiB0aGlzLnNlbGVjdGVkW2tleV19KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHdhcyA9IHRoaXMuaXNTZWxlY3RlZChrZXkpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuc2VsZWN0ZWRba2V5XTtcblx0XHRcdHRoaXMuZG9EZXNlbGVjdCh7a2V5OiBrZXksIGRhdGE6IHdhc30pO1xuXHRcdH1cblx0XHR0aGlzLmRvQ2hhbmdlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGVzZWxlY3RzIGEgcm93LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvdy5cblx0KiBAcHVibGljXG5cdCovXG5cdGRlc2VsZWN0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKHRoaXMuaXNTZWxlY3RlZChrZXkpKSB7XG5cdFx0XHR0aGlzLnNldEJ5S2V5KGtleSwgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgcm93LiBJZiB0aGUgW211bHRpXXtAbGluayBlbnlvLlNlbGVjdGlvbiNtdWx0aX0gcHJvcGVydHkgaXMgc2V0IHRvIGBmYWxzZWAsXG5cdCogdGhpcyB3aWxsIGFsc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzIFtzZWxlY3Rpb25de0BsaW5rIGVueW8uU2VsZWN0aW9ufS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb3cuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSAtIEFuIG9wdGlvbmFsIGRhdGEgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdG8gc3RvcmVcblx0KiBpbiB0aGUgc2VsZWN0aW9uIGZvciB0aGUga2V5IHRoYXQgd2lsbCBiZSBzZW50IHdpdGggdGhlXG5cdCpcdFtvblNlbGVjdF17QGxpbmsgZW55by5TZWxlY3Rpb24jb25TZWxlY3R9IG9yXG5cdCpcdFtvbkRlc2VsZWN0XXtAbGluayBlbnlvLlNlbGVjdGlvbiNvbkRlc2VsZWN0fSB7QGdsb3NzYXJ5IGV2ZW50fS4gSWZcblx0Klx0bm90IHVzZWQsIHRoZSBgZGF0YWAgd2lsbCBiZSBzZXQgdG8gYHRydWVgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0OiBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XG5cdFx0aWYgKHRoaXMubXVsdGkpIHtcblx0XHRcdHRoaXMuc2V0QnlLZXkoa2V5LCAhdGhpcy5pc1NlbGVjdGVkKGtleSksIGRhdGEpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuaXNTZWxlY3RlZChrZXkpKSB7XG5cdFx0XHR0aGlzLmhpZ2hsYW5kZXIoKTtcblx0XHRcdHRoaXMuc2V0QnlLZXkoa2V5LCB0cnVlLCBkYXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogVG9nZ2xlcyBbc2VsZWN0aW9uXXtAbGluayBlbnlvLlNlbGVjdGlvbn0gc3RhdGUgZm9yIGEgcm93LiBJZiB0aGVcblx0KiBbbXVsdGlde0BsaW5rIGVueW8uU2VsZWN0aW9uI211bHRpfSBwcm9wZXJ0eSBpcyBzZXQgdG8gYGZhbHNlYCwgdG9nZ2xpbmcgYVxuXHQqIHNlbGVjdGlvbiBcIm9uXCIgd2lsbCBkZXNlbGVjdCB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJvdy5cblx0KiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIC0gQW4gb3B0aW9uYWwgZGF0YSBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBzdG9yZVxuXHQqIGluIHRoZSBzZWxlY3Rpb24gZm9yIHRoZSBrZXkgdGhhdCB3aWxsIGJlIHNlbnQgd2l0aCB0aGVcblx0Klx0W29uU2VsZWN0XXtAbGluayBlbnlvLlNlbGVjdGlvbiNvblNlbGVjdH0gb3Jcblx0Klx0W29uRGVzZWxlY3Rde0BsaW5rIGVueW8uU2VsZWN0aW9uI29uRGVzZWxlY3R9IHtAZ2xvc3NhcnkgZXZlbnR9LiBJZlxuXHQqXHRub3QgdXNlZCwgdGhlIGBkYXRhYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0b2dnbGU6IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcblx0XHRpZiAoIXRoaXMubXVsdGkgJiYgdGhpcy5sYXN0U2VsZWN0ZWQgIT0ga2V5KSB7XG5cdFx0XHR0aGlzLmRlc2VsZWN0KHRoaXMubGFzdFNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRCeUtleShrZXksICF0aGlzLmlzU2VsZWN0ZWQoa2V5KSwgZGF0YSk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBjdXJyZW50IFtzZWxlY3Rpb25de0BsaW5rIGVueW8uU2VsZWN0aW9ufS5cblx0KlxuXHQqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzZWxlY3Rpb24gYXMgYSBbaGFzaF17QGdsb3NzYXJ5IE9iamVjdH0gaW4gd2hpY2ggZWFjaFxuXHQqIHNlbGVjdGVkIGl0ZW0gaGFzIGEgdmFsdWU7IHVuc2VsZWN0ZWQgaXRlbXMgYXJlIFt1bmRlZmluZWRde0BnbG9zc2FyeSB1bmRlZmluZWR9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZDtcblx0fSxcblxuXHQvKipcblx0KiBSZW1vdmVzIGEgcm93IHRoYXQncyBpbmNsdWRlZCBpbiB0aGUgW3NlbGVjdGlvbl17QGxpbmsgZW55by5TZWxlY3Rpb259IHNldC5cblx0KiBJZiB0aGlzIHJvdyBpcyBzZWxlY3RlZCwgaXQgd2lsbCBiZSB1bnNlbGVjdGVkLiAgQW55IHJvd3MgYWJvdmUgdGhpcyByb3dcblx0KiB3aWxsIGhhdmUgdGhlaXIga2V5cyB2YWx1ZSByZWR1Y2VkIGJ5IG9uZS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByb3cuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgbmV3U2VsZWN0ZWQgPSB7fTtcblx0XHRmb3IgKHZhciByb3cgaW4gdGhpcy5zZWxlY3RlZCkge1xuXHRcdFx0aWYgKHJvdyA8IGtleSkge1xuXHRcdFx0XHRuZXdTZWxlY3RlZFtyb3ddID0gdGhpcy5zZWxlY3RlZFtyb3ddO1xuXHRcdFx0fSBlbHNlIGlmIChyb3cgPiBrZXkpIHtcblx0XHRcdFx0bmV3U2VsZWN0ZWRbcm93IC0gMV0gPSB0aGlzLnNlbGVjdGVkW3Jvd107XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0ZWQgPSBuZXdTZWxlY3RlZDtcblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db21wb25lbnRcIjoxMyxcIi4va2luZFwiOjY2fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5TaWduYWxzfSBpcyBhIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB1c2VkIHRvIGxpc3RlblxuKiB0byBnbG9iYWwgbWVzc2FnZXMuXG4qIFxuKiBBbiBvYmplY3Qgd2l0aCBhIFNpZ25hbHMgY29tcG9uZW50IGNhbiBsaXN0ZW4gdG8gbWVzc2FnZXMgc2VudCBmcm9tIGFueXdoZXJlXG4qIGJ5IGRlY2xhcmluZyBoYW5kbGVycyBmb3IgdGhlbS5cbiogXG4qIERPTSBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IHRoYXQgaGF2ZSBubyBub2RlIHRhcmdldHMgYXJlIGJyb2FkY2FzdCBhc1xuKiBzaWduYWxzLiBUaGVzZSBldmVudHMgaW5jbHVkZSBXaW5kb3cgZXZlbnRzLCBzdWNoIGFzIGBvbmxvYWRgIGFuZFxuKiBgb25iZWZvcmV1bmxvYWRgLCBhcyB3ZWxsIGFzIGV2ZW50cyB0aGF0IG9jY3VyIGRpcmVjdGx5IG9uIGBkb2N1bWVudGAsIHN1Y2hcbiogYXMgYG9ua2V5cHJlc3NgIGlmIGBkb2N1bWVudGAgaGFzIHRoZSBmb2N1cy5cbiogXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb24gW0V2ZW50XG4qIEhhbmRsaW5nXXtAbGlua3BsYWluICRkZXYtZ3VpZGUva2V5LWNvbmNlcHRzL2V2ZW50LWhhbmRsaW5nLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uU2lnbmFsc1xuKiBAZXh0ZW5kcyBlbnlvLkNvbXBvbmVudFxuKiBAcHVibGljXG4qL1xudmFyIFNpZ25hbHMgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5TaWduYWxzLnByb3RvdHlwZSAqLyB7XG5cblx0bmFtZTogJ2VueW8uU2lnbmFscycsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29tcG9uZW50LFxuXG5cdC8qKlxuXHQqIE5lZWRlZCBiZWNhdXNlIG9mIGVhcmx5IGNhbGxzIHRvIGJpbmQgRE9NIHtAZ2xvc3NhcnkgZXZlbnR9IGxpc3RlbmVyc1xuXHQqIHRvIHRoZSBbZW55by5TaWduYWxzLnNlbmQoKV17QGxpbmsgZW55by5TaWduYWxzI3NlbmR9IGNhbGwuXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRTaWduYWxzLmFkZExpc3RlbmVyKHRoaXMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFNpZ25hbHMucmVtb3ZlTGlzdGVuZXIodGhpcyk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRub3RpZnk6IGZ1bmN0aW9uIChtc2csIGxvYWQpIHtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobXNnLCBsb2FkKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcm90ZWN0ZWRTdGF0aWNzOiB7XG5cdFx0bGlzdGVuZXJzOiBbXSxcblx0XHRhZGRMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0XHR1dGlscy5yZW1vdmUobGlzdGVuZXIsIHRoaXMubGlzdGVuZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhdGljczogXG5cdFx0LyoqIEBsZW5kcyBlbnlvLlNpZ25hbHMucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogQnJvYWRjYXN0cyBhIGdsb2JhbCBtZXNzYWdlIHRvIGJlIGNvbnN1bWVkIGJ5IHN1YnNjcmliZXJzLlxuXHRcdCogXG5cdFx0KiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZDsgdXN1YWxseSB0aGUgbmFtZSBvZiB0aGVcblx0XHQqXHR7QGdsb3NzYXJ5IGV2ZW50fS5cblx0XHQqIEBwYXJhbSB7T2JqZWN0fSBsb2FkIC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBhbnlcblx0XHQqXHRhc3NvY2lhdGVkIGV2ZW50IHByb3BlcnRpZXMgdG8gYmUgYWNjZXNzZWQgYnkgc3Vic2NyaWJlcnMuXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRzZW5kOiBmdW5jdGlvbiAobXNnLCBsb2FkKSB7XG5cdFx0XHR1dGlscy5mb3JFYWNoKHRoaXMubGlzdGVuZXJzLCBmdW5jdGlvbihsKSB7XG5cdFx0XHRcdGwubm90aWZ5KG1zZywgbG9hZCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29tcG9uZW50XCI6MTMsXCIuL2tpbmRcIjo2NixcIi4vdXRpbHNcIjo3NX1dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50JyksXG5cdFNpZ25hbHMgPSByZXF1aXJlKCcuL1NpZ25hbHMnKTtcblxuLyoqXG4qIERlZmF1bHQgb3duZXIgYXNzaWduZWQgdG8gb3duZXJsZXNzIFtVaUNvbXBvbmVudHNde0BsaW5rIGVueW8uVWlDb21wb25lbnR9LFxuKiB0byBhbGxvdyBzdWNoIFVpQ29tcG9uZW50cyB0byBiZSBub3RpZmllZCBvZiBpbXBvcnRhbnQgc3lzdGVtIGV2ZW50cyBsaWtlIHdpbmRvdyByZXNpemUuXG4qXG4qIE5PVEU6IE93bmVybGVzcyBbVWlDb21wb25lbnRzXXtAbGluayBlbnlvLlVpQ29tcG9uZW50fSB3aWxsIG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZCB1bmxlc3MgXG4qIGV4cGxpY2l0bHkgZGVzdHJveWVkLCBhcyB0aGV5IHdpbGwgYmUgcmVmZXJlbmNlZCBieSBgZW55by5tYXN0ZXJgLlxuKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciBtYXN0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBDb21wb25lbnQoe1xuXHRuYW1lOiAnbWFzdGVyJyxcblx0bm90SW5zdGFuY2VPd25lcjogdHJ1ZSxcblx0ZXZlbnRGbGFnczoge3Nob3dpbmdPbmx5OiB0cnVlfSwgLy8gZG9uJ3Qgd2F0ZXJmYWxsIHRoZXNlIGV2ZW50cyBpbnRvIGhpZGRlbiBjb250cm9sc1xuXHRnZXRJZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnJztcblx0fSxcblx0aXNEZXNjZW5kYW50T2Y6IHV0aWxzLm5vcCxcblx0YnViYmxlOiBmdW5jdGlvbiAobm9tLCBldmVudCkge1xuXHRcdC8vZW55by5sb2coJ21hc3RlciBldmVudDogJyArIG5vbSk7XG5cdFx0aWYgKG5vbSA9PSAnb25yZXNpemUnKSB7XG5cdFx0XHQvLyBSZXNpemUgaXMgc3BlY2lhbDsgd2F0ZXJmYWxsIHRoaXMgbWVzc2FnZS5cblx0XHRcdC8vIFRoaXMgd29ya3MgYmVjYXVzZSBtYXN0ZXIgaXMgYSBDb21wb25lbnQsIHNvIGl0IHdhdGVyZmFsbHNcblx0XHRcdC8vIHRvIGl0cyBvd25lZCBDb21wb25lbnRzIChpLmUuLCBtYXN0ZXIgaGFzIG5vIGNoaWxkcmVuKS5cblx0XHRcdG1hc3Rlci53YXRlcmZhbGxEb3duKCdvbnJlc2l6ZScsIHRoaXMuZXZlbnRGbGFncyk7XG5cdFx0XHRtYXN0ZXIud2F0ZXJmYWxsRG93bignb25wb3N0cmVzaXplJywgdGhpcy5ldmVudEZsYWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxsIG90aGVyIHRvcC1sZXZlbCBldmVudHMgYXJlIHNlbnQgb25seSB0byBpbnRlcmVzdGVkIFNpZ25hbFxuXHRcdFx0Ly8gcmVjZWl2ZXJzLlxuXHRcdFx0U2lnbmFscy5zZW5kKG5vbSwgZXZlbnQpO1xuXHRcdH1cblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db21wb25lbnRcIjoxMyxcIi4vU2lnbmFsc1wiOjQ3LFwiLi91dGlsc1wiOjc1fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcblx0bWFzdGVyID0gcmVxdWlyZSgnLi9tYXN0ZXInKTtcblxudmFyXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5VaUNvbXBvbmVudH0gaW1wbGVtZW50cyBhIGNvbnRhaW5lciBzdHJhdGVneSBzdWl0YWJsZSBmb3IgcHJlc2VudGF0aW9uIGxheWVycy5cbiogXG4qIGBVaUNvbXBvbmVudGAgaXRzZWxmIGlzIGFic3RyYWN0LiBDb25jcmV0ZSBbc3Via2luZHNde0BnbG9zc2FyeSBzdWJraW5kfSBpbmNsdWRlXG4qIHtAbGluayBlbnlvLkNvbnRyb2x9IChmb3IgSFRNTC9ET00pIGFuZFxuKiB7QGxpbmsgZW55by5jYW52YXMuQ29udHJvbH0gKGZvciBDYW52YXMgY29udGV4dHMpLlxuKlxuKiBAY2xhc3MgZW55by5VaUNvbXBvbmVudFxuKiBAZXh0ZW5kcyBlbnlvLkNvbXBvbmVudFxuKiBAcHVibGljXG4qL1xudmFyIFVpQ29tcG9uZW50ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlVpQ29tcG9uZW50LnByb3RvdHlwZSAqLyB7XG5cblx0bmFtZTogJ2VueW8uVWlDb21wb25lbnQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbXBvbmVudCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgIGVueW8uVWlDb21wb25lbnQucHJvdG90eXBlICovIHtcblxuXHRcdC8qKiBcblx0XHQqIFRoZSBbVWlDb21wb25lbnRde0BsaW5rIGVueW8uVWlDb21wb25lbnR9IHRoYXQgcGh5c2ljYWxseSBjb250YWlucyB0aGlzIFxuXHRcdCogW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IGluIHRoZSBET00uXG5cdFx0KlxuXHRcdCogQHR5cGUge2VueW8uVWlDb21wb25lbnR9XG5cdFx0KiBAZGVmYXVsdCBudWxsXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRjb250YWluZXI6IG51bGwsXG5cblx0XHQvKipcblx0XHQqIFRoZSBbVWlDb21wb25lbnRde0BsaW5rIGVueW8uVWlDb21wb25lbnR9IHRoYXQgb3ducyB0aGlzXG5cdFx0KiBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gZm9yIHB1cnBvc2VzIG9mIHtAZ2xvc3NhcnkgZXZlbnR9XG5cdFx0KiBwcm9wYWdhdGlvbi5cblx0XHQqXG5cdFx0KiBAdHlwZSB7ZW55by5VaUNvbXBvbmVudH1cblx0XHQqIEBkZWZhdWx0IG51bGxcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHBhcmVudDogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCogVGhlIFtVaUNvbXBvbmVudF17QGxpbmsgZW55by5VaUNvbXBvbmVudH0gdGhhdCB3aWxsIHBoeXNpY2FsbHkgY29udGFpbiBuZXcgaXRlbXMgYWRkZWRcblx0XHQqIGJ5IGNhbGxzIHRvIFtjcmVhdGVDb21wb25lbnQoKV17QGxpbmsgZW55by5VaUNvbXBvbmVudCNjcmVhdGVDb21wb25lbnR9LlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnY2xpZW50J1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y29udHJvbFBhcmVudE5hbWU6ICdjbGllbnQnLFxuXHRcdFxuXHRcdC8qKiBcblx0XHQqIEEgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB1c2VkIHRvIG1hbmFnZSB0aGUgc2l6ZSBhbmQgcGxhY2VtZW50IG9mIGNoaWxkIFxuXHRcdCogW2NvbXBvbmVudHNde0BsaW5rIGVueW8uQ29tcG9uZW50fS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGxheW91dEtpbmQ6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbnJlc2l6ZTogJ2hhbmRsZVJlc2l6ZSdcblx0fSxcblxuXHQvKipcblx0KiBXaGVuIHNldCwgcHJvdmlkZXMgYSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSByZWZlcmVuY2UgdXNlZCB0byBpbmRpY2F0ZSB3aGVyZSBhXG5cdCogbmV3bHktY3JlYXRlZCBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gc2hvdWxkIGJlIGFkZGVkIGluIHRoZVxuXHQqIFtVaUNvbXBvbmVudCdzXXtAbGluayBlbnlvLlVpQ29tcG9uZW50fSBbYXJyYXlde0BnbG9zc2FyeSBBcnJheX0gb2YgY2hpbGRyZW4uIFRoaXMgaXNcblx0KiB0eXBpY2FsbHkgdXNlZCB3aGVuIGNyZWF0aW5nIGNoaWxkcmVuIGR5bmFtaWNhbGx5IChyYXRoZXIgdGhhbiBhdCBkZXNpZ24gdGltZSkuIElmIHNldFxuXHQqIHRvIGBudWxsYCwgdGhlIG5ldyBjb250cm9sIHdpbGwgYmUgYWRkZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXk7IGlmIHNldCB0byBhXG5cdCogc3BlY2lmaWMgZXhpc3RpbmcgY29udHJvbCwgdGhlIG5ldyBjb250cm9sIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWRcblx0KiBjb250cm9sLiBJZiBsZWZ0IGFzIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBhZGQgdGhlIG5ldyBjb250cm9sXG5cdCogYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG5cdCpcblx0KiBAdHlwZSB7ZW55by5Db250cm9sfVxuXHQqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkQmVmb3JlOiB1bmRlZmluZWQsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcm90ZWN0ZWRTdGF0aWNzOiB7XG5cdFx0X3Jlc2l6ZUZsYWdzOiB7c2hvd2luZ09ubHk6IHRydWV9IC8vIGRvbid0IHdhdGVyZmFsbCB0aGVzZSBldmVudHMgaW50byBoaWRkZW4gY29udHJvbHNcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzIHx8IFtdO1xuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gfHwgW107XG5cdFx0XHR0aGlzLmNvbnRhaW5lckNoYW5nZWQoKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5sYXlvdXRLaW5kQ2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIERlc3Ryb3lzIGFsbCBub24tY2hyb21lIGNvbnRyb2xzIChyZWdhcmRsZXNzIG9mIG93bmVyKS5cblx0XHRcdHRoaXMuZGVzdHJveUNsaWVudENvbnRyb2xzKCk7XG5cdFx0XHQvLyBSZW1vdmVzIHVzIGZyb20gb3VyIGNvbnRhaW5lci5cblx0XHRcdHRoaXMuc2V0Q29udGFpbmVyKG51bGwpO1xuXHRcdFx0Ly8gRGVzdHJveXMgY2hyb21lIGNvbnRyb2xzIG93bmVkIGJ5IHRoaXMuXG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1wb3J0UHJvcHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGluUHJvcHMpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCF0aGlzLm93bmVyKSB7XG5cdFx0XHRcdHRoaXMub3duZXIgPSBtYXN0ZXI7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQ3JlYXRlcyBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9IGFzIGRlZmluZWQgYnkgdGhlIFthcnJheXNde0BnbG9zc2FyeSBBcnJheX1cblx0KiBvZiBiYXNlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnR5IFtoYXNoZXNde0BnbG9zc2FyeSBPYmplY3R9LiBUaGUgc3RhbmRhcmQgYW5kIFxuXHQqIGFkZGl0aW9uYWwgcHJvcGVydHkgaGFzaGVzIGFyZSBjb21iaW5lZCBhcyBkZXNjcmliZWQgaW5cblx0KiB7QGxpbmsgZW55by5Db21wb25lbnQjY3JlYXRlQ29tcG9uZW50fS5cblx0KiBcblx0KiBgYGBcblx0KiAvLyBhc2sgZm9vIHRvIGNyZWF0ZSBjb21wb25lbnRzICdiYXInIGFuZCAnem90JywgYnV0IHNldCB0aGUgb3duZXIgb2Zcblx0KiAvLyBib3RoIGNvbXBvbmVudHMgdG8gJ3RoaXMnLlxuXHQqIHRoaXMuJC5mb28uY3JlYXRlQ29tcG9uZW50cyhbXG5cdCpcdHtuYW1lOiAnYmFyJ30sXG5cdCpcdHtuYW1lOiAnem90J31cblx0KiBdLCB7b3duZXI6IHRoaXN9KTtcblx0KiBgYGBcblx0KlxuXHQqIEFzIGltcGxlbWVudGVkLCBbY29udHJvbFBhcmVudE5hbWVde0BsaW5rIGVueW8uVWlDb21wb25lbnQjY29udHJvbFBhcmVudE5hbWV9IG9ubHkgd29ya3Ncblx0KiB0byBpZGVudGlmeSBhbiBvd25lZCBjb250cm9sIGNyZWF0ZWQgdmlhIGBjcmVhdGVDb21wb25lbnRzKClgXG5cdCogKGkuZS4sIHVzdWFsbHkgaW4gb3VyIGBjb21wb25lbnRzYCBibG9jaykuIFRvIGF0dGFjaCBhIGBjb250cm9sUGFyZW50YCB2aWEgb3RoZXIgbWVhbnMsIFxuXHQqIG9uZSBtdXN0IGNhbGwgW2Rpc2NvdmVyQ29udHJvbFBhcmVudCgpXXtAbGluayBlbnlvLlVpQ29tcG9uZW50I2Rpc2NvdmVyQ29udHJvbFBhcmVudH0gb3IgXG5cdCogc2V0IGBjb250cm9sUGFyZW50YCBkaXJlY3RseS5cblx0KiBcblx0KiBXZSBjb3VsZCBjYWxsIGBkaXNjb3ZlckNvbnRyb2xQYXJlbnQoKWAgaW5cblx0KiBbYWRkQ29tcG9uZW50KClde0BsaW5rIGVueW8uQ29tcG9uZW50I2FkZENvbXBvbmVudH0sIGJ1dCB0aGF0IHdvdWxkXG5cdCogY2F1c2UgYSBsb3Qgb2YgdXNlbGVzcyBjaGVja2luZy5cblx0KiBcblx0KiBAcGFyYW0ge09iamVjdFtdfSBwcm9wcyBUaGUgYXJyYXkgb2Yge0BsaW5rIGVueW8uQ29tcG9uZW50fSBkZWZpbml0aW9ucyB0byBiZSBjcmVhdGVkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBleHQgLSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgc3VwcGxpZWQgYXMgZGVmYXVsdHMgZm9yIGVhY2guXG5cdCogQHJldHVybnMge2VueW8uQ29tcG9uZW50W119IFRoZSBhcnJheSBvZiBjb21wb25lbnRzIHRoYXQgd2VyZSBjcmVhdGVkLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdC8vIFxuXHRjcmVhdGVDb21wb25lbnRzOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXN1bHRzID0gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmRpc2NvdmVyQ29udHJvbFBhcmVudCgpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyBhbmQgc2V0cyB0aGUgY3VycmVudCBbY29udHJvbCdzXXtAbGluayBlbnlvLkNvbnRyb2x9IHBhcmVudC5cblx0KlxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0ZGlzY292ZXJDb250cm9sUGFyZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jb250cm9sUGFyZW50ID0gdGhpcy4kW3RoaXMuY29udHJvbFBhcmVudE5hbWVdIHx8IHRoaXMuY29udHJvbFBhcmVudDtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YWRqdXN0Q29tcG9uZW50UHJvcHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGluUHJvcHMpIHtcblx0XHRcdC8vIENvbXBvbmVudHMgd2UgY3JlYXRlIGhhdmUgdXMgYXMgYSBjb250YWluZXIgYnkgZGVmYXVsdC5cblx0XHRcdGluUHJvcHMuY29udGFpbmVyID0gaW5Qcm9wcy5jb250YWluZXIgfHwgdGhpcztcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIENvbnRhaW5tZW50XG5cdCogXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnRhaW5lckNoYW5nZWQ6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ29udHJvbCh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5hZGRDb250cm9sKHRoaXMsIHRoaXMuYWRkQmVmb3JlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUGFyZW50YWdlXG5cdCogXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHBhcmVudENoYW5nZWQ6IGZ1bmN0aW9uIChvbGRQYXJlbnQpIHtcblx0XHRpZiAob2xkUGFyZW50ICYmIG9sZFBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuXHRcdFx0b2xkUGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IGlzIGEgZGVzY2VuZGFudCBvZlxuXHQqIGFub3RoZXIgY29udHJvbC5cblx0KiBcblx0KiBOb3RlOiBPZGRseSwgYSBjb250cm9sIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZi5cblx0KlxuXHQqIEBwYXJhbSB7ZW55by5Db250cm9sfSBhbmNlc3RvciAtIFRoZSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSB3aG9zZSBsaW5lYWdlXG5cdCpcdHdpbGwgYmUgY2hlY2tlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBjb250cm9sIGlzIGEgZGVzY2VuZGFudC5cblx0KiBAcHVibGljXG5cdCovXG5cdGlzRGVzY2VuZGFudE9mOiBmdW5jdGlvbiAoYW5jZXN0b3IpIHtcblx0XHR2YXIgcCA9IHRoaXM7XG5cdFx0d2hpbGUgKHAgJiYgcCE9YW5jZXN0b3IpIHtcblx0XHRcdHAgPSBwLnBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGFuY2VzdG9yICYmIChwID09PSBhbmNlc3Rvcik7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyBhbGwgY29udHJvbHMuXG5cdCpcblx0KiBAcmV0dXJucyB7ZW55by5Db250cm9sW119IEFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBbY29udHJvbHNde0BsaW5rIGVueW8uQ29udHJvbH0uXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRDb250cm9sczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRyb2xzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgYWxsIG5vbi1jaHJvbWUgY29udHJvbHMuXG5cdCpcblx0KiBAcmV0dXJucyB7ZW55by5Db250cm9sW119IEFuIFthcnJheV17QGdsb3NzYXJ5IEFycmF5fSBvZiBbY29udHJvbHNde0BsaW5rIGVueW8uQ29udHJvbH0uXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRDbGllbnRDb250cm9sczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXN1bHRzID0gW107XG5cdFx0Zm9yICh2YXIgaT0wLCBjcz10aGlzLmNvbnRyb2xzLCBjOyAoYz1jc1tpXSk7IGkrKykge1xuXHRcdFx0aWYgKCFjLmlzQ2hyb21lKSB7XG5cdFx0XHRcdHJlc3VsdHMucHVzaChjKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH0sXG5cblx0LyoqXG5cdCogRGVzdHJveXMgXCJjbGllbnQgY29udHJvbHNcIiwgdGhlIHNhbWUgc2V0IG9mIFtjb250cm9sc117QGxpbmsgZW55by5Db250cm9sfSByZXR1cm5lZCBieSBcblx0KiBbZ2V0Q2xpZW50Q29udHJvbHMoKV17QGxpbmsgZW55by5VaUNvbXBvbmVudCNnZXRDbGllbnRDb250cm9sc30uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGRlc3Ryb3lDbGllbnRDb250cm9sczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjJCA9IHRoaXMuZ2V0Q2xpZW50Q29udHJvbHMoKTtcblx0XHRmb3IgKHZhciBpPTAsIGM7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRjLmRlc3Ryb3koKTtcblx0XHR9XG5cdH0sXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY3RsLCBiZWZvcmUpIHtcblx0XHQvLyBDYWxsZWQgdG8gYWRkIGFuIGFscmVhZHkgY3JlYXRlZCBjb250cm9sIHRvIHRoZSBvYmplY3QncyBjb250cm9sIGxpc3QuIEl0IGlzXG5cdFx0Ly8gbm90IHVzZWQgdG8gY3JlYXRlIGNvbnRyb2xzIGFuZCBzaG91bGQgbGlrZWx5IG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdFx0Ly8gSXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gZGV0ZWN0IHdoZW4gY29udHJvbHMgYXJlIGFkZGVkLlxuXHRcdGlmIChiZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIGlkeCA9IChiZWZvcmUgPT09IG51bGwpID8gMCA6IHRoaXMuaW5kZXhPZkNvbnRyb2woYmVmb3JlKTtcblx0XHRcdHRoaXMuY29udHJvbHMuc3BsaWNlKGlkeCwgMCwgY3RsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb250cm9scy5wdXNoKGN0bCk7XG5cdFx0fVxuXHRcdC8vIFdoZW4gd2UgYWRkIGEgQ29udHJvbCwgd2UgYWxzbyBlc3RhYmxpc2ggYSBwYXJlbnQuXG5cdFx0dGhpcy5hZGRDaGlsZChjdGwsIGJlZm9yZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGN0bCkge1xuXHRcdC8vIENhbGxlZCB0byByZW1vdmUgYSBjb250cm9sIGZyb20gdGhlIG9iamVjdCdzIGNvbnRyb2wgbGlzdC4gQXMgd2l0aCBhZGRDb250cm9sIGl0XG5cdFx0Ly8gY2FuIGJlIG92ZXJyaWRkZW4gdG8gZGV0ZWN0IHdoZW4gY29udHJvbHMgYXJlIHJlbW92ZWQuXG5cdFx0Ly8gV2hlbiB3ZSByZW1vdmUgYSBDb250cm9sLCB3ZSBhbHNvIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQuXG5cdFx0Y3RsLnNldFBhcmVudChudWxsKTtcblx0XHRyZXR1cm4gdXRpbHMucmVtb3ZlKGN0bCwgdGhpcy5jb250cm9scyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5kZXhPZkNvbnRyb2w6IGZ1bmN0aW9uIChjdGwpIHtcblx0XHRyZXR1cm4gdXRpbHMuaW5kZXhPZihjdGwsIHRoaXMuY29udHJvbHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluZGV4T2ZDbGllbnRDb250cm9sOiBmdW5jdGlvbiAoY3RsKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmluZGV4T2YoY3RsLCB0aGlzLmdldENsaWVudENvbnRyb2xzKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluZGV4SW5Db250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuaW5kZXhPZkNvbnRyb2wodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xpZW50SW5kZXhJbkNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lci5pbmRleE9mQ2xpZW50Q29udHJvbCh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb250cm9sQXRJbmRleDogZnVuY3Rpb24gKGlkeCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRyb2xzW2lkeF07XG5cdH0sXG5cdFxuXHQvKipcblx0KiBDaGlsZHJlblxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGJlZm9yZSkge1xuXHRcdC8vIGlmIGJlZm9yZSBpcyB1bmRlZmluZWQsIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBjaGlsZCBsaXN0LlxuXHRcdC8vIElmIGl0J3MgbnVsbCwgYWRkIHRvIGZyb250IG9mIGxpc3QsIG90aGVyd2lzZSBhZGQgYmVmb3JlIHRoZVxuXHRcdC8vIHNwZWNpZmllZCBjb250cm9sLlxuXHRcdC8vXG5cdFx0Ly8gYWxsb3cgZGVsZWdhdGluZyB0aGUgY2hpbGQgdG8gYSBkaWZmZXJlbnQgY29udGFpbmVyXG5cdFx0aWYgKHRoaXMuY29udHJvbFBhcmVudCAvKiYmICFjaGlsZC5pc0Nocm9tZSovKSB7XG5cdFx0XHQvLyB0aGlzLmNvbnRyb2xQYXJlbnQgbWlnaHQgaGF2ZSBhIGNvbnRyb2xQYXJlbnQsIGFuZCBzbyBvbjsgc2VlayB0aGUgdWx0aW1hdGUgcGFyZW50XG5cdFx0XHR0aGlzLmNvbnRyb2xQYXJlbnQuYWRkQ2hpbGQoY2hpbGQsIGJlZm9yZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE5PVEU6IGFkZENoaWxkIGRyaXZlcyBzZXRQYXJlbnQuXG5cdFx0XHQvLyBJdCdzIHRoZSBvcHBvc2l0ZSBmb3Igc2V0Q29udGFpbmVyLCB3aGVyZSBjb250YWluZXJDaGFuZ2VkIChpbiBDb250YWluYWJsZSlcblx0XHRcdC8vIGRyaXZlcyBhZGRDb250cm9sLlxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgd2F5ICdwYXJlbnQnIGlzIGRlcml2ZWQgZnJvbSAnY29udGFpbmVyJywgdGhpcyBkaWZmZXJlbmNlIGlzXG5cdFx0XHQvLyBoZWxwZnVsIGZvciBpbXBsZW1lbnRpbmcgY29udHJvbFBhcmVudC5cblx0XHRcdC8vIEJ5IHRoZSBzYW1lIHRva2VuLCBzaW5jZSAncGFyZW50JyBpcyBkZXJpdmVkIGZyb20gJ2NvbnRhaW5lcicsIHNldFBhcmVudCBpc1xuXHRcdFx0Ly8gbm90IGludGVuZGVkIHRvIGJlIGNhbGxlZCBieSBjbGllbnQgY29kZS4gVGhlcmVmb3JlLCB0aGUgbGFjayBvZiBwYXJhbGxlbGlzbVxuXHRcdFx0Ly8gc2hvdWxkIGJlIHByaXZhdGUgdG8gdGhpcyBpbXBsZW1lbnRhdGlvbi5cblx0XHRcdC8vIFNldCB0aGUgY2hpbGQncyBwYXJlbnQgcHJvcGVydHkgdG8gdGhpc1xuXHRcdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuXHRcdFx0Ly8gdHJhY2sgaW4gY2hpbGRyZW4gYXJyYXlcblx0XHRcdGlmIChiZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgaWR4ID0gKGJlZm9yZSA9PT0gbnVsbCkgPyAwIDogdGhpcy5pbmRleE9mQ2hpbGQoYmVmb3JlKTtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0cmV0dXJuIHV0aWxzLnJlbW92ZShjaGlsZCwgdGhpcy5jaGlsZHJlbik7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5kZXhPZkNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRyZXR1cm4gdXRpbHMuaW5kZXhPZihjaGlsZCwgdGhpcy5jaGlsZHJlbik7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGF5b3V0S2luZENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5sYXlvdXQpIHtcblx0XHRcdHRoaXMubGF5b3V0LmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0dGhpcy5sYXlvdXQgPSBraW5kLmNyZWF0ZUZyb21LaW5kKHRoaXMubGF5b3V0S2luZCwgdGhpcyk7XG5cdFx0aWYgKHRoaXMuZ2VuZXJhdGVkKSB7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmbG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMubGF5b3V0KSB7XG5cdFx0XHR0aGlzLmxheW91dC5mbG93KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENBVkVBVDogY3VycmVudGx5IHdlIHVzZSB0aGUgZW50cnkgcG9pbnQgZm9yIGJvdGggcG9zdC1yZW5kZXIgbGF5b3V0IHdvcmsgKmFuZCogXG5cdCogcG9zdC1yZXNpemUgbGF5b3V0IHdvcmsuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVmbG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMubGF5b3V0KSB7XG5cdFx0XHR0aGlzLmxheW91dC5yZWZsb3coKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsbCBhZnRlciB0aGlzIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IGhhcyBiZWVuIHJlc2l6ZWQgdG8gYWxsb3cgaXQgdG8gcHJvY2VzcyB0aGUgXG5cdCogc2l6ZSBjaGFuZ2UuIFRvIHJlc3BvbmQgdG8gYSByZXNpemUsIG92ZXJyaWRlIGBoYW5kbGVSZXNpemUoKWAgaW5zdGVhZC4gQWN0cyBhcyBzeW50YWN0aWMgXG5cdCogc3VnYXIgZm9yIGB3YXRlcmZhbGwoJ29ucmVzaXplJylgLlxuXHQqIFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy53YXRlcmZhbGwoJ29ucmVzaXplJywgVWlDb21wb25lbnQuX3Jlc2l6ZUZsYWdzKTtcblx0XHR0aGlzLndhdGVyZmFsbCgnb25wb3N0cmVzaXplJywgVWlDb21wb25lbnQuX3Jlc2l6ZUZsYWdzKTtcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZVJlc2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEZJWE1FOiBvbmNlIHdlIGFyZSBpbiB0aGUgYnVzaW5lc3Mgb2YgcmVmbG93aW5nIGxheW91dHMgb24gcmVzaXplLCB0aGVuIHdlIGhhdmUgYW5cblx0XHQvLyBpbnNpZGUvb3V0c2lkZSBwcm9ibGVtOiBzb21lIHNjZW5hcmlvcyB3aWxsIG5lZWQgdG8gcmVmbG93IGJlZm9yZSBjaGlsZFxuXHRcdC8vIGNvbnRyb2xzIHJlZmxvdywgYW5kIHNvbWUgd2lsbCBuZWVkIHRvIHJlZmxvdyBhZnRlci4gRXZlbiBtb3JlIGNvbXBsZXggc2NlbmFyaW9zXG5cdFx0Ly8gaGF2ZSBjaXJjdWxhciBkZXBlbmRlbmNpZXMsIGFuZCBjYW4gcmVxdWlyZSBtdWx0aXBsZSBwYXNzZXMgb3Igb3RoZXIgcmVzb2x1dGlvbi5cblx0XHQvLyBXaGVuIHdlIGNhbiByZWx5IG9uIENTUyB0byBtYW5hZ2UgcmVmbG93cyB3ZSBkbyBub3QgaGF2ZSB0aGVzZSBwcm9ibGVtcy5cblx0XHR0aGlzLnJlZmxvdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNlbmRzIGEgbWVzc2FnZSB0byBhbGwgb2YgbXkgZGVzY2VuZGFudHMsIGJ1dCBub3QgbXlzZWxmLiBZb3UgY2FuIHN0b3AgYVxuXHQqIFt3YXRlcmZhbGxde0BsaW5rIGVueW8uQ29tcG9uZW50I3dhdGVyZmFsbH0gaW50byBbY29tcG9uZW50c117QGxpbmsgZW55by5Db21wb25lbnR9XG5cdCogb3duZWQgYnkgYSByZWNlaXZpbmcgW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gYnkgcmV0dXJuaW5nIGEgdHJ1dGh5IHZhbHVlIGZyb20gdGhlXG5cdCoge0BnbG9zc2FyeSBldmVudH0gW2hhbmRsZXJde0BsaW5rIGVueW8uQ29tcG9uZW50fkV2ZW50SGFuZGxlcn0uXG5cdCogXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5vbSAtIFRoZSBuYW1lIG9mIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cblx0KiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSAtIFRoZSBldmVudCBvYmplY3QgdG8gcGFzcyBhbG9uZy5cblx0KiBAcGFyYW0ge2VueW8uQ29tcG9uZW50fSBbc2VuZGVyPXRoaXNdIC0gVGhlIGV2ZW50J3Mgb3JpZ2luYXRvci5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR3YXRlcmZhbGxEb3duOiBmdW5jdGlvbiAobm9tLCBldmVudCwgc2VuZGVyKSB7XG5cdFx0ZXZlbnQgPSBldmVudCB8fCB7fTtcblx0XHQvLyBOb3RlOiBDb250cm9scyB3aWxsIGdlbmVyYWxseSBiZSBib3RoIGluIGEgJCBoYXNoIGFuZCBhIGNoaWxkIGxpc3Qgc29tZXdoZXJlLlxuXHRcdC8vIEF0dGVtcHQgdG8gYXZvaWQgZHVwbGljYXRlZCBtZXNzYWdlcyBieSBzZW5kaW5nIG9ubHkgdG8gY29tcG9uZW50cyB0aGF0IGFyZSBub3Rcblx0XHQvLyBVaUNvbXBvbmVudCwgYXMgdGhvc2UgY29tcG9uZW50cyBhcmUgZ3VhcmFudGVlZCBub3QgdG8gYmUgaW4gYSBjaGlsZCBsaXN0LlxuXHRcdC8vIE1heSBjYXVzZSBhIHByb2JsZW0gaWYgdGhlcmUgaXMgYSBzY2VuYXJpbyB3aGVyZSBhIFVpQ29tcG9uZW50IG93bnMgYSBwdXJlXG5cdFx0Ly8gQ29tcG9uZW50IHRoYXQgaW4gdHVybiBvd25zIENvbnRyb2xzLlxuXHRcdC8vXG5cdFx0Ly8gd2F0ZXJmYWxsIHRvIGFsbCBwdXJlIGNvbXBvbmVudHNcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuJCkge1xuXHRcdFx0aWYgKCEodGhpcy4kW25dIGluc3RhbmNlb2YgVWlDb21wb25lbnQpKSB7XG5cdFx0XHRcdHRoaXMuJFtuXS53YXRlcmZhbGwobm9tLCBldmVudCwgc2VuZGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gd2F0ZXJmYWxsIHRvIG15IGNoaWxkcmVuXG5cdFx0Zm9yICh2YXIgaT0wLCBjcz10aGlzLmNoaWxkcmVuLCBjOyAoYz1jc1tpXSk7IGkrKykge1xuXHRcdFx0Ly8gRG8gbm90IHNlbmQge3Nob3dpbmdPbmx5OiB0cnVlfSBldmVudHMgdG8gaGlkZGVuIGNvbnRyb2xzLiBUaGlzIGZsYWcgaXMgc2V0IGZvciByZXNpemUgZXZlbnRzXG5cdFx0XHQvLyB3aGljaCBhcmUgYnJvYWRjYXN0IGZyb20gd2l0aGluIHRoZSBmcmFtZXdvcmsuIFRoaXMgc2F2ZXMgYSAqbG90KiBvZiB1bm5lY2Vzc2FyeSBsYXlvdXQuXG5cdFx0XHQvLyBUT0RPOiBNYXliZSByZW1lbWJlciB0aGF0IHdlIGRpZCB0aGlzLCBhbmQgcmUtc2VuZCB0aG9zZSBtZXNzYWdlcyBvbiBzZXRTaG93aW5nKHRydWUpP1xuXHRcdFx0Ly8gTm8gb2J2aW91cyBwcm9ibGVtcyB3aXRoIGl0IGFzLWlzLCB0aG91Z2hcblx0XHRcdGlmIChjLnNob3dpbmcgfHwgIShldmVudCAmJiBldmVudC5zaG93aW5nT25seSkpIHtcblx0XHRcdFx0Yy53YXRlcmZhbGwobm9tLCBldmVudCwgc2VuZGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0QnViYmxlVGFyZ2V0OiBmdW5jdGlvbiAobm9tLCBldmVudCkge1xuXHRcdGlmIChldmVudC5kZWxlZ2F0ZSkgcmV0dXJuIHRoaXMub3duZXI7XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0aGlzLmJ1YmJsZVRhcmdldFxuXHRcdFx0XHR8fCAodGhpcy5jYWNoZWRCdWJibGUgJiYgdGhpcy5jYWNoZWRCdWJibGVUYXJnZXRbbm9tXSlcblx0XHRcdFx0fHwgdGhpcy5wYXJlbnRcblx0XHRcdFx0fHwgdGhpcy5vd25lclxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29tcG9uZW50XCI6MTMsXCIuL2tpbmRcIjo2NixcIi4vbWFzdGVyXCI6NjgsXCIuL3V0aWxzXCI6NzV9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpLFxuXHRtYXN0ZXIgPSByZXF1aXJlKCcuL21hc3RlcicpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyk7XG5cbnZhclxuXHREb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4vKipcbiAqIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGRlc2NyaWJpbmcgdGhlIHRoZSBsYXN0IGtub3duIGNvb3JkaW5hdGVzIG9mIHRoZSBjdXJzb3Igb3JcbiAqIHVzZXItaW50ZXJhY3Rpb24gcG9pbnQgaW4gdG91Y2ggZW52aXJvbm1lbnRzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IGVueW8uZGlzcGF0Y2hlcn5DdXJzb3JDb29yZGluYXRlc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGNsaWVudFggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHdpdGhpbiB0aGUgYXBwbGljYXRpb24ncyBjbGllbnQgYXJlYS5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjbGllbnRZIC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgd2l0aGluIHRoZSBhcHBsaWNhdGlvbidzIGNsaWVudCBhcmVhLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHBhZ2VYIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgaW5jbHVkaW5nIGFueVxuICogICBzY3JvbGwgb2Zmc2V0LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHBhZ2VZIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgaW5jbHVkaW5nIGFueVxuICogICBzY3JvbGwgb2Zmc2V0LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcmVlblggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gdGhlIHNjcmVlbiwgbm90IGluY2x1ZGluZ1xuICogICBhbnkgc2Nyb2xsIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JlZW5ZIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4sIG5vdCBpbmNsdWRpbmdcbiAqICAgYW55IHNjcm9sbCBvZmZzZXQuXG4gKi9cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgZGlzcGF0Y2hlciA9IG1vZHVsZS5leHBvcnRzID0gZGlzcGF0Y2hlciA9XG5cdC8qKiBAbGVuZHMgZW55by5kaXNwYXRjaGVyLnByb3RvdHlwZSAqLyB7XG5cblx0JDoge30sXG5cblx0LyoqXG5cdCogVGhlc2UgZXZlbnRzIGNvbWUgZnJvbSBkb2N1bWVudFxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiBbXCJtb3VzZWRvd25cIiwgXCJtb3VzZXVwXCIsIFwibW91c2VvdmVyXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXdoZWVsXCIsXG5cdFx0XCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwiY2hhbmdlXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwia2V5cHJlc3NcIiwgXCJpbnB1dFwiLFxuXHRcdFwicGFzdGVcIiwgXCJjb3B5XCIsIFwiY3V0XCIsIFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25lbmRcIiwgXCJ3ZWJraXRBbmltYXRpb25FbmRcIiwgXCJhbmltYXRpb25lbmRcIixcblx0XHRcIndlYmtpdEFuaW1hdGlvblN0YXJ0XCIsIFwiYW5pbWF0aW9uc3RhcnRcIiwgXCJ3ZWJraXRBbmltYXRpb25JdGVyYXRpb25cIiwgXCJhbmltYXRpb25pdGVyYXRpb25cIl0sXG5cblx0LyoqXG5cdCogVGhlc2UgZXZlbnRzIGNvbWUgZnJvbSB3aW5kb3dcblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHdpbmRvd0V2ZW50czogW1wicmVzaXplXCIsIFwibG9hZFwiLCBcInVubG9hZFwiLCBcIm1lc3NhZ2VcIiwgXCJoYXNoY2hhbmdlXCIsIFwicG9wc3RhdGVcIiwgXCJmb2N1c1wiLCBcImJsdXJcIl0sXG5cblx0LyoqXG5cdCogRmVhdHVyZSBwbHVnaW5zIChha2EgZmlsdGVycylcblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZlYXR1cmVzOiBbXSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25uZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZCA9IGRpc3BhdGNoZXIsIGksIG47XG5cdFx0Zm9yIChpPTA7IChuPWQuZXZlbnRzW2ldKTsgaSsrKSB7XG5cdFx0XHRkLmxpc3Rlbihkb2N1bWVudCwgbik7XG5cdFx0fVxuXHRcdGZvciAoaT0wOyAobj1kLndpbmRvd0V2ZW50c1tpXSk7IGkrKykge1xuXHRcdFx0Ly8gQ2hyb21lIFBhY2thZ2VkIEFwcHMgZG9uJ3QgbGlrZSBcInVubG9hZFwiXG5cdFx0XHRpZihuID09PSBcInVubG9hZFwiICYmXG5cdFx0XHRcdCh0eXBlb2YgZ2xvYmFsLmNocm9tZSA9PT0gXCJvYmplY3RcIikgJiZcblx0XHRcdFx0Z2xvYmFsLmNocm9tZS5hcHApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGQubGlzdGVuKHdpbmRvdywgbik7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGxpc3RlbjogZnVuY3Rpb24oaW5MaXN0ZW5lciwgaW5FdmVudE5hbWUsIGluSGFuZGxlcikge1xuXHRcdGlmIChpbkxpc3RlbmVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHRoaXMubGlzdGVuID0gZnVuY3Rpb24oaW5MaXN0ZW5lciwgaW5FdmVudE5hbWUsIGluSGFuZGxlcikge1xuXHRcdFx0XHRpbkxpc3RlbmVyLmFkZEV2ZW50TGlzdGVuZXIoaW5FdmVudE5hbWUsIGluSGFuZGxlciB8fCBkaXNwYXRjaCwgZmFsc2UpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9lbnlvLmxvZyhcIklFOCBDT01QQVQ6IHVzaW5nICdhdHRhY2hFdmVudCdcIik7XG5cdFx0XHR0aGlzLmxpc3RlbiA9IGZ1bmN0aW9uKGluTGlzdGVuZXIsIGluRXZlbnQsIGluSGFuZGxlcikge1xuXHRcdFx0XHRpbkxpc3RlbmVyLmF0dGFjaEV2ZW50KFwib25cIiArIGluRXZlbnQsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudDtcblx0XHRcdFx0XHRpZiAoIWUucHJldmVudERlZmF1bHQpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQgPSB0aGlzLmllUHJldmVudERlZmF1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAoaW5IYW5kbGVyIHx8IGRpc3BhdGNoKShlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLmxpc3Rlbihpbkxpc3RlbmVyLCBpbkV2ZW50TmFtZSwgaW5IYW5kbGVyKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihpbkxpc3RlbmVyLCBpbkV2ZW50TmFtZSwgaW5IYW5kbGVyKSB7XG5cdFx0aWYgKGluTGlzdGVuZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24oaW5MaXN0ZW5lciwgaW5FdmVudE5hbWUsIGluSGFuZGxlcikge1xuXHRcdFx0XHRpbkxpc3RlbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoaW5FdmVudE5hbWUsIGluSGFuZGxlciB8fCBkaXNwYXRjaCwgZmFsc2UpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9lbnlvLmxvZyhcIklFOCBDT01QQVQ6IHVzaW5nICdkZXRhY2hFdmVudCdcIik7XG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbihpbkxpc3RlbmVyLCBpbkV2ZW50LCBpbkhhbmRsZXIpIHtcblx0XHRcdFx0aW5MaXN0ZW5lci5kZXRhY2hFdmVudChcIm9uXCIgKyBpbkV2ZW50LCBpbkhhbmRsZXIgfHwgZGlzcGF0Y2gpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nKGluTGlzdGVuZXIsIGluRXZlbnROYW1lLCBpbkhhbmRsZXIpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEZpcmVzIGFuIGV2ZW50IGZvciBFbnlvIHRvIGxpc3RlbiBmb3IuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkaXNwYXRjaDogZnVuY3Rpb24oZSkge1xuXHRcdC8vIEZpbmQgdGhlIGNvbnRyb2wgd2hvIG1hcHMgdG8gZS50YXJnZXQsIG9yIHRoZSBmaXJzdCBjb250cm9sIHRoYXQgbWFwcyB0byBhbiBhbmNlc3RvciBvZiBlLnRhcmdldC5cblx0XHR2YXIgYyA9IHRoaXMuZmluZERpc3BhdGNoVGFyZ2V0KGUudGFyZ2V0KSB8fCB0aGlzLmZpbmREZWZhdWx0VGFyZ2V0KCk7XG5cdFx0Ly8gQ2FjaGUgdGhlIG9yaWdpbmFsIHRhcmdldFxuXHRcdGUuZGlzcGF0Y2hUYXJnZXQgPSBjO1xuXHRcdC8vIHN1cHBvcnQgcGx1Z2dhYmxlIGZlYXR1cmVzIHJldHVybiB0cnVlIHRvIGFib3J0IGltbWVkaWF0ZWx5IG9yIHNldCBlLnByZXZlbnREaXNwYXRjaCB0byBhdm9pZCBwcm9jZXNzaW5nLlxuXHRcdGZvciAodmFyIGk9MCwgZm47IChmbj10aGlzLmZlYXR1cmVzW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAoZm4uY2FsbCh0aGlzLCBlKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjICYmICFlLnByZXZlbnREaXNwYXRjaCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hCdWJibGUoZSwgYyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFRha2VzIGFuIGV2ZW50IHRhcmdldCBhbmQgZmluZHMgdGhlIGNvcnJlc3BvbmRpbmcgRW55byBjb250cm9sLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZmluZERpc3BhdGNoVGFyZ2V0OiBmdW5jdGlvbihpbk5vZGUpIHtcblx0XHR2YXIgdCwgbiA9IGluTm9kZTtcblx0XHQvLyBGSVhNRTogTW96aWxsYTogdHJ5L2NhdGNoIGlzIGhlcmUgdG8gc3F1ZWxjaCBcIlBlcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSB4eHggZnJvbSBhIG5vbi1jaHJvbWUgY29udGV4dFwiXG5cdFx0Ly8gd2hpY2ggYXBwZWFycyB0byBoYXBwZW4gZm9yIHNjcm9sbGJhciBub2RlcyBpbiBwYXJ0aWN1bGFyLiBJdCdzIHVuY2xlYXIgd2h5IHRob3NlIG5vZGVzIGFyZSB2YWxpZCB0YXJnZXRzIGlmXG5cdFx0Ly8gaXQgaXMgaWxsZWdhbCB0byBpbnRlcnJvZ2F0ZSB0aGVtLiBXb3VsZCBsaWtlIHRvIHRyYXAgdGhlIGJhZCBub2RlcyBleHBsaWNpdGx5IHJhdGhlciB0aGFuIHVzaW5nIGFuIGV4Y2VwdGlvbiBibG9jay5cblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKG4pIHtcblx0XHRcdFx0aWYgKCh0ID0gdGhpcy4kW24uaWRdKSkge1xuXHRcdFx0XHRcdC8vIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG5vZGVzIHdpdGggdGhpcyBpZCwgdGhlIHJlbGV2YW50IG5vZGUgZm9yIHRoaXMgZXZlbnQgaXMgblxuXHRcdFx0XHRcdC8vIHdlIGRvbid0IHB1c2ggdGhpcyBkaXJlY3RseSB0byB0Lm5vZGUgYmVjYXVzZSBzb21ldGltZXMgd2UgYXJlIGp1c3QgYXNraW5nIHdoYXRcblx0XHRcdFx0XHQvLyB0aGUgdGFyZ2V0ICd3b3VsZCBiZScgKGFrYSwgY2FsbGluZyBmaW5kRGlzcGF0Y2hUYXJnZXQgZnJvbSBoYW5kbGVNb3VzZU92ZXJPdXQpXG5cdFx0XHRcdFx0dC5ldmVudE5vZGUgPSBuO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4gPSBuLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCh4KSB7XG5cdFx0XHRsb2dnZXIubG9nKHgsIG4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdDtcblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBkZWZhdWx0IEVueW8gY29udHJvbCBmb3IgZXZlbnRzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZmluZERlZmF1bHRUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBtYXN0ZXI7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzcGF0Y2hCdWJibGU6IGZ1bmN0aW9uKGUsIGMpIHtcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcblx0XHR0eXBlID0gZS5jdXN0b21FdmVudCA/IHR5cGUgOiBcIm9uXCIgKyB0eXBlO1xuXHRcdHJldHVybiBjLmJ1YmJsZSh0eXBlLCBlLCBjKTtcblx0fVxufTtcblxuLyoqXG4qIENhbGxlZCBpbiB0aGUgY29udGV4dCBvZiBhbiBldmVudC5cbipcbiogQHByaXZhdGVcbiovXG5kaXNwYXRjaGVyLmllUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHR0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdH1cblx0Y2F0Y2goZSkge1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gZGlzcGF0Y2ggKGluRXZlbnQpIHtcblx0cmV0dXJuIGRpc3BhdGNoZXIuZGlzcGF0Y2goaW5FdmVudCk7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5kaXNwYXRjaGVyLmJ1YmJsZSA9IGZ1bmN0aW9uKGluRXZlbnQpIHtcblx0Ly8gJ3x8IHdpbmRvdy5ldmVudCcgY2xhdXNlIG5lZWRlZCBmb3IgSUU4XG5cdHZhciBlID0gaW5FdmVudCB8fCBnbG9iYWwuZXZlbnQ7XG5cdGlmIChlKSB7XG5cdFx0Ly8gV2UgZGVwZW5kIG9uIGUudGFyZ2V0IGV4aXN0aW5nIGZvciBldmVudCB0cmFja2luZyBhbmQgZGlzcGF0Y2hpbmcuXG5cdFx0aWYgKCFlLnRhcmdldCkge1xuXHRcdFx0ZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7XG5cdFx0fVxuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH1cbn07XG5cbi8vIFRoaXMgc3RyaW5nIGlzIHNldCBvbiBldmVudCBoYW5kbGVycyBhdHRyaWJ1dGVzIGZvciBET00gZWxlbWVudHMgdGhhdFxuLy8gZG9uJ3Qgbm9ybWFsbHkgYnViYmxlIChsaWtlIG9uc2Nyb2xsKSBzbyB0aGF0IHRoZXkgY2FuIHBhcnRpY2lwYXRlIGluIHRoZVxuLy8gRW55byBldmVudCBzeXN0ZW0uXG5kaXNwYXRjaGVyLmJ1YmJsZXIgPSBcImVueW8uYnViYmxlKGFyZ3VtZW50c1swXSlcIjtcblxuLy8gVGhlIGNvZGUgYmVsb3cgaGVscHMgbWFrZSBFbnlvIGNvbXBhdGlibGUgd2l0aCBHb29nbGUgUGFja2FnZWQgQXBwc1xuLy8gQ29udGVudCBTZWN1cml0eSBQb2xpY3koaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvY29udGVudFNlY3VyaXR5UG9saWN5Lmh0bWwpLFxuLy8gd2hpY2gsIGFtb25nIG90aGVyIHRoaW5ncywgZm9yYmlkcyB0aGUgdXNlIG9mIGlubGluZSBzY3JpcHRzLlxuLy8gV2UgcmVwbGFjZSBvbmxpbmUgc2NyaXB0aW5nIHdpdGggZXF1aXZhbGVudCBtZWFucywgbGVhdmluZyBlbnlvLmJ1YmJsZXJcbi8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgYnViYmxlVXAgPSBmdW5jdGlvbigpIHtcblx0XHRkaXNwYXRjaGVyLmJ1YmJsZShhcmd1bWVudHNbMF0pO1xuXHR9O1xuXG5cdC8qKlxuXHQqIE1ha2VzIGdpdmVuIGV2ZW50cyBidWJibGUgb24gYSBzcGVjaWZpZWQgRW55byBjb250cm9sLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzcGF0Y2hlci5tYWtlQnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxuXHRcdFx0Y29udHJvbCA9IGFyZ3Muc2hpZnQoKTtcblxuXHRcdGlmKCh0eXBlb2YgY29udHJvbCA9PT0gXCJvYmplY3RcIikgJiYgKHR5cGVvZiBjb250cm9sLmhhc05vZGUgPT09IFwiZnVuY3Rpb25cIikpIHtcblx0XHRcdHV0aWxzLmZvckVhY2goYXJncywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdFx0XHRkaXNwYXRjaGVyLmxpc3Rlbih0aGlzLm5vZGUsIGV2ZW50LCBidWJibGVVcCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGNvbnRyb2wpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0KiBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5pbmcgYW5kIGJ1YmJsaW5nIGluaXRpYXRlZCBieVxuXHQqIFtlbnlvLm1ha2VCdWJibGUoKV17QGxpbmsgZW55by5tYWtlQnViYmxlfSBvbiBhIHNwZWNpZmljIGNvbnRyb2wuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkaXNwYXRjaGVyLnVubWFrZUJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcblx0XHRcdGNvbnRyb2wgPSBhcmdzLnNoaWZ0KCk7XG5cblx0XHRpZigodHlwZW9mIGNvbnRyb2wgPT09IFwib2JqZWN0XCIpICYmICh0eXBlb2YgY29udHJvbC5oYXNOb2RlID09PSBcImZ1bmN0aW9uXCIpKSB7XG5cdFx0XHR1dGlscy5mb3JFYWNoKGFyZ3MsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmKHRoaXMuaGFzTm9kZSgpKSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hlci5zdG9wTGlzdGVuaW5nKHRoaXMubm9kZSwgZXZlbnQsIGJ1YmJsZVVwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgY29udHJvbCk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuLy8gRklYTUU6IHdlIG5lZWQgdG8gY3JlYXRlIGFuZCBpbml0aWFsaXplIGRpc3BhdGNoZXIgc29tZXBsYWNlIGVsc2UgdG8gYWxsb3cgb3ZlcnJpZGVzXG5Eb20ucmVxdWlyZXNXaW5kb3coZGlzcGF0Y2hlci5jb25uZWN0KTtcblxuLyoqXG4qIEdlbmVyYXRlcyBhIHRhcHBlZCBldmVudCBmb3IgYSByYXctY2xpY2sgZXZlbnQuXG4qXG4qIEBwcml2YXRlXG4qL1xuZGlzcGF0Y2hlci5mZWF0dXJlcy5wdXNoKFxuXHRmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChcImNsaWNrXCIgPT09IGUudHlwZSkge1xuXHRcdFx0aWYgKGUuY2xpZW50WCA9PT0gMCAmJiBlLmNsaWVudFkgPT09IDApIHtcblx0XHRcdFx0Ly8gdGhpcyBhbGxvd3MgdGhlIGNsaWNrIHRvIGRpc3BhdGNoIGFzIHdlbGxcblx0XHRcdFx0Ly8gYnV0IG5vdGUgdGhlIHRhcCBldmVudCB3aWxsIGZpcmUgZmlyc3Rcblx0XHRcdFx0dmFyIGNwID0gdXRpbHMuY2xvbmUoZSk7XG5cdFx0XHRcdGNwLnR5cGUgPSBcInRhcFwiO1xuXHRcdFx0XHRjcC5wcmV2ZW50RGVmYXVsdCA9IHV0aWxzLm5vcDtcblx0XHRcdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChjcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG4pO1xuXG4vKipcbiogSW5zdGVhZCBvZiBoYXZpbmcgbXVsdGlwbGUgYGZlYXR1cmVzYCBwdXNoZWQgYW5kIGhhbmRsZWQgaW4gc2VwYXJhdGUgbWV0aG9kc1xuKiBmb3IgdGhlc2UgZXZlbnRzLCB3ZSBoYW5kbGUgdGhlbSB1bmlmb3JtbHkgaGVyZSB0byBleHBvc2UgdGhlIGxhc3Qga25vd25cbiogaW50ZXJhY3Rpb24gY29vcmRpbmF0ZXMgYXMgYWNjdXJhdGVseSBhcyBwb3NzaWJsZS5cbipcbiogQHByaXZhdGVcbiovXG52YXIgX3h5ID0ge307XG5kaXNwYXRjaGVyLmZlYXR1cmVzLnB1c2goXG5cdGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKFxuXHRcdFx0KGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiKSAgfHxcblx0XHRcdChlLnR5cGUgPT0gXCJ0YXBcIikgICAgICAgIHx8XG5cdFx0XHQoZS50eXBlID09IFwiY2xpY2tcIikgICAgICB8fFxuXHRcdFx0KGUudHlwZSA9PSBcInRvdWNobW92ZVwiKVxuXHRcdCkge1xuXHRcdFx0X3h5LmNsaWVudFggPSBlLmNsaWVudFg7XG5cdFx0XHRfeHkuY2xpZW50WSA9IGUuY2xpZW50WTtcblx0XHRcdC8vIG5vdGUgb25seSBpZTggZG9lcyBub3Qgc3VwcG9ydCBwYWdlWC9wYWdlWVxuXHRcdFx0X3h5LnBhZ2VYICAgPSBlLnBhZ2VYO1xuXHRcdFx0X3h5LnBhZ2VZICAgPSBlLnBhZ2VZO1xuXHRcdFx0Ly8gbm90ZSBpZTggYW5kIG9wZXJhIHJlcG9ydCB0aGVzZSB2YWx1ZXMgaW5jb3JyZWN0bHlcblx0XHRcdF94eS5zY3JlZW5YID0gZS5zY3JlZW5YO1xuXHRcdFx0X3h5LnNjcmVlblkgPSBlLnNjcmVlblk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vKipcbiogUmV0cmlldmVzIHRoZSBsYXN0IGtub3duIGNvb3JkaW5hdGVzIG9mIHRoZSBjdXJzb3Igb3IgdXNlci1pbnRlcmFjdGlvbiBwb2ludFxuKiBpbiB0b3VjaCBlbnZpcm9ubWVudHMuIFJldHVybnMgYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIHRoZSBgY2xpZW50WGAsXG4qIGBjbGllbnRZYCwgYHBhZ2VYYCwgYHBhZ2VZYCwgYHNjcmVlblhgLCBhbmQgYHNjcmVlbllgIHByb3BlcnRpZXMuIEl0IGlzXG4qIGltcG9ydGFudCB0byBub3RlIHRoYXQgSUU4IGFuZCBPcGVyYSBoYXZlIGltcHJvcGVyIHJlcG9ydGluZyBmb3IgdGhlXG4qIGBzY3JlZW5YYCBhbmQgYHNjcmVlbllgIHByb3BlcnRpZXMgKHRoZXkgYm90aCB1c2UgQ1NTIHBpeGVscyBhcyBvcHBvc2VkIHRvXG4qIGRldmljZSBwaXhlbHMpIGFuZCBJRTggaGFzIG5vIHN1cHBvcnQgZm9yIHRoZSBgcGFnZVhgIGFuZCBgcGFnZVlgIHByb3BlcnRpZXMsXG4qIHNvIHRoZXkgYXJlIGZhY2FkZWQuXG4qXG4qIEByZXR1cm5zIHtlbnlvLmRpc3BhdGNoZXJ+Q3Vyc29yQ29vcmRpbmF0ZXN9IEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGRlc2NyaWJpbmcgdGhlXG4qXHR0aGUgbGFzdCBrbm93biBjb29yZGluYXRlcyBvZiB0aGUgY3Vyc29yIG9yIHVzZXItaW50ZXJhY3Rpb24gcG9pbnQgaW4gdG91Y2ggZW52aXJvbm1lbnRzLlxuKiBAcHVibGljXG4qL1xuZGlzcGF0Y2hlci5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHAgPSB1dGlscy5jbG9uZShfeHkpO1xuXHQvLyBpZiB3ZSBhcmUgaW4gaWU4IHdlIGZhY2FkZSB0aGUgX3BhZ2VYLCBwYWdlWV8gcHJvcGVydGllc1xuXHRpZiAocGxhdGZvcm0uaWUgPCA5KSB7XG5cdFx0dmFyIGQgPSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KTtcblx0XHRwLnBhZ2VYID0gKHAuY2xpZW50WCArIGQuc2Nyb2xsTGVmdCk7XG5cdFx0cC5wYWdlWSA9IChwLmNsaWVudFkgKyBkLnNjcm9sbFRvcCk7XG5cdH1cblx0cmV0dXJuIHA7XG59O1xuXG5cbi8qKlxuKiBLZXkgbWFwcGluZyBmZWF0dXJlOiBBZGRzIGEgYGtleVN5bWJvbGAgcHJvcGVydHkgdG8ga2V5IFtldmVudHNde0BnbG9zc2FyeSBldmVudH0sXG4qIGJhc2VkIG9uIGEgZ2xvYmFsIGtleSBtYXBwaW5nLiBVc2VcbiogW2VueW8uZGlzcGF0Y2hlci5yZWdpc3RlcktleU1hcCgpXXtAbGluayBlbnlvLmRpc3BhdGNoZXIucmVnaXN0ZXJLZXlNYXB9IHRvIGFkZFxuKiBrZXlDb2RlLXRvLWtleVN5bWJvbCBtYXBwaW5ncyB2aWEgYSBzaW1wbGUgaGFzaC4gVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZFxuKiBtdWx0aXBsZSB0aW1lcyBmcm9tIGRpZmZlcmVudCBsaWJyYXJpZXMgdG8gbWl4IGRpZmZlcmVudCBtYXBzIGludG8gdGhlIGdsb2JhbFxuKiBtYXBwaW5nIHRhYmxlOyBpZiBjb25mbGljdHMgYXJpc2UsIHRoZSBsYXN0LWluIHdpbnMuXG4qXG4qIGBgYFxuKiBlbnlvLmRpc3BhdGNoZXIucmVnaXN0ZXJLZXlNYXAoe1xuKiBcdDQxNSA6ICdwbGF5JyxcbiogXHQ0MTMgOiAnc3RvcCcsXG4qIFx0MTkgIDogJ3BhdXNlJyxcbiogXHQ0MTIgOiAncmV3aW5kJyxcbiogXHQ0MTcgOiAnZmFzdGZvcndhcmQnXG4qIH0pO1xuKiBgYGBcbiogXG4qIEBwcml2YXRlXG4qL1xuZGlzcGF0Y2hlci5mZWF0dXJlcy5wdXNoKGZ1bmN0aW9uKGUpIHtcblx0aWYgKChlLnR5cGUgPT09ICdrZXlkb3duJykgfHwgKGUudHlwZSA9PT0gJ2tleXVwJykgfHwgKGUudHlwZSA9PT0gJ2tleXByZXNzJykpIHtcblx0XHRlLmtleVN5bWJvbCA9IHRoaXMua2V5TWFwW2Uua2V5Q29kZV07XG5cdFx0Ly8gRGlzcGF0Y2gga2V5IGV2ZW50cyB0byBiZSBzZW50IHZpYSBTaWduYWxzXG5cdFx0dmFyIGMgPSB0aGlzLmZpbmREZWZhdWx0VGFyZ2V0KCk7XG5cdFx0aWYgKGUuZGlzcGF0Y2hUYXJnZXQgIT09IGMpIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hCdWJibGUoZSwgYyk7XG5cdFx0fVxuXHR9XG59KTtcblxudXRpbHMubWl4aW4oZGlzcGF0Y2hlciwge1xuXHRrZXlNYXA6IHt9LFxuXHRyZWdpc3RlcktleU1hcDogZnVuY3Rpb24obWFwKSB7XG5cdFx0dXRpbHMubWl4aW4odGhpcy5rZXlNYXAsIG1hcCk7XG5cdH1cbn0pO1xuXG5cbi8qKlxuKiBFdmVudCBtb2RhbCBjYXB0dXJlIGZlYXR1cmUuIENhcHR1cmUgZXZlbnRzIHRvIGEgc3BlY2lmaWMgY29udHJvbCB2aWFcbiogW2VueW8uZGlzcGF0Y2hlci5jYXB0dXJlKGluQ29udHJvbCwgaW5TaG91bGRGb3J3YXJkKV17QGxpbmtjb2RlIGVueW8uZGlzcGF0Y2hlci5jYXB0dXJlfTtcbiogcmVsZWFzZSBldmVudHMgdmlhIFtlbnlvLmRpc3BhdGNoZXIucmVsZWFzZSgpXXtAbGluayBlbnlvLmRpc3BhdGNoZXIucmVsZWFzZX0uXG4qXG4qIEBwcml2YXRlXG4qL1xuZGlzcGF0Y2hlci5mZWF0dXJlcy5wdXNoKGZ1bmN0aW9uKGUpIHtcblx0aWYgKHRoaXMuY2FwdHVyZVRhcmdldCkge1xuXHRcdHZhciBjID0gZS5kaXNwYXRjaFRhcmdldDtcblx0XHR2YXIgZXZlbnROYW1lID0gKGUuY3VzdG9tRXZlbnQgPyAnJyA6ICdvbicpICsgZS50eXBlO1xuXHRcdHZhciBoYW5kbGVyTmFtZSA9IHRoaXMuY2FwdHVyZUV2ZW50c1tldmVudE5hbWVdO1xuXHRcdHZhciBoYW5kbGVyU2NvcGUgPSB0aGlzLmNhcHR1cmVIYW5kbGVyU2NvcGUgfHwgdGhpcy5jYXB0dXJlVGFyZ2V0O1xuXHRcdHZhciBoYW5kbGVyID0gaGFuZGxlck5hbWUgJiYgaGFuZGxlclNjb3BlW2hhbmRsZXJOYW1lXTtcblx0XHR2YXIgc2hvdWxkQ2FwdHVyZSA9IGhhbmRsZXIgJiYgIShjICYmIGMuaXNEZXNjZW5kYW50T2YgJiYgYy5pc0Rlc2NlbmRhbnRPZih0aGlzLmNhcHR1cmVUYXJnZXQpKTtcblx0XHRpZiAoc2hvdWxkQ2FwdHVyZSkge1xuXHRcdFx0dmFyIGMxID0gZS5jYXB0dXJlVGFyZ2V0ID0gdGhpcy5jYXB0dXJlVGFyZ2V0O1xuXHRcdFx0Ly8gTk9URTogV2UgZG8gbm90IHdhbnQgcmVsZWFzaW5nIGNhcHR1cmUgd2hpbGUgYW4gZXZlbnQgaXMgYmVpbmcgcHJvY2Vzc2VkIHRvIGFsdGVyXG5cdFx0XHQvLyB0aGUgd2F5IHRoZSBldmVudCBwcm9wYWdhdGVzLiBUaGVyZWZvcmUgZGVjaWRlIGlmIHRoZSBldmVudCBzaG91bGQgZm9yd2FyZFxuXHRcdFx0Ly8gYmVmb3JlIHRoZSBjYXB0dXJlIHRhcmdldCByZWNlaXZlcyB0aGUgZXZlbnQgKHNpbmNlIGl0IG1heSByZWxlYXNlIGNhcHR1cmUpLlxuXHRcdFx0ZS5wcmV2ZW50RGlzcGF0Y2ggPSBoYW5kbGVyICYmIGhhbmRsZXIuYXBwbHkoaGFuZGxlclNjb3BlLCBbYzEsIGVdKSAmJiAhdGhpcy5hdXRvRm9yd2FyZEV2ZW50c1tlLnR5cGVdO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vXG4vLyAgICAgICAgTk9URTogVGhpcyBvYmplY3QgaXMgYSBwbHVnLWluOyB0aGVzZSBtZXRob2RzIHNob3VsZFxuLy8gICAgICAgIGJlIGNhbGxlZCBvbiBgZW55by5kaXNwYXRjaGVyYCwgYW5kIG5vdCBvbiB0aGUgcGx1Zy1pbiBpdHNlbGYuXG4vL1xudXRpbHMubWl4aW4oZGlzcGF0Y2hlciwge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGF1dG9Gb3J3YXJkRXZlbnRzOiB7bGVhdmU6IDEsIHJlc2l6ZTogMX0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FwdHVyZXM6IFtdLFxuXG5cdC8qKiBcblx0KiBDYXB0dXJlcyBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IGZvciBgaW5UYXJnZXRgLCB3aGVyZSBgaW5FdmVudHNgIGlzIHNwZWNpZmllZCBhcyBhXG5cdCogaGFzaCBvZiBldmVudCBuYW1lcyBtYXBwZWQgdG8gY2FsbGJhY2sgaGFuZGxlciBuYW1lcyB0byBiZSBjYWxsZWQgb24gYGluVGFyZ2V0YCAob3IsXG5cdCogb3B0aW9uYWxseSwgYGluU2NvcGVgKS4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIGFueSBvZiB0aGUgY2FwdHVyZWQgZXZlbnRzIGFyZVxuXHQqIGRpc3BhdGNoZWQgb3V0c2lkZSBvZiB0aGUgY2FwdHVyaW5nIGNvbnRyb2wuIFJldHVybmluZyBgdHJ1ZWAgZnJvbSB0aGUgY2FsbGJhY2sgc3RvcHNcblx0KiBkaXNwYXRjaCBvZiB0aGUgZXZlbnQgdG8gdGhlIG9yaWdpbmFsIGBkaXNwYXRjaFRhcmdldGAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYXB0dXJlOiBmdW5jdGlvbihpblRhcmdldCwgaW5FdmVudHMsIGluU2NvcGUpIHtcblx0XHR2YXIgaW5mbyA9IHt0YXJnZXQ6IGluVGFyZ2V0LCBldmVudHM6IGluRXZlbnRzLCBzY29wZTogaW5TY29wZX07XG5cdFx0dGhpcy5jYXB0dXJlcy5wdXNoKGluZm8pO1xuXHRcdHRoaXMuc2V0Q2FwdHVyZUluZm8oaW5mbyk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHRhcmdldCBmcm9tIHRoZSBjYXB0dXJlIGxpc3QuXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVsZWFzZTogZnVuY3Rpb24oaW5UYXJnZXQpIHtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5jYXB0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKHRoaXMuY2FwdHVyZXNbaV0udGFyZ2V0ID09PSBpblRhcmdldCkge1xuXHRcdFx0XHR0aGlzLmNhcHR1cmVzLnNwbGljZShpLDEpO1xuXHRcdFx0XHR0aGlzLnNldENhcHR1cmVJbmZvKHRoaXMuY2FwdHVyZXNbdGhpcy5jYXB0dXJlcy5sZW5ndGgtMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgaW5mb3JtYXRpb24gZm9yIGEgY2FwdHVyZWQge0BnbG9zc2FyeSBldmVudH0uXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0Q2FwdHVyZUluZm86IGZ1bmN0aW9uKGluSW5mbykge1xuXHRcdHRoaXMuY2FwdHVyZVRhcmdldCA9IGluSW5mbyAmJiBpbkluZm8udGFyZ2V0O1xuXHRcdHRoaXMuY2FwdHVyZUV2ZW50cyA9IGluSW5mbyAmJiBpbkluZm8uZXZlbnRzO1xuXHRcdHRoaXMuY2FwdHVyZUhhbmRsZXJTY29wZSA9IGluSW5mbyAmJiBpbkluZm8uc2NvcGU7XG5cdH1cbn0pO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cdC8qKlxuXHQqIERpc3BhdGNoZXIgcHJldmlldyBmZWF0dXJlXG5cdCogXG5cdCogQWxsb3dzIHtAbGluayBlbnlvLkNvbnRyb2x9IGFuY2VzdG9ycyBvZiB0aGUge0BnbG9zc2FyeSBldmVudH0gdGFyZ2V0XG5cdCogYSBjaGFuY2UgKGVsZGVzdCBmaXJzdCkgdG8gcmVhY3QgYnkgaW1wbGVtZW50aW5nIGBwcmV2aWV3RG9tRXZlbnRgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dmFyIGZuID0gJ3ByZXZpZXdEb21FdmVudCc7XG5cdHZhciBwcmV2aWV3ID0gXG5cdFx0LyoqIEBsZW5kcyBlbnlvLmRpc3BhdGNoZXIuZmVhdHVyZXMgKi8ge1xuXG5cdFx0LyoqXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0ZmVhdHVyZTogZnVuY3Rpb24oZSkge1xuXHRcdFx0cHJldmlldy5kaXNwYXRjaChlLCBlLmRpc3BhdGNoVGFyZ2V0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0KiBAcmV0dXJucyB7KEJvb2xlYW58dW5kZWZpbmVkKX0gSGFuZGxlcnMgcmV0dXJuIGB0cnVlYCB0byBhYm9ydCBwcmV2aWV3IGFuZCBwcmV2ZW50IGRlZmF1bHRcblx0XHQqXHRldmVudCBwcm9jZXNzaW5nLlxuXHRcdCpcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRkaXNwYXRjaDogZnVuY3Rpb24oZXZ0LCBjb250cm9sKSB7XG5cdFx0XHR2YXIgaSwgbCxcblx0XHRcdGxpbmVhZ2UgPSB0aGlzLmJ1aWxkTGluZWFnZShjb250cm9sKTtcblx0XHRcdGZvciAoaT0wOyAobD1saW5lYWdlW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGlmIChsW2ZuXSAmJiBsW2ZuXShldnQpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0ZXZ0LnByZXZlbnREaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogV2UgYXNjZW5kLCBtYWtpbmcgYSBsaXN0IG9mIEVueW8gW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9LlxuXHRcdCpcblx0XHQqIE5vdGUgdGhhdCBhIGNvbnRyb2wgaXMgY29uc2lkZXJlZCB0byBiZSBpdHMgb3duIGFuY2VzdG9yLlxuXHRcdCpcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRidWlsZExpbmVhZ2U6IGZ1bmN0aW9uKGNvbnRyb2wpIHtcblx0XHRcdHZhciBsaW5lYWdlID0gW10sXG5cdFx0XHRcdGMgPSBjb250cm9sO1xuXHRcdFx0d2hpbGUgKGMpIHtcblx0XHRcdFx0bGluZWFnZS51bnNoaWZ0KGMpO1xuXHRcdFx0XHRjID0gYy5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGluZWFnZTtcblx0XHR9XG5cdH07XG5cblx0ZGlzcGF0Y2hlci5mZWF0dXJlcy5wdXNoKHByZXZpZXcuZmVhdHVyZSk7XG59KSgpO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9kb21cIjo1OCxcIi4vbG9nZ2VyXCI6NjcsXCIuL21hc3RlclwiOjY4LFwiLi9wbGF0Zm9ybVwiOjcxLFwiLi91dGlsc1wiOjc1fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vLi4vZW55bycpO1xuXG5cblxudmFyXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhclxuXHRTaWduYWxzID0gcmVxdWlyZSgnLi4vU2lnbmFscycpLFxuXHRSZWFkeSA9IHJlcXVpcmUoJy4uL3JlYWR5Jyk7XG5cbi8qKlxuKiBOb3JtYWxpemVzIGFuZCBwcm92aWRlcyBmdWxsc2NyZWVuIHN1cHBvcnQgZm9yIFtjb250cm9sc117QGxpbmsgZW55by5Db250cm9sfSxcbiogYmFzZWQgb24gdGhlIFtmdWxsc2NyZWVuXXtAZ2xvc3NhcnkgZnVsbHNjcmVlbn0gQVBJLlxuKlxuKiBAbmFtZSBlbnlvLmZ1bGxzY3JlZW5cbiogQHR5cGUgT2JqZWN0XG4qIEBwdWJsaWNcbiovXG52YXIgZnVsbHNjcmVlbiA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHRcblx0LyoqXG5cdCogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGZ1bGxzY3JlZW4gW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmdWxsc2NyZWVuQ29udHJvbDogbnVsbCxcblxuXHQvKipcblx0KiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBlbGVtZW50IChmYWxsYmFjayBmb3IgcGxhdGZvcm1zXG5cdCogd2l0aG91dCBuYXRpdmUgc3VwcG9ydCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmdWxsc2NyZWVuRWxlbWVudDogbnVsbCxcblxuXHQvKiogXG5cdCogUmVmZXJlbmNlIHRvIHRoYXQgW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gdGhhdCByZXF1ZXN0ZWQgZnVsbHNjcmVlbi5cblx0KiBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZXF1ZXN0b3I6IG51bGwsXG5cblx0LyoqIFxuXHQqIE5hdGl2ZSBhY2Nlc3NvciB1c2VkIHRvIGdldCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZnVsbHNjcmVlbiBlbGVtZW50LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZWxlbWVudEFjY2Vzc29yOlxuXHRcdCgnZnVsbHNjcmVlbkVsZW1lbnQnIGluIGRvY3VtZW50KSA/ICdmdWxsc2NyZWVuRWxlbWVudCcgOlxuXHRcdCgnbW96RnVsbFNjcmVlbkVsZW1lbnQnIGluIGRvY3VtZW50KSA/ICdtb3pGdWxsU2NyZWVuRWxlbWVudCcgOlxuXHRcdCgnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnIGluIGRvY3VtZW50KSA/ICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcgOlxuXHRcdG51bGwsXG5cblx0LyoqIFxuXHQqIE5hdGl2ZSBhY2Nlc3NvciB1c2VkIHRvIHJlcXVlc3QgZnVsbHNjcmVlbi5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlcXVlc3RBY2Nlc3Nvcjpcblx0XHQoJ3JlcXVlc3RGdWxsc2NyZWVuJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID8gJ3JlcXVlc3RGdWxsc2NyZWVuJyA6XG5cdFx0KCdtb3pSZXF1ZXN0RnVsbFNjcmVlbicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA/ICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicgOlxuXHRcdCgnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgPyAnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nIDpcblx0XHRudWxsLFxuXG5cdC8qKiBcblx0KiBOYXRpdmUgYWNjZXNzb3IgdXNlZCB0byBjYW5jZWwgZnVsbHNjcmVlbi5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbmNlbEFjY2Vzc29yOlxuXHRcdCgnY2FuY2VsRnVsbFNjcmVlbicgaW4gZG9jdW1lbnQpID8gJ2NhbmNlbEZ1bGxTY3JlZW4nIDpcblx0XHQoJ21vekNhbmNlbEZ1bGxTY3JlZW4nIGluIGRvY3VtZW50KSA/ICdtb3pDYW5jZWxGdWxsU2NyZWVuJyA6XG5cdFx0KCd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyBpbiBkb2N1bWVudCkgPyAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicgOlxuXHRcdG51bGwsXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyB0aGUgW2Z1bGxzY3JlZW5de0BnbG9zc2FyeSBmdWxsc2NyZWVufSBBUEkuXG5cdCogXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHBsYXRmb3JtIHN1cHBvcnRzIGFsbCBvZiB0aGUgXG5cdCpcdFtmdWxsc2NyZWVuXXtAZ2xvc3NhcnkgZnVsbHNjcmVlbn0gQVBJLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0KiBAcHVibGljXG5cdCovXG5cdG5hdGl2ZVN1cHBvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5lbGVtZW50QWNjZXNzb3IgIT09IG51bGwgJiYgdGhpcy5yZXF1ZXN0QWNjZXNzb3IgIT09IG51bGwgJiYgdGhpcy5jYW5jZWxBY2Nlc3NvciAhPT0gbnVsbCk7XG5cdH0sXG5cblx0LyoqIFxuXHQqIE5vcm1hbGl6ZXMgYGdldEZ1bGxzY3JlZW5FbGVtZW50KClgLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRGdWxsc2NyZWVuRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLm5hdGl2ZVN1cHBvcnQoKSkgPyBkb2N1bWVudFt0aGlzLmVsZW1lbnRBY2Nlc3Nvcl0gOiB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50O1xuXHR9LFxuXG5cdC8qKiBcblx0KiBSZXR1cm5zIGN1cnJlbnQgZnVsbHNjcmVlbiBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0RnVsbHNjcmVlbkNvbnRyb2w6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmZ1bGxzY3JlZW5Db250cm9sO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE5vcm1hbGl6ZXMgYHJlcXVlc3RGdWxsc2NyZWVuKClgLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZXF1ZXN0RnVsbHNjcmVlbjogZnVuY3Rpb24oY3RsKSB7XG5cdFx0aWYgKHRoaXMuZ2V0RnVsbHNjcmVlbkNvbnRyb2woKSB8fCAhKGN0bC5oYXNOb2RlKCkpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZXF1ZXN0b3IgPSBjdGw7XG5cblx0XHQvLyBPbmx5IHVzZSBuYXRpdmUgcmVxdWVzdCBpZiBwbGF0Zm9ybSBzdXBwb3J0cyBhbGwgb2YgdGhlIEFQSVxuXHRcdGlmICh0aGlzLm5hdGl2ZVN1cHBvcnQoKSkge1xuXHRcdFx0Y3RsLmhhc05vZGUoKVt0aGlzLnJlcXVlc3RBY2Nlc3Nvcl0oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mYWxsYmFja1JlcXVlc3RGdWxsc2NyZWVuKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqIFxuXHQqIE5vcm1hbGl6ZXMgYGNhbmNlbEZ1bGxzY3JlZW4oKWAuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGNhbmNlbEZ1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLm5hdGl2ZVN1cHBvcnQoKSkge1xuXHRcdFx0ZG9jdW1lbnRbdGhpcy5jYW5jZWxBY2Nlc3Nvcl0oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5mYWxsYmFja0NhbmNlbEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqIFxuXHQqIEZhbGxiYWNrIHN1cHBvcnQgZm9yIHNldHRpbmcgZnVsbHNjcmVlbiBlbGVtZW50IChkb25lIGJ5IGJyb3dzZXIgb24gcGxhdGZvcm1zIHdpdGhcblx0KiBuYXRpdmUgc3VwcG9ydCkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZXRGdWxsc2NyZWVuRWxlbWVudDogZnVuY3Rpb24obm9kZSkge1xuXHRcdHRoaXMuZnVsbHNjcmVlbkVsZW1lbnQgPSBub2RlO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBTZXRzIGN1cnJlbnQgZnVsbHNjcmVlbiBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldEZ1bGxzY3JlZW5Db250cm9sOiBmdW5jdGlvbihjdGwpIHtcblx0XHR0aGlzLmZ1bGxzY3JlZW5Db250cm9sID0gY3RsO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBGYWxsYmFjayBmdWxsc2NyZWVuIHJlcXVlc3QgZm9yIHBsYXRmb3JtcyB3aXRob3V0IGZ1bGxzY3JlZW4gc3VwcG9ydC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZhbGxiYWNrUmVxdWVzdEZ1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb250cm9sID0gdGhpcy5yZXF1ZXN0b3I7XG5cblx0XHRpZiAoIWNvbnRyb2wpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBHZXQgYmVmb3JlIG5vZGUgdG8gYWxsb3cgdXMgdG8gZXhpdCBmbG9hdGluZyBsYXllciB0byB0aGUgcHJvcGVyIHBvc2l0aW9uXG5cdFx0Y29udHJvbC5wcmV2QWRkQmVmb3JlID0gY29udHJvbC5wYXJlbnQuY29udHJvbEF0SW5kZXgoY29udHJvbC5pbmRleEluQ29udGFpbmVyKCkgKyAxKTtcblx0XHRcblx0XHR2YXIgZmxvYXRpbmdMYXllciA9IENvbnRyb2wuZmxvYXRpbmdMYXllcjtcblx0XHRcblx0XHQvLyBSZW5kZXIgZmxvYXRpbmcgbGF5ZXIgaWYgd2UgbmVlZCB0b1xuXHRcdGlmICghZmxvYXRpbmdMYXllci5oYXNOb2RlKCkpIHtcblx0XHRcdGZsb2F0aW5nTGF5ZXIucmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0Y29udHJvbC5hZGRDbGFzcygnZW55by1mdWxsc2NyZWVuJyk7XG5cdFx0Y29udHJvbC5hcHBlbmROb2RlVG9QYXJlbnQoZmxvYXRpbmdMYXllci5oYXNOb2RlKCkpO1xuXHRcdGNvbnRyb2wucmVzaXplKCk7XG5cblx0XHR0aGlzLnNldEZ1bGxzY3JlZW5Db250cm9sKGNvbnRyb2wpO1xuXHRcdHRoaXMuc2V0RnVsbHNjcmVlbkVsZW1lbnQoY29udHJvbC5oYXNOb2RlKCkpO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBGYWxsYmFjayBjYW5jZWwgZnVsbHNjcmVlbiBmb3IgcGxhdGZvcm1zIHdpdGhvdXQgZnVsbHNjcmVlbiBzdXBwb3J0LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZmFsbGJhY2tDYW5jZWxGdWxsc2NyZWVuOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udHJvbCA9IHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wsXG5cdFx0XHRiZWZvcmVOb2RlLFxuXHRcdFx0cGFyZW50Tm9kZVxuXHRcdDtcblxuXHRcdGlmICghY29udHJvbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZpbmQgYmVmb3JlTm9kZSBiYXNlZCBvbiBfdGhpcy5hZGRCZWZvcmVfIGFuZCBfdGhpcy5wcmV2QWRkQmVmb3JlX1xuXHRcdGJlZm9yZU5vZGUgPSAoY29udHJvbC5wcmV2QWRkQmVmb3JlKSA/IGNvbnRyb2wucHJldkFkZEJlZm9yZS5oYXNOb2RlKCkgOiBudWxsO1xuXHRcdHBhcmVudE5vZGUgPSBjb250cm9sLnBhcmVudC5oYXNOb2RlKCk7XG5cdFx0Y29udHJvbC5wcmV2QWRkQmVmb3JlID0gbnVsbDtcblxuXHRcdGNvbnRyb2wucmVtb3ZlQ2xhc3MoJ2VueW8tZnVsbHNjcmVlbicpO1xuXG5cdFx0aWYgKCFiZWZvcmVOb2RlKSB7XG5cdFx0XHRjb250cm9sLmFwcGVuZE5vZGVUb1BhcmVudChwYXJlbnROb2RlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udHJvbC5pbnNlcnROb2RlSW5QYXJlbnQocGFyZW50Tm9kZSwgYmVmb3JlTm9kZSk7XG5cdFx0fVxuXG5cdFx0Y29udHJvbC5yZXNpemUoKTtcblxuXHRcdHRoaXMuc2V0RnVsbHNjcmVlbkNvbnRyb2wobnVsbCk7XG5cdFx0dGhpcy5zZXRGdWxsc2NyZWVuRWxlbWVudChudWxsKTtcblx0fSxcblxuXHQvKiogXG5cdCogTGlzdGVucyBmb3IgZnVsbHNjcmVlbiBjaGFuZ2Uge0BnbG9zc2FyeSBldmVudH0gYW5kIGJyb2FkY2FzdHMgaXQgYXMgYVxuXHQqIG5vcm1hbGl6ZWQgZXZlbnQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXRlY3RGdWxsc2NyZWVuQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0RnVsbHNjcmVlbkNvbnRyb2wodGhpcy5yZXF1ZXN0b3IpO1xuXHRcdHRoaXMucmVxdWVzdG9yID0gbnVsbDtcblxuXHRcdC8vIEJyb2FkY2FzdCBjaGFuZ2Vcblx0XHRTaWduYWxzLnNlbmQoJ29uRnVsbHNjcmVlbkNoYW5nZScpO1xuXHR9XG59O1xuXG4vKipcbiogTm9ybWFsaXplcyBwbGF0Zm9ybS1zcGVjaWZpYyBmdWxsc2NyZWVuIGNoYW5nZSBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9LlxuKlxuKiBAcHJpdmF0ZVxuKi9cblJlYWR5KGZ1bmN0aW9uKCkge1xuXHQvLyBubyBuZWVkIGZvciBJRTggZmFsbGJhY2ssIHNpbmNlIGl0IHdvbid0IGV2ZXIgc2VuZCB0aGlzIGV2ZW50XG5cdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIHV0aWxzLmJpbmQoZnVsbHNjcmVlbiwgJ2RldGVjdEZ1bGxzY3JlZW5DaGFuZ2VFdmVudCcpLCBmYWxzZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsICAgIHV0aWxzLmJpbmQoZnVsbHNjcmVlbiwgJ2RldGVjdEZ1bGxzY3JlZW5DaGFuZ2VFdmVudCcpLCBmYWxzZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsICAgICAgIHV0aWxzLmJpbmQoZnVsbHNjcmVlbiwgJ2RldGVjdEZ1bGxzY3JlZW5DaGFuZ2VFdmVudCcpLCBmYWxzZSk7XG5cdH1cbn0pO1xuXG4vKipcbiogSWYgdGhpcyBwbGF0Zm9ybSBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yIGZ1bGxzY3JlZW4sIGFkZCBhbiBlc2NhcGUgaGFuZGxlciB0byBtaW1pYyBcbiogbmF0aXZlIGJlaGF2aW9yLlxuKi9cbmlmKCFmdWxsc2NyZWVuLm5hdGl2ZVN1cHBvcnQoKSkge1xuXHRkaXNwYXRjaGVyLmZlYXR1cmVzLnB1c2goXG5cdFx0ZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmIGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0ZnVsbHNjcmVlbi5jYW5jZWxGdWxsc2NyZWVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufVxufSx7XCIuLi8uLi8uLi9lbnlvXCI6MSxcIi4uL1NpZ25hbHNcIjo0NyxcIi4uL2Rpc3BhdGNoZXJcIjo1NyxcIi4uL3JlYWR5XCI6NzIsXCIuLi91dGlsc1wiOjc1fV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi9wbGF0Zm9ybScpLFxuXHRkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyk7XG5cbnZhclxuXHREb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG5cbi8qKlxuKiBFbnlvIHN1cHBvcnRzIGEgc2V0IG9mIG5vcm1hbGl6ZWQgZXZlbnRzIHRoYXQgd29yayBzaW1pbGFybHkgYWNyb3NzIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlxuKiBUaGVzZSBldmVudHMgYXJlIHByb3ZpZGVkIHNvIHRoYXQgdXNlcnMgY2FuIHdyaXRlIGEgc2luZ2xlIHNldCBvZiBldmVudCBoYW5kbGVycyBmb3JcbiogYXBwbGljYXRpb25zIHRoYXQgcnVuIG9uIGJvdGggbW9iaWxlIGFuZCBkZXNrdG9wIHBsYXRmb3Jtcy4gVGhleSBhcmUgbmVlZGVkIGJlY2F1c2UgZGVza3RvcFxuKiBhbmQgbW9iaWxlIHBsYXRmb3JtcyBoYW5kbGUgYmFzaWMgaW5wdXQgZGlmZmVyZW50bHkuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG5vcm1hbGl6ZWQgaW5wdXQgZXZlbnRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHByb3BlcnRpZXMsIHNlZSB0aGVcbiogZG9jdW1lbnRhdGlvbiBvbiBbRXZlbnQgSGFuZGxpbmdde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9rZXktY29uY2VwdHMvZXZlbnQtaGFuZGxpbmcuaHRtbH1cbiogaW4gdGhlIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAbmFtZXNwYWNlIGdlc3R1cmVcbiogQHB1YmxpY1xuKi9cbnZhciBnZXN0dXJlID0gbW9kdWxlLmV4cG9ydHMgPVxuXHQvKiogQGxlbmRzIGdlc3R1cmUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50UHJvcHM6IFsndGFyZ2V0JywgJ3JlbGF0ZWRUYXJnZXQnLCAnY2xpZW50WCcsICdjbGllbnRZJywgJ3BhZ2VYJywgJ3BhZ2VZJyxcblx0XHQnc2NyZWVuWCcsICdzY3JlZW5ZJywgJ2FsdEtleScsICdjdHJsS2V5JywgJ21ldGFLZXknLCAnc2hpZnRLZXknLFxuXHRcdCdkZXRhaWwnLCAnaWRlbnRpZmllcicsICdkaXNwYXRjaFRhcmdldCcsICd3aGljaCcsICdzcmNFdmVudCddLFxuXG5cdC8qKlxuXHQqIENyZWF0ZXMgYW4ge0BnbG9zc2FyeSBldmVudH0gb2YgdHlwZSBgdHlwZWAgYW5kIHJldHVybnMgaXQuXG5cdCogYGV2dGAgc2hvdWxkIGJlIGFuIGV2ZW50IFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB7QGdsb3NzYXJ5IGV2ZW50fSB0byBtYWtlLlxuXHQqIEBwYXJhbSB7KEV2ZW50fE9iamVjdCl9IGV2dCAtIFRoZSBldmVudCB5b3UnZCBsaWtlIHRvIGNsb25lIG9yIGFuIG9iamVjdCB0aGF0IGxvb2tzIGxpa2UgaXQuXG5cdCogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyBldmVudCBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fS5cblx0KiBAcHVibGljXG5cdCovXG5cdG1ha2VFdmVudDogZnVuY3Rpb24odHlwZSwgZXZ0KSB7XG5cdFx0dmFyIGUgPSB7fTtcblx0XHRlLnR5cGUgPSB0eXBlO1xuXHRcdGZvciAodmFyIGk9MCwgcDsgKHA9dGhpcy5ldmVudFByb3BzW2ldKTsgaSsrKSB7XG5cdFx0XHRlW3BdID0gZXZ0W3BdO1xuXHRcdH1cblx0XHRlLnNyY0V2ZW50ID0gZS5zcmNFdmVudCB8fCBldnQ7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCA9IHRoaXMucHJldmVudERlZmF1bHQ7XG5cdFx0ZS5kaXNhYmxlUHJldmVudGlvbiA9IHRoaXMuZGlzYWJsZVByZXZlbnRpb247XG5cblx0XHRpZiAoRG9tLl9ib2R5U2NhbGVGYWN0b3JYICE9PSAxIHx8IERvbS5fYm9keVNjYWxlRmFjdG9yWSAhPT0gMSkge1xuXHRcdFx0Ly8gSW50ZXJjZXB0IG9ubHkgdGhlc2UgZXZlbnRzLCBub3QgYWxsIGV2ZW50cywgbGlrZTogaG9sZCwgcmVsZWFzZSwgdGFwLCBldGMsXG5cdFx0XHQvLyB0byBhdm9pZCBkb2luZyB0aGUgb3BlcmF0aW9uIGFnYWluLlxuXHRcdFx0aWYgKGUudHlwZSA9PSAnbW92ZScgfHwgZS50eXBlID09ICd1cCcgfHwgZS50eXBlID09ICdkb3duJyB8fCBlLnR5cGUgPT0gJ2VudGVyJyB8fCBlLnR5cGUgPT0gJ2xlYXZlJykge1xuXHRcdFx0XHRlLmNsaWVudFggKj0gRG9tLl9ib2R5U2NhbGVGYWN0b3JYO1xuXHRcdFx0XHRlLmNsaWVudFkgKj0gRG9tLl9ib2R5U2NhbGVGYWN0b3JZO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvL1xuXHRcdC8vIG5vcm1hbGl6ZSBldmVudC53aGljaCBhbmQgZXZlbnQucGFnZVgvZXZlbnQucGFnZVlcblx0XHQvLyBOb3RlIHRoYXQgd2hpbGUgJ3doaWNoJyB3b3JrcyBpbiBJRTksIGl0IGlzIGJyb2tlbiBmb3IgbW91c2Vtb3ZlLiBUaGVyZWZvcmUsXG5cdFx0Ly8gaW4gSUUsIHVzZSBnbG9iYWwuZXZlbnQuYnV0dG9uXG5cdFx0aWYgKHBsYXRmb3JtLmllIDwgMTApIHtcblx0XHRcdC8vRml4IGZvciBJRTgsIHdoaWNoIGRvZXNuJ3QgaW5jbHVkZSBwYWdlWCBhbmQgcGFnZVkgcHJvcGVydGllc1xuXHRcdFx0aWYocGxhdGZvcm0uaWU9PTggJiYgZS50YXJnZXQpIHtcblx0XHRcdFx0ZS5wYWdlWCA9IGUuY2xpZW50WCArIGUudGFyZ2V0LnNjcm9sbExlZnQ7XG5cdFx0XHRcdGUucGFnZVkgPSBlLmNsaWVudFkgKyBlLnRhcmdldC5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYiA9IGdsb2JhbC5ldmVudCAmJiBnbG9iYWwuZXZlbnQuYnV0dG9uO1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0Ly8gbXVsdGktYnV0dG9uIG5vdCBzdXBwb3J0ZWQsIHByaW9yaXR5OiBsZWZ0LCByaWdodCwgbWlkZGxlXG5cdFx0XHRcdC8vIChub3RlOiBJRSBiaXRtYXNrIGlzIDE9bGVmdCwgMj1yaWdodCwgND1jZW50ZXIpO1xuXHRcdFx0XHRlLndoaWNoID0gYiAmIDEgPyAxIDogKGIgJiAyID8gMiA6IChiICYgNCA/IDMgOiAwKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChwbGF0Zm9ybS53ZWJvcyB8fCBnbG9iYWwuUGFsbVN5c3RlbSkge1xuXHRcdFx0Ly8gVGVtcG9yYXJ5IGZpeCBmb3Igb3dvczogaXQgZG9lcyBub3QgY3VycmVudGx5IHN1cHBseSAnd2hpY2gnIG9uIG1vdmUgZXZlbnRzXG5cdFx0XHQvLyBhbmQgdGhlIHVzZXIgYWdlbnQgc3RyaW5nIGRvZXNuJ3QgaWRlbnRpZnkgaXRzZWxmIHNvIHdlIHRlc3QgZm9yIFBhbG1TeXN0ZW1cblx0XHRcdGlmIChlLndoaWNoID09PSAwKSB7XG5cdFx0XHRcdGUud2hpY2ggPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZTtcblx0fSxcblxuXHQvKipcblx0KiBIYW5kbGVzIFwiZG93blwiIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0sIGluY2x1ZGluZyBgbW91c2Vkb3duYCBhbmQgYGtleWRvd25gLiBUaGlzIGlzXG5cdCogcmVzcG9uc2libGUgZm9yIHRoZSBwcmVzcy1hbmQtaG9sZCBrZXkgcmVwZWF0ZXIuXG5cdCpcblx0KiBAcGFyYW0ge0V2ZW50fSBldnQgLSBUaGUgc3RhbmRhcmQge0BnbG9zc2FyeSBldmVudH0gW29iamVjdF17Z2xvc3NhcnkgT2JqZWN0fS5cblx0KiBAcHVibGljXG5cdCovXG5cdGRvd246IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBlID0gdGhpcy5tYWtlRXZlbnQoJ2Rvd24nLCBldnQpO1xuXG5cdFx0Ly8gcHJlcGFyZSBmb3IgaG9sZFxuXHRcdHRoaXMuZHJhZy5wcmVwYXJlSG9sZChlKTtcblxuXHRcdC8vIGVuYWJsZSBwcmV2ZW50aW9uIG9mIHRhcCBldmVudFxuXHRcdGUucHJldmVudFRhcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZS5fdGFwUHJldmVudGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChlKTtcblx0XHR0aGlzLmRvd25FdmVudCA9IGU7XG5cblx0XHQvLyBzdGFydCBob2xkLCBub3cgdGhhdCBjb250cm9sIGhhcyBoYWQgYSBjaGFuY2Vcblx0XHQvLyB0byBvdmVycmlkZSB0aGUgaG9sZFB1bHNlIGNvbmZpZ3VyYXRpb25cblx0XHR0aGlzLmRyYWcuYmVnaW5Ib2xkKGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgYG1vdXNlbW92ZWAgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fS5cblx0KlxuXHQqIEBwYXJhbSB7RXZlbnR9IGV2dCAtIFRoZSBzdGFuZGFyZCB7QGdsb3NzYXJ5IGV2ZW50fSBbb2JqZWN0XXtnbG9zc2FyeSBPYmplY3R9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bW92ZTogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGUgPSB0aGlzLm1ha2VFdmVudCgnbW92ZScsIGV2dCk7XG5cdFx0Ly8gaW5jbHVkZSBkZWx0YSBhbmQgZGlyZWN0aW9uIHYuIGRvd24gaW5mbyBpbiBtb3ZlIGV2ZW50XG5cdFx0ZS5keCA9IGUuZHkgPSBlLmhvcml6b250YWwgPSBlLnZlcnRpY2FsID0gMDtcblx0XHRpZiAoZS53aGljaCAmJiB0aGlzLmRvd25FdmVudCkge1xuXHRcdFx0ZS5keCA9IGV2dC5jbGllbnRYIC0gdGhpcy5kb3duRXZlbnQuY2xpZW50WDtcblx0XHRcdGUuZHkgPSBldnQuY2xpZW50WSAtIHRoaXMuZG93bkV2ZW50LmNsaWVudFk7XG5cdFx0XHRlLmhvcml6b250YWwgPSBNYXRoLmFicyhlLmR4KSA+IE1hdGguYWJzKGUuZHkpO1xuXHRcdFx0ZS52ZXJ0aWNhbCA9ICFlLmhvcml6b250YWw7XG5cdFx0fVxuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogSGFuZGxlcyBcInVwXCIgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fSwgaW5jbHVkaW5nIGBtb3VzZXVwYCBhbmQgYGtleXVwYC5cblx0KlxuXHQqIEBwYXJhbSB7RXZlbnR9IGV2dCAtIFRoZSBzdGFuZGFyZCB7QGdsb3NzYXJ5IGV2ZW50fSBbb2JqZWN0XXtnbG9zc2FyeSBPYmplY3R9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dXA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBlID0gdGhpcy5tYWtlRXZlbnQoJ3VwJywgZXZ0KTtcblxuXHRcdC8vIFdlIGhhdmUgYWRkZWQgc29tZSBsb2dpYyB0byBzeW5jaHJvbml6ZSB1cCBhbmQgZG93biBldmVudHMgaW4gY2VydGFpbiBzY2VuYXJpb3MgKGkuZS5cblx0XHQvLyBjbGlja2luZyBtdWx0aXBsZSBidXR0b25zIHdpdGggYSBtb3VzZSkgYW5kIHRvIGdlbmVyYWxseSBndWFyZCBhZ2FpbnN0IGFueSBwb3RlbnRpYWxcblx0XHQvLyBhc3ltbWV0cnksIGJ1dCBhIGZ1bGwgc29sdXRpb24gd291bGQgYmUgdG8gbWFpbnRhaW4gYSBtYXAgb2YgdXAvZG93biBldmVudHMgYXMgYW4gXG5cdFx0Ly8gaWRlYWwgc29sdXRpb24sIGZvciBmdXR1cmUgd29yay5cblx0XHRlLl90YXBQcmV2ZW50ZWQgPSB0aGlzLmRvd25FdmVudCAmJiB0aGlzLmRvd25FdmVudC5fdGFwUHJldmVudGVkICYmIHRoaXMuZG93bkV2ZW50LndoaWNoID09IGUud2hpY2g7XG5cdFx0ZS5wcmV2ZW50VGFwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRlLl90YXBQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKGUpO1xuXHRcdGlmICghZS5fdGFwUHJldmVudGVkICYmIHRoaXMuZG93bkV2ZW50ICYmIHRoaXMuZG93bkV2ZW50LndoaWNoID09IDEpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB0aGlzLmZpbmRDb21tb25BbmNlc3Rvcih0aGlzLmRvd25FdmVudC50YXJnZXQsIGV2dC50YXJnZXQpO1xuXG5cdFx0XHQvLyB0aGUgY29tbW9uIGFuY2VzdG9yIG9mIHRoZSBkb3duL3VwIGV2ZW50cyBpcyB0aGUgdGFyZ2V0IG9mIHRoZSB0YXBcblx0XHRcdGlmKHRhcmdldCkge1xuXHRcdFx0XHRpZih0aGlzLnN1cHBvcnRzRG91YmxlVGFwKHRhcmdldCkpIHtcblx0XHRcdFx0XHR0aGlzLmRvdWJsZVRhcChlLCB0YXJnZXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2VuZFRhcChlLCB0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLmRvd25FdmVudCAmJiB0aGlzLmRvd25FdmVudC53aGljaCA9PSBlLndoaWNoKSB7XG5cdFx0XHR0aGlzLmRvd25FdmVudCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgYG1vdXNlb3ZlcmAgW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fS5cblx0KlxuXHQqIEBwYXJhbSB7RXZlbnR9IGV2dCAtIFRoZSBzdGFuZGFyZCB7QGdsb3NzYXJ5IGV2ZW50fSBbb2JqZWN0XXtnbG9zc2FyeSBPYmplY3R9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0b3ZlcjogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGUgPSB0aGlzLm1ha2VFdmVudCgnZW50ZXInLCBldnQpO1xuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogSGFuZGxlcyBgbW91c2VvdXRgIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uXG5cdCpcblx0KiBAcGFyYW0ge0V2ZW50fSBldnQgLSBUaGUgc3RhbmRhcmQge0BnbG9zc2FyeSBldmVudH0gW29iamVjdF17Z2xvc3NhcnkgT2JqZWN0fS5cblx0KiBAcHVibGljXG5cdCovXG5cdG91dDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGUgPSB0aGlzLm1ha2VFdmVudCgnbGVhdmUnLCBldnQpO1xuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogR2VuZXJhdGVzIGB0YXBgIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uXG5cdCpcblx0KiBAcGFyYW0ge0V2ZW50fSBldnQgLSBUaGUgc3RhbmRhcmQge0BnbG9zc2FyeSBldmVudH0gW29iamVjdF17Z2xvc3NhcnkgT2JqZWN0fS5cblx0KiBAcHVibGljXG5cdCovXG5cdHNlbmRUYXA6IGZ1bmN0aW9uKGV2dCwgdGFyZ2V0KSB7XG5cdFx0dmFyIGUgPSB0aGlzLm1ha2VFdmVudCgndGFwJywgZXZ0KTtcblx0XHRlLnRhcmdldCA9IHRhcmdldDtcblx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRhcERhdGE6IHtcblx0XHRpZDogbnVsbCxcblx0XHR0aW1lcjogbnVsbCxcblx0XHRzdGFydDogMFxuXHR9LFxuXG5cdC8qKlxuXHQqIEdsb2JhbCBjb25maWd1cmF0aW9uIGZvciBkb3VibGUgdGFwIHN1cHBvcnQuIElmIHRoaXMgaXMgdHJ1ZSwgYWxsIHRhcCBldmVudHMgZm9yIENvbnRyb2xzXG5cdCogdGhhdCBkbyBub3QgaGF2ZSB7QGxpbmsgZW55by5Db250cm9sI2RvdWJsZVRhcEVuYWJsZWR9IGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIHdpbGwgYmVcblx0KiBkZWxheWVkIGJ5IHRoZSB7QGxpbmsgZW55by5Db250cm9sI2RvdWJsZVRhcEludGVydmFsfS5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0ICBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZG91YmxlVGFwRW5hYmxlZDogZmFsc2UsXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG5vZGUgc3VwcG9ydHMgZG91YmxlIHRhcCBldmVudHNcblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdXBwb3J0c0RvdWJsZVRhcDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG9iaiA9IGRpc3BhdGNoZXIuZmluZERpc3BhdGNoVGFyZ2V0KHRhcmdldCk7XG5cblx0XHRpZihvYmopIHtcblx0XHRcdC8vIENvbnRyb2wuZG91YmxlVGFwRW5hYmxlZCBpcyBhIHRyaS12YWx1ZSBwcm9wZXJ0eS4gVGhlIGRlZmF1bHQgaXMgJ2luaGVyaXQnXG5cdFx0XHQvLyB3aGljaCB0YWtlcyBpdHMgY3VlIGZyb20gZ2VzdHVyZSdzIGRvdWJsZVRhcEVuYWJsZWQuIFZhbHVlcyBvZiB0cnVlIG9yIGZhbHNlXG5cdFx0XHQvLyBvdmVycmlkZSB0aGUgZGVmYXVsdC4gU28sIGlmIHRoZSBnbG9iYWwgaXMgdHJ1ZSwgYW55IHRydXRoeSB2YWx1ZSBvbiBDb250cm9sXG5cdFx0XHQvLyByZXN1bHRzIGluIHRydWUuIElmIHRoZSBnbG9iYWwgaXMgZmFsc2UsIG9ubHkgYW4gZXhwbGljaXQgdHJ1ZSBvbiBDb250cm9sXG5cdFx0XHQvLyByZXN1bHRzIGluIHRydWUuXG5cdFx0XHRyZXR1cm4gdGhpcy5kb3VibGVUYXBFbmFibGVkPyAhIW9iai5kb3VibGVUYXBFbmFibGVkIDogb2JqLmRvdWJsZVRhcEVuYWJsZWQgPT09IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogcHJpdmF0ZVxuXHQqL1xuXHRkb3VibGVUYXA6IGZ1bmN0aW9uKGV2dCwgdCkge1xuXHRcdHZhciBvYmogPSBkaXNwYXRjaGVyLmZpbmREaXNwYXRjaFRhcmdldCh0KTtcblxuXHRcdGlmKHRoaXMudGFwRGF0YS5pZCAhPT0gb2JqLmlkKSB7XHQvLyB0aGlzIGlzIHRoZSBmaXJzdCB0YXBcblx0XHRcdHRoaXMucmVzZXRUYXBEYXRhKHRydWUpO1xuXG5cdFx0XHR0aGlzLnRhcERhdGEuaWQgPSBvYmouaWQ7XG5cdFx0XHR0aGlzLnRhcERhdGEuZXZlbnQgPSBldnQ7XG5cdFx0XHR0aGlzLnRhcERhdGEudGFyZ2V0ID0gdDtcblx0XHRcdHRoaXMudGFwRGF0YS50aW1lciA9IHNldFRpbWVvdXQodXRpbHMuYmluZCh0aGlzLCBcInJlc2V0VGFwRGF0YVwiLCB0cnVlKSwgb2JqLmRvdWJsZVRhcEludGVydmFsKTtcblx0XHRcdHRoaXMudGFwRGF0YS5zdGFydCA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHR9IGVsc2Uge1x0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgZG91YmxlIHRhcFxuXHRcdFx0dmFyIGUyID0gdGhpcy5tYWtlRXZlbnQoJ2RvdWJsZXRhcCcsIGV2dCk7XG5cdFx0XHRlMi50YXJnZXQgPSB0O1xuXHRcdFx0ZTIudGFwSW50ZXJ2YWwgPSB1dGlscy5wZXJmTm93KCkgLSB0aGlzLnRhcERhdGEuc3RhcnQ7XG5cdFx0XHR0aGlzLnJlc2V0VGFwRGF0YShmYWxzZSk7XG5cdFx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKGUyKTtcblx0XHR9XG5cdH0sXG5cblx0cmVzZXRUYXBEYXRhOiBmdW5jdGlvbihzZW5kVGFwKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLnRhcERhdGE7XG5cblx0XHRpZihzZW5kVGFwICYmIGRhdGEuaWQpIHtcblx0XHRcdHRoaXMuc2VuZFRhcChkYXRhLmV2ZW50LCBkYXRhLnRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KGRhdGEudGltZXIpO1xuXHRcdGRhdGEuaWQgPSBkYXRhLnN0YXJ0ID0gZGF0YS5ldmVudCA9IGRhdGEudGFyZ2V0ID0gZGF0YS50aW1lciA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCogR2l2ZW4gdHdvIFtET00gbm9kZXNde0BnbG9zc2FyeSBOb2RlfSwgc2VhcmNoZXMgZm9yIGEgc2hhcmVkIGFuY2VzdG9yIChsb29rcyB1cFxuXHQqIHRoZSBoaWVyYXJjaGljIFtET01de0BnbG9zc2FyeSBET019IHRyZWUgb2YgW25vZGVzXXtAZ2xvc3NhcnkgTm9kZX0pLiBUaGUgc2hhcmVkXG5cdCogYW5jZXN0b3Igbm9kZSBpcyByZXR1cm5lZC5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gY29udHJvbEEgLSBDb250cm9sIG9uZS5cblx0KiBAcGFyYW0ge05vZGV9IGNvbnRyb2xCIC0gQ29udHJvbCB0d28uXG5cdCogQHJldHVybnMgeyhOb2RlfHVuZGVmaW5lZCl9IFRoZSBzaGFyZWQgYW5jZXN0b3IuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmaW5kQ29tbW9uQW5jZXN0b3I6IGZ1bmN0aW9uKGNvbnRyb2xBLCBjb250cm9sQikge1xuXHRcdHZhciBwID0gY29udHJvbEI7XG5cdFx0d2hpbGUgKHApIHtcblx0XHRcdGlmICh0aGlzLmlzVGFyZ2V0RGVzY2VuZGFudE9mKGNvbnRyb2xBLCBwKSkge1xuXHRcdFx0XHRyZXR1cm4gcDtcblx0XHRcdH1cblx0XHRcdHAgPSBwLnBhcmVudE5vZGU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEdpdmVuIHR3byBjb250cm9scywgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBjaGlsZGAgaXMgaW5zaWRlIHRoZSBgcGFyZW50YC5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gc2VhcmNoIGZvci5cblx0KiBAcGFyYW0ge05vZGV9IHBhcmVudCAtIFRoZSBleHBlY3RlZCBwYXJlbnQuXG5cdCogQHJldHVybnMgeyhCb29sZWFufHVuZGVmaW5lZCl9IGB0cnVlYCBpZiB0aGUgYGNoaWxkYCBpcyBhY3R1YWxseSBhIGNoaWxkIG9mIGBwYXJlbnRgLlxuXHQqL1xuXHRpc1RhcmdldERlc2NlbmRhbnRPZjogZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuXHRcdHZhciBjID0gY2hpbGQ7XG5cdFx0d2hpbGUoYykge1xuXHRcdFx0aWYgKGMgPT0gcGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YyA9IGMucGFyZW50Tm9kZTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuKiBJbnN0YWxsZWQgb24gW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fSBhbmQgY2FsbGVkIGluIGV2ZW50IGNvbnRleHQuXG4qXG4qIEBwcml2YXRlXG4qL1xuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5zcmNFdmVudCkge1xuXHRcdHRoaXMuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fVxufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuZ2VzdHVyZS5kaXNhYmxlUHJldmVudGlvbiA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnByZXZlbnREZWZhdWx0ID0gdXRpbHMubm9wO1xuXHRpZiAodGhpcy5zcmNFdmVudCkge1xuXHRcdHRoaXMuc3JjRXZlbnQucHJldmVudERlZmF1bHQgPSB1dGlscy5ub3A7XG5cdH1cbn07XG5cbmRpc3BhdGNoZXIuZmVhdHVyZXMucHVzaChcblx0ZnVuY3Rpb24oZSkge1xuXHRcdC8vIE5PVEU6IGJld2FyZSBvZiBwcm9wZXJ0aWVzIGluIGdlc3R1cmUgaW5hZHZlcnRlbnRseSBtYXBwZWQgdG8gZXZlbnQgdHlwZXNcblx0XHRpZiAoZ2VzdHVyZS5ldmVudHNbZS50eXBlXSkge1xuXHRcdFx0cmV0dXJuIGdlc3R1cmUuZXZlbnRzW2UudHlwZV0oZSk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vKipcbiogQG5hbWVzcGFjZSBnZXN0dXJlLmV2ZW50c1xuKiBAcHVibGljXG4qL1xuZ2VzdHVyZS5ldmVudHMgPVxuXHQvKiogQGxlbmRzIGdlc3R1cmUuZXZlbnRzICovIHtcblxuXHQvKipcblx0KiBTaG9ydGN1dCB0byBbZ2VzdHVyZS5kb3duKClde0BsaW5rIGdlc3R1cmUuZG93bn0uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuXHRcdGdlc3R1cmUuZG93bihlKTtcblx0fSxcblxuXHQvKipcblx0KiBTaG9ydGN1dCB0byBbZ2VzdHVyZS51cCgpXXtAbGluayBnZXN0dXJlLnVwfS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bW91c2V1cDogZnVuY3Rpb24oZSkge1xuXHRcdGdlc3R1cmUudXAoZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2hvcnRjdXQgdG8gW2dlc3R1cmUubW92ZSgpXXtAbGluayBnZXN0dXJlLm1vdmV9LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRtb3VzZW1vdmU6ICBmdW5jdGlvbihlKSB7XG5cdFx0Z2VzdHVyZS5tb3ZlKGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNob3J0Y3V0IHRvIFtnZXN0dXJlLm92ZXIoKV17QGxpbmsgZ2VzdHVyZS5vdmVyfS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bW91c2VvdmVyOiAgZnVuY3Rpb24oZSkge1xuXHRcdGdlc3R1cmUub3ZlcihlKTtcblx0fSxcblxuXHQvKipcblx0KiBTaG9ydGN1dCB0byBbZ2VzdHVyZS5vdXQoKV17QGxpbmsgZ2VzdHVyZS5vdXR9LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRtb3VzZW91dDogIGZ1bmN0aW9uKGUpIHtcblx0XHRnZXN0dXJlLm91dChlKTtcblx0fVxufTtcblxuLy8gRmlyZWZveCBtb3VzZXdoZWVsIGhhbmRsaW5nXG5Eb20ucmVxdWlyZXNXaW5kb3coZnVuY3Rpb24oKSB7XG5cdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBmdW5jdGlvbihpbkV2ZW50KSB7XG5cdFx0XHR2YXIgZSA9IHV0aWxzLmNsb25lKGluRXZlbnQpO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9O1xuXHRcdFx0ZS50eXBlID0gJ21vdXNld2hlZWwnO1xuXHRcdFx0dmFyIHAgPSBlLlZFUlRJQ0FMX0FYSVMgPT0gZS5heGlzID8gJ3doZWVsRGVsdGFZJyA6ICd3aGVlbERlbHRhWCc7XG5cdFx0XHRlW3BdID0gIGUuZGV0YWlsICogLTQwO1xuXHRcdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChlKTtcblx0XHR9LCBmYWxzZSk7XG5cdH1cbn0pO1xuXG5cblxuLyoqXG4qIFRoZSBleHRlbmRlZCB7QGdsb3NzYXJ5IGV2ZW50fSBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0aGF0IGlzIHByb3ZpZGVkIHdoZW4gd2VcbiogZW11bGF0ZSBpT1MgZ2VzdHVyZSBldmVudHMgb24gbm9uLWlPUyBkZXZpY2VzLlxuKlxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLmdlc3R1cmV+RW11bGF0ZWRHZXN0dXJlRXZlbnRcbiogQHByb3BlcnR5IHtOdW1iZXJ9IHBhZ2VYIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIHBvaW50IGJldHdlZW4gZmluZ2Vycy5cbiogQHByb3BlcnR5IHtOdW1iZXJ9IHBhZ2VZIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIHBvaW50IGJldHdlZW4gZmluZ2Vycy5cbiogQHByb3BlcnR5IHtOdW1iZXJ9IHJvdGF0aW9uIC0gVGhlIGRlZ3JlZXMgb2Ygcm90YXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnZXN0dXJlLlxuKiBAcHJvcGVydHkge051bWJlcn0gc2NhbGUgLSBUaGUgcGVyY2VudCBjaGFuZ2Ugb2YgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXJzLlxuKi9cblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuaWYgKCFwbGF0Zm9ybS5nZXN0dXJlICYmIHBsYXRmb3JtLnRvdWNoKSB7XG5cdGRpc3BhdGNoZXIuZmVhdHVyZXMucHVzaChmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGhhbmRsZXJzW2UudHlwZV0pIHtcblx0XHRcdHRvdWNoR2VzdHVyZXNbZS50eXBlXShlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiogQHByaXZhdGVcbiovXG52YXIgaGFuZGxlcnMgPSB7XG5cdHRvdWNoc3RhcnQ6IHRydWUsXG5cdHRvdWNobW92ZTogdHJ1ZSxcblx0dG91Y2hlbmQ6IHRydWVcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbnZhciB0b3VjaEdlc3R1cmVzID0ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG9yZGVyZWRUb3VjaGVzOiBbXSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXN0dXJlOiBudWxsLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gc29tZSBkZXZpY2VzIGNhbiBzZW5kIG11bHRpcGxlIGNoYW5nZWQgdG91Y2hlcyBvbiBzdGFydCBhbmQgZW5kXG5cdFx0dmFyIGksXG5cdFx0XHRjaGFuZ2VkVG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXMsXG5cdFx0XHRsZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IGNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXI7XG5cblx0XHRcdC8vIHNvbWUgZGV2aWNlcyBjYW4gc2VuZCBtdWx0aXBsZSB0b3VjaHN0YXJ0c1xuXHRcdFx0aWYgKHV0aWxzLmluZGV4T2YoaWQsIHRoaXMub3JkZXJlZFRvdWNoZXMpIDwgMCkge1xuXHRcdFx0XHR0aGlzLm9yZGVyZWRUb3VjaGVzLnB1c2goaWQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID49IDIgJiYgIXRoaXMuZ2VzdHVyZSkge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmdlc3R1cmVQb3NpdGlvbnMoZSk7XG5cblx0XHRcdHRoaXMuZ2VzdHVyZSA9IHRoaXMuZ2VzdHVyZVZlY3RvcihwKTtcblx0XHRcdHRoaXMuZ2VzdHVyZS5hbmdsZSA9IHRoaXMuZ2VzdHVyZUFuZ2xlKHApO1xuXHRcdFx0dGhpcy5nZXN0dXJlLnNjYWxlID0gMTtcblx0XHRcdHRoaXMuZ2VzdHVyZS5yb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgZyA9IHRoaXMubWFrZUdlc3R1cmUoJ2dlc3R1cmVzdGFydCcsIGUsIHt2ZWN0b3I6IHRoaXMuZ2VzdHVyZSwgc2NhbGU6IDEsIHJvdGF0aW9uOiAwfSk7XG5cdFx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKGcpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0b3VjaGVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBzb21lIGRldmljZXMgY2FuIHNlbmQgbXVsdGlwbGUgY2hhbmdlZCB0b3VjaGVzIG9uIHN0YXJ0IGFuZCBlbmRcblx0XHR2YXIgaSxcblx0XHRcdGNoYW5nZWRUb3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcyxcblx0XHRcdGxlbmd0aCA9IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dXRpbHMucmVtb3ZlKGNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXIsIHRoaXMub3JkZXJlZFRvdWNoZXMpO1xuXHRcdH1cblxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoIDw9IDEgJiYgdGhpcy5nZXN0dXJlKSB7XG5cdFx0XHR2YXIgdCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzW2UuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIC0gMV07XG5cblx0XHRcdC8vIGdlc3R1cmUgZW5kIHNlbmRzIGxhc3Qgcm90YXRpb24gYW5kIHNjYWxlLCB3aXRoIHRoZSB4L3kgb2YgdGhlIGxhc3QgZmluZ2VyXG5cdFx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKHRoaXMubWFrZUdlc3R1cmUoJ2dlc3R1cmVlbmQnLCBlLCB7dmVjdG9yOiB7eGNlbnRlcjogdC5wYWdlWCwgeWNlbnRlcjogdC5wYWdlWX0sIHNjYWxlOiB0aGlzLmdlc3R1cmUuc2NhbGUsIHJvdGF0aW9uOiB0aGlzLmdlc3R1cmUucm90YXRpb259KSk7XG5cdFx0XHR0aGlzLmdlc3R1cmUgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0b3VjaG1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuZ2VzdHVyZSkge1xuXHRcdFx0dmFyIGcgPSB0aGlzLm1ha2VHZXN0dXJlKCdnZXN0dXJlY2hhbmdlJywgZSk7XG5cdFx0XHR0aGlzLmdlc3R1cmUuc2NhbGUgPSBnLnNjYWxlO1xuXHRcdFx0dGhpcy5nZXN0dXJlLnJvdGF0aW9uID0gZy5yb3RhdGlvbjtcblx0XHRcdGVueW8uZGlzcGF0Y2goZyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZpbmRJZGVudGlmaWVkVG91Y2g6IGZ1bmN0aW9uICh0b3VjaGVzLCBpZCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCB0OyAodCA9IHRvdWNoZXNbaV0pOyBpKyspIHtcblx0XHRcdGlmICh0LmlkZW50aWZpZXIgPT09IGlkKSB7XG5cdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXN0dXJlUG9zaXRpb25zOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZmluZElkZW50aWZpZWRUb3VjaChlLnRvdWNoZXMsIHRoaXMub3JkZXJlZFRvdWNoZXNbMF0pO1xuXHRcdHZhciBsYXN0ID0gdGhpcy5maW5kSWRlbnRpZmllZFRvdWNoKGUudG91Y2hlcywgdGhpcy5vcmRlcmVkVG91Y2hlc1t0aGlzLm9yZGVyZWRUb3VjaGVzLmxlbmd0aCAtIDFdKTtcblx0XHR2YXIgZnggPSBmaXJzdC5wYWdlWCwgbHggPSBsYXN0LnBhZ2VYLCBmeSA9IGZpcnN0LnBhZ2VZLCBseSA9IGxhc3QucGFnZVk7XG5cdFx0Ly8gY2VudGVyIHRoZSBmaXJzdCB0b3VjaCBhcyAwLDBcblx0XHR2YXIgeCA9IGx4IC0gZngsIHkgPSBseSAtIGZ5O1xuXHRcdHZhciBoID0gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5LCBoOiBoLCBmeDogZngsIGx4OiBseCwgZnk6IGZ5LCBseTogbHl9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIEZpbmRzIHJvdGF0aW9uIGFuZ2xlLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdlc3R1cmVBbmdsZTogZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuXHRcdHZhciBwID0gcG9zaXRpb25zO1xuXHRcdC8vIHlheSBtYXRoISwgcmFkIC0+IGRlZ1xuXHRcdHZhciBhID0gTWF0aC5hc2luKHAueSAvIHAuaCkgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdFx0Ly8gZml4IGZvciByYW5nZSBsaW1pdHMgb2YgYXNpbiAoLTkwIHRvIDkwKVxuXHRcdC8vIFF1YWRyYW50cyBJSSBhbmQgSUlJXG5cdFx0aWYgKHAueCA8IDApIHtcblx0XHRcdGEgPSAxODAgLSBhO1xuXHRcdH1cblx0XHQvLyBRdWFkcmFudCBJVlxuXHRcdGlmIChwLnggPiAwICYmIHAueSA8IDApIHtcblx0XHRcdGEgKz0gMzYwO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fSxcblxuXHQvKipcblx0KiBGaW5kcyBib3VuZGluZyBib3guXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2VzdHVyZVZlY3RvcjogZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuXHRcdC8vIHRoZSBsZWFzdCByZWNlbnQgdG91Y2ggYW5kIHRoZSBtb3N0IHJlY2VudCB0b3VjaCBkZXRlcm1pbmUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZ2VzdHVyZSBldmVudFxuXHRcdHZhciBwID0gcG9zaXRpb25zO1xuXHRcdC8vIGNlbnRlciB0aGUgZmlyc3QgdG91Y2ggYXMgMCwwXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1hZ25pdHVkZTogcC5oLFxuXHRcdFx0eGNlbnRlcjogTWF0aC5hYnMoTWF0aC5yb3VuZChwLmZ4ICsgKHAueCAvIDIpKSksXG5cdFx0XHR5Y2VudGVyOiBNYXRoLmFicyhNYXRoLnJvdW5kKHAuZnkgKyAocC55IC8gMikpKVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bWFrZUdlc3R1cmU6IGZ1bmN0aW9uICh0eXBlLCBlLCBjYWNoZSkge1xuXHRcdHZhciB2ZWN0b3IsIHNjYWxlLCByb3RhdGlvbjtcblx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdHZlY3RvciA9IGNhY2hlLnZlY3Rvcjtcblx0XHRcdHNjYWxlID0gY2FjaGUuc2NhbGU7XG5cdFx0XHRyb3RhdGlvbiA9IGNhY2hlLnJvdGF0aW9uO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMuZ2VzdHVyZVBvc2l0aW9ucyhlKTtcblx0XHRcdHZlY3RvciA9IHRoaXMuZ2VzdHVyZVZlY3RvcihwKTtcblx0XHRcdHNjYWxlID0gdmVjdG9yLm1hZ25pdHVkZSAvIHRoaXMuZ2VzdHVyZS5tYWduaXR1ZGU7XG5cdFx0XHQvLyBnZXN0dXJlRXZlbnQucm90YXRpb24gaXMgZGlmZmVyZW5jZSBmcm9tIHRoZSBzdGFydGluZyBhbmdsZSwgY2xvY2t3aXNlXG5cdFx0XHRyb3RhdGlvbiA9ICgzNjAgKyB0aGlzLmdlc3R1cmVBbmdsZShwKSAtIHRoaXMuZ2VzdHVyZS5hbmdsZSkgJSAzNjA7XG5cdFx0fVxuXHRcdHZhciBldmVudCA9IHV0aWxzLmNsb25lKGUpO1xuXHRcdHJldHVybiB1dGlscy5taXhpbihldmVudCwge1xuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdHNjYWxlOiBzY2FsZSxcblx0XHRcdHBhZ2VYOiB2ZWN0b3IueGNlbnRlcixcblx0XHRcdHBhZ2VZOiB2ZWN0b3IueWNlbnRlcixcblx0XHRcdHJvdGF0aW9uOiByb3RhdGlvblxuXHRcdH0pO1xuXHR9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9kaXNwYXRjaGVyXCI6NTcsXCIuL2RvbVwiOjU4LFwiLi9wbGF0Zm9ybVwiOjcxLFwiLi91dGlsc1wiOjc1fV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9kaXNwYXRjaGVyJyksXG5cdGRvbSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2RvbScpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL3BsYXRmb3JtJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvdXRpbHMnKSxcblx0QW5pbWF0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9BbmltYXRvcicpO1xuXG52YXJcblx0Q2FyZEFycmFuZ2VyID0gcmVxdWlyZSgnLi4vQ2FyZEFycmFuZ2VyJyk7XG5cbi8qKlxuKiBGaXJlcyBhdCB0aGUgc3RhcnQgb2YgYSBwYW5lbCB0cmFuc2l0aW9uLCB3aGVuIFtzZXRJbmRleCgpXXtAbGluayBlbnlvLlBhbmVscyNzZXRJbmRleH1cbiogaXMgY2FsbGVkLCBhbmQgYWxzbyBkdXJpbmcgZHJhZ2dpbmcuXG4qXG4qIEBldmVudCBlbnlvLlBhbmVscyNvblRyYW5zaXRpb25TdGFydFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge051bWJlcn0gZnJvbUluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBvbGQgcGFuZWwuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSB0b0luZGV4ICAgLSBUaGUgaW5kZXggb2YgdGhlIG5ldyBwYW5lbC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIGF0IHRoZSBlbmQgb2YgYSBwYW5lbCB0cmFuc2l0aW9uLCB3aGVuIFtzZXRJbmRleCgpXXtAbGluayBlbnlvLlBhbmVscyNzZXRJbmRleH1cbiogaXMgY2FsbGVkLCBhbmQgYWxzbyBkdXJpbmcgZHJhZ2dpbmcuXG4qXG4qIEBldmVudCBlbnlvLlBhbmVscyNvblRyYW5zaXRpb25GaW5pc2hcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtOdW1iZXJ9IGZyb21JbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgb2xkIHBhbmVsLlxuKiBAcHJvcGVydHkge051bWJlcn0gdG9JbmRleCAgIC0gVGhlIGluZGV4IG9mIHRoZSBuZXcgcGFuZWwuXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBUaGUge0BsaW5rIGVueW8uUGFuZWxzfSBraW5kIGlzIGRlc2lnbmVkIHRvIHNhdGlzZnkgYSB2YXJpZXR5IG9mIGNvbW1vbiB1c2UgY2FzZXNcbiogZm9yIGFwcGxpY2F0aW9uIGxheW91dC4gVXNpbmcgYGVueW8uUGFuZWxzYCwgY29udHJvbHMgbWF5IGJlIGFycmFuZ2VkIGFzIChhbW9uZ1xuKiBvdGhlciB0aGluZ3MpIGEgY2Fyb3VzZWwsIGEgc2V0IG9mIGNvbGxhcHNpbmcgcGFuZWxzLCBhIGNhcmQgc3RhY2sgdGhhdCBmYWRlc1xuKiBiZXR3ZWVuIHBhbmVscywgb3IgYSBncmlkLlxuKlxuKiBBbnkgRW55byBjb250cm9sIG1heSBiZSBwbGFjZWQgaW5zaWRlIGFuIGBlbnlvLlBhbmVsc2AsIGJ1dCBieSBjb252ZW50aW9uIHdlXG4qIHJlZmVyIHRvIGVhY2ggb2YgdGhlc2UgY29udHJvbHMgYXMgYSBcInBhbmVsXCIuIEZyb20gdGhlIHNldCBvZiBwYW5lbHMgaW4gYW5cbiogYGVueW8uUGFuZWxzYCwgb25lIGlzIGNvbnNpZGVyZWQgdG8gYmUgYWN0aXZlLiBUaGUgYWN0aXZlIHBhbmVsIGlzIHNldCBieSBpbmRleFxuKiB1c2luZyB0aGUgW3NldEluZGV4KClde0BsaW5rIGVueW8uUGFuZWxzI3NldEluZGV4fSBtZXRob2QuIFRoZSBhY3R1YWwgbGF5b3V0IG9mXG4qIHRoZSBwYW5lbHMgdHlwaWNhbGx5IGNoYW5nZXMgZWFjaCB0aW1lIHRoZSBhY3RpdmUgcGFuZWwgaXMgc2V0LCBzdWNoIHRoYXQgdGhlIG5ld1xuKiBhY3RpdmUgcGFuZWwgaGFzIHRoZSBtb3N0IHByb21pbmVudCBwb3NpdGlvbi5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbUGFuZWxzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvcGFuZWxzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQHVpXG4qIEBjbGFzcyBlbnlvLlBhbmVsc1xuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHB1YmxpY1xuKi9cbnZhciBQYW5lbHMgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgIGVueW8uUGFuZWxzLnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uUGFuZWxzJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGFzc2VzOiAnZW55by1wYW5lbHMnLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLlBhbmVscy5wcm90b3R5cGVcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IHtcblx0XHQvKipcblx0XHQqIFRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHBhbmVsLiBUaGUgbGF5b3V0IG9mIHBhbmVscyBpcyBjb250cm9sbGVkIGJ5IHRoZVxuXHRcdCogW2xheW91dEtpbmRde0BsaW5rIGVueW8uUGFuZWxzI2xheW91dEtpbmR9LCBidXQgYXMgYSBydWxlLCB0aGUgYWN0aXZlIHBhbmVsXG5cdFx0KiBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1vc3QgcHJvbWluZW50IHBvc2l0aW9uLiBGb3IgZXhhbXBsZSwgaW4gdGhlIChkZWZhdWx0KVxuXHRcdCoge0BsaW5rIGVueW8uQ2FyZEFycmFuZ2VyfSBsYXlvdXQsIHRoZSBhY3RpdmUgcGFuZWwgaXMgc2hvd24gYW5kIHRoZSBvdGhlclxuXHRcdCogcGFuZWxzIGFyZSBoaWRkZW4uXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0ICAwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRpbmRleDogMCxcblxuXHRcdC8qKlxuXHRcdCogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgbWF5IGRyYWcgYmV0d2VlbiBwYW5lbHMuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0ZHJhZ2dhYmxlOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcGFuZWxzIGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uaW5nLCBlLmcuLCB3aGVuXG5cdFx0KiBbc2V0SW5kZXgoKV17QGxpbmsgZW55by5QYW5lbHMjc2V0SW5kZXh9IGlzIGNhbGxlZC5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0ICB0cnVlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRhbmltYXRlOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciBwYW5lbHMgXCJ3cmFwIGFyb3VuZFwiIHdoZW4gbW92aW5nIHBhc3QgdGhlIGVuZC5cblx0XHQqIFRoZSBhY3R1YWwgZWZmZWN0IGRlcGVuZHMgdXBvbiB0aGUgYXJyYW5nZXIgaW4gdXNlLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgIGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR3cmFwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogVGhlIGFycmFuZ2VyIGtpbmQgdG8gYmUgdXNlZCBmb3IgZHluYW1pYyBsYXlvdXQuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICAnQ2FyZEFycmFuZ2VyJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YXJyYW5nZXJLaW5kOiBDYXJkQXJyYW5nZXIsXG5cblx0XHQvKipcblx0XHQqIEJ5IGRlZmF1bHQsIGVhY2ggcGFuZWwgd2lsbCBiZSBzaXplZCB0byBmaXQgdGhlIFBhbmVscycgd2lkdGggd2hlbiB0aGVcblx0XHQqIHNjcmVlbiBzaXplIGlzIHN1ZmZpY2llbnRseSBuYXJyb3cgKGxlc3MgdGhhbiA4MDBweCkuIFNldCB0byBgZmFsc2VgIHRvXG5cdFx0KiBhdm9pZCB0aGlzIGJlaGF2aW9yLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgIHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG5hcnJvd0ZpdDogdHJ1ZVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uVHJhbnNpdGlvblN0YXJ0OiAnJyxcblx0XHRvblRyYW5zaXRpb25GaW5pc2g6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbmRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG5cdFx0b25kcmFnOiAnZHJhZycsXG5cdFx0b25kcmFnZmluaXNoOiAnZHJhZ2ZpbmlzaCcsXG5cdFx0b25zY3JvbGw6ICdkb21TY3JvbGwnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dG9vbHM6IFtcblx0XHR7a2luZDogQW5pbWF0b3IsIG9uU3RlcDogJ3N0ZXAnLCBvbkVuZDogJ2FuaW1hdGlvbkVuZGVkJ31cblx0XSxcblxuXHQvKipcblx0KiBUcmFja3MgY29tcGxldGlvbiBwZXJjZW50YWdlIGZvciBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gcGFuZWxzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZnJhY3Rpb246IDAsXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uUG9pbnRzID0gW107XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuYXJyYW5nZXJLaW5kQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5uYXJyb3dGaXRDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLmluZGV4Q2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRkaXNwYXRjaGVyLm1ha2VCdWJibGUodGhpcywgJ3Njcm9sbCcpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvbVNjcm9sbDogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdGlmICh0aGlzLm5vZGUuc2Nyb2xsTGVmdCA+IDApIHtcblx0XHRcdFx0Ly8gUmVzZXQgc2Nyb2xsTGVmdCBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm5vZGUuc2Nyb2xsTGVmdCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbml0Q29tcG9uZW50czoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jcmVhdGVDaHJvbWUodGhpcy50b29scyk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhcnJhbmdlcktpbmRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRMYXlvdXRLaW5kKHRoaXMuYXJyYW5nZXJLaW5kKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYXJyb3dGaXRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5hZGRSZW1vdmVDbGFzcyhQYW5lbHMuZ2V0TmFycm93Q2xhc3MoKSwgdGhpcy5uYXJyb3dGaXQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBXaGVuIHRoZSBlbnRpcmUgcGFuZWxzIGlzIGdvaW5nIGF3YXksIHRha2Ugbm90ZSBzbyB3ZSBkb24ndCB0cnkgYW5kIGRvIHNpbmdsZS1wYW5lbFxuXHRcdFx0Ly8gcmVtb3ZlIGxvZ2ljIHN1Y2ggYXMgY2hhbmdpbmcgdGhlIGluZGV4IGFuZCByZWZsb3dpbmcgd2hlbiBlYWNoIHBhbmVsIGlzIGRlc3Ryb3llZFxuXHRcdFx0dGhpcy5kZXN0cm95aW5nID0gdHJ1ZTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEFkanVzdHMgdGhlIGluZGV4IGlmIHRoZSByZW1vdmVkIGNvbnRyb2wgaXMgdGhlIGFjdGl2ZSBwYW5lbCBhbmQgcmVmbG93cyB0aGUgbGF5b3V0LlxuXHQqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbW92ZUNvbnRyb2w6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG5cdFx0XHQvLyBTa2lwIGV4dHJhIHdvcmsgZHVyaW5nIHBhbmVsIGRlc3RydWN0aW9uLlxuXHRcdFx0aWYgKHRoaXMuZGVzdHJveWluZykge1xuXHRcdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGp1c3QgaW5kZXggaWYgdGhlIGN1cnJlbnQgcGFuZWwgaXMgYmVpbmcgcmVtb3ZlZFxuXHRcdFx0Ly8gc28gaXQncyBlaXRoZXIgdGhlIHByZXZpb3VzIHBhbmVsIG9yIHRoZSBmaXJzdCBvbmUuXG5cdFx0XHR2YXIgbmV3SW5kZXggPSAtMTtcblx0XHRcdHZhciBjb250cm9sSW5kZXggPSB1dGlscy5pbmRleE9mKGNvbnRyb2wsIHRoaXMuY29udHJvbHMpO1xuXHRcdFx0aWYgKGNvbnRyb2xJbmRleCA9PT0gdGhpcy5pbmRleCkge1xuXHRcdFx0XHRuZXdJbmRleCA9IE1hdGgubWF4KGNvbnRyb2xJbmRleCAtIDEsIDApO1xuXHRcdFx0fVxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAobmV3SW5kZXggIT09IC0xICYmIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLnNldEluZGV4KG5ld0luZGV4KTtcblx0XHRcdFx0dGhpcy5mbG93KCk7XG5cdFx0XHRcdHRoaXMucmVmbG93KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogRGVzaWduZWQgdG8gYmUgb3ZlcnJpZGRlbiBpbiBraW5kcyBkZXJpdmVkIGZyb20gUGFuZWxzIHRoYXQgaGF2ZVxuXHQqIG5vbi1wYW5lbCBjbGllbnQgY29udHJvbHMuXG5cdCpcblx0KiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG5cdCogQHByb3RlY3RlZFxuXHQqIEB0b2RvICBBc3N1bWUgdGhhdCB0aGlzIHNob3VsZCB0YWtlIGEgY29udHJvbCBhcyBhIHBhcmFtZXRlci5cblx0Ki9cblx0aXNQYW5lbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmbG93OiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmFycmFuZ2VtZW50cyA9IFtdO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlZmxvdzoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5hcnJhbmdlbWVudHMgPSBbXTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgYXJyYXkgb2YgY29udGFpbmVkIHBhbmVscy4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyBpZiB0aGV5XG5cdCogZG9uJ3Qgd2FudCB0aGUgYXJyYW5nZXIgdG8gbGF5IG91dCBhbGwgb2YgdGhlaXIgY2hpbGRyZW4uXG5cdCpcblx0KiBAcmV0dXJuIHtlbnlvLkNvbnRyb2xbXX0gLSBUaGUgYXJyYXkgb2YgY29udGFpbmVkIHBhbmVscy5cblx0Ki9cblx0Z2V0UGFuZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHAgPSB0aGlzLmNvbnRyb2xQYXJlbnQgfHwgdGhpcztcblx0XHRyZXR1cm4gcC5jaGlsZHJlbjtcblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgcGFuZWwtLWkuZS4sIHRoZSBwYW5lbCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQqXG5cdCogQHJldHVybiB7ZW55by5Db250cm9sfSAtIFRoZSBhY3RpdmUgcGFuZWwuXG5cdCovXG5cdGdldEFjdGl2ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwJCA9IHRoaXMuZ2V0UGFuZWxzKCk7XG5cdFx0Ly9Db25zdHJhaW4gdGhlIGluZGV4IHdpdGhpbiB0aGUgYXJyYXkgb2YgcGFuZWxzLCBuZWVkZWQgaWYgd3JhcHBpbmcgaXMgZW5hYmxlZFxuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXggJSBwJC5sZW5ndGg7XG5cdFx0aWYgKGluZGV4IDwgMCkge1xuXHRcdFx0aW5kZXggKz0gcCQubGVuZ3RoO1xuXHRcdH1cblx0XHRyZXR1cm4gcCRbaW5kZXhdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHtAbGluayBlbnlvLkFuaW1hdG9yfSBpbnN0YW5jZSB1c2VkIHRvXG5cdCogYW5pbWF0ZSBwYW5lbCB0cmFuc2l0aW9ucy4gVGhlIFBhbmVscycgYW5pbWF0b3IgbWF5IGJlIHVzZWQgdG8gc2V0IHRoZVxuXHQqIGR1cmF0aW9uIG9mIHBhbmVsIHRyYW5zaXRpb25zLCBlLmcuOlxuXHQqXG5cdCogYGBgXG5cdCogdGhpcy5nZXRBbmltYXRvcigpLnNldER1cmF0aW9uKDEwMDApO1xuXHQqIGBgYFxuXHQqXG5cdCogQHJldHVybiB7ZW55by5BbmltYXRvcn0gLSBUaGUge0BsaW5rIGVueW8uQW5pbWF0b3J9IGluc3RhbmNlIHVzZWQgdG8gYW5pbWF0ZVxuXHQqIHBhbmVsIHRyYW5zaXRpb25zLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0QW5pbWF0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy4kLmFuaW1hdG9yO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIGFjdGl2ZSBwYW5lbCB0byB0aGUgcGFuZWwgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBpbmRleC5cblx0KiBOb3RlIHRoYXQgaWYgdGhlIFthbmltYXRlXXtAbGluayBlbnlvLlBhbmVscyNhbmltYXRlfSBwcm9wZXJ0eSBpcyBzZXQgdG9cblx0KiBgdHJ1ZWAsIHRoZSBhY3RpdmUgcGFuZWwgd2lsbCBhbmltYXRlIGludG8gdmlldy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcGFuZWwgdG8gYWN0aXZhdGUuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRJbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0Ly8gb3ZlcnJpZGUgc2V0SW5kZXggc28gdGhhdCBpbmRleENoYW5nZWQgaXMgY2FsbGVkXG5cdFx0Ly8gd2hldGhlciB0aGlzLmluZGV4IGhhcyBhY3R1YWxseSBjaGFuZ2VkIG9yIG5vdC4gQWxzbywgZG9cblx0XHQvLyBpbmRleCBjbGFtcGluZyBoZXJlLlxuXHRcdHZhciBwcmV2SW5kZXggPSB0aGlzLmdldCgnaW5kZXgnKSxcblx0XHRcdG5ld0luZGV4ID0gdGhpcy5jbGFtcChpbmRleCk7XG5cdFx0dGhpcy5pbmRleCA9IG5ld0luZGV4O1xuXHRcdHRoaXMubm90aWZ5T2JzZXJ2ZXJzKCdpbmRleCcsIHByZXZJbmRleCwgbmV3SW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIGFjdGl2ZSBwYW5lbCB0byB0aGUgcGFuZWwgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBpbmRleC5cblx0KiBUaGUgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBwYW5lbCB3aWxsIGJlIGltbWVkaWF0ZSBhbmQgd2lsbCBub3QgYmUgYW5pbWF0ZWQsXG5cdCogcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgdGhlIFthbmltYXRlXXtAbGluayBlbnlvLlBhbmVscyNhbmltYXRlfSBwcm9wZXJ0eS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcGFuZWwgdG8gYWN0aXZhdGUuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRJbmRleERpcmVjdDogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0aWYgKHRoaXMuYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5hbmltYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGV4KTtcblx0XHRcdHRoaXMuYW5pbWF0ZSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kZXgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBTZWxlY3RzIHRoZSBuYW1lZCBjb21wb25lbnQgb3duZWQgYnkgdGhlIFBhbmVscyBhbmQgcmV0dXJucyBpdHMgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFuZWwgdG8gYWN0aXZhdGUuXG5cdCogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIG5ld2x5IGFjdGl2YXRlZCBwYW5lbC5cblx0KiBAcHVibGljXG5cdCovXG5cdHNlbGVjdFBhbmVsQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghbmFtZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgaWR4ID0gMDtcblx0XHR2YXIgcGFuZWxzID0gdGhpcy5nZXRQYW5lbHMoKTtcblx0XHR2YXIgbGVuID0gcGFuZWxzLmxlbmd0aDtcblx0XHRmb3IgKDsgaWR4IDwgbGVuOyArK2lkeCkge1xuXHRcdFx0aWYgKG5hbWUgPT09IHBhbmVsc1tpZHhdLm5hbWUpIHtcblx0XHRcdFx0dGhpcy5zZXRJbmRleChpZHgpO1xuXHRcdFx0XHRyZXR1cm4gaWR4O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBUcmFuc2l0aW9ucyB0byB0aGUgcHJldmlvdXMgcGFuZWwtLWkuZS4sIHRoZSBwYW5lbCB3aG9zZSBpbmRleCB2YWx1ZSBpcyBvbmVcblx0KiBsZXNzIHRoYW4gdGhhdCBvZiB0aGUgY3VycmVudCBhY3RpdmUgcGFuZWwuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZXZJbmRleCA9IHRoaXMuaW5kZXggLSAxO1xuXHRcdGlmICh0aGlzLndyYXAgJiYgcHJldkluZGV4IDwgMCkge1xuXHRcdFx0cHJldkluZGV4ID0gdGhpcy5nZXRQYW5lbHMoKS5sZW5ndGggLSAxO1xuXHRcdH1cblx0XHR0aGlzLnNldEluZGV4KHByZXZJbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogVHJhbnNpdGlvbnMgdG8gdGhlIG5leHQgcGFuZWwtLWkuZS4sIHRoZSBwYW5lbCB3aG9zZSBpbmRleCB2YWx1ZSBpcyBvbmVcblx0KiBncmVhdGVyIHRoYW4gdGhhdCBvZiB0aGUgY3VycmVudCBhY3RpdmUgcGFuZWwuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbmV4dEluZGV4ID0gdGhpcy5pbmRleCsxO1xuXHRcdGlmICh0aGlzLndyYXAgJiYgbmV4dEluZGV4ID49IHRoaXMuZ2V0UGFuZWxzKCkubGVuZ3RoKSB7XG5cdFx0XHRuZXh0SW5kZXggPSAwO1xuXHRcdH1cblx0XHR0aGlzLnNldEluZGV4KG5leHRJbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5zdXJlcyB0aGF0IGB2YWx1ZWAgcmVmZXJlbmNlcyBhIHZhbGlkIHBhbmVsLCBhY2NvdW50aW5nIGZvclxuXHQqIFt3cmFwcGluZ117QGxpbmsgZW55by5QYW5lbHMjd3JhcH0uXG5cdCpcblx0KiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIGluZGV4IG9mIGEgcGFuZWwuXG5cdCogQHJldHVybiB7TnVtYmVyfSAgICAgICAtIFRoZSB2YWxpZCBpbmRleCBvZiBhIHBhbmVsLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsYW1wOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIgbCA9IHRoaXMuZ2V0UGFuZWxzKCkubGVuZ3RoO1xuXHRcdGlmICh0aGlzLndyYXApIHtcblx0XHRcdC8vIEZJWE1FOiBkcmFnZ2luZyBtYWtlcyBhc3N1bXB0aW9ucyBhYm91dCBkaXJlY3Rpb24gYW5kIGZyb20tPnN0YXJ0IGluZGV4ZXMuXG5cdFx0XHQvL3JldHVybiB2YWx1ZSA8IDAgPyBsIDogKHZhbHVlID4gbCA/IDAgOiB2YWx1ZSk7XG5cdFx0XHR2YWx1ZSAlPSBsO1xuXHRcdFx0cmV0dXJuICh2YWx1ZSA8IDApID8gdmFsdWUgKyBsIDogdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZSwgbCAtIDEpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5kZXhDaGFuZ2VkOiBmdW5jdGlvbiAob2xkKSB7XG5cdFx0dGhpcy5sYXN0SW5kZXggPSBvbGQ7XG5cdFx0aWYgKCF0aGlzLmRyYWdnaW5nICYmIHRoaXMuJC5hbmltYXRvciAmJiB0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0aWYgKHRoaXMuc2hvdWxkQW5pbWF0ZSgpKSB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIG1pZC10cmFuc2l0aW9uLCBjb21wbGV0ZSBpdCBhbmQgaW5kaWNhdGUgd2UgbmVlZCB0byB0cmFuc2l0aW9uXG5cdFx0XHRcdGlmICh0aGlzLiQuYW5pbWF0b3IuaXNBbmltYXRpbmcoKSkge1xuXHRcdFx0XHRcdHRoaXMudHJhbnNpdGlvbk9uQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuJC5hbmltYXRvci5jb21wbGV0ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYW5pbWF0ZVRyYW5zaXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kaXJlY3RUcmFuc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYW5lbHMgc2hvdWxkIGFuaW1hdGUgaW4gdGhlIHRyYW5zaXRpb24gZnJvbSBgZnJvbUluZGV4YCB0b1xuXHQqIGB0b0luZGV4YC4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBhIHtAZ2xvc3Nhcnkgc3Via2luZH0gZm9yIGdyZWF0ZXIgY3VzdG9taXphdGlvbi5cblx0KlxuXHQqIEBwcm90ZWN0ZWRcblx0Ki9cblx0c2hvdWxkQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGU7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RlcDogZnVuY3Rpb24gKHNlbmRlcikge1xuXHRcdHRoaXMuZnJhY3Rpb24gPSBzZW5kZXIudmFsdWU7XG5cdFx0dGhpcy5zdGVwVHJhbnNpdGlvbigpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFuaW1hdGlvbkVuZGVkOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMuY29tcGxldGVkKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29tcGxldGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5maW5pc2hUcmFuc2l0aW9uKCk7XG5cblx0XHQvLyBBbmltYXRvci5vbkVuZCBmaXJlcyBhc3luY2hyb25vdXNseSBzbyB3ZSBuZWVkIGFuIGludGVybmFsIGZsYWcgdG8gaW5kaWNhdGUgd2UgbmVlZFxuXHRcdC8vIHRvIHN0YXJ0IHRoZSBuZXh0IHRyYW5zaXRpb24gd2hlbiB0aGUgcHJldmlvdXMgY29tcGxldGVzXG5cdFx0aWYgKHRoaXMudHJhbnNpdGlvbk9uQ29tcGxldGUpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbk9uQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYW5pbWF0ZVRyYW5zaXRpb24oKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnc3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZHJhZ2dhYmxlICYmIHRoaXMubGF5b3V0ICYmIHRoaXMubGF5b3V0LmNhbkRyYWdFdmVudChldmVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLmRyYWdzdGFydFRyYW5zaXRpb24oZXZlbnQpO1xuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdFx0XHR0aGlzLiQuYW5pbWF0b3Iuc3RvcCgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWc6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLmRyYWdUcmFuc2l0aW9uKGV2ZW50KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ2ZpbmlzaDogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0ZXZlbnQucHJldmVudFRhcCgpO1xuXHRcdFx0dGhpcy5kcmFnZmluaXNoVHJhbnNpdGlvbihldmVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdzdGFydFRyYW5zaXRpb246IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICghdGhpcy4kLmFuaW1hdG9yLmlzQW5pbWF0aW5nKCkpIHtcblx0XHRcdHZhciBmID0gdGhpcy5mcm9tSW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdFx0dGhpcy50b0luZGV4ID0gZiAtICh0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LmNhbGNEcmFnRGlyZWN0aW9uKGV2ZW50KSA6IDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZlcmlmeURyYWdUcmFuc2l0aW9uKGV2ZW50KTtcblx0XHR9XG5cdFx0dGhpcy5mcm9tSW5kZXggPSB0aGlzLmNsYW1wKHRoaXMuZnJvbUluZGV4KTtcblx0XHR0aGlzLnRvSW5kZXggPSB0aGlzLmNsYW1wKHRoaXMudG9JbmRleCk7XG5cdFx0Ly90aGlzLmxvZyh0aGlzLmZyb21JbmRleCwgdGhpcy50b0luZGV4KTtcblx0XHR0aGlzLmZpcmVUcmFuc2l0aW9uU3RhcnQoKTtcblx0XHRpZiAodGhpcy5sYXlvdXQpIHtcblx0XHRcdHRoaXMubGF5b3V0LnN0YXJ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBub3RlOiBmb3Igc2ltcGxpY2l0eSB3ZSBjaG9vc2UgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBkaXJlY3RseSBiZXR3ZWVuXG5cdFx0Ly8gdGhlIGZpcnN0IGFuZCBsYXN0IHRyYW5zaXRpb24gcG9pbnQuXG5cdFx0dmFyIGQgPSB0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LmNhbGNEcmFnKGV2ZW50KSA6IDA7XG5cdFx0dmFyIHQkID0gdGhpcy50cmFuc2l0aW9uUG9pbnRzLCBzID0gdCRbMF0sIGYgPSB0JFt0JC5sZW5ndGgtMV07XG5cdFx0dmFyIGFzID0gdGhpcy5mZXRjaEFycmFuZ2VtZW50KHMpO1xuXHRcdHZhciBhZiA9IHRoaXMuZmV0Y2hBcnJhbmdlbWVudChmKTtcblx0XHR2YXIgZHggPSB0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LmRyYWcoZCwgcywgYXMsIGYsIGFmKSA6IDA7XG5cdFx0dmFyIGRyYWdGYWlsID0gZCAmJiAhZHg7XG5cdFx0aWYgKGRyYWdGYWlsKSB7XG5cdFx0XHQvL3RoaXMubG9nKGR4LCBzLCBhcywgZiwgYWYpO1xuXHRcdH1cblx0XHR0aGlzLmZyYWN0aW9uICs9IGR4O1xuXHRcdHZhciBmciA9IHRoaXMuZnJhY3Rpb247XG5cdFx0aWYgKGZyID4gMSB8fCBmciA8IDAgfHwgZHJhZ0ZhaWwpIHtcblx0XHRcdGlmIChmciA+IDAgfHwgZHJhZ0ZhaWwpIHtcblx0XHRcdFx0dGhpcy5kcmFnZmluaXNoVHJhbnNpdGlvbihldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRyYWdzdGFydFRyYW5zaXRpb24oZXZlbnQpO1xuXHRcdFx0dGhpcy5mcmFjdGlvbiA9IDA7XG5cdFx0XHQvLyBGSVhNRTogYWNjb3VudCBmb3IgbG9zdCBmcmFjdGlvblxuXHRcdFx0Ly90aGlzLmRyYWdUcmFuc2l0aW9uKGV2ZW50KTtcblx0XHR9XG5cdFx0dGhpcy5zdGVwVHJhbnNpdGlvbigpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdmaW5pc2hUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLnZlcmlmeURyYWdUcmFuc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLnNldEluZGV4KHRoaXMudG9JbmRleCk7XG5cdFx0Ly8gbm90ZTogaWYgd2UncmUgc3RpbGwgZHJhZ2dpbmcsIHRoZW4gd2UncmUgYXQgYSB0cmFuc2l0aW9uIGJvdW5kYXJ5XG5cdFx0Ly8gYW5kIHNob3VsZCBmaXJlIHRoZSBmaW5pc2ggZXZlbnRcblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xuXHRcdFx0dGhpcy5maXJlVHJhbnNpdGlvbkZpbmlzaCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR2ZXJpZnlEcmFnVHJhbnNpdGlvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGQgPSB0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LmNhbGNEcmFnRGlyZWN0aW9uKGV2ZW50KSA6IDA7XG5cdFx0dmFyIGYgPSBNYXRoLm1pbih0aGlzLmZyb21JbmRleCwgdGhpcy50b0luZGV4KTtcblx0XHR2YXIgdCA9IE1hdGgubWF4KHRoaXMuZnJvbUluZGV4LCB0aGlzLnRvSW5kZXgpO1xuXHRcdGlmIChkID4gMCkge1xuXHRcdFx0dmFyIHMgPSBmO1xuXHRcdFx0ZiA9IHQ7XG5cdFx0XHR0ID0gcztcblx0XHR9XG5cdFx0aWYgKGYgIT0gdGhpcy5mcm9tSW5kZXgpIHtcblx0XHRcdHRoaXMuZnJhY3Rpb24gPSAxIC0gdGhpcy5mcmFjdGlvbjtcblx0XHR9XG5cdFx0Ly90aGlzLmxvZygnb2xkJywgdGhpcy5mcm9tSW5kZXgsIHRoaXMudG9JbmRleCwgJ25ldycsIGYsIHQpO1xuXHRcdHRoaXMuZnJvbUluZGV4ID0gZjtcblx0XHR0aGlzLnRvSW5kZXggPSB0O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyB0aGUgcGFuZWxzIHdpdGhvdXQgc2VuZGluZyBhbnkgZXZlbnRzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLiQuYW5pbWF0b3IgJiYgdGhpcy4kLmFuaW1hdG9yLmlzQW5pbWF0aW5nKCkpIHtcblx0XHRcdHRoaXMuJC5hbmltYXRvci5zdG9wKCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0dXBUcmFuc2l0aW9uKCk7XG5cdFx0dGhpcy5mcmFjdGlvbiA9IDE7XG5cdFx0dGhpcy5zdGVwVHJhbnNpdGlvbigpO1xuXHRcdHRoaXMudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuY29tcGxldGVUcmFuc2l0aW9uKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogVHJhbnNpdGlvbnMgdG8gdGhlIG5ldyBpbmRleCB3aXRob3V0IGFuaW1hdGlvblxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlyZWN0VHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uKCk7XG5cdFx0dGhpcy5mcmFjdGlvbiA9IDE7XG5cdFx0dGhpcy5zdGVwVHJhbnNpdGlvbigpO1xuXHRcdHRoaXMuZmluaXNoVHJhbnNpdGlvbigpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFuaW1hdGVzIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgaW5kZXhcblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFuaW1hdGVUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zdGFydFRyYW5zaXRpb24oKTtcblx0XHR0aGlzLiQuYW5pbWF0b3IucGxheSh7XG5cdFx0XHRzdGFydFZhbHVlOiB0aGlzLmZyYWN0aW9uXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCogU3RhcnRzIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIHBhbmVscy4gaWYgYSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHRoaXMgaXNcblx0KiBhIG5vLW9wLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhcnRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLnRyYW5zaXRpb25pbmcpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbmluZyA9IHRydWU7XG5cdFx0XHR0aGlzLnNldHVwVHJhbnNpdGlvbigpO1xuXHRcdFx0dGhpcy5maXJlVHJhbnNpdGlvblN0YXJ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdXAgdHJhbnNpdGlvbiBzdGF0ZVxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0dXBUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5mcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleCAhPSBudWxsID8gdGhpcy5mcm9tSW5kZXggOiB0aGlzLmxhc3RJbmRleCB8fCAwO1xuXHRcdHRoaXMudG9JbmRleCA9IHRoaXMudG9JbmRleCAhPSBudWxsID8gdGhpcy50b0luZGV4IDogdGhpcy5pbmRleDtcblx0XHRpZiAodGhpcy5sYXlvdXQpIHtcblx0XHRcdHRoaXMubGF5b3V0LnN0YXJ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENvbXBsZXRlcyB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBwYW5lbHMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaW5pc2hUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5jb21wbGV0ZVRyYW5zaXRpb24odHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQ29tcGxldGVzIHRoZSB0cmFuc2l0aW9uIGJ5IHBlcmZvcm1pbmcgYW55IHRhc2tzIHRvIGJlIHJ1biB3aGVuIHRoZSB0cmFuc2l0aW9uIGVuZHMsXG5cdCogaW5jbHVkaW5nIGZpcmluZyBldmVudHMgYW5kIGNsZWFuLXVwLlxuXHQqXG5cdCogQHBhcmFtIHtCb29sZWFufSBbZmlyZV0gLSBJZiBgdHJ1ZWAsIHdpbGwgZmlyZSB0aGUge0BsaW5rIGVueW8uUGFuZWxzI29uVHJhbnNpdGlvbkZpbmlzaH1cblx0Klx0ZXZlbnQgaWYgZGVlbWVkIG5lY2Vzc2FyeS5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZVRyYW5zaXRpb246IGZ1bmN0aW9uIChmaXJlKSB7XG5cdFx0aWYgKHRoaXMubGF5b3V0KSB7XG5cdFx0XHR0aGlzLmxheW91dC5maW5pc2goKTtcblx0XHR9XG5cblx0XHRpZiAoZmlyZSkge1xuXHRcdFx0dGhpcy5maXJlVHJhbnNpdGlvbkZpbmlzaCh0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jbGVhclRyYW5zaXRpb25EYXRhKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENsZWFycyB0cmFuc2l0aW9uLXJlbGF0ZWQgZGF0YS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsZWFyVHJhbnNpdGlvbkRhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNpdGlvblBvaW50cyA9IFtdO1xuXHRcdHRoaXMuZnJhY3Rpb24gPSAwO1xuXHRcdHRoaXMuZnJvbUluZGV4ID0gdGhpcy50b0luZGV4ID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5QYW5lbHMjb25UcmFuc2l0aW9uU3RhcnRcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaXJlVHJhbnNpdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHQgPSB0aGlzLnN0YXJ0VHJhbnNpdGlvbkluZm87XG5cdFx0aWYgKHRoaXMuaGFzTm9kZSgpICYmICghdCB8fCAodC5mcm9tSW5kZXggIT0gdGhpcy5mcm9tSW5kZXggfHwgdC50b0luZGV4ICE9IHRoaXMudG9JbmRleCkpKSB7XG5cdFx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvbkluZm8gPSB7ZnJvbUluZGV4OiB0aGlzLmZyb21JbmRleCwgdG9JbmRleDogdGhpcy50b0luZGV4fTtcblx0XHRcdHRoaXMuZG9UcmFuc2l0aW9uU3RhcnQodXRpbHMuY2xvbmUodGhpcy5zdGFydFRyYW5zaXRpb25JbmZvKSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBmaXJlcyBlbnlvLlBhbmVscyNvblRyYW5zaXRpb25GaW5pc2hcblx0KiBAcGFyYW0ge0Jvb2xlYW59IFtjbGVhckRhdGFdIC0gSWYgYHRydWVgLCB7QGxpbmsgZW55by5QYW5lbHMjY2xlYXJUcmFuc2l0aW9uRGF0YX0gd2lsbCBiZVxuXHQqXHRjYWxsZWQgYWZ0ZXIgcmVjb3JkaW5nIHRoZSB2YWx1ZXMgbmVlZGVkIGZvciB0aGUgY2FsbGJhY2suXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZmlyZVRyYW5zaXRpb25GaW5pc2g6IGZ1bmN0aW9uIChjbGVhckRhdGEpIHtcblx0XHR2YXIgdCA9IHRoaXMuZmluaXNoVHJhbnNpdGlvbkluZm8sXG5cdFx0XHRmcm9tSW5kZXggPSB0ID8gdC5mcm9tSW5kZXggOiBudWxsLFxuXHRcdFx0dG9JbmRleCA9IHQgPyB0LnRvSW5kZXggOiBudWxsO1xuXHRcdGlmICh0aGlzLmhhc05vZGUoKSAmJiAoIXQgfHwgKGZyb21JbmRleCAhPSB0aGlzLmZyb21JbmRleCB8fCB0b0luZGV4ICE9IHRoaXMudG9JbmRleCkpKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRyYW5zaXRpb25PbkNvbXBsZXRlKSB7XG5cdFx0XHRcdHRoaXMuZmluaXNoVHJhbnNpdGlvbkluZm8gPSB7ZnJvbUluZGV4OiB0b0luZGV4LCB0b0luZGV4OiB0aGlzLmxhc3RJbmRleH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5maW5pc2hUcmFuc2l0aW9uSW5mbyA9IHtmcm9tSW5kZXg6IHRoaXMubGFzdEluZGV4LCB0b0luZGV4OiB0aGlzLmluZGV4fTtcblx0XHRcdFx0fVxuXHRcdFx0aWYgKGNsZWFyRGF0YSkge1xuXHRcdFx0XHR0aGlzLmNsZWFyVHJhbnNpdGlvbkRhdGEoKTtcblx0XHRcdH1cblx0XHRcdFx0dGhpcy5kb1RyYW5zaXRpb25GaW5pc2goZW55by5jbG9uZSh0aGlzLmZpbmlzaFRyYW5zaXRpb25JbmZvKSk7XG5cdFx0fSBlbHNlIGlmIChjbGVhckRhdGEpIHtcblx0XHRcdHRoaXMuY2xlYXJUcmFuc2l0aW9uRGF0YSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBJbnRlcnBvbGF0ZXMgYmV0d2VlbiBhcnJhbmdlbWVudHMgYXMgbmVlZGVkLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RlcFRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdC8vIHNlbGVjdCBjb3JyZWN0IHRyYW5zaXRpb24gcG9pbnRzIGFuZCBub3JtYWxpemUgZnJhY3Rpb24uXG5cdFx0XHR2YXIgdCQgPSB0aGlzLnRyYW5zaXRpb25Qb2ludHM7XG5cdFx0XHR2YXIgciA9ICh0aGlzLmZyYWN0aW9uIHx8IDApICogKHQkLmxlbmd0aC0xKTtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihyKTtcblx0XHRcdHIgPSByIC0gaTtcblx0XHRcdHZhciBzID0gdCRbaV0sIGYgPSB0JFtpKzFdO1xuXHRcdFx0Ly8gZ2V0IGFycmFuZ2VtZW50cyBhbmQgbGVycCBiZXR3ZWVuIHRoZW1cblx0XHRcdHZhciBzMCA9IHRoaXMuZmV0Y2hBcnJhbmdlbWVudChzKTtcblx0XHRcdHZhciBzMSA9IHRoaXMuZmV0Y2hBcnJhbmdlbWVudChmKTtcblx0XHRcdHRoaXMuYXJyYW5nZW1lbnQgPSBzMCAmJiBzMSA/IFBhbmVscy5sZXJwKHMwLCBzMSwgcikgOiAoczAgfHwgczEpO1xuXHRcdFx0aWYgKHRoaXMuYXJyYW5nZW1lbnQgJiYgdGhpcy5sYXlvdXQpIHtcblx0XHRcdFx0dGhpcy5sYXlvdXQuZmxvd0FycmFuZ2VtZW50KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEZldGNoZXMgdGhlIGFycmFuZ2VtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4LCBpbml0aWFsaXppbmcgaXQgaWYgbmVjZXNzYXJ5LlxuXHQqXG5cdCogQHBhcmFtICB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZGVzaXJlZCBhcnJhbmdlbWVudCBmcm9tIGB0cmFuc2l0aW9uUG9pbnRzYC5cblx0KiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZXNpcmVkIGFycmFuZ2VtZW50IG9iamVjdC5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmZXRjaEFycmFuZ2VtZW50OiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRpZiAoKGluZGV4ICE9IG51bGwpICYmICF0aGlzLmFycmFuZ2VtZW50c1tpbmRleF0gJiYgdGhpcy5sYXlvdXQpIHtcblx0XHRcdHRoaXMubGF5b3V0Ll9hcnJhbmdlKGluZGV4KTtcblx0XHRcdHRoaXMuYXJyYW5nZW1lbnRzW2luZGV4XSA9IHRoaXMucmVhZEFycmFuZ2VtZW50KHRoaXMuZ2V0UGFuZWxzKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hcnJhbmdlbWVudHNbaW5kZXhdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEl0ZXJhdGVzIG92ZXIgYHBhbmVsc2AgYW5kIHJldHJpZXZlcyBhIGNvcHkgb2YgZWFjaCBwYW5lbCdzIGBfYXJyYW5nZXJgLlxuXHQqXG5cdCogQHBhcmFtICB7ZW55by5Db250cm9sW119IHBhbmVscyAtIFRoZSBhcnJheSBvZiBwYW5lbHMuXG5cdCogQHJldHVybiB7T2JqZWN0W119ICAgICAgICAgICAgICAtIFRoZSBhcnJheSBvZiBhcnJhbmdlbWVudCBvYmplY3RzLlxuXHQqL1xuXHRyZWFkQXJyYW5nZW1lbnQ6IGZ1bmN0aW9uIChwYW5lbHMpIHtcblx0XHR2YXIgciA9IFtdO1xuXHRcdGZvciAodmFyIGk9MCwgYyQ9cGFuZWxzLCBjOyAoYz1jJFtpXSk7IGkrKykge1xuXHRcdFx0ci5wdXNoKHV0aWxzLmNsb25lKGMuX2FycmFuZ2VyKSk7XG5cdFx0fVxuXHRcdHJldHVybiByO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBsZW5kcyAgZW55by5QYW5lbHNcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGF0aWNzOiB7XG5cdFx0LyoqXG5cdFx0KiBSZXR1cm5zIGB0cnVlYCBmb3IgaU9TIGFuZCBBbmRyb2lkIHBob25lIGZvcm0gZmFjdG9ycywgb3Igd2hlbiB3aW5kb3cgd2lkdGhcblx0XHQqIGlzIDgwMHB4IG9yIGxlc3MuIEFwcHJveGltYXRlcyB3b3JrIGRvbmUgdXNpbmcgbWVkaWEgcXVlcmllcyBpbiBgUGFuZWxzLmNzc2AuXG5cdFx0KlxuXHRcdCogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGZvciBuYXJyb3cgZGV2aWNlcyBvciB2aWV3cG9ydHM7IG90aGVyd2lzZSwgYGZhbHNlYC5cblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGlzU2NyZWVuTmFycm93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZihQYW5lbHMuaXNOYXJyb3dEZXZpY2UoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBkb20uZ2V0V2luZG93V2lkdGgoKSA8PSA4MDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogUmV0dXJucyB0aGUgY2xhc3MgbmFtZSB0byBhcHBseSBmb3IgbmFycm93IGZpdHRpbmcuIFNlZSBtZWRpYSBxdWVyaWVzXG5cdFx0KiBpbiBgUGFuZWxzLmNzc2AuXG5cdFx0KlxuXHRcdCogQHJldHVybiB7U3RyaW5nfSBUaGUgQ1NTIGNsYXNzIG5hbWUgdG8gYXBwbHkuXG5cdFx0Ki9cblx0XHRnZXROYXJyb3dDbGFzczogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoUGFuZWxzLmlzTmFycm93RGV2aWNlKCkpIHtcblx0XHRcdFx0cmV0dXJuICdlbnlvLXBhbmVscy1mb3JjZS1uYXJyb3cnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICdlbnlvLXBhbmVscy1maXQtbmFycm93Jztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0KiBMZXJwcyBiZXR3ZWVuIGFycmFuZ2VtZW50cy5cblx0XHQqXG5cdFx0KiBAcGFyYW0gIHtPYmplY3RbXX0gYTAgICAgIC0gQXJyYXkgb2YgY3VycmVudCBhcnJhbmdlbWVudCBvYmplY3RzLlxuXHRcdCogQHBhcmFtICB7T2JqZWN0W119IGExICAgICAtIEFycmF5IG9mIHRhcmdldCBhcnJhbmdlbWVudCBvYmplY3QuXG5cdFx0KiBAcGFyYW0gIHtOdW1iZXJ9IGZyYWN0aW9uIC0gVGhlIGZyYWN0aW9uIChiZXR3ZWVuIDAgYW5kIDEpIHdpdGggd2hpY2ggdG8gbGVycC5cblx0XHQqIEByZXR1cm4ge09iamVjdFtdfSAgICAgICAgLSBBcnJheSBvZiBhcnJhbmdlbWVudHMgdGhhdCBpcyBgZnJhY3Rpb25gIGJldHdlZW5cblx0XHQqIFx0YGEwYCBhbmQgYGExYC5cblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRsZXJwOiBmdW5jdGlvbiAoYTAsIGExLCBmcmFjdGlvbikge1xuXHRcdFx0dmFyIHIgPSBbXTtcblx0XHRcdGZvciAodmFyIGk9MCwgayQ9dXRpbHMua2V5cyhhMCksIGs7IChrPWskW2ldKTsgaSsrKSB7XG5cdFx0XHRcdHIucHVzaCh0aGlzLmxlcnBPYmplY3QoYTBba10sIGExW2tdLCBmcmFjdGlvbikpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogTGVycHMgYmV0d2VlbiB0aGUgdmFsdWVzIG9mIGFycmFuZ2VtZW50IG9iamVjdHMuXG5cdFx0KlxuXHRcdCogQHBhcmFtICB7T2JqZWN0fSBhMCAgICAgICAtIFRoZSBzb3VyY2UgYXJyYWdlbWVudC5cblx0XHQqIEBwYXJhbSAge09iamVjdH0gYTEgICAgICAgLSBUaGUgZGVzdGluYXRpb24gYXJyYWdlbWVudC5cblx0XHQqIEBwYXJhbSAge051bWJlcn0gZnJhY3Rpb24gLSBUaGUgZnJhY3Rpb24gKGJldHdlZW4gMCBhbmQgMSkgd2l0aCB3aGljaCB0byBsZXJwLlxuXHRcdCpcblx0XHQqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgLSBUaGUgbGVycGVkIGFycmFuZ2VtZW50LlxuXHRcdCogQHByaXZhdGVcblx0XHQqL1xuXHRcdGxlcnBPYmplY3Q6IGZ1bmN0aW9uIChhMCwgYTEsIGZyYWN0aW9uKSB7XG5cdFx0XHR2YXIgYiA9IHV0aWxzLmNsb25lKGEwKSwgbiwgbztcblx0XHRcdC8vIGExIG1pZ2h0IGJlIHVuZGVmaW5lZCB3aGVuIGRlbGV0aW5nIHBhbmVsc1xuXHRcdFx0aWYgKGExKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgaW4gYTApIHtcblx0XHRcdFx0XHRuID0gYTBbaV07XG5cdFx0XHRcdFx0byA9IGExW2ldO1xuXHRcdFx0XHRcdGlmIChuICE9IG8pIHtcblx0XHRcdFx0XHRcdGJbaV0gPSBuIC0gKG4gLSBvKSAqIGZyYWN0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogVGVzdHMgVXNlciBBZ2VudCBzdHJpbmdzIHRvIGlkZW50aWZ5IG5hcnJvdyBkZXZpY2VzLlxuXHRcdCpcblx0XHQqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgYSBuYXJyb3cgZGV2aWNlO1xuXHRcdCogb3RoZXJ3aXNlLCBgZmFsc2VgLlxuXHRcdCovXG5cdFx0aXNOYXJyb3dEZXZpY2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdFx0XHRzd2l0Y2ggKHBsYXRmb3JtLnBsYXRmb3JtTmFtZSkge1xuXHRcdFx0XHRjYXNlICdpb3MnOlxuXHRcdFx0XHRcdHJldHVybiAoL2lQKD86aG9uZXxvZDsoPzogVTspPyBDUFUpIE9TIChcXGQrKS8pLnRlc3QodWEpO1xuXHRcdFx0XHRjYXNlICdhbmRyb2lkJzpcblx0XHRcdFx0XHRyZXR1cm4gKC9Nb2JpbGUvKS50ZXN0KHVhKSAmJiAocGxhdGZvcm0uYW5kcm9pZCA+IDIpO1xuXHRcdFx0XHRjYXNlICdhbmRyb2lkQ2hyb21lJzpcblx0XHRcdFx0XHRyZXR1cm4gKC9Nb2JpbGUvKS50ZXN0KHVhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9BbmltYXRvclwiOjUsXCIuLi8uLi8uLi9lbnlvL2xpYi9kaXNwYXRjaGVyXCI6NTcsXCIuLi8uLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2VueW8vbGliL3BsYXRmb3JtXCI6NzEsXCIuLi8uLi8uLi9lbnlvL2xpYi91dGlsc1wiOjc1LFwiLi4vQ2FyZEFycmFuZ2VyXCI6Nzl9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi8uLi9lbnlvJyk7XG5cblxuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3BsYXRmb3JtJyksXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyJyksXG5cdGZ1bGxzY3JlZW4gPSByZXF1aXJlKCcuLi9mdWxsc2NyZWVuJyksXG5cdHJvb3RzID0gcmVxdWlyZSgnLi4vcm9vdHMnKTtcblxudmFyXG5cdFVpQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vVWlDb21wb25lbnQnKSxcblx0SFRNTFN0cmluZ0RlbGVnYXRlID0gcmVxdWlyZSgnLi4vSFRNTFN0cmluZ0RlbGVnYXRlJyksXG5cdERvbSA9IHJlcXVpcmUoJy4uL2RvbScpLFxuXHRGbG9hdGluZ0xheWVyID0gcmVxdWlyZSgnLi4vZmxvYXRpbmdMYXllcicpO1xuXG52YXIgbm9kZVB1cmdhdG9yeTtcblxuLyoqXG4qIENhbGxlZCBieSBgQ29udHJvbC50ZWFyZG93blJlbmRlcigpYC4gSW4gY2VydGFpbiBjaXJjdW1zdGFuY2VzLFxuKiB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IGtlZXAgYSBET00gbm9kZSBhcm91bmQgYWZ0ZXIgdGVhcmluZyBkb3duXG4qIGJlY2F1c2Ugd2UncmUgc3RpbGwgYWN0aW5nIG9uIGEgc3RyZWFtIG9mIHRvdWNoIGV2ZW50cyBlbWFuYXRpbmdcbiogZnJvbSB0aGUgbm9kZS4gU2VlIGBDb250cm9sLnJldGFpbk5vZGUoKWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qXG4qIEBwcml2YXRlXG4qL1xuZnVuY3Rpb24gc3RvcmVSZXRhaW5lZE5vZGUgKGNvbnRyb2wpIHtcblx0dmFyIHAgPSBnZXROb2RlUHVyZ2F0b3J5KCksXG5cdFx0biA9IGNvbnRyb2wuX3JldGFpbmVkTm9kZTtcblx0aWYgKG4pIHtcblx0XHRwLmFwcGVuZENoaWxkKG4pO1xuXHR9XG5cdGNvbnRyb2wuX3JldGFpbmVkTm9kZSA9IG51bGw7XG59XG5cbi8qKlxuKiBDYWxsZWQgKHZpYSBhIGNhbGxiYWNrKSB3aGVuIGl0J3MgdGltZSB0byByZWxlYXNlIGEgRE9NIG5vZGVcbiogdGhhdCB3ZSd2ZSByZXRhaW5lZC5cbipcbiogQHByaXZhdGVcbiovXG5mdW5jdGlvbiByZWxlYXNlUmV0YWluZWROb2RlIChyZXRhaW5lZE5vZGUpIHtcblx0dmFyIHAgPSBnZXROb2RlUHVyZ2F0b3J5KCk7XG5cdGlmIChyZXRhaW5lZE5vZGUpIHtcblx0XHRwLnJlbW92ZUNoaWxkKHJldGFpbmVkTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4qIExhemlseSBhZGQgYSBoaWRkZW4gYDxkaXY+YCB0byBgZG9jdW1lbnQuYm9keWAgdG8gc2VydmUgYXMgYVxuKiBjb250YWluZXIgZm9yIHJldGFpbmVkIERPTSBub2Rlcy5cbipcbiogQHByaXZhdGVcbiovXG5mdW5jdGlvbiBnZXROb2RlUHVyZ2F0b3J5ICgpIHtcblx0dmFyIHAgPSBub2RlUHVyZ2F0b3J5O1xuXHRpZiAoIXApIHtcblx0XHRwID0gbm9kZVB1cmdhdG9yeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0cC5pZCA9IFwibm9kZV9wdXJnYXRvcnlcIjtcblx0XHRwLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHApO1xuXHR9XG5cdHJldHVybiBwO1xufVxuXG4vKipcbioge0BsaW5rIGVueW8uQ29udHJvbH0gaXMgYSBbY29tcG9uZW50XXtAbGluayBlbnlvLlVpQ29tcG9uZW50fSB0aGF0IGNvbnRyb2xzXG4qIGEgW0RPTV17QGdsb3NzYXJ5IERPTX0gW25vZGVde0BnbG9zc2FyeSBOb2RlfSAoaS5lLiwgYW4gZWxlbWVudCBpbiB0aGUgdXNlclxuKiBpbnRlcmZhY2UpLiBDb250cm9scyBhcmUgZ2VuZXJhbGx5IHZpc2libGUgYW5kIHRoZSB1c2VyIG9mdGVuIGludGVyYWN0cyB3aXRoXG4qIHRoZW0gZGlyZWN0bHkuIFdoaWxlIHRoaW5ncyBsaWtlIGJ1dHRvbnMgYW5kIGlucHV0IGJveGVzIGFyZSBvYnZpb3VzbHlcbiogY29udHJvbHMsIGluIEVueW8sIGEgY29udHJvbCBtYXkgYmUgYXMgc2ltcGxlIGFzIGEgdGV4dCBpdGVtIG9yIGFzIGNvbXBsZXhcbiogYXMgYW4gZW50aXJlIGFwcGxpY2F0aW9uLiBCb3RoIGluaGVyaXQgdGhlIHNhbWUgYmFzaWMgY29yZSBjYXBhYmlsaXRpZXMgZnJvbVxuKiB0aGlzIGtpbmQuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0NvbnRyb2xzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUva2V5LWNvbmNlcHRzL2NvbnRyb2xzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogKipJZiB5b3UgbWFrZSBjaGFuZ2VzIHRvIGBlbnlvLkNvbnRyb2xgLCBiZSBzdXJlIHRvIGFkZCBvciB1cGRhdGUgdGhlXG4qIGFwcHJvcHJpYXRlIHVuaXQgdGVzdHMuKipcbipcbiogQGNsYXNzIGVueW8uQ29udHJvbFxuKiBAZXh0ZW5kcyBlbnlvLlVpQ29tcG9uZW50XG4qIEB1aVxuKiBAcHVibGljXG4qL1xudmFyIENvbnRyb2wgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Db250cm9sLnByb3RvdHlwZSAqLyB7XG5cblx0bmFtZTogJ2VueW8uQ29udHJvbCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogVWlDb21wb25lbnQsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblxuXG5cdC8qKlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ2VueW8uQ29udHJvbCdcblx0KiBAcHVibGljXG5cdCovXG5cdGRlZmF1bHRLaW5kOiBudWxsLCAvLyBzZXQgYWZ0ZXIgdGhlIGZhY3RcblxuXHQvKipcblx0KiBUaGUgW0RPTSBub2RlXXtAZ2xvc3NhcnkgRE9NfSB0YWcgbmFtZSB0aGF0IHNob3VsZCBiZSBjcmVhdGVkLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnZGl2J1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0dGFnOiAnZGl2JyxcblxuXHQvKipcblx0KiBBIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSBvZiBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNyZWF0ZWRcblx0KiBbRE9NXXtAZ2xvc3NhcnkgRE9NfSBub2RlLlxuXHQqXG5cdCogQHR5cGUge09iamVjdH1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhdHRyaWJ1dGVzOiBudWxsLFxuXG5cdC8qKlxuXHQqIFtCb29sZWFuXXtAZ2xvc3NhcnkgQm9vbGVhbn0gZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBlbGVtZW50IHNob3VsZFxuXHQqIFwiZml0XCIsIG9yIGZpbGwgaXRzIGNvbnRhaW5lcidzIHNpemUuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmaXQ6IG51bGwsXG5cblx0LyoqXG5cdCogW0Jvb2xlYW5de0BnbG9zc2FyeSBCb29sZWFufSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBIVE1MIGlzIGFsbG93ZWQgaW5cblx0KiB0aGlzIGNvbnRyb2wncyBbY29udGVudF17QGxpbmsgZW55by5Db250cm9sI2NvbnRlbnR9IHByb3BlcnR5LiBJZiBgZmFsc2VgXG5cdCogKHRoZSBkZWZhdWx0KSwgSFRNTCB3aWxsIGJlIGVuY29kZWQgaW50byBbSFRNTCBlbnRpdGllc117QGdsb3NzYXJ5IGVudGl0eX1cblx0KiAoZS5nLiwgYCZsdDtgIGFuZCBgJmd0O2ApIGZvciBsaXRlcmFsIHZpc3VhbCByZXByZXNlbnRhdGlvbi5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdGFsbG93SHRtbDogZmFsc2UsXG5cblx0LyoqXG5cdCogTWltaWNzIHRoZSBIVE1MIGBzdHlsZWAgYXR0cmlidXRlLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0c3R5bGU6ICcnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmRTdHlsZTogJycsXG5cblx0LyoqXG5cdCogTWltaWNzIHRoZSBIVE1MIGBjbGFzc2AgYXR0cmlidXRlLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2xhc3NlczogJycsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZENsYXNzZXM6ICcnLFxuXG5cdC8qKlxuXHQqIFtDbGFzc2VzXXtAbGluayBlbnlvLkNvbnRyb2wjY2xhc3Nlc30gdGhhdCBhcmUgYXBwbGllZCB0byBhbGwgY29udHJvbHMuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICcnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb250cm9sQ2xhc3NlczogJycsXG5cblx0LyoqXG5cdCogVGhlIHRleHQtYmFzZWQgY29udGVudCBvZiB0aGUgQ29udHJvbC4gSWYgdGhlIFthbGxvd0h0bWxde0BsaW5rIGVueW8uQ29udHJvbCNhbGxvd0h0bWx9XG5cdCogZmxhZyBpcyBzZXQgdG8gYHRydWVgLCB5b3UgbWF5IHNldCB0aGlzIHByb3BlcnR5IHRvIGFuIEhUTUwgc3RyaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29udGVudDogJycsXG5cblx0LyoqXG5cdCogSWYgdHJ1ZSBvciAnaW5oZXJpdCcgYW5kIGVueW8uZ2VzdHVyZS5kb3VibGVUYWJFbmFibGVkID09IHRydWUsIHdpbGwgZmlyZSBhIGRvdWJsZXRhcFxuXHQqIGV2ZW50LCBhbmQgd2lsbCB0ZW1wb3JhcmlseSBzdXBwcmVzcyBhIHNpbmdsZSB0YXAgd2hpbGUgd2FpdGluZyBmb3IgYSBkb3VibGUgdGFwLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ3xCb29sZWFufVxuXHQqIEBkZWZhdWx0ICdpbmhlcml0J1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZG91YmxlVGFwRW5hYmxlZDogJ2luaGVyaXQnLFxuXG5cdC8qKlxuXHQqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgdG8gZGV0ZWN0IGEgZG91YmxlIHRhcFxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCAzMDBcblx0KiBAcHVibGljXG5cdCovXG5cdGRvdWJsZVRhcEludGVydmFsOiAzMDAsXG5cblx0LyoqXG5cdCogQHRvZG8gRmluZCBvdXQgaG93IHRvIGRvY3VtZW50IFwiaGFuZGxlcnNcIi5cblx0KiBAcHVibGljXG5cdCovXG5cdGhhbmRsZXJzOiB7XG5cdFx0b250YXA6ICd0YXAnLFxuXHRcdG9uU2hvd2luZ0NoYW5nZWQ6ICdzaG93aW5nQ2hhbmdlZEhhbmRsZXInXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RyaWN0bHlJbnRlcm5hbEV2ZW50czoge29uZW50ZXI6IDEsIG9ubGVhdmU6IDF9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzSW50ZXJuYWxFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIHJkdCA9IGRpc3BhdGNoZXIuZmluZERpc3BhdGNoVGFyZ2V0KGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuXHRcdHJldHVybiByZHQgJiYgcmR0LmlzRGVzY2VuZGFudE9mKHRoaXMpO1xuXHR9LFxuXG5cdC8vIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxuXHQvLyBET00gTk9ERSBNQU5JUFVMQVRJT04gQVBJXG5cblx0LyoqXG5cdCogR2V0cyB0aGUgYm91bmRzIGZvciB0aGlzIGNvbnRyb2wuIFRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMgcmV0dXJuZWRcblx0KiBieSB0aGlzIG1ldGhvZCByZXByZXNlbnQgdGhlIGNvbnRyb2wncyBwb3NpdGlvbmFsIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tXG5cdCogZWl0aGVyIEEpIHRoZSBmaXJzdCBwYXJlbnQgb2YgdGhpcyBjb250cm9sIHRoYXQgaXMgYWJzb2x1dGVseSBvciByZWxhdGl2ZWx5XG5cdCogcG9zaXRpb25lZCwgb3IgQikgdGhlIGBkb2N1bWVudC5ib2R5YC5cblx0KlxuXHQqIFRoaXMgaXMgYSBzaG9ydGN1dCBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHtAbGluayBlbnlvLmRvbS5nZXRCb3VuZHN9LlxuXHQqXG5cdCogQHJldHVybnMge09iamVjdH0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBgdG9wYCwgYGxlZnRgLFxuXHQqIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLmhhc05vZGUoKSxcblx0XHRcdGJvdW5kcyA9IG5vZGUgJiYgRG9tLmdldEJvdW5kcyhub2RlKTtcblxuXHRcdHJldHVybiBib3VuZHMgfHwge2xlZnQ6IHVuZGVmaW5lZCwgdG9wOiB1bmRlZmluZWQsIHdpZHRoOiB1bmRlZmluZWQsIGhlaWdodDogdW5kZWZpbmVkfTtcblx0fSxcblxuXHQvKipcblx0KiBTZXRzIHRoZSBhYnNvbHV0ZS9yZWxhdGl2ZSBwb3NpdGlvbiBhbmQvb3Igc2l6ZSBmb3IgdGhpcyBjb250cm9sLiBWYWx1ZXNcblx0KiBvZiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgZm9yIHRoZSBgYm91bmRzYCBwcm9wZXJ0aWVzIHdpbGwgYmUgaWdub3JlZC4gWW91XG5cdCogbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBhIGB1bml0YCAoaS5lLiwgYSB2YWxpZCBDU1MgbWVhc3VyZW1lbnQgdW5pdCkgYXMgYVxuXHQqIFtzdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBvZiB0aGUgcG9zaXRpb24vc2l6ZVxuXHQqIGFzc2lnbm1lbnRzLlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IGJvdW5kcyAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LCBvcHRpb25hbGx5XG5cdCogY29udGFpbmluZyBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IGB3aWR0aGAsIGBoZWlnaHRgLFxuXHQqIGB0b3BgLCBgcmlnaHRgLCBgYm90dG9tYCwgYW5kIGBsZWZ0YC5cblx0KiBAcGFyYW0ge1N0cmluZ30gW3VuaXQ9J3B4J11cblx0KiBAcHVibGljXG5cdCovXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgdW5pdCkge1xuXHRcdHZhciBuZXdTdHlsZSA9ICcnLFxuXHRcdFx0ZXh0ZW50cyA9IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR2YWwsXG5cdFx0XHRleHQ7XG5cblx0XHQvLyBpZiBubyB1bml0IGlzIHN1cHBsaWVkLCB3ZSBkZWZhdWx0IHRvIHBpeGVsc1xuXHRcdHVuaXQgPSB1bml0IHx8ICdweCc7XG5cblx0XHRmb3IgKDsgKGV4dCA9IGV4dGVudHNbaV0pOyArK2kpIHtcblx0XHRcdHZhbCA9IGJvdW5kc1tleHRdO1xuXHRcdFx0aWYgKHZhbCB8fCB2YWwgPT09IDApIHtcblx0XHRcdFx0bmV3U3R5bGUgKz0gKGV4dCArICc6JyArIHZhbCArICh0eXBlb2YgdmFsID09ICdzdHJpbmcnID8gJycgOiB1bml0KSArICc7Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXQoJ3N0eWxlJywgdGhpcy5zdHlsZSArIG5ld1N0eWxlKTtcblx0fSxcblxuXHQvKipcblx0KiBHZXRzIHRoZSBib3VuZHMgZm9yIHRoaXMgY29udHJvbC4gVGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcyByZXR1cm5lZFxuXHQqIGJ5IHRoaXMgbWV0aG9kIHJlcHJlc2VudCB0aGUgY29udHJvbCdzIHBvc2l0aW9uYWwgZGlzdGFuY2UgaW4gcGl4ZWxzIGZyb21cblx0KiBgZG9jdW1lbnQuYm9keWAuIFRvIGdldCB0aGUgYm91bmRzIHJlbGF0aXZlIHRvIHRoaXMgY29udHJvbCdzIHBhcmVudChzKSxcblx0KiB1c2UgW2dldEJvdW5kcygpXXtAbGluayBlbnlvLkNvbnRyb2wjZ2V0Qm91bmRzfS5cblx0KlxuXHQqIFRoaXMgaXMgYSBzaG9ydGN1dCBjb252ZW5pZW5jZSBtZXRob2QgZm9yIHtAbGluayBlbnlvLmRvbS5nZXRBYnNvbHV0ZUJvdW5kc30uXG5cdCpcblx0KiBAcmV0dXJucyB7T2JqZWN0fSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGB0b3BgLCBgbGVmdGAsXG5cdCogYHdpZHRoYCwgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRBYnNvbHV0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBub2RlID0gdGhpcy5oYXNOb2RlKCksXG5cdFx0XHRib3VuZHMgPSBub2RlICYmIERvbS5nZXRBYnNvbHV0ZUJvdW5kcyhub2RlKTtcblxuXHRcdHJldHVybiBib3VuZHMgfHwge1xuXHRcdFx0bGVmdDogdW5kZWZpbmVkLFxuXHRcdFx0dG9wOiB1bmRlZmluZWQsXG5cdFx0XHR3aWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0aGVpZ2h0OiB1bmRlZmluZWQsXG5cdFx0XHRib3R0b206IHVuZGVmaW5lZCxcblx0XHRcdHJpZ2h0OiB1bmRlZmluZWRcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNob3J0Y3V0IG1ldGhvZCB0byBzZXQgW3Nob3dpbmdde0BsaW5rIGVueW8uQ29udHJvbCNzaG93aW5nfSB0byBgdHJ1ZWAuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNob3c6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldCgnc2hvd2luZycsIHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNob3J0Y3V0IG1ldGhvZCB0byBzZXQgW3Nob3dpbmdde0BsaW5rIGVueW8uQ29udHJvbCNzaG93aW5nfSB0byBgZmFsc2VgLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXQoJ3Nob3dpbmcnLCBmYWxzZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGlzIGNvbnRyb2wgdG8gYmUgW2ZvY3VzZWRde0BnbG9zc2FyeSBmb2N1c30uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuaGFzTm9kZSgpKSB0aGlzLm5vZGUuZm9jdXMoKTtcblx0fSxcblxuXHQvKipcblx0KiBbQmx1cnNde0BnbG9zc2FyeSBibHVyfSB0aGlzIGNvbnRyb2wuIChUaGUgb3Bwb3NpdGUgb2Zcblx0KiBbZm9jdXMoKV17QGxpbmsgZW55by5Db250cm9sI2ZvY3VzfS4pXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHRoaXMubm9kZS5ibHVyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgY29udHJvbCBjdXJyZW50bHkgaGFzIHRoZSBbZm9jdXNde0BnbG9zc2FyeSBmb2N1c30uXG5cdCpcblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGlzIGNvbnRyb2wgaGFzIGZvY3VzLiBgdHJ1ZWAgaWYgdGhlIGNvbnRyb2xcblx0KiBoYXMgZm9jdXM7IG90aGVyd2lzZSwgYGZhbHNlYC5cblx0KiBAcHVibGljXG5cdCovXG5cdGhhc0ZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuaGFzTm9kZSgpKSByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5ub2RlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB0aGlzIGNvbnRyb2wncyBbRE9NIG5vZGVde0BnbG9zc2FyeSBOb2RlfSBoYXMgYmVlbiBjcmVhdGVkLlxuXHQqXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhpcyBjb250cm9sJ3MgW0RPTSBub2RlXXtAZ2xvc3NhcnkgTm9kZX0gaGFzXG5cdCogYmVlbiBjcmVhdGVkLiBgdHJ1ZWAgaWYgaXQgaGFzIGJlZW4gY3JlYXRlZDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGFzTm9kZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlZCAmJiAodGhpcy5ub2RlIHx8IHRoaXMuZmluZE5vZGVCeUlkKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEdldHMgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSAoYG5hbWVgKSBmcm9tIHRoZSBjb250cm9sJ3MgYXR0cmlidXRlc1xuXHQqIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSwgZnJvbSBpdHMgY2FjaGUgb2Ygbm9kZSBhdHRyaWJ1dGVzLCBvciwgaWYgaXQgaGFzXG5cdCogeWV0IHRvIGJlIGNhY2hlZCwgZnJvbSB0aGUgW25vZGVde0BnbG9zc2FyeSBOb2RlfSBpdHNlbGYuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBnZXQuXG5cdCogQHJldHVybnMgeyhTdHJpbmd8TnVsbCl9IFRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSwgb3IgYG51bGxgXG5cdCogaWYgdGhlcmUgaXNuJ3QgYSBbRE9NIG5vZGVde0BnbG9zc2FyeSBOb2RlfSB5ZXQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIG5vZGU7XG5cblx0XHQvLyBUT0RPOiBUaGlzIGlzIGEgZml4ZWQgQVBJIGFzc3VtaW5nIHRoYXQgbm8gY2hhbmdlcyB3aWxsIGhhcHBlbiB0byB0aGUgRE9NIHRoYXRcblx0XHQvLyBkbyBub3QgdXNlIGl0Li4ub3JpZ2luYWwgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgdXNlZCB0aGUgbm9kZSdzIG93blxuXHRcdC8vIGdldEF0dHJpYnV0ZSBtZXRob2QgZXZlcnkgdGltZSBpdCBjb3VsZCBidXQgd2UgcmVhbGx5IG9ubHkgbmVlZCB0byBkbyB0aGF0IGlmIHdlXG5cdFx0Ly8gd2VyZW4ndCB0aGUgb25lcyB0aGF0IHNldCB0aGUgdmFsdWUgdG8gYmVnaW4gd2l0aCAtLSBpbiBzbG93IERPTSBzaXR1YXRpb25zIHRoaXNcblx0XHQvLyBjb3VsZCBzdGlsbCBiZSBmYXN0ZXIgYnV0IGl0IG5lZWRzIHRvIGJlIHZlcmlmaWVkXG5cdFx0aWYgKHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblx0XHRlbHNlIHtcblx0XHRcdG5vZGUgPSB0aGlzLmhhc05vZGUoKTtcblxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIHZhbHVlIHNvIHRoYXQgbmV4dCB0aW1lIHdlJ2xsIGtub3cgd2hhdCBpdCBpc1xuXHRcdFx0Lypqc2hpbnQgLVcwOTMgKi9cblx0XHRcdHJldHVybiAodGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gKG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSA6IG51bGwpKTtcblx0XHRcdC8qanNoaW50ICtXMDkzICovXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEFzc2lnbnMgYW4gYXR0cmlidXRlIHRvIGEgY29udHJvbCdzIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0uIEFzc2lnbmluZ1xuXHQqIGBuYW1lYCBhIHZhbHVlIG9mIGBudWxsYCwgYGZhbHNlYCwgb3IgdGhlIGVtcHR5IHN0cmluZyBgKFwiXCIpYCB3aWxsIHJlbW92ZVxuXHQqIHRoZSBhdHRyaWJ1dGUgZnJvbSB0aGUgbm9kZSBhbHRvZ2V0aGVyLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBBdHRyaWJ1dGUgbmFtZSB0byBhc3NpZ24vcmVtb3ZlLlxuXHQqIEBwYXJhbSB7KFN0cmluZ3xOdW1iZXJ8bnVsbCl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnbiB0byBgbmFtZWBcblx0KiBAcmV0dXJucyB7dGhpc30gQ2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzLFxuXHRcdFx0bm9kZSA9IHRoaXMuaGFzTm9kZSgpLFxuXHRcdFx0ZGVsZWdhdGUgPSB0aGlzLnJlbmRlckRlbGVnYXRlIHx8IENvbnRyb2wucmVuZGVyRGVsZWdhdGU7XG5cblx0XHRpZiAobmFtZSkge1xuXHRcdFx0YXR0cnNbbmFtZV0gPSB2YWx1ZTtcblxuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAnJykge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHR9IGVsc2Ugbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGRlbGVnYXRlLmludmFsaWRhdGUodGhpcywgJ2F0dHJpYnV0ZXMnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBSZWFkcyB0aGUgYG5hbWVgIHByb3BlcnR5IGRpcmVjdGx5IGZyb20gdGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0uIFlvdVxuXHQqIG1heSBwcm92aWRlIGEgZGVmYXVsdCAoYGRlZmApIHRvIHVzZSBpZiB0aGVyZSBpcyBubyBub2RlIHlldC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gcHJvcGVydHkgbmFtZSB0byBnZXQuXG5cdCogQHBhcmFtIHsqfSBkZWYgLSBUaGUgZGVmYXVsdCB2YWx1ZSB0byBhcHBseSBpZiB0aGVyZSBpcyBubyBub2RlLlxuXHQqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgYG5hbWVgIHByb3BlcnR5LCBvciBgZGVmYCBpZiB0aGUgbm9kZVxuXHQqIHdhcyBub3QgYXZhaWxhYmxlLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0Tm9kZVByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgZGVmKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzTm9kZSgpID8gdGhpcy5ub2RlW25hbWVdIDogZGVmO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKGBuYW1lYCkgZGlyZWN0bHkgb24gdGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0uXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBbbm9kZV17QGdsb3NzYXJ5IE5vZGV9IHByb3BlcnR5IG5hbWUgdG8gc2V0LlxuXHQqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBwcm9wZXJ0eS5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXROb2RlUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdGlmICh0aGlzLmhhc05vZGUoKSkgdGhpcy5ub2RlW25hbWVdID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogQXBwZW5kcyBhZGRpdGlvbmFsIGNvbnRlbnQgdG8gdGhpcyBjb250cm9sLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IHN0cmluZyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgYGNvbnRlbnRgXG5cdCogcHJvcGVydHkuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXQoJ2NvbnRlbnQnLCB0aGlzLmdldCgnY29udGVudCcpICsgY29udGVudCk7XG5cdH0sXG5cblx0Ly8gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXG5cblx0Ly8gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXG5cdC8vIFNUWUxFL0NMQVNTIEFQSVxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB0aGlzIGNvbnRyb2wgaGFzIHRoZSBjbGFzcyBgbmFtZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyAob3IgY2xhc3NlcykgdG8gY2hlY2sgZm9yLlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb250cm9sIGhhcyB0aGUgY2xhc3MgYG5hbWVgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUgJiYgKCcgJyArIHRoaXMuY2xhc3NlcyArICcgJykuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSA+IC0xO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFkZHMgdGhlIHNwZWNpZmllZCBjbGFzcyB0byB0aGlzIGNvbnRyb2wncyBsaXN0IG9mIGNsYXNzZXMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBhZGQuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmNsYXNzZXMgfHwgJyc7XG5cblx0XHQvLyBOT1RFOiBCZWNhdXNlIHRoaXMgbWV0aG9kIGFjY2VwdHMgYSBzdHJpbmcgYW5kIGZvciBlZmZpY2llbmN5IGRvZXMgbm90IHdpc2ggdG9cblx0XHQvLyBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYWN0dWFsbHkgbXVsdGlwbGUgY2xhc3NlcyB3ZSBsYXRlciBwdWxsIGEgdHJpY2tcblx0XHQvLyB0byBrZWVwIGl0IG5vcm1hbGl6ZWQgYW5kIHN5bmNocm9uaXplZCB3aXRoIG91ciBhdHRyaWJ1dGVzIGhhc2ggYW5kIHRoZSBub2RlJ3Ncblx0XHRpZiAoIXRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcblxuXHRcdFx0Ly8gdGhpcyBpcyBob29rZWRcblx0XHRcdHRoaXMuc2V0KCdjbGFzc2VzJywgY2xhc3NlcyArIChjbGFzc2VzID8gKCcgJyArIG5hbWUpIDogbmFtZSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzcyBmcm9tIHRoaXMgY29udHJvbCdzIGxpc3Qgb2YgY2xhc3Nlcy5cblx0KlxuXHQqICoqTm90ZTogSXQgaXMgbm90IGFkdmlzYWJsZSB0byBwYXNzIGEgc3RyaW5nIG9mIG11bHRpcGxlLCBzcGFjZS1kZWxpbWl0ZWRcblx0KiBjbGFzcyBuYW1lcyBpbnRvIHRoaXMgbWV0aG9kLiBJbnN0ZWFkLCBjYWxsIHRoZSBtZXRob2Qgb25jZSBmb3IgZWFjaCBjbGFzc1xuXHQqIG5hbWUgdGhhdCB5b3Ugd2FudCB0byByZW1vdmUuKipcblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIHJlbW92ZS5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuY2xhc3NlcztcblxuXHRcdGlmIChuYW1lKSB7XG5cdFx0XHR0aGlzLnNldCgnY2xhc3NlcycsICgnICcgKyBjbGFzc2VzICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykudHJpbSgpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBBZGRzIG9yIHJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzcyBjb25kaXRpb25hbGx5LCBiYXNlZCBvbiB0aGUgc3RhdGVcblx0KiBvZiB0aGUgYGFkZGAgYXJndW1lbnQuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlLlxuXHQqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkIC0gSWYgYHRydWVgLCBgbmFtZWAgd2lsbCBiZSBhZGRlZCBhcyBhIGNsYXNzOyBpZlxuXHQqIGBmYWxzZWAsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cblx0KiBAcmV0dXJucyB7dGhpc30gVGhlIGNhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhZGRSZW1vdmVDbGFzczogZnVuY3Rpb24gKG5hbWUsIGFkZCkge1xuXHRcdHJldHVybiBuYW1lID8gdGhpc1thZGQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10obmFtZSkgOiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsYXNzZXNDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmNsYXNzZXMsXG5cdFx0XHRub2RlID0gdGhpcy5oYXNOb2RlKCksXG5cdFx0XHRhdHRycyA9IHRoaXMuYXR0cmlidXRlcyxcblx0XHRcdGRlbGVnYXRlID0gdGhpcy5yZW5kZXJEZWxlZ2F0ZSB8fCBDb250cm9sLnJlbmRlckRlbGVnYXRlO1xuXG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdGlmIChjbGFzc2VzIHx8IHRoaXMua2luZENsYXNzZXMpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NlcyB8fCB0aGlzLmtpbmRDbGFzc2VzKTtcblx0XHRcdH0gZWxzZSBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblxuXHRcdFx0dGhpcy5jbGFzc2VzID0gY2xhc3NlcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH1cblxuXHRcdC8vIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBhdHRyaWJ1dGVzLmNsYXNzIHZhbHVlIGFuZCBmbGFnIG91cnNlbHZlcyB0byBiZVxuXHRcdC8vIHVwZGF0ZWRcblx0XHRhdHRyc1snY2xhc3MnXSA9IGNsYXNzZXM7XG5cblx0XHQvLyB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgZGVsZWdhdGUgdGhhdCB0aGUgYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQgaW4gY2FzZSBpdCB3YW50c1xuXHRcdC8vIHRvIGhhbmRsZSB0aGlzIGlzIHNvbWUgc3BlY2lhbCB3YXlcblx0XHRkZWxlZ2F0ZS5pbnZhbGlkYXRlKHRoaXMsICdhdHRyaWJ1dGVzJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQXBwbGllcyBhIENTUyBzdHlsZSBkaXJlY3RseSB0byB0aGUgY29udHJvbC4gVXNlIHRoZSBgcHJvcGAgYXJndW1lbnQgdG9cblx0KiBzcGVjaWZ5IHRoZSBDU1MgcHJvcGVydHkgbmFtZSB5b3UnZCBsaWtlIHRvIHNldCwgYW5kIGB2YWx1ZWAgdG8gc3BlY2lmeVxuXHQqIHRoZSBkZXNpcmVkIHZhbHVlLiBTZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgIHdpbGwgcmVtb3ZlIHRoZSBDU1MgcHJvcGVydHlcblx0KiBgcHJvcGAgYWx0b2dldGhlci5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIC0gVGhlIENTUyBwcm9wZXJ0eSB0byBhc3NpZ24uXG5cdCogQHBhcmFtIHsoU3RyaW5nfE51bWJlcnxudWxsfHVuZGVmaW5lZCl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFzc2lnbiB0b1xuXHQqIGBwcm9wYC4gU2V0dGluZyBhIHZhbHVlIG9mIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIHRoZSBlbXB0eSBzdHJpbmcgYChcIlwiKWBcblx0KiB3aWxsIHJlbW92ZSB0aGUgcHJvcGVydHkgYHByb3BgIGZyb20gdGhlIGNvbnRyb2wuXG5cdCogQHJldHVybnMge3RoaXN9IENhbGxlZSBmb3IgY2hhaW5pbmcuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhcHBseVN0eWxlOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcblxuXHRcdC8vIE5PVEU6IFRoaXMgbWV0aG9kIGRlbGliZXJhdGVseSBhdm9pZHMgY2FsbGluZyBzZXQoJ3N0eWxlJywgLi4uKSBmb3IgcGVyZm9ybWFuY2Vcblx0XHQvLyBhcyBpdCB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHBhcnNlZCBieSB0aGUgYnJvd3NlciBzbyB3ZSBwYXNzIGl0IG9uIHZpYSB0aGVcblx0XHQvLyBub3RpZmljYXRpb24gc3lzdGVtIHdoaWNoIGlzIHRoZSBzYW1lXG5cblx0XHQvLyBUT0RPOiBXaXNoIHdlIGNvdWxkIGRlbGF5IHRoaXMgcG90ZW50aWFsbHkuLi5cblx0XHQvLyBpZiB3ZSBoYXZlIGEgbm9kZSB3ZSByZW5kZXIgdGhlIHZhbHVlIGltbWVkaWF0ZWx5IGFuZCB1cGRhdGUgb3VyIHN0eWxlIHN0cmluZ1xuXHRcdC8vIGluIHRoZSBwcm9jZXNzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHR2YXIgbm9kZSA9IHRoaXMuaGFzTm9kZSgpLFxuXHRcdFx0c3R5bGUgPSB0aGlzLnN0eWxlLFxuXHRcdFx0ZGVsZWdhdGUgPSB0aGlzLnJlbmRlckRlbGVnYXRlIHx8IENvbnRyb2wucmVuZGVyRGVsZWdhdGU7XG5cblx0XHQvLyBGSVhNRTogVGhpcyBpcyBwdXQgaW4gcGxhY2UgZm9yIGEgRmlyZWZveCBidWcgd2hlcmUgc2V0dGluZyBhIHN0eWxlIHZhbHVlIG9mIGEgbm9kZSBcblx0XHQvLyB2aWEgaXRzIENTU1N0eWxlRGVjbGFyYXRpb24gb2JqZWN0IChieSBhY2Nlc3NpbmcgaXRzIG5vZGUuc3R5bGUgcHJvcGVydHkpIGRvZXNcblx0XHQvLyBub3Qgd29yayB3aGVuIHVzaW5nIGEgQ1NTIHByb3BlcnR5IG5hbWUgdGhhdCBjb250YWlucyBvbmUgb3IgbW9yZSBkYXNoLCBhbmQgcmVxdWlyZXMgXG5cdFx0Ly8gc2V0dGluZyB0aGUgcHJvcGVydHkgdmlhIHRoZSBKYXZhU2NyaXB0LXN0eWxlIHByb3BlcnR5IG5hbWUuIFRoaXMgZml4IHNob3VsZCBiZSBcblx0XHQvLyByZW1vdmVkIG9uY2UgdGhpcyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZCBpbiB0aGUgRmlyZWZveCBtYWlubGluZSBhbmQgaXRzIHZhcmlhbnRzXG5cdFx0Ly8gKGl0IGlzIGN1cnJlbnRseSByZXNvbHZlZCBpbiB0aGUgMzYuMGExIG5pZ2h0bHkpOlxuXHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwODM0NTdcblx0XHRpZiAobm9kZSAmJiAocGxhdGZvcm0uZmlyZWZveCA8IDM1IHx8IHBsYXRmb3JtLmZpcmVmb3hPUyB8fCBwbGF0Zm9ybS5hbmRyb2lkRmlyZWZveCkpIHtcblx0XHRcdHByb3AgPSBwcm9wLnJlcGxhY2UoLy0oW2Etel0pL2dpLCBmdW5jdGlvbihtYXRjaCwgc3VibWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIHN1Ym1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVwZGF0ZSBvdXIgY3VycmVudCBjYWNoZWQgdmFsdWVcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdG5vZGUuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBjc3NUZXh0IGlzIGFuIGludGVybmFsIHByb3BlcnR5IHVzZWQgdG8gaGVscCBrbm93IHdoZW4gdG8gc3luYyBhbmQgbm90XG5cdFx0XHRcdC8vIHN5bmMgd2l0aCB0aGUgbm9kZSBpbiBzdHlsZUNoYW5nZWRcblx0XHRcdFx0dGhpcy5zdHlsZSA9IHRoaXMuY3NzVGV4dCA9IG5vZGUuc3R5bGUuY3NzVGV4dDtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGludmFsaWRhdGUgdGhlIHN0eWxlIGZvciB0aGUgZGVsZWdhdGVcblx0XHRcdFx0ZGVsZWdhdGUuaW52YWxpZGF0ZSh0aGlzLCAnc3R5bGUnKTtcblxuXHRcdFx0XHQvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byB0cnkgYW5kIHByZXBhcmUgaXQgZm9yIHRoZSBuZXh0IHRpbWUgaXQgaXMgcmVuZGVyZWQgd2Vcblx0XHRcdFx0Ly8gd2lsbCBuZWVkIHRvIHVwZGF0ZSBpdCBiZWNhdXNlIGl0IHdpbGwgbm90IGJlIHN5bmNocm9uaXplZFxuXHRcdFx0fSBlbHNlIHRoaXMuc2V0KCdzdHlsZScsIHN0eWxlICsgKCcgJyArIHByb3AgKyAnOicgKyB2YWx1ZSArICc7JykpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBhcmUgdHJ5aW5nIHRvIGNsZWFyIHRoZSBzdHlsZSBwcm9wZXJ0eSBzbyBpZiB3ZSBoYXZlIHRoZSBub2RlXG5cdFx0XHQvLyB3ZSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHdoYXRldmVyIHRoZSB2YWx1ZSBzaG91bGQgYmUgbm93IGFuZCBvdGhlcndpc2Vcblx0XHRcdC8vIHdlIGhhdmUgdG8gcGFyc2UgaXQgb3V0IG9mIHRoZSBzdHlsZSBzdHJpbmcgYW5kIHdhaXQgdG8gYmUgcmVuZGVyZWRcblxuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0bm9kZS5zdHlsZVtwcm9wXSA9ICcnO1xuXHRcdFx0XHR0aGlzLnN0eWxlID0gdGhpcy5jc3NUZXh0ID0gbm9kZS5zdHlsZS5jc3NUZXh0O1xuXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSB0aGUgc3R5bGUgZm9yIHRoZSBkZWxlZ2F0ZVxuXHRcdFx0XHRkZWxlZ2F0ZS5pbnZhbGlkYXRlKHRoaXMsICdzdHlsZScpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyB0aGlzIGlzIGEgcmFyZSBjYXNlIHRvIG51bGxpZnkgdGhlIHN0eWxlIG9mIGEgY29udHJvbCB0aGF0IGlzIG5vdFxuXHRcdFx0XHQvLyByZW5kZXJlZCBvciBkb2VzIG5vdCBoYXZlIGEgbm9kZVxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlLnJlcGxhY2UobmV3IFJlZ0V4cChcblx0XHRcdFx0XHQvLyBUaGlzIGxvb2tzIGEgbG90IHdvcnNlIHRoYW4gaXQgaXMuIFRoZSBjb21wbGV4aXR5IHN0ZW1zIGZyb20gbmVlZGluZyB0b1xuXHRcdFx0XHRcdC8vIG1hdGNoIGEgdXJsIGNvbnRhaW5lciB0aGF0IGNhbiBoYXZlIG90aGVyIGNoYXJhY3RlcnMgaW5jbHVkaW5nIHNlbWktXG5cdFx0XHRcdFx0Ly8gY29sb24gYW5kIGFsc28gdGhhdCB0aGUgbGFzdCBwcm9wZXJ0eSBtYXkvbWF5LW5vdCBlbmQgd2l0aCBvbmVcblx0XHRcdFx0XHQnXFxcXHMqJyArIHByb3AgKyAnXFxcXHMqOlxcXFxzKlthLXpBLVowLTlcXFxcICgpX1xcXFwtXFwnXCIlLF0qKD86dXJsXFxcXCguKlxcXFwpXFxcXHMqW2EtekEtWjAtOVxcXFwgKClfXFxcXC1cXCdcIiUsXSopP1xcXFxzKig/Ojt8Oz8kKScsXG5cdFx0XHRcdFx0J2dpJ1xuXHRcdFx0XHQpLCcnKTtcblx0XHRcdFx0dGhpcy5zZXQoJ3N0eWxlJywgc3R5bGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFsbG93cyB0aGUgYWRkaXRpb24gb2Ygc2V2ZXJhbCBDU1MgcHJvcGVydGllcyBhbmQgdmFsdWVzIGF0IG9uY2UsIHZpYSBhXG5cdCogc2luZ2xlIHN0cmluZywgc2ltaWxhciB0byBob3cgdGhlIEhUTUwgYHN0eWxlYCBhdHRyaWJ1dGUgd29ya3MuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gY3NzIC0gQSBzdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSB2YWxpZCBDU1Mgc3R5bGVzLlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdGFkZFN0eWxlczogZnVuY3Rpb24gKGNzcykge1xuXHRcdHZhciBrZXksXG5cdFx0XHRuZXdTdHlsZSA9ICcnO1xuXG5cdFx0aWYgKHR5cGVvZiBjc3MgPT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAoa2V5IGluIGNzcykgbmV3U3R5bGUgKz0gKGtleSArICc6JyArIGNzc1trZXldICsgJzsnKTtcblx0XHR9IGVsc2UgbmV3U3R5bGUgPSBjc3MgfHwgJyc7XG5cblx0XHR0aGlzLnNldCgnc3R5bGUnLCB0aGlzLnN0eWxlICsgbmV3U3R5bGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0eWxlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkZWxlZ2F0ZSA9IHRoaXMucmVuZGVyRGVsZWdhdGUgfHwgQ29udHJvbC5yZW5kZXJEZWxlZ2F0ZTtcblxuXHRcdC8vIGlmIHRoZSBjc3NUZXh0IGludGVybmFsIHN0cmluZyBkb2Vzbid0IG1hdGNoIHRoZW4gd2Uga25vdyBzdHlsZSB3YXMgc2V0IGRpcmVjdGx5XG5cdFx0aWYgKHRoaXMuY3NzVGV4dCAhPT0gdGhpcy5zdHlsZSkge1xuXG5cdFx0XHQvLyB3ZSBuZWVkIHRvIHJlbmRlciB0aGUgY2hhbmdlcyBhbmQgc3luY2hyb25pemUgLSB0aGlzIG1lYW5zIHRoYXQgdGhlIHN0eWxlXG5cdFx0XHQvLyBwcm9wZXJ0eSB3YXMgc2V0IGRpcmVjdGx5IHNvIHdlIHdpbGwgcmVzZXQgaXQgcHJlcGVuZGluZyBpdCB3aXRoIHRoZSBvcmlnaW5hbFxuXHRcdFx0Ly8gc3R5bGUgKGlmIGFueSkgZm9yIHRoZSBraW5kIGFuZCBrZWVwaW5nIHdoYXRldmVyIHRoZSBicm93c2VyIGlzIGtlZXBpbmdcblx0XHRcdGlmICh0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dCA9IHRoaXMua2luZFN0eWxlICsgKHRoaXMuc3R5bGUgfHwgJycpO1xuXHRcdFx0XHQvLyBub3cgd2Ugc3RvcmUgdGhlIHBhcnNlZCB2ZXJzaW9uXG5cdFx0XHRcdHRoaXMuY3NzVGV4dCA9IHRoaXMuc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgZGVsZWdhdGUgaGFzIGFuIG9wcG9ydHVuaXR5IHRvIGhhbmRsZSB0aGlzIGNoYW5nZVxuXHRcdFx0Ly8gc2VwYXJhdGVseSBpZiBpdCBuZWVkcyB0b1xuXHRcdFx0ZGVsZWdhdGUuaW52YWxpZGF0ZSh0aGlzLCAnc3R5bGUnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIGEgY29udHJvbCdzIENTUyBwcm9wZXJ0eSB2YWx1ZS4gVGhpcyBkb2Vzbid0IGp1c3QgcHVsbCB0aGVcblx0KiBhc3NpZ25lZCB2YWx1ZSBvZiBgcHJvcGA7IGl0IHJldHVybnMgdGhlIGJyb3dzZXIncyB1bmRlcnN0YW5kaW5nIG9mIGBwcm9wYCxcblx0KiB0aGUgXCJjb21wdXRlZFwiIHZhbHVlLiBJZiB0aGUgY29udHJvbCBpc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgYW5kIHlvdSBuZWVkXG5cdCogYSBkZWZhdWx0IHZhbHVlIChzdWNoIGFzIGAwYCksIGluY2x1ZGUgaXQgaW4gdGhlIGFyZ3VtZW50cyBhcyBgZGVmYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gZ2V0LlxuXHQqIEBwYXJhbSB7Kn0gW2RlZl0gLSBBbiBvcHRpb25hbCBkZWZhdWx0IHZhbHVlLCBpbiBjYXNlIHRoZSBjb250cm9sIGlzbid0XG5cdCogcmVuZGVyZWQgeWV0LlxuXHQqIEByZXR1cm5zIHsoU3RyaW5nfE51bWJlcil9IFRoZSBjb21wdXRlZCB2YWx1ZSBvZiBgcHJvcGAsIGFzIHRoZSBicm93c2VyXG5cdCogc2VlcyBpdC5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldENvbXB1dGVkU3R5bGVWYWx1ZTogZnVuY3Rpb24gKHByb3AsIGRlZikge1xuXHRcdHJldHVybiB0aGlzLmhhc05vZGUoKSA/IERvbS5nZXRDb21wdXRlZFN0eWxlVmFsdWUodGhpcy5ub2RlLCBwcm9wKSA6IGRlZjtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaW5kTm9kZUJ5SWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pZCAmJiAodGhpcy5ub2RlID0gRG9tLmJ5SWQodGhpcy5pZCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlkQ2hhbmdlZDogZnVuY3Rpb24gKHdhcykge1xuXHRcdGlmICh3YXMpIENvbnRyb2wudW5yZWdpc3RlckRvbUV2ZW50cyh3YXMpO1xuXHRcdGlmICh0aGlzLmlkKSB7XG5cdFx0XHRDb250cm9sLnJlZ2lzdGVyRG9tRXZlbnRzKHRoaXMuaWQsIHRoaXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnRlbnRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGRlbGVnYXRlID0gdGhpcy5yZW5kZXJEZWxlZ2F0ZSB8fCBDb250cm9sLnJlbmRlckRlbGVnYXRlO1xuXHRcdGRlbGVnYXRlLmludmFsaWRhdGUodGhpcywgJ2NvbnRlbnQnKTtcblx0fSxcblxuXHQvKipcblx0KiBJZiB0aGUgY29udHJvbCBoYXMgYmVlbiBnZW5lcmF0ZWQsIHJlLWZsb3dzIHRoZSBjb250cm9sLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRiZWZvcmVDaGlsZFJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGlmIHdlIGFyZSBnZW5lcmF0ZWQsIHdlIHNob3VsZCBmbG93IGJlZm9yZSByZW5kZXJpbmcgYSBjaGlsZDtcblx0XHQvLyBpZiBub3QsIHRoZSByZW5kZXIgY29udGV4dCBpc24ndCByZWFkeSBhbnl3YXlcblx0XHRpZiAodGhpcy5nZW5lcmF0ZWQpIHRoaXMuZmxvdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNob3dpbmdDaGFuZ2VkOiBmdW5jdGlvbiAod2FzKSB7XG5cdFx0Ly8gaWYgd2UgYXJlIGNoYW5naW5nIGZyb20gbm90IHNob3dpbmcgdG8gc2hvd2luZyB3ZSBhdHRlbXB0IHRvIGZpbmQgd2hhdGV2ZXJcblx0XHQvLyBvdXIgbGFzdCBrbm93biB2YWx1ZSBmb3IgZGlzcGxheSB3YXMgb3IgdXNlIHRoZSBkZWZhdWx0XG5cdFx0aWYgKCF3YXMgJiYgdGhpcy5zaG93aW5nKSB7XG5cdFx0XHR0aGlzLmFwcGx5U3R5bGUoJ2Rpc3BsYXknLCB0aGlzLl9kaXNwbGF5IHx8ICcnKTtcblx0XHRcdHRoaXMuc2VuZFNob3dpbmdDaGFuZ2VkRXZlbnQod2FzKTtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSBhcmUgc3VwcG9zZWQgdG8gYmUgaGlkaW5nIHRoZSBjb250cm9sIHRoZW4gd2UgbmVlZCB0byBjYWNoZSBvdXIgY3VycmVudFxuXHRcdC8vIGRpc3BsYXkgc3RhdGVcblx0XHRlbHNlIGlmICh3YXMgJiYgIXRoaXMuc2hvd2luZykge1xuXHRcdFx0dGhpcy5zZW5kU2hvd2luZ0NoYW5nZWRFdmVudCh3YXMpO1xuXHRcdFx0Ly8gd2UgY2FuJ3QgdHJ1bHkgY2FjaGUgdGhpcyBiZWNhdXNlIGl0IF9jb3VsZF8gcG90ZW50aWFsbHkgYmUgc2V0IHRvIG11bHRpcGxlXG5cdFx0XHQvLyB2YWx1ZXMgdGhyb3VnaG91dCBpdHMgbGlmZWN5Y2xlIGFsdGhvdWdoIHRoYXQgc2VlbXMgaGlnaGx5IHVubGlrZWx5Li4uXG5cdFx0XHR0aGlzLl9kaXNwbGF5ID0gdGhpcy5oYXNOb2RlKCkgPyB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA6ICcnO1xuXHRcdFx0dGhpcy5hcHBseVN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZW5kU2hvd2luZ0NoYW5nZWRFdmVudDogZnVuY3Rpb24gKHdhcykge1xuXHRcdHZhciB3YXRlcmZhbGwgPSAod2FzID09PSB0cnVlIHx8IHdhcyA9PT0gZmFsc2UpLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHQvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIHRoZSB3YXRlcmZhbGwgd2hlbiB0aGlzIG1ldGhvZFxuXHRcdC8vIGlzIGFyYml0cmFyaWx5IGNhbGxlZCBkdXJpbmcgX2NyZWF0ZV8gYW5kIGl0IHNob3VsZCBvbmx5IG1hdHRlclxuXHRcdC8vIHRoYXQgaXQgY2hhbmdlZCBpZiBvdXIgcGFyZW50J3MgYXJlIGFsbCBzaG93aW5nIGFzIHdlbGxcblx0XHRpZiAod2F0ZXJmYWxsICYmIChwYXJlbnQgPyBwYXJlbnQuZ2V0QWJzb2x1dGVTaG93aW5nKHRydWUpIDogdHJ1ZSkpIHtcblx0XHRcdHRoaXMud2F0ZXJmYWxsKCdvblNob3dpbmdDaGFuZ2VkJywge29yaWdpbmF0b3I6IHRoaXMsIHNob3dpbmc6IHRoaXMuc2hvd2luZ30pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGNvbnRyb2wgYW5kIGFsbCBwYXJlbnRzIGFyZSBzaG93aW5nLlxuXHQqXG5cdCogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVCb3VuZHMgLSBJZiBgdHJ1ZWAsIGl0IHdpbGwgbm90IGZvcmNlIGEgbGF5b3V0IGJ5IHJldHJpZXZpbmdcblx0Klx0Y29tcHV0ZWQgYm91bmRzIGFuZCByZWx5IG9uIHRoZSByZXR1cm4gZnJvbSBbc2hvd2luZ117QGxpbmsgZW55by5Db250cm9sI3Nob3dpbmd9XG5cdCogZXhjbHVzaXZlbHkuXG5cdCogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgc2hvd2luZyAodmlzaWJsZSkuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRBYnNvbHV0ZVNob3dpbmc6IGZ1bmN0aW9uIChpZ25vcmVCb3VuZHMpIHtcblx0XHR2YXIgYm91bmRzID0gIWlnbm9yZUJvdW5kcyA/IHRoaXMuZ2V0Qm91bmRzKCkgOiBudWxsLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIXRoaXMuZ2VuZXJhdGVkIHx8IHRoaXMuZGVzdHJveWVkIHx8ICF0aGlzLnNob3dpbmcgfHwgKGJvdW5kcyAmJlxuXHRcdFx0Ym91bmRzLmhlaWdodCA9PT0gMCAmJiBib3VuZHMud2lkdGggPT09IDApKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZ2V0QWJzb2x1dGVTaG93aW5nKSB7XG5cblx0XHRcdC8vIHdlIGFjdHVhbGx5IGRvbid0IGNhcmUgd2hhdCB0aGUgcGFyZW50IHNheXMgaWYgaXQgaXMgdGhlIGZsb2F0aW5nIGxheWVyXG5cdFx0XHRpZiAoIXRoaXMucGFyZW50Tm9kZSB8fCAodGhpcy5wYXJlbnROb2RlICE9PSBDb250cm9sLmZsb2F0aW5nTGF5ZXIuaGFzTm9kZSgpKSkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50LmdldEFic29sdXRlU2hvd2luZyhpZ25vcmVCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgdGhlIGBvblNob3dpbmdDaGFuZ2VkYCBldmVudCB0aGF0IGlzIHdhdGVyZmFsbGVkIGJ5IGNvbnRyb2xzIHdoZW5cblx0KiB0aGVpciBgc2hvd2luZ2AgdmFsdWUgaXMgbW9kaWZpZWQuIElmIHRoZSBjb250cm9sIGlzIG5vdCBzaG93aW5nIGl0c2VsZlxuXHQqIGFscmVhZHksIGl0IHdpbGwgbm90IGNvbnRpbnVlIHRoZSB3YXRlcmZhbGwuIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvXG5cdCogcHJvdmlkZSBhZGRpdGlvbmFsIGhhbmRsaW5nIGZvciB0aGlzIGV2ZW50LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd2luZ0NoYW5nZWRIYW5kbGVyOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHJldHVybiBzZW5kZXIgPT09IHRoaXMgPyBmYWxzZSA6ICF0aGlzLnNob3dpbmc7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Zml0Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucGFyZW50LnJlZmxvdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB3ZSBhcmUgaW4gZnVsbHNjcmVlbiBtb2RlIG9yIG5vdC5cblx0KlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgaW4gZnVsbHNjcmVlbiBtb2RlLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLmhhc05vZGUoKSAmJiB0aGlzLm5vZGUgPT09IGZ1bGxzY3JlZW4uZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVxdWVzdHMgdGhhdCB0aGlzIGNvbnRyb2wgYmUgZGlzcGxheWVkIGZ1bGxzY3JlZW4gKGxpa2UgYSB2aWRlb1xuXHQqIGNvbnRhaW5lcikuIElmIHRoZSByZXF1ZXN0IGlzIGdyYW50ZWQsIHRoZSBjb250cm9sIGZpbGxzIHRoZSBzY3JlZW4gYW5kXG5cdCogYHRydWVgIGlzIHJldHVybmVkOyBpZiB0aGUgcmVxdWVzdCBpcyBkZW5pZWQsIHRoZSBjb250cm9sIGlzIG5vdCByZXNpemVkXG5cdCogYW5kIGBmYWxzZWAgaXMgcmV0dXJuZWQuXG5cdCpcblx0KiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIG9uIHN1Y2Nlc3M7IG90aGVyd2lzZSwgYGZhbHNlYC5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlcXVlc3RGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmhhc05vZGUoKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKGZ1bGxzY3JlZW4ucmVxdWVzdEZ1bGxzY3JlZW4odGhpcykpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0KiBFbmRzIGZ1bGxzY3JlZW4gbW9kZSBmb3IgdGhpcyBjb250cm9sLlxuXHQqXG5cdCogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSBjb250cm9sIHdhcyBpbiBmdWxsc2NyZWVuIG1vZGUgYmVmb3JlIHRoaXNcblx0KiBtZXRob2Qgd2FzIGNhbGxlZCwgaXQgaXMgdGFrZW4gb3V0IG9mIHRoYXQgbW9kZSBhbmQgYHRydWVgIGlzIHJldHVybmVkO1xuXHQqIG90aGVyd2lzZSwgYGZhbHNlYCBpcyByZXR1cm5lZC5cblx0KiBAcHVibGljXG5cdCovXG5cdGNhbmNlbEZ1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzRnVsbHNjcmVlbigpKSB7XG5cdFx0XHRmdWxsc2NyZWVuLmNhbmNlbEZ1bGxzY3JlZW4oKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cblxuXHQvLyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cblx0Ly8gUkVOREVSLVNDSEVNRSBBUElcblxuXHQvKipcblx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29udHJvbCBpcyBhbGxvd2VkIHRvIGJlIGdlbmVyYXRlZCwgaS5lLiwgcmVuZGVyZWRcblx0KiBpbnRvIHRoZSBbRE9NXXtAZ2xvc3NhcnkgRE9NfSB0cmVlLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2FuR2VuZXJhdGU6IHRydWUsXG5cblx0LyoqXG5cdCogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgdmlzaWJsZS5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHRydWVcblx0KiBAcHVibGljXG5cdCovXG5cdHNob3dpbmc6IHRydWUsXG5cblx0LyoqXG5cdCogVGhlIFtub2RlXXtAZ2xvc3NhcnkgTm9kZX0gdGhhdCB0aGlzIGNvbnRyb2wgd2lsbCBiZSByZW5kZXJlZCBpbnRvLlxuXHQqXG5cdCogQHR5cGUge2VueW8uQ29udHJvbH1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW5kZXJEZWxlZ2F0ZTogbnVsbCxcblxuXHQvKipcblx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29udHJvbCBoYXMgYmVlbiBnZW5lcmF0ZWQgeWV0LlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZW5lcmF0ZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEZvcmNlcyB0aGUgY29udHJvbCB0byBiZSByZW5kZXJlZC4gWW91IHNob3VsZCB1c2UgdGhpcyBzcGFyaW5nbHksIGFzIGl0XG5cdCogY2FuIGJlIGNvc3RseSwgYnV0IGl0IG1heSBiZSBuZWNlc3NhcnkgaW4gY2FzZXMgd2hlcmUgYSBjb250cm9sIG9yIGl0c1xuXHQqIGNvbnRlbnRzIGhhdmUgYmVlbiB1cGRhdGVkIHN1cnJlcHRpdGlvdXNseS5cblx0KlxuXHQqIEByZXR1cm5zIHt0aGlzfSBUaGUgY2FsbGVlIGZvciBjaGFpbmluZy5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcHJpb3JpdGl6ZSB0aGUgZGVsZWdhdGUgc2V0IGZvciB0aGlzIGNvbnRyb2wgb3RoZXJ3aXNlIHVzZSB0aGUgZGVmYXVsdFxuXHRcdHZhciBkZWxlZ2F0ZSA9IHRoaXMucmVuZGVyRGVsZWdhdGUgfHwgQ29udHJvbC5yZW5kZXJEZWxlZ2F0ZTtcblxuXHRcdC8vIHRoZSByZW5kZXIgZGVsZWdhdGUgYWN0cyBvbiB0aGUgY29udHJvbFxuXHRcdGRlbGVnYXRlLnJlbmRlcih0aGlzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFRha2VzIHRoaXMgY29udHJvbCBhbmQgZHJvcHMgaXQgaW50byBhIChuZXcvZGlmZmVyZW50KVxuXHQqIFtET00gbm9kZV17QGdsb3NzYXJ5IE5vZGV9LiBUaGlzIHdpbGwgcmVwbGFjZSBhbnkgZXhpc3Rpbmcgbm9kZXMgaW4gdGhlXG5cdCogdGFyZ2V0IGBwYXJlbnROb2RlYC5cblx0KlxuXHQqIEBwYXJhbSB7Tm9kZX0gcGFyZW50Tm9kZSAtIFRoZSBuZXcgcGFyZW50IG9mIHRoaXMgY29udHJvbC5cblx0KiBAcGFyYW0ge0Jvb2xlYW59IHByZXZlbnRSb290aW5nIC0gSWYgYHRydWVgLCB0aGlzIGNvbnRyb2wgd2lsbCBub3QgYmUgdHJlYXRlZCBhcyBhIHJvb3QgXG5cdCpcdHZpZXcgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBzZXQgb2Ygcm9vdHMuXG5cdCogQHJldHVybnMge3RoaXN9IFRoZSBjYWxsZWUgZm9yIGNoYWluaW5nLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVuZGVySW50bzogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHByZXZlbnRSb290aW5nKSB7XG5cdFx0dmFyIGRlbGVnYXRlID0gdGhpcy5yZW5kZXJEZWxlZ2F0ZSB8fCBDb250cm9sLnJlbmRlckRlbGVnYXRlLFxuXHRcdFx0bm9GaXQgPSB0aGlzLmZpdCA9PT0gZmFsc2U7XG5cblx0XHQvLyBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBwYXJlbnROb2RlXG5cdFx0cGFyZW50Tm9kZSA9IERvbS5ieUlkKHBhcmVudE5vZGUpO1xuXG5cdFx0Ly8gdGVhcmRvd24gaW4gY2FzZSBvZiBwcmV2aW91cyByZW5kZXJcblx0XHRkZWxlZ2F0ZS50ZWFyZG93blJlbmRlcih0aGlzKTtcblxuXHRcdGlmIChwYXJlbnROb2RlID09IGRvY3VtZW50LmJvZHkgJiYgIW5vRml0KSB0aGlzLnNldHVwQm9keUZpdHRpbmcoKTtcblx0XHRlbHNlIGlmICh0aGlzLmZpdCkgdGhpcy5hZGRDbGFzcygnZW55by1maXQgZW55by1jbGlwJyk7XG5cblx0XHQvLyBmb3IgSUUxMCBzdXBwb3J0LCB3ZSB3YW50IGZ1bGwgc3VwcG9ydCBvdmVyIHRvdWNoIGFjdGlvbnMgaW4gZW55by1yZW5kZXJlZCBhcmVhc1xuXHRcdHRoaXMuYWRkQ2xhc3MoJ2VueW8tbm8tdG91Y2gtYWN0aW9uJyk7XG5cblx0XHQvLyBhZGQgY3NzIHRvIGVuYWJsZSBody1hY2NlbGVyYXRlZCBzY3JvbGxpbmcgb24gbm9uLWFuZHJvaWQgcGxhdGZvcm1zXG5cdFx0Ly8gRU5ZTy05MDAsIEVOWU8tOTAxXG5cdFx0dGhpcy5zZXR1cE92ZXJmbG93U2Nyb2xsaW5nKCk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgdW5mbHVzaGVkIGJvZHkgY2xhc3NlcyB3ZSBmbHVzaCB0aGVtIG5vdy4uLlxuXHRcdERvbS5mbHVzaEJvZHlDbGFzc2VzKCk7XG5cblx0XHQvLyB3ZSBpbmplY3QgdGhpcyBhcyBhIHJvb3QgdmlldyBiZWNhdXNlLCB3ZWxsLCBhcHBhcmVudGx5IHRoYXQgaXMganVzdCBhbiBhc3N1bXB0aW9uXG5cdFx0Ly8gd2UndmUgYmVlbiBtYWtpbmcuLi5cblx0XHRpZiAoIXByZXZlbnRSb290aW5nKSB7XG5cdFx0XHRyb290cy5hZGRUb1Jvb3RzKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vIG5vdyBsZXQgdGhlIGRlbGVnYXRlIHJlbmRlciBpdCB0aGUgd2F5IGl0IG5lZWRzIHRvXG5cdFx0ZGVsZWdhdGUucmVuZGVySW50byh0aGlzLCBwYXJlbnROb2RlKTtcblxuXHRcdERvbS51cGRhdGVTY2FsZUZhY3RvcigpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogQSBmdW5jdGlvbiB0aGF0IGZpcmVzIGFmdGVyIHRoZSBjb250cm9sIGhhcyByZW5kZXJlZC4gVGhpcyBwZXJmb3JtcyBhXG5cdCogcmVmbG93LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW5kZXJlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGlsZCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Ly8gQ0FWRUFUOiBDdXJyZW50bHkgd2UgdXNlIG9uZSBlbnRyeSBwb2ludCAoJ3JlZmxvdycpIGZvclxuXHRcdC8vIHBvc3QtcmVuZGVyIGxheW91dCB3b3JrICphbmQqIHBvc3QtcmVzaXplIGxheW91dCB3b3JrLlxuXHRcdHRoaXMucmVmbG93KCk7XG5cblx0XHRmb3IgKDsgKGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSk7ICsraSkge1xuXHRcdFx0aWYgKGNoaWxkLmdlbmVyYXRlZCkgY2hpbGQucmVuZGVyZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogWW91IHNob3VsZCBnZW5lcmFsbHkgbm90IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiB5b3VyIGFwcCBjb2RlLlxuXHQqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSBzb21lIEVueW8gVUkgbGlicmFyaWVzIHRvIGhhbmRsZSBhIHJhcmVcblx0KiBpc3N1ZSB0aGF0IHNvbWV0aW1lcyBhcmlzZXMgd2hlbiB1c2luZyBhIHZpcnR1YWxpemVkIGxpc3Qgb3IgcmVwZWF0ZXJcblx0KiBvbiBhIHRvdWNoIGRldmljZS5cblx0KlxuXHQqIFRoaXMgaXNzdWUgb2NjdXJzIHdoZW4gYSBnZXN0dXJlIChlLmcuIGEgZHJhZykgb3JpZ2luYXRlcyB3aXRoIGEgRE9NXG5cdCogbm9kZSB0aGF0IGVuZHMgdXAgYmVpbmcgZGVzdHJveWVkIGluIG1pZC1nZXN0dXJlIGFzIHRoZSBsaXN0IHVwZGF0ZXMuXG5cdCogV2hlbiB0aGUgbm9kZSBpcyBkZXN0cm95ZWQsIHRoZSBzdHJlYW0gb2YgRE9NIGV2ZW50cyByZXByZXNlbnRpbmcgdGhlXG5cdCogZ2VzdHVyZSBzdG9wcywgY2F1c2luZyB0aGUgYXNzb2NpYXRlZCBhY3Rpb24gdG8gc3RvcCBvciBvdGhlcndpc2Vcblx0KiBmYWlsLlxuXHQqXG5cdCogWW91IGNhbiBwcmV2ZW50IHRoaXMgcHJvYmxlbSBmcm9tIG9jY3VycmluZyBieSBjYWxsaW5nIGByZXRhaW5Ob2RlYFxuXHQqIG9uIHRoZSB7QGxpbmsgZW55by5Db250cm9sfSBmcm9tIHdoaWNoIHRoZSBnZXN0dXJlIG9yaWdpbmF0ZXMuIERvaW5nXG5cdCogc28gd2lsbCBjYXVzZSBFbnlvIHRvIGtlZXAgdGhlIERPTSBub2RlIGFyb3VuZCAoaGlkZGVuIGZyb20gdmlldylcblx0KiB1bnRpbCB5b3UgZXhwbGljaXRseSByZWxlYXNlIGl0LiBZb3Ugc2hvdWxkIGNhbGwgYHJldGFpbk5vZGVgIGluIHRoZVxuXHQqIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBldmVudCB0aGF0IHN0YXJ0cyB0aGUgZ2VzdHVyZS5cblx0KlxuXHQqIGByZXRhaW5Ob2RlYCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB5b3UgbXVzdCBjYWxsIHdoZW4gdGhlIGdlc3R1cmVcblx0KiBlbmRzIHRvIHJlbGVhc2UgdGhlIG5vZGUuIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGF2b2lkXG5cdCogXCJsZWFraW5nXCIgdGhlIERPTSBub2RlIChmYWlsaW5nIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBET00pLlxuXHQqXG5cdCogQHBhcmFtIHtOb2RlfSBub2RlIC0gT3B0aW9uYWwuIERlZmF1bHRzIHRvIHRoZSBub2RlIGFzc29jaWF0ZWQgd2l0aFxuXHQqIHRoZSBDb250cm9sIChgQ29udHJvbC5ub2RlYCkuIFlvdSBjYW4gZ2VuZXJhbGx5IG9taXQgdGhpcyBwYXJhbWV0ZXJcblx0KiB3aGVuIHdvcmtpbmcgd2l0aCB7QGxpbmsgZW55by5EYXRhTGlzdH0gb3Ige0BsaW5rIGVueW8uRGF0YUdyaWRMaXN0fSxcblx0KiBidXQgc2hvdWxkIGdlbmVyYWxseSBwYXNzIGluIHRoZSBldmVudCdzIHRhcmdldCBub2RlIChgZXZlbnQudGFyZ2V0YClcblx0KiB3aGVuIHdvcmtpbmcgd2l0aCB7QGxpbmsgZW55by5MaXN0fS4gKEJlY2F1c2Uge0BsaW5rIGVueW8uTGlzdH0gaXNcblx0KiBiYXNlZCBvbiB0aGUgRmx5d2VpZ2h0IHBhdHRlcm4sIHRoZSBldmVudCdzIHRhcmdldCBub2RlIGlzIG9mdGVuIG5vdFxuXHQqIHRoZSBub2RlIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhlIENvbnRyb2wgYXQgdGhlIHRpbWUgdGhlIGV2ZW50XG5cdCogb2NjdXJzLilcblx0KiBAcmV0dXJucyB7RnVuY3Rpb259IEtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBmdW5jdGlvbiBhbmQgY2FsbCBpdFxuXHQqIHRvIHJlbGVhc2UgdGhlIG5vZGUgd2hlbiB0aGUgZ2VzdHVyZSBoYXMgZW5kZWQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZXRhaW5Ob2RlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0dmFyIGNvbnRyb2wgPSB0aGlzLFxuXHRcdFx0cmV0YWluZWROb2RlID0gdGhpcy5fcmV0YWluZWROb2RlID0gKG5vZGUgfHwgdGhpcy5oYXNOb2RlKCkpO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChjb250cm9sICYmIChjb250cm9sLl9yZXRhaW5lZE5vZGUgPT0gcmV0YWluZWROb2RlKSkge1xuXHRcdFx0XHRjb250cm9sLl9yZXRhaW5lZE5vZGUgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVsZWFzZVJldGFpbmVkTm9kZShyZXRhaW5lZE5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGVhcmRvd25SZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZGVsZWdhdGUgPSB0aGlzLnJlbmRlckRlbGVnYXRlIHx8IENvbnRyb2wucmVuZGVyRGVsZWdhdGU7XG5cblx0XHRpZiAodGhpcy5fcmV0YWluZWROb2RlKSB7XG5cdFx0XHRzdG9yZVJldGFpbmVkTm9kZSh0aGlzKTtcblx0XHR9XG5cblx0XHRkZWxlZ2F0ZS50ZWFyZG93blJlbmRlcih0aGlzKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0ZWFyZG93bkNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGRlbGVnYXRlID0gdGhpcy5yZW5kZXJEZWxlZ2F0ZSB8fCBDb250cm9sLnJlbmRlckRlbGVnYXRlO1xuXG5cdFx0ZGVsZWdhdGUudGVhcmRvd25DaGlsZHJlbih0aGlzKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhZGROb2RlVG9QYXJlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG47XG5cblx0XHRpZiAodGhpcy5ub2RlKSB7XG5cdFx0XHRwbiA9IHRoaXMuZ2V0UGFyZW50Tm9kZSgpO1xuXHRcdFx0aWYgKHBuKSB7XG5cdFx0XHRcdGlmICh0aGlzLmFkZEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnNlcnROb2RlSW5QYXJlbnQocG4sIHRoaXMuYWRkQmVmb3JlICYmIHRoaXMuYWRkQmVmb3JlLmhhc05vZGUoKSk7XG5cdFx0XHRcdH0gZWxzZSB0aGlzLmFwcGVuZE5vZGVUb1BhcmVudChwbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFwcGVuZE5vZGVUb1BhcmVudDogZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuXHRcdHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbnNlcnROb2RlSW5QYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudE5vZGUsIGJlZm9yZU5vZGUpIHtcblx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIGJlZm9yZU5vZGUgfHwgcGFyZW50Tm9kZS5maXJzdENoaWxkKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW1vdmVOb2RlRnJvbURvbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGFzTm9kZSgpICYmIHRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG5cdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRQYXJlbnROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50Tm9kZSB8fCAodGhpcy5wYXJlbnQgJiYgKFxuXHRcdFx0dGhpcy5wYXJlbnQuaGFzTm9kZSgpIHx8IHRoaXMucGFyZW50LmdldFBhcmVudE5vZGUoKSlcblx0XHQpO1xuXHR9LFxuXG5cdC8vIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnN0cnVjdG9yOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdHZhciBhdHRycyA9IHByb3BzICYmIHByb3BzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdC8vIGVuc3VyZSB0aGF0IHdlIGJvdGgga2VlcCBhbiBpbnN0YW5jZSBjb3B5IG9mIGRlZmluZWQgYXR0cmlidXRlcyBidXQgYWxzb1xuXHRcdFx0Ly8gdXBkYXRlIHRoZSBoYXNoIHdpdGggYW55IGFkZGl0aW9uYWwgaW5zdGFuY2UgZGVmaW5pdGlvbnMgYXQgcnVudGltZVxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzID8gdXRpbHMuY2xvbmUodGhpcy5hdHRyaWJ1dGVzKSA6IHt9O1xuXHRcdFx0aWYgKGF0dHJzKSB7XG5cdFx0XHRcdHV0aWxzLm1peGluKHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuXHRcdFx0XHRkZWxldGUgIHByb3BzLmF0dHJpYnV0ZXM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdFx0dmFyIGNsYXNzZXM7XG5cblx0XHRcdC8vIGluaXRpYWxpemUgdGhlIHN0eWxlcyBmb3IgdGhpcyBpbnN0YW5jZVxuXHRcdFx0dGhpcy5zdHlsZSA9IHRoaXMua2luZFN0eWxlICsgdGhpcy5zdHlsZTtcblxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgdGhlIGRlZmF1bHQgdmFsdWUgYXNzaWduZWQgdG8gc2hvd2luZyBpcyBhY3R1YWxseSBhIGJvb2xlYW5cblx0XHRcdHRoaXMuc2hvd2luZyA9ICEhIHRoaXMuc2hvd2luZztcblxuXHRcdFx0Ly8gc3VwZXIgaW5pdGlhbGl6YXRpb25cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBlbnN1cmUgdGhhdCBpZiB3ZSBhcmVuJ3Qgc2hvd2luZyAtPiB0cnVlIHRoZW4gdGhlIGNvcnJlY3Qgc3R5bGVcblx0XHRcdC8vIGlzIGFwcGxpZWQgLSBub3RlIHRoYXQgdGhlcmUgbWlnaHQgYmUgaXNzdWVzIHdpdGggdGhpcyBiZWNhdXNlIHdlIGFyZVxuXHRcdFx0Ly8gdHJ5aW5nIG5vdCB0byBoYXZlIHRvIHBhcnNlIG91dCBhbnkgb3RoZXIgZXhwbGljaXQgZGlzcGxheSB2YWx1ZSBkdXJpbmdcblx0XHRcdC8vIGluaXRpYWxpemF0aW9uIGFuZCB3ZSBjYW4ndCBjaGVjayBiZWNhdXNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgeWV0XG5cdFx0XHRpZiAoIXRoaXMuc2hvd2luZykgdGhpcy5zdHlsZSArPSAnIGRpc3BsYXk6IG5vbmU7JztcblxuXHRcdFx0Ly8gdHJ5IGFuZCBtYWtlIGl0IHNvIHdlIG9ubHkgbmVlZCB0byBjYWxsIHRoZSBtZXRob2Qgb25jZSBkdXJpbmdcblx0XHRcdC8vIGluaXRpYWxpemF0aW9uIGFuZCBvbmx5IHRoZW4gd2hlbiB3ZSBoYXZlIHNvbWV0aGluZyB0byBhZGRcblx0XHRcdGNsYXNzZXMgPSB0aGlzLmtpbmRDbGFzc2VzO1xuXHRcdFx0aWYgKGNsYXNzZXMgJiYgdGhpcy5jbGFzc2VzKSBjbGFzc2VzICs9ICgnICcgKyB0aGlzLmNsYXNzZXMpO1xuXHRcdFx0ZWxzZSBpZiAodGhpcy5jbGFzc2VzKSBjbGFzc2VzID0gdGhpcy5jbGFzc2VzO1xuXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUga25vd24gY2xhc3NlcyBuZWVkZWQgdG8gYmUgYXBwbGllZCBmcm9tIHRoZSBraW5kXG5cdFx0XHQvLyBkZWZpbml0aW9uIGFuZCB0aGUgaW5zdGFuY2UgZGVmaW5pdGlvbiAoc3VjaCBhcyBhIGNvbXBvbmVudCBibG9jaylcblx0XHRcdHRoaXMuY2xhc3NlcyA9IHRoaXMuYXR0cmlidXRlc1snY2xhc3MnXSA9IGNsYXNzZXMgPyBjbGFzc2VzLnRyaW0oKSA6IGNsYXNzZXM7XG5cblx0XHRcdC8vIHNldHVwIHRoZSBpZCBmb3IgdGhpcyBjb250cm9sIGlmIHdlIGhhdmUgb25lXG5cdFx0XHR0aGlzLmlkQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5jb250ZW50Q2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIERlc3Ryb3lzIHRoZSBjb250cm9sIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIFtET01de0BnbG9zc2FyeSBET019LiBBbHNvXG5cdCogcmVtb3ZlcyB0aGUgY29udHJvbCdzIGFiaWxpdHkgdG8gcmVjZWl2ZSBidWJibGVkIGV2ZW50cy5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBpZiB0aGUgY29udHJvbCBoYXMgYmVlbiByZW5kZXJlZCB3ZSBlbnN1cmUgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cblx0XHRcdHRoaXMucmVtb3ZlTm9kZUZyb21Eb20oKTtcblxuXHRcdFx0Ly8gZW5zdXJlIG5vIG90aGVyIGJ1YmJsZWQgZXZlbnRzIGNhbiBiZSBkaXNwYXRjaGVkIHRvIHRoaXMgY29udHJvbFxuXHRcdFx0ZGlzcGF0Y2hlci4kW3RoaXMuaWRdID0gbnVsbDtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRpc3BhdGNoRXZlbnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBldmVudCwgc2VuZGVyKSB7XG5cdFx0XHQvLyBwcmV2ZW50IGRpc3BhdGNoIGFuZCBidWJibGUgb2YgZXZlbnRzIHRoYXQgYXJlIHN0cmljdGx5IGludGVybmFsIChlLmcuXG5cdFx0XHQvLyBlbnRlci9sZWF2ZSlcblx0XHRcdGlmICh0aGlzLnN0cmljdGx5SW50ZXJuYWxFdmVudHNbbmFtZV0gJiYgdGhpcy5pc0ludGVybmFsRXZlbnQoZXZlbnQpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFkZENoaWxkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdFx0Y29udHJvbC5hZGRDbGFzcyh0aGlzLmNvbnRyb2xDbGFzc2VzKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbW92ZUNoaWxkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRjb250cm9sLnJlbW92ZUNsYXNzKHRoaXMuY29udHJvbENsYXNzZXMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvcHRzKSB7XG5cdFx0XHQvLyB0aGlzIHNob3VsZCBiZSB1cGRhdGVkIGlmIGEgYmV0dGVyIGFwaSBmb3IgaG9va2luZyBiZWNvbWVzIGF2YWlsYWJsZSBidXQgZm9yXG5cdFx0XHQvLyBub3cgd2UganVzdCBkbyB0aGlzIGRpcmVjdGx5IHRvIGVuc3VyZSB0aGF0IHRoZSBzaG93aW5nIHZhbHVlIGlzIGFjdHVhbGx5XG5cdFx0XHQvLyBhIGJvb2xlYW5cblx0XHRcdGlmIChwYXRoID09ICdzaG93aW5nJykge1xuXHRcdFx0XHRyZXR1cm4gc3VwLmNhbGwodGhpcywgcGF0aCwgISEgdmFsdWUsIG9wdHMpO1xuXHRcdFx0fSBlbHNlIHJldHVybiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvLyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cblx0Ly8gQkFDS1dBUkRTIENPTVBBVElCTEUgQVBJLCBMRUdBQ1kgTUVUSE9EUyBBTkQgUFVCTElDIFBST1BFUlRZXG5cdC8vIE1FVEhPRFMgT1IgUFJPUEVSVElFUyBUSEFUIFBST0JBQkxZIFNIT1VMRCBOT1QgQkUgSEVSRSBCVVQgQVJFIEFOWVdBWVxuXG5cdC8qKlxuXHQqIEFwcGFyZW50bHkgdXNlZCBieSBBcmVzIDIgc3RpbGwgYnV0IHdlIGhhdmUgdGhlIHByb3BlcnR5IGVtYmVkZGVkIGluIHRoZSBraW5kLi4uXG5cdCpcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGlzQ29udGFpbmVyOiBmYWxzZSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRydGw6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldHVwQm9keUZpdHRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHREb20uYXBwbHlCb2R5Rml0KCk7XG5cdFx0dGhpcy5hZGRDbGFzcygnZW55by1maXQgZW55by1jbGlwJyk7XG5cdH0sXG5cblx0Lypcblx0KiBJZiB0aGUgcGxhdGZvcm0gaXMgQW5kcm9pZCBvciBBbmRyb2lkLUNocm9tZSwgZG9uJ3QgaW5jbHVkZSB0aGUgY3NzIHJ1bGVcblx0KiBgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoYCwgYXMgaXQgaXMgbm90IHN1cHBvcnRlZCBpbiBBbmRyb2lkIGFuZCBsZWFkcyB0b1xuXHQqIG92ZXJmbG93IGlzc3VlcyAoRU5ZTy05MDAgYW5kIEVOWU8tOTAxKS4gU2ltaWxhcmx5LCBCQjEwIGhhcyBpc3N1ZXMgcmVwYWludGluZ1xuXHQqIG91dC1vZi12aWV3cG9ydCBjb250ZW50IHdoZW4gYC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nYCBpcyB1c2VkIChFTllPLTEzOTYpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0dXBPdmVyZmxvd1Njcm9sbGluZzogZnVuY3Rpb24gKCkge1xuXHRcdGlmKHBsYXRmb3JtLmFuZHJvaWQgfHwgcGxhdGZvcm0uYW5kcm9pZENocm9tZSB8fCBwbGF0Zm9ybS5ibGFja2JlcnJ5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdERvbS5hZGRCb2R5Q2xhc3MoJ3dlYmtpdE92ZXJmbG93U2Nyb2xsaW5nJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgY29udHJvbCdzIGRpcmVjdGlvbmFsaXR5IGJhc2VkIG9uIGl0cyBjb250ZW50LCBvciBhbiBvcHRpb25hbCBgc3RyaW5nSW5zdGVhZGAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ0luc3RlYWRdIEFuIGFsdGVybmF0ZSBzdHJpbmcgZm9yIGNvbnNpZGVyYXRpb24gbWF5IGJlIHNlbnQgaW5zdGVhZCxcblx0Klx0aW4tY2FzZSB0aGUgc3RyaW5nIHRvIHRlc3QgdGhlIGRpcmVjdGlvbmFsaXR5IG9mIHRoZSBjb250cm9sIGlzIHN0b3JlZCBpbiBgdGhpcy52YWx1ZWAsXG5cdCpcdG9yIHNvbWUgb3RoZXIgcHJvcGVydHksIGZvciBleGFtcGxlLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRldGVjdFRleHREaXJlY3Rpb25hbGl0eTogZnVuY3Rpb24gKHN0cmluZ0luc3RlYWQpIHtcblx0XHQvLyBJZiBhbiBhcmd1bWVudCB3YXMgc3VwcGxpZWQgYXQgYWxsLCB1c2UgaXQsIGV2ZW4gaWYgaXQncyB1bmRlZmluZWQuXG5cdFx0Ly8gVmFsdWVzIHRoYXQgYXJlIG51bGwgb3IgdW5kZWZpbmVkLCBvciBhcmUgbnVtYmVycywgYXJyYXlzLCBhbmQgc29tZSBvYmplY3RzIGFyZSBzYWZlXG5cdFx0Ly8gdG8gYmUgdGVzdGVkLlxuXHRcdHZhciBzdHIgPSAoYXJndW1lbnRzLmxlbmd0aCkgPyBzdHJpbmdJbnN0ZWFkIDogdGhpcy5jb250ZW50O1xuXHRcdGlmIChzdHIgfHwgc3RyID09PSAwKSB7XG5cdFx0XHR0aGlzLnJ0bCA9IHV0aWxzLmlzUnRsKHN0cik7XG5cdFx0XHR0aGlzLmFwcGx5U3R5bGUoJ2RpcmVjdGlvbicsIHRoaXMucnRsID8gJ3J0bCcgOiAnbHRyJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXBwbHlTdHlsZSgnZGlyZWN0aW9uJywgbnVsbCk7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXG5cblx0Ly8gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXG5cdC8vIERFUFJFQ0FURURcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0VGFnOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGFnO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRUYWc6IGZ1bmN0aW9uICh0YWcpIHtcblx0XHR2YXIgd2FzID0gdGhpcy50YWc7XG5cblx0XHRpZiAodGFnICYmIHR5cGVvZiB0YWcgPT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMudGFnID0gdGFnO1xuXHRcdFx0aWYgKHdhcyAhPT0gdGFnKSB0aGlzLm5vdGlmeSgndGFnJywgd2FzLCB0YWcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0QXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdHNldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRycykge1xuXHRcdHZhciB3YXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRpZiAodHlwZW9mIGF0dHJzID09ICdvYmplY3QnKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRycztcblx0XHRcdGlmIChhdHRycyAhPT0gd2FzKSB0aGlzLm5vdGlmeSgnYXR0cmlidXRlcycsIHdhcywgYXR0cnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3Nlcztcblx0fSxcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0Q2xhc3NlczogZnVuY3Rpb24gKGNsYXNzZXMpIHtcblx0XHR2YXIgd2FzID0gdGhpcy5jbGFzc2VzO1xuXG5cdFx0dGhpcy5jbGFzc2VzID0gY2xhc3Nlcztcblx0XHRpZiAod2FzICE9IGNsYXNzZXMpIHRoaXMubm90aWZ5KCdjbGFzc2VzJywgd2FzLCBjbGFzc2VzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnN0eWxlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0dmFyIHdhcyA9IHRoaXMuc3R5bGU7XG5cblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0aWYgKHdhcyAhPSBzdHlsZSkgdGhpcy5ub3RpZnkoJ3N0eWxlJywgd2FzLCBzdHlsZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRlbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0dmFyIHdhcyA9IHRoaXMuY29udGVudDtcblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXG5cdFx0aWYgKHdhcyAhPSBjb250ZW50KSB0aGlzLm5vdGlmeSgnY29udGVudCcsIHdhcywgY29udGVudCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0U2hvd2luZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNob3dpbmc7XG5cdH0sXG5cblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNob3dpbmc6IGZ1bmN0aW9uIChzaG93aW5nKSB7XG5cdFx0dmFyIHdhcyA9IHRoaXMuc2hvd2luZztcblxuXHRcdC8vIGZvcmNlIHRoZSBzaG93aW5nIHByb3BlcnR5IHRvIGFsd2F5cyBiZSBhIGJvb2xlYW4gdmFsdWVcblx0XHR0aGlzLnNob3dpbmcgPSAhISBzaG93aW5nO1xuXG5cdFx0aWYgKHdhcyAhPSBzaG93aW5nKSB0aGlzLm5vdGlmeSgnc2hvd2luZycsIHdhcywgc2hvd2luZyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0QWxsb3dIdG1sOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWxsb3dIdG1sO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRBbGxvd0h0bWw6IGZ1bmN0aW9uIChhbGxvdykge1xuXHRcdHZhciB3YXMgPSB0aGlzLmFsbG93SHRtbDtcblx0XHR0aGlzLmFsbG93SHRtbCA9ICEhIGFsbG93O1xuXG5cdFx0aWYgKHdhcyAhPT0gYWxsb3cpIHRoaXMubm90aWZ5KCdhbGxvd0h0bWwnLCB3YXMsIGFsbG93KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRDYW5HZW5lcmF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNhbkdlbmVyYXRlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRDYW5HZW5lcmF0ZTogZnVuY3Rpb24gKGNhbikge1xuXHRcdHZhciB3YXMgPSB0aGlzLmNhbkdlbmVyYXRlO1xuXHRcdHRoaXMuY2FuR2VuZXJhdGUgPSAhISBjYW47XG5cblx0XHRpZiAod2FzICE9PSBjYW4pIHRoaXMubm90aWZ5KCdjYW5HZW5lcmF0ZScsIHdhcywgY2FuKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRGaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5maXQ7XG5cdH0sXG5cblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdHNldEZpdDogZnVuY3Rpb24gKGZpdCkge1xuXHRcdHZhciB3YXMgPSB0aGlzLmZpdDtcblx0XHR0aGlzLmZpdCA9ICEhIGZpdDtcblxuXHRcdGlmICh3YXMgIT09IGZpdCkgdGhpcy5ub3RpZnkoJ2ZpdCcsIHdhcywgZml0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBhcmVzXG5cdCogQGRlcHJlY2F0ZWRcblx0KiBAcHVibGljXG5cdCovXG5cdGdldElzQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNDb250YWluZXI7XG5cdH0sXG5cblx0LyoqXG5cdCogQGFyZXNcblx0KiBAZGVwcmVjYXRlZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0SXNDb250YWluZXI6IGZ1bmN0aW9uIChpc0NvbnRhaW5lcikge1xuXHRcdHZhciB3YXMgPSB0aGlzLmlzQ29udGFpbmVyO1xuXHRcdHRoaXMuaXNDb250YWluZXIgPSAhISBpc0NvbnRhaW5lcjtcblxuXHRcdGlmICh3YXMgIT09IGlzQ29udGFpbmVyKSB0aGlzLm5vdGlmeSgnaXNDb250YWluZXInLCB3YXMsIGlzQ29udGFpbmVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXG5cbn0pO1xuXG4vKipcbiogQHN0YXRpY1xuKiBAcHVibGljXG4qL1xua2luZC5zZXREZWZhdWx0Q3RvcihDb250cm9sKTtcblxuLyoqXG4qIEBzdGF0aWNcbiogQHB1YmxpY1xuKi9cbkNvbnRyb2wucmVuZGVyRGVsZWdhdGUgPSBIVE1MU3RyaW5nRGVsZWdhdGU7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKi9cbkNvbnRyb2wucmVnaXN0ZXJEb21FdmVudHMgPSBmdW5jdGlvbiAoaWQsIGNvbnRyb2wpIHtcblx0ZGlzcGF0Y2hlci4kW2lkXSA9IGNvbnRyb2w7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5Db250cm9sLnVucmVnaXN0ZXJEb21FdmVudHMgPSBmdW5jdGlvbiAoaWQpIHtcblx0ZGlzcGF0Y2hlci4kW2lkXSA9IG51bGw7XG59O1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5Db250cm9sLm5vcm1hbGl6ZUNzc1N0eWxlU3RyaW5nID0gZnVuY3Rpb24gKHN0eWxlKSB7XG5cdHJldHVybiBzdHlsZSA/IChcblx0XHQoXCI7XCIgKyBzdHlsZSlcblx0XHQvLyBhZGQgYSBzZW1pLWNvbG9uIGlmIGl0J3Mgbm90IHRoZSBsYXN0IGNoYXJhY3RlciAoYWxzbyB0cmltIHBvc3NpYmxlIHVubmVjZXNzYXJ5IHdoaXRlc3BhY2UpXG5cdFx0LnJlcGxhY2UoLyhbXjtdKVxccyokLywgXCIkMTtcIilcblx0XHQvLyBlbnN1cmUgd2UgaGF2ZSBvbmUgc3BhY2UgYWZ0ZXIgZWFjaCBjb2xvbiBvciBzZW1pLWNvbG9uXG5cdFx0LnJlcGxhY2UoL1xccyo7XFxzKihbXFx3LV0rKVxccyo6XFxzKi9nLCBcIjsgJDE6IFwiKVxuXHRcdC8vIHJlbW92ZSBmaXJzdCBzZW1pLWNvbG9uIGFuZCBzcGFjZVxuXHRcdC5zdWJzdHIoMikudHJpbSgpXG5cdCkgOiBcIlwiO1xufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qL1xuQ29udHJvbC5jb25jYXQgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMsIGluc3RhbmNlKSB7XG5cdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3IsXG5cdFx0YXR0cnMsXG5cdFx0c3RyO1xuXG5cdGlmIChwcm9wcy5jbGFzc2VzKSB7XG5cdFx0aWYgKGluc3RhbmNlKSB7XG5cdFx0XHRzdHIgPSAocHJvdG8uY2xhc3NlcyA/IChwcm90by5jbGFzc2VzICsgJyAnKSA6ICcnKSArIHByb3BzLmNsYXNzZXM7XG5cdFx0XHRwcm90by5jbGFzc2VzID0gc3RyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHIgPSAocHJvdG8ua2luZENsYXNzZXMgfHwgJycpICsgKHByb3RvLmNsYXNzZXMgPyAoJyAnICsgcHJvdG8uY2xhc3NlcykgOiAnJyk7XG5cdFx0XHRwcm90by5raW5kQ2xhc3NlcyA9IHN0cjtcblx0XHRcdHByb3RvLmNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzO1xuXHRcdH1cblx0XHRkZWxldGUgcHJvcHMuY2xhc3Nlcztcblx0fVxuXG5cdGlmIChwcm9wcy5zdHlsZSkge1xuXHRcdGlmIChpbnN0YW5jZSkge1xuXHRcdFx0c3RyID0gKHByb3RvLnN0eWxlID8gKHByb3RvLnN0eWxlICsgJzsnKSA6ICcnKSArIChwcm9wcy5zdHlsZSArICc7Jyk7XG5cdFx0XHRwcm90by5zdHlsZSA9IENvbnRyb2wubm9ybWFsaXplQ3NzU3R5bGVTdHJpbmcoc3RyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RyID0gcHJvdG8ua2luZFN0eWxlID8gcHJvdG8ua2luZFN0eWxlIDogJyc7XG5cdFx0XHRzdHIgKz0gcHJvdG8uc3R5bGUgPyAoJzsnICsgcHJvdG8uc3R5bGUpIDogJyc7XG5cdFx0XHRzdHIgKz0gcHJvcHMuc3R5bGU7XG5cblx0XHRcdC8vIG1vdmVkIGl0IGFsbCB0byBraW5kU3R5bGUgc28gdGhhdCBpdCB3aWxsIGJlIGF2YWlsYWJsZSB3aGVuZXZlciBpbnN0YW5jZWRcblx0XHRcdHByb3RvLmtpbmRTdHlsZSA9IENvbnRyb2wubm9ybWFsaXplQ3NzU3R5bGVTdHJpbmcoc3RyKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHByb3BzLnN0eWxlO1xuXHR9XG5cblx0aWYgKHByb3BzLmF0dHJpYnV0ZXMpIHtcblx0XHRhdHRycyA9IHByb3RvLmF0dHJpYnV0ZXM7XG5cdFx0cHJvdG8uYXR0cmlidXRlcyA9IGF0dHJzID8gdXRpbHMubWl4aW4oe30sIFthdHRycywgcHJvcHMuYXR0cmlidXRlc10pIDogcHJvcHMuYXR0cmlidXRlcztcblx0XHRkZWxldGUgcHJvcHMuYXR0cmlidXRlcztcblx0fVxufTtcblxuQ29udHJvbC5wcm90b3R5cGUuZGVmYXVsdEtpbmQgPSBDb250cm9sO1xuXG4vLyBDb250cm9sIGhhcyB0byBiZSAqY29tcGxldGVseSogc2V0IHVwIGJlZm9yZSBjcmVhdGluZyB0aGUgZmxvYXRpbmcgbGF5ZXIgb3RoZXJ3aXNlIHRoaW5ncyB3aWxsXG4vLyBlcnJvciBvdXQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cblxuLyoqXG4qIEBzdGF0aWNcbiogQHB1YmxpY1xuKi9cbkNvbnRyb2wuRmxvYXRpbmdMYXllciA9IEZsb2F0aW5nTGF5ZXIoQ29udHJvbCk7XG5cbi8qKlxuKiBAc3RhdGljXG4qIEBwdWJsaWNcbiovXG5Db250cm9sLmZsb2F0aW5nTGF5ZXIgPSBuZXcgQ29udHJvbC5GbG9hdGluZ0xheWVyKHtpZDogJ2Zsb2F0aW5nTGF5ZXInfSk7XG59LHtcIi4uLy4uLy4uL2VueW9cIjoxLFwiLi4vSFRNTFN0cmluZ0RlbGVnYXRlXCI6MjIsXCIuLi9VaUNvbXBvbmVudFwiOjU1LFwiLi4vZGlzcGF0Y2hlclwiOjU3LFwiLi4vZG9tXCI6NTgsXCIuLi9mbG9hdGluZ0xheWVyXCI6NjAsXCIuLi9mdWxsc2NyZWVuXCI6NjEsXCIuLi9raW5kXCI6NjYsXCIuLi9wbGF0Zm9ybVwiOjcxLFwiLi4vcm9vdHNcIjo3NCxcIi4uL3V0aWxzXCI6NzV9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyksXG5cdGdlc3R1cmUgPSByZXF1aXJlKCcuL2dlc3R1cmUnKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiogQHByaXZhdGVcbiovXG5kaXNwYXRjaGVyLmZlYXR1cmVzLnB1c2goXG5cdGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBOT1RFOiBiZXdhcmUgb2YgcHJvcGVydGllcyBpbiBnZXN0dXJlIGluYWR2ZXJ0ZW50bHkgbWFwcGVkIHRvIGV2ZW50IHR5cGVzXG5cdFx0aWYgKGdlc3R1cmUuZHJhZ1tlLnR5cGVdKSB7XG5cdFx0XHRyZXR1cm4gZ2VzdHVyZS5kcmFnW2UudHlwZV0oZSk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vKipcbiogRW55byBzdXBwb3J0cyBhIGNyb3NzLXBsYXRmb3JtIHNldCBvZiBkcmFnIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uIFRoZXNlXG4qIGV2ZW50cyBhbGxvdyB1c2VycyB0byB3cml0ZSBhIHNpbmdsZSBzZXQgb2YgZXZlbnQgaGFuZGxlcnMgZm9yIGFwcGxpY2F0aW9uc1xuKiB0aGF0IHJ1biBvbiBib3RoIG1vYmlsZSBhbmQgZGVza3RvcCBwbGF0Zm9ybXMuXG4qXG4qIFRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBwcm92aWRlZDpcbipcbiogKiAnZHJhZ3N0YXJ0J1xuKiAqICdkcmFnZmluaXNoJ1xuKiAqICdkcmFnJ1xuKiAqICdkcm9wJ1xuKiAqICdkcmFnb3ZlcidcbiogKiAnZHJhZ291dCdcbiogKiAnaG9sZCdcbiogKiAncmVsZWFzZSdcbiogKiAnaG9sZHB1bHNlJ1xuKiAqICdmbGljaydcbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UgZXZlbnRzLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0V2ZW50IEhhbmRsaW5nXXtAbGlua3BsYWluICRkZXYtZ3VpZGUva2V5LWNvbmNlcHRzL2V2ZW50LWhhbmRsaW5nLmh0bWx9IGluXG4qIHRoZSBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQG5hbWVzcGFjZSBnZXN0dXJlLmRyYWdcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0gZ2VzdHVyZS5kcmFnID1cblx0LyoqIEBsZW5kcyBnZXN0dXJlLmRyYWcgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhvbGRQdWxzZURlZmF1bHRDb25maWc6IHtcblx0XHRmcmVxdWVuY3k6IDIwMCxcblx0XHRldmVudHM6IFt7bmFtZTogJ2hvbGQnLCB0aW1lOiAyMDB9XSxcblx0XHRyZXN1bWU6IGZhbHNlLFxuXHRcdG1vdmVUb2xlcmFuY2U6IDE2LFxuXHRcdGVuZEhvbGQ6ICdvbk1vdmUnXG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsbCB0aGlzIG1ldGhvZCB0byBzcGVjaWZ5IHRoZSBmcmFtZXdvcmsncyAnaG9sZFB1bHNlJyBiZWhhdmlvciwgd2hpY2hcblx0KiBkZXRlcm1pbmVzIHRoZSBuYXR1cmUgb2YgdGhlIGV2ZW50cyBnZW5lcmF0ZWQgd2hlbiBhIHVzZXIgcHJlc3NlcyBhbmQgaG9sZHNcblx0KiBvbiBhIHVzZXIgaW50ZXJmYWNlIGVsZW1lbnQuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCBhbiBgb25ob2xkYCBldmVudCBmaXJlcyBhZnRlciAyMDAgbXMuIEFmdGVyIHRoYXQsIGFuIGBvbmhvbGRwdWxzZWBcblx0KiBldmVudCBmaXJlcyBldmVyeSAyMDAgbXMgdW50aWwgdGhlIHVzZXIgc3RvcHMgaG9sZGluZywgYXQgd2hpY2ggcG9pbnQgYVxuXHQqIGBvbnJlbGVhc2VgIGV2ZW50IGZpcmVzLlxuXHQqXG5cdCogVG8gY2hhbmdlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLCBjYWxsIHRoaXMgbWV0aG9kIGFuZCBwYXNzIGl0IGEgaG9sZFB1bHNlXG5cdCogY29uZmlndXJhdGlvbiBvYmplY3QuIFRoZSBob2xkUHVsc2UgY29uZmlndXJhdGlvbiBvYmplY3QgaGFzIGEgbnVtYmVyIG9mXG5cdCogcHJvcGVydGllcy5cblx0KlxuXHQqIFlvdSBjYW4gc3BlY2lmeSBhIHNldCBvZiBjdXN0b20gaG9sZCBldmVudHMgYnkgc2V0dGluZyB0aGUgYGV2ZW50c2AgcHJvcGVydHlcblx0KiB0byBhbiBhcnJheSBjb250YWluaW5nIG9uZSBvciBtb3JlIG9iamVjdHMuIEVhY2ggb2JqZWN0IHNwZWNpZmllcyBhIGN1c3RvbVxuXHQqIGhvbGQgZXZlbnQsIGluIHRoZSBmb3JtIG9mIGEgYG5hbWVgIC8gYHRpbWVgIHBhaXIuIE5vdGVzOlxuXHQqXG5cdCogICogWW91ciBjdXN0b20gZXZlbnQgbmFtZXMgc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSAnb24nIHByZWZpeDsgdGhhdCB3aWxsIGJlXG5cdCogICAgYWRkZWQgYXV0b21hdGljYWxseSBieSB0aGUgZnJhbWV3b3JrLlxuXHQqXG5cdCogICogVGltZXMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiBtaWxsaXNlY29uZHMuXG5cdCpcblx0KiAgKiBZb3VyIGBldmVudHNgIGFycmF5IG92ZXJyaWRlcyB0aGUgZnJhbWV3b3JrIGRlZmF1bHRzIGVudGlyZWx5LCBzbyBpZiB5b3Vcblx0KiAgICB3YW50IHRoZSBzdGFuZGFyZCBgaG9sZGAgZXZlbnQgdG8gZmlyZSBhdCAyMDAgbXMgKGluIGFkZGl0aW9uIHRvIHdoYXRldmVyXG5cdCogICAgY3VzdG9tIGV2ZW50cyB5b3UgZGVmaW5lKSwgeW91J2xsIG5lZWQgdG8gcmVkZWZpbmUgaXQgeW91cnNlbGYgYXMgcGFydCBvZlxuXHQqICAgIHlvdXIgYGV2ZW50c2AgYXJyYXkuXG5cdCpcblx0KiBSZWdhcmRsZXNzIG9mIGhvdyBtYW55IGN1c3RvbSBob2xkIGV2ZW50cyB5b3UgZGVmaW5lLCBgb25ob2xkcHVsc2VgIGV2ZW50c1xuXHQqIHdpbGwgc3RhcnQgZmlyaW5nIGFmdGVyIHRoZSBmaXJzdCBjdXN0b20gaG9sZCBldmVudCBmaXJlcywgYW5kIGNvbnRpbnVlIHVudGlsXG5cdCogdGhlIHVzZXIgc3RvcHMgaG9sZGluZy4gTGlrZXdpc2UsIG9ubHkgb25lIGBvbnJlbGVhc2VgIGV2ZW50IHdpbGwgZmlyZSxcblx0KiByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGN1c3RvbSBob2xkIGV2ZW50cyB5b3UgZGVmaW5lLlxuXHQqXG5cdCogVGhlYGZyZXF1ZW5jeWAgcGFyYW1ldGVyIGRldGVybWluZXMgbm90IG9ubHkgaG93IG9mdGVuIGBob2xkcHVsc2VgIGV2ZW50cyBhcmVcblx0KiBzZW50LCBidXQgdGhlIGZyZXF1ZW5jeSB3aXRoIHdoaWNoIHRoZSBob2xkIGR1cmF0aW9uIGlzIG1lYXN1cmVkLiBUaGlzIG1lYW5zXG5cdCogdGhhdCB0aGUgdmFsdWUgeW91IHNldCBmb3IgYGZyZXF1ZW5jeWAgc2hvdWxkIGFsd2F5cyBiZSBhIGNvbW1vbiBmYWN0b3Igb2YgdGhlXG5cdCogdGltZXMgeW91IHNldCBmb3IgeW91ciBjdXN0b20gaG9sZCBldmVudHMsIHRvIGVuc3VyZSBhY2N1cmF0ZSBldmVudCB0aW1pbmcuXG5cdCpcblx0KiBZb3UgY2FuIHVzZSB0aGUgYGVuZEhvbGRgIHByb3BlcnR5IHRvIHNwZWNpZnkgdGhlIGNpcmN1bXN0YW5jZXMgdW5kZXIgd2hpY2ggYVxuXHQqIGhvbGQgaXMgY29uc2lkZXJlZCB0byBlbmQuIFNldCBgZW5kSG9sZGAgdG8gYG9uTW92ZWAgKHRoZSBkZWZhdWx0KSBpZiB5b3Ugd2FudFxuXHQqIHRoZSBob2xkIHRvIGVuZCBhcyBzb29uIGFzIHRoZSB1c2VyJ3MgZmluZ2VyIG9yIHBvaW50ZXIgbW92ZXMuIFNldCBgZW5kSG9sZGBcblx0KiB0byBgb25MZWF2ZWAgaWYgeW91IHdhbnQgdGhlIGhvbGQgdG8gZW5kIG9ubHkgd2hlbiB0aGUgZmluZ2VyIG9yIHBvaW50ZXJcblx0KiBsZWF2ZXMgdGhlIGVsZW1lbnQgYWx0b2dldGhlci4gV2hlbiBzcGVjaWZ5aW5nIGBvbk1vdmVgLCB5b3UgY2FuIGFsc28gcHJvdmlkZVxuXHQqIGEgYG1vdmVUb2xlcmFuY2VgIHZhbHVlIChkZWZhdWx0OiBgMTZgKSB0aGF0IGRldGVybWluZXMgaG93IHRvbGVyYW50IHlvdSB3YW50XG5cdCogdG8gYmUgb2Ygc21hbGwgbW92ZW1lbnRzIHdoZW4gZGVjaWRpbmcgd2hldGhlciBhIGhvbGQgaGFzIGVuZGVkLiBUaGUgaGlnaGVyXG5cdCogdGhlIHZhbHVlLCB0aGUgZnVydGhlciBhIHVzZXIncyBmaW5nZXIgb3IgcG9pbnRlciBtYXkgbW92ZSB3aXRob3V0IGNhdXNpbmdcblx0KiB0aGUgaG9sZCB0byBlbmQuXG5cdCpcblx0KiBGaW5hbGx5LCB0aGUgYHJlc3VtZWAgcGFyYW1ldGVyIChkZWZhdWx0OiBgZmFsc2VgKSBzcGVjaWZpZXMgd2hldGhlciBhIGhvbGRcblx0KiB0aGF0IGhhcyBlbmRlZCBkdWUgdG8gZmluZ2VyIC8gcG9pbnRlciBtb3ZlbWVudCBzaG91bGQgYmUgcmVzdW1lZCBpZiB0aGVcblx0KiB1c2VyJ3MgZmluZ2VyIG9yIHBvaW50ZXIgbW92ZXMgYmFjayBpbnNpZGUgdGhlIHRvbGVyYW5jZSB0aHJlc2hvbGQgKGluIHRoZVxuXHQqIGNhc2Ugb2YgYGVuZEhvbGQ6IG9uTW92ZWApIG9yIGJhY2sgb3ZlciB0aGUgZWxlbWVudCAoaW4gdGhlIGNhc2Ugb2Zcblx0KiBgZW5kSG9sZDogb25MZWF2ZWApLlxuXHQqXG5cdCogSGVyZSBpcyBhbiBleGFtcGxlOlxuXHQqXG5cdCogYGBgXG5cdCogZ2VzdHVyZS5kcmFnLmNvbmZpZ3VyZUhvbGRQdWxzZSh7XG5cdCogICAgIGZyZXF1ZW5jeTogMTAwLFxuXHQqICAgICBldmVudHM6IFtcblx0KiAgICAgICAgIHtuYW1lOiAnaG9sZCcsIHRpbWU6IDIwMH0sXG5cdCogICAgICAgICB7bmFtZTogJ2xvbmdwcmVzcycsIHRpbWU6IDUwMH1cblx0KiAgICAgXSxcblx0KiAgICAgZW5kSG9sZDogJ29uTGVhdmUnLFxuXHQqICAgICByZXN1bWU6IHRydWVcblx0KiB9KTtcblx0KiBgYGBcblx0KiBGb3IgY29tcGFyaXNvbiwgaGVyZSBhcmUgdGhlIG91dC1vZi10aGUtYm94IGRlZmF1bHRzOlxuXHQqXG5cdCogYGBgXG5cdCogZ2VzdHVyZS5kcmFnLmNvbmZpZ3VyZUhvbGRQdWxzZSh7XG5cdCogICAgIGZyZXF1ZW5jeTogMjAwLFxuXHQqICAgICBldmVudHM6IFtcblx0KiAgICAgICAgIHtuYW1lOiAnaG9sZCcsIHRpbWU6IDIwMH1cblx0KiAgICAgXSxcblx0KiAgICAgZW5kSG9sZDogJ29uTW92ZScsXG5cdCogICAgIG1vdmVUb2xlcmFuY2U6IDE2LFxuXHQqICAgICByZXN1bWU6IGZhbHNlXG5cdCogfSk7XG5cdCogYGBgXG5cdCpcblx0KiBUaGUgc2V0dGluZ3MgeW91IHByb3ZpZGUgdmlhIHRoaXMgbWV0aG9kIHdpbGwgYmUgYXBwbGllZCBnbG9iYWxseSwgYWZmZWN0aW5nXG5cdCogZXZlcnkgQ29udHJvbC4gTm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBvdmVycmlkZSB0aGUgZGVmYXVsdHMgb24gYSBjYXNlLWJ5LWNhc2Vcblx0KiBiYXNpcyBieSBoYW5kbGluZyB0aGUgYGRvd25gIGV2ZW50IGZvciBhbnkgQ29udHJvbCBhbmQgY2FsbGluZyB0aGVcblx0KiBgY29uZmlndXJlSG9sZFB1bHNlYCBtZXRob2QgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLiBUaGF0IG1ldGhvZCB3b3Jrc1xuXHQqIGV4YWN0bHkgbGlrZSB0aGlzIG9uZSwgZXhjZXB0IHRoYXQgdGhlIHNldHRpbmdzIHlvdSBwcm92aWRlIHdpbGwgYXBwbHkgb25seSB0b1xuXHQqIGhvbGRzIG9uIHRoYXQgcGFydGljdWxhciBDb250cm9sLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRjb25maWd1cmVIb2xkUHVsc2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdC8vIFRPRE86IE1pZ2h0IGJlIG5pY2UgdG8gZG8gc29tZSB2YWxpZGF0aW9uLCBlcnJvciBoYW5kbGluZ1xuXHRcdHRoaXMuaG9sZFB1bHNlRGVmYXVsdENvbmZpZyA9IGNvbmZpZztcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRob2xkUHVsc2VDb25maWc6IHt9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRyYWNrQ291bnQ6IDUsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bWluRmxpY2s6IDAuMSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtaW5UcmFjazogOCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkb3duOiBmdW5jdGlvbihlKSB7XG5cdFx0Ly8gdHJhY2tpbmcgaWYgdGhlIG1vdXNlIGlzIGRvd25cblx0XHQvL2VueW8ubG9nKCd0cmFja2luZyBPTicpO1xuXHRcdC8vIE5vdGU6ICd0cmFja2luZycgZmxhZyBpbmRpY2F0ZXMgaW50ZXJlc3QgaW4gbW91c2Vtb3ZlLCBpdCdzIHR1cm5lZCBvZmZcblx0XHQvLyBvbiBtb3VzZXVwXG5cdFx0Ly8gbWFrZSBzdXJlIHRvIHN0b3AgZHJhZ2dpbmcgaW4gY2FzZSB0aGUgdXAgZXZlbnQgd2FzIG5vdCByZWNlaXZlZC5cblx0XHR0aGlzLnN0b3BEcmFnZ2luZyhlKTtcblx0XHR0aGlzLnRhcmdldCA9IGUudGFyZ2V0O1xuXHRcdHRoaXMuc3RhcnRUcmFja2luZyhlKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtb3ZlOiBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKHRoaXMudHJhY2tpbmcpIHtcblx0XHRcdHRoaXMudHJhY2soZSk7XG5cdFx0XHQvLyBJZiB0aGUgbW91c2UgaXMgbm90IGRvd24gYW5kIHdlJ3JlIHRyYWNraW5nIGEgZHJhZywgYWJvcnQuXG5cdFx0XHQvLyB0aGlzIGVycm9yIGNvbmRpdGlvbiBjYW4gb2NjdXIgb24gSUUvV2Via2l0IGFmdGVyIGludGVyYWN0aW9uIHdpdGggYSBzY3JvbGxiYXIuXG5cdFx0XHRpZiAoIWUud2hpY2gpIHtcblx0XHRcdFx0dGhpcy5zdG9wRHJhZ2dpbmcoZSk7XG5cdFx0XHRcdHRoaXMuZW5kSG9sZCgpO1xuXHRcdFx0XHR0aGlzLnRyYWNraW5nID0gZmFsc2U7XG5cdFx0XHRcdC8vZW55by5sb2coJ2dlc3R1cmUuZHJhZzogbW91c2UgbXVzdCBiZSBkb3duIHRvIGRyYWcuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmRyYWdFdmVudCkge1xuXHRcdFx0XHR0aGlzLnNlbmREcmFnKGUpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmhvbGRQdWxzZUNvbmZpZy5lbmRIb2xkID09PSAnb25Nb3ZlJykge1xuXHRcdFx0XHRpZiAodGhpcy5keSp0aGlzLmR5ICsgdGhpcy5keCp0aGlzLmR4ID49IHRoaXMuaG9sZFB1bHNlQ29uZmlnLm1vdmVUb2xlcmFuY2UpIHsgLy8gb3V0c2lkZSBvZiB0YXJnZXRcblx0XHRcdFx0XHRpZiAodGhpcy5ob2xkSm9iKSB7IC8vIG9ubHkgc3RvcC9jYW5jZWwgaG9sZCBqb2IgaWYgaXQgY3VycmVudGx5IGV4aXN0c1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaG9sZFB1bHNlQ29uZmlnLnJlc3VtZSkgeyAvLyBwYXVzZSBob2xkIHRvIHBvdGVudGlhbGx5IHJlc3VtZSBsYXRlclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN1c3BlbmRIb2xkKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBjb21wbGV0ZWx5IGNhbmNlbCBob2xkXG5cdFx0XHRcdFx0XHRcdHRoaXMuZW5kSG9sZCgpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbmREcmFnU3RhcnQoZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaG9sZFB1bHNlQ29uZmlnLnJlc3VtZSAmJiAhdGhpcy5ob2xkSm9iKSB7IC8vIHdoZW4gbW92aW5nIGluc2lkZSB0YXJnZXQsIG9ubHkgcmVzdW1lIGhvbGQgam9iIGlmIGl0IHdhcyBwcmV2aW91c2x5IHBhdXNlZFxuXHRcdFx0XHRcdHRoaXMucmVzdW1lSG9sZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwOiBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5lbmRUcmFja2luZyhlKTtcblx0XHR0aGlzLnN0b3BEcmFnZ2luZyhlKTtcblx0XHR0aGlzLmVuZEhvbGQoKTtcblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZW50ZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHQvLyByZXN1bWUgaG9sZCB3aGVuIHJlLWVudGVyaW5nIG9yaWdpbmFsIHRhcmdldCB3aGVuIHVzaW5nICdvbkxlYXZlJyBlbmRIb2xkIHZhbHVlXG5cdFx0aWYgKHRoaXMuaG9sZFB1bHNlQ29uZmlnLnJlc3VtZSAmJiB0aGlzLmhvbGRQdWxzZUNvbmZpZy5lbmRIb2xkID09PSAnb25MZWF2ZScgJiYgdGhpcy50YXJnZXQgJiYgZS50YXJnZXQgPT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHR0aGlzLnJlc3VtZUhvbGQoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGVhdmU6IGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAodGhpcy5kcmFnRXZlbnQpIHtcblx0XHRcdHRoaXMuc2VuZERyYWdPdXQoZSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmhvbGRQdWxzZUNvbmZpZy5lbmRIb2xkID09PSAnb25MZWF2ZScpIHtcblx0XHRcdGlmICh0aGlzLmhvbGRQdWxzZUNvbmZpZy5yZXN1bWUpIHsgLy8gcGF1c2UgaG9sZCB0byBwb3RlbnRpYWxseSByZXN1bWUgbGF0ZXJcblx0XHRcdFx0dGhpcy5zdXNwZW5kSG9sZCgpO1xuXHRcdFx0fSBlbHNlIHsgLy8gY29tcGxldGVseSBjYW5jZWwgaG9sZFxuXHRcdFx0XHR0aGlzLmVuZEhvbGQoKTtcblx0XHRcdFx0dGhpcy5zZW5kRHJhZ1N0YXJ0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdG9wRHJhZ2dpbmc6IGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAodGhpcy5kcmFnRXZlbnQpIHtcblx0XHRcdHRoaXMuc2VuZERyb3AoZSk7XG5cdFx0XHR2YXIgaGFuZGxlZCA9IHRoaXMuc2VuZERyYWdGaW5pc2goZSk7XG5cdFx0XHR0aGlzLmRyYWdFdmVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gaGFuZGxlZDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bWFrZURyYWdFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpblRhcmdldCwgaW5FdmVudCwgaW5JbmZvKSB7XG5cdFx0dmFyIGFkeCA9IE1hdGguYWJzKHRoaXMuZHgpLCBhZHkgPSBNYXRoLmFicyh0aGlzLmR5KTtcblx0XHR2YXIgaCA9IGFkeCA+IGFkeTtcblx0XHQvLyBzdWdnZXN0IGxvY2tpbmcgaWYgb2ZmLWF4aXMgPCAyMi41IGRlZ3JlZXNcblx0XHR2YXIgbCA9IChoID8gYWR5L2FkeCA6IGFkeC9hZHkpIDwgMC40MTQ7XG5cdFx0dmFyIGUgPSB7fTtcblx0XHQvLyB2YXIgZSA9IHtcblx0XHRlLnR5cGUgPSBpblR5cGU7XG5cdFx0ZS5keCA9IHRoaXMuZHg7XG5cdFx0ZS5keSA9IHRoaXMuZHk7XG5cdFx0ZS5kZHggPSB0aGlzLmR4IC0gdGhpcy5sYXN0RHg7XG5cdFx0ZS5kZHkgPSB0aGlzLmR5IC0gdGhpcy5sYXN0RHk7XG5cdFx0ZS54RGlyZWN0aW9uID0gdGhpcy54RGlyZWN0aW9uO1xuXHRcdGUueURpcmVjdGlvbiA9IHRoaXMueURpcmVjdGlvbjtcblx0XHRlLnBhZ2VYID0gaW5FdmVudC5wYWdlWDtcblx0XHRlLnBhZ2VZID0gaW5FdmVudC5wYWdlWTtcblx0XHRlLmNsaWVudFggPSBpbkV2ZW50LmNsaWVudFg7XG5cdFx0ZS5jbGllbnRZID0gaW5FdmVudC5jbGllbnRZO1xuXHRcdGUuaG9yaXpvbnRhbCA9IGg7XG5cdFx0ZS52ZXJ0aWNhbCA9ICFoO1xuXHRcdGUubG9ja2FibGUgPSBsO1xuXHRcdGUudGFyZ2V0ID0gaW5UYXJnZXQ7XG5cdFx0ZS5kcmFnSW5mbyA9IGluSW5mbztcblx0XHRlLmN0cmxLZXkgPSBpbkV2ZW50LmN0cmxLZXk7XG5cdFx0ZS5hbHRLZXkgPSBpbkV2ZW50LmFsdEtleTtcblx0XHRlLm1ldGFLZXkgPSBpbkV2ZW50Lm1ldGFLZXk7XG5cdFx0ZS5zaGlmdEtleSA9IGluRXZlbnQuc2hpZnRLZXk7XG5cdFx0ZS5zcmNFdmVudCA9IGluRXZlbnQuc3JjRXZlbnQ7XG5cdFx0Ly8gfTtcblx0XHQvL0ZpeCBmb3IgSUU4LCB3aGljaCBkb2Vzbid0IGluY2x1ZGUgcGFnZVggYW5kIHBhZ2VZIHByb3BlcnRpZXNcblx0XHRpZihwbGF0Zm9ybS5pZT09OCAmJiBlLnRhcmdldCkge1xuXHRcdFx0ZS5wYWdlWCA9IGUuY2xpZW50WCArIGUudGFyZ2V0LnNjcm9sbExlZnQ7XG5cdFx0XHRlLnBhZ2VZID0gZS5jbGllbnRZICsgZS50YXJnZXQuc2Nyb2xsVG9wO1xuXHRcdH1cblx0XHRlLnByZXZlbnREZWZhdWx0ID0gZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdDtcblx0XHRlLmRpc2FibGVQcmV2ZW50aW9uID0gZ2VzdHVyZS5kaXNhYmxlUHJldmVudGlvbjtcblx0XHRyZXR1cm4gZTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZW5kRHJhZ1N0YXJ0OiBmdW5jdGlvbihlKSB7XG5cdFx0Ly9lbnlvLmxvZygnZHJhZ3N0YXJ0Jyk7XG5cdFx0dGhpcy5kcmFnRXZlbnQgPSB0aGlzLm1ha2VEcmFnRXZlbnQoJ2RyYWdzdGFydCcsIHRoaXMudGFyZ2V0LCBlKTtcblx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKHRoaXMuZHJhZ0V2ZW50KTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZW5kRHJhZzogZnVuY3Rpb24oZSkge1xuXHRcdC8vZW55by5sb2coJ3NlbmREcmFnIHRvICcgKyB0aGlzLmRyYWdFdmVudC50YXJnZXQuaWQgKyAnLCBvdmVyIHRvICcgKyBlLnRhcmdldC5pZCk7XG5cdFx0Ly8gc2VuZCBkcmFnT3ZlciBldmVudCB0byB0aGUgc3RhbmRhcmQgZXZlbnQgdGFyZ2V0XG5cdFx0dmFyIHN5bnRoID0gdGhpcy5tYWtlRHJhZ0V2ZW50KCdkcmFnb3ZlcicsIGUudGFyZ2V0LCBlLCB0aGlzLmRyYWdFdmVudC5kcmFnSW5mbyk7XG5cdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChzeW50aCk7XG5cdFx0Ly8gc2VuZCBkcmFnIGV2ZW50IHRvIHRoZSBkcmFnIHNvdXJjZVxuXHRcdHN5bnRoLnR5cGUgPSAnZHJhZyc7XG5cdFx0c3ludGgudGFyZ2V0ID0gdGhpcy5kcmFnRXZlbnQudGFyZ2V0O1xuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goc3ludGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNlbmREcmFnRmluaXNoOiBmdW5jdGlvbihlKSB7XG5cdFx0Ly9lbnlvLmxvZygnZHJhZ2ZpbmlzaCcpO1xuXHRcdHZhciBzeW50aCA9IHRoaXMubWFrZURyYWdFdmVudCgnZHJhZ2ZpbmlzaCcsIHRoaXMuZHJhZ0V2ZW50LnRhcmdldCwgZSwgdGhpcy5kcmFnRXZlbnQuZHJhZ0luZm8pO1xuXHRcdHN5bnRoLnByZXZlbnRUYXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChlLnByZXZlbnRUYXApIHtcblx0XHRcdFx0ZS5wcmV2ZW50VGFwKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKHN5bnRoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZW5kRHJhZ091dDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBzeW50aCA9IHRoaXMubWFrZURyYWdFdmVudCgnZHJhZ291dCcsIGUudGFyZ2V0LCBlLCB0aGlzLmRyYWdFdmVudC5kcmFnSW5mbyk7XG5cdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChzeW50aCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2VuZERyb3A6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgc3ludGggPSB0aGlzLm1ha2VEcmFnRXZlbnQoJ2Ryb3AnLCBlLnRhcmdldCwgZSwgdGhpcy5kcmFnRXZlbnQuZHJhZ0luZm8pO1xuXHRcdHN5bnRoLnByZXZlbnRUYXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChlLnByZXZlbnRUYXApIHtcblx0XHRcdFx0ZS5wcmV2ZW50VGFwKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRkaXNwYXRjaGVyLmRpc3BhdGNoKHN5bnRoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGFydFRyYWNraW5nOiBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy50cmFja2luZyA9IHRydWU7XG5cdFx0Ly8gbm90ZTogdXNlIGNsaWVudFgvWSB0byBiZSBjb21wYXRpYmxlIHdpdGggaWU4XG5cdFx0dGhpcy5weDAgPSBlLmNsaWVudFg7XG5cdFx0dGhpcy5weTAgPSBlLmNsaWVudFk7XG5cdFx0Ly8gdGhpcy5mbGlja0luZm8gPSB7c3RhcnRFdmVudDogZSwgbW92ZXM6IFtdfTtcblx0XHR0aGlzLmZsaWNrSW5mbyA9IHt9O1xuXHRcdHRoaXMuZmxpY2tJbmZvLnN0YXJ0RXZlbnQgPSBlO1xuXHRcdC8vIEZJWE1FOiBzbyB3ZSdyZSB0cnlpbmcgdG8gcmV1c2Ugb2JqZWN0cyB3aGVyZSBwb3NzaWJsZSwgc2hvdWxkXG5cdFx0Ly8gZG8gdGhlIHNhbWUgaW4gc2NlbmFyaW9zIGxpa2UgdGhpcyBmb3IgYXJyYXlzXG5cdFx0dGhpcy5mbGlja0luZm8ubW92ZXMgPSBbXTtcblx0XHR0aGlzLnRyYWNrKGUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRyYWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5sYXN0RHggPSB0aGlzLmR4O1xuXHRcdHRoaXMubGFzdER5ID0gdGhpcy5keTtcblx0XHR0aGlzLmR4ID0gZS5jbGllbnRYIC0gdGhpcy5weDA7XG5cdFx0dGhpcy5keSA9IGUuY2xpZW50WSAtIHRoaXMucHkwO1xuXHRcdHRoaXMueERpcmVjdGlvbiA9IHRoaXMuY2FsY0RpcmVjdGlvbih0aGlzLmR4IC0gdGhpcy5sYXN0RHgsIDApO1xuXHRcdHRoaXMueURpcmVjdGlvbiA9IHRoaXMuY2FsY0RpcmVjdGlvbih0aGlzLmR5IC0gdGhpcy5sYXN0RHksIDApO1xuXHRcdC8vXG5cdFx0dmFyIHRpID0gdGhpcy5mbGlja0luZm87XG5cdFx0dGkubW92ZXMucHVzaCh7XG5cdFx0XHR4OiBlLmNsaWVudFgsXG5cdFx0XHR5OiBlLmNsaWVudFksXG5cdFx0XHR0OiB1dGlscy5wZXJmTm93KClcblx0XHR9KTtcblx0XHQvLyB0cmFjayBzcGVjaWZpZWQgIyBvZiBwb2ludHNcblx0XHRpZiAodGkubW92ZXMubGVuZ3RoID4gdGhpcy50cmFja0NvdW50KSB7XG5cdFx0XHR0aS5tb3Zlcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlbmRUcmFja2luZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFja2luZyA9IGZhbHNlO1xuXHRcdHZhciB0aSA9IHRoaXMuZmxpY2tJbmZvO1xuXHRcdHZhciBtb3ZlcyA9IHRpICYmIHRpLm1vdmVzO1xuXHRcdGlmIChtb3ZlcyAmJiBtb3Zlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBub3RlOiBpbXBvcnRhbnQgdG8gdXNlIHVwIHRpbWUgdG8gcmVkdWNlIGZsaWNrXG5cdFx0XHQvLyB2ZWxvY2l0eSBiYXNlZCBvbiB0aW1lIGJldHdlZW4gbW92ZSBhbmQgdXAuXG5cdFx0XHR2YXIgbCA9IG1vdmVzW21vdmVzLmxlbmd0aC0xXTtcblx0XHRcdHZhciBuID0gdXRpbHMucGVyZk5vdygpO1xuXHRcdFx0Ly8gdGFrZSB0aGUgZ3JlYXRlc3Qgb2YgZmxpY2sgYmV0d2VlbiBlYWNoIHRyYWNrZWQgbW92ZSBhbmQgbGFzdCBtb3ZlXG5cdFx0XHRmb3IgKHZhciBpPW1vdmVzLmxlbmd0aC0yLCBkdD0wLCB4MT0wLCB5MT0wLCB4PTAsIHk9MCwgc3g9MCwgc3k9MCwgbTsgKG09bW92ZXNbaV0pOyBpLS0pIHtcblx0XHRcdFx0Ly8gdGhpcyBmbGljayAodGhpcyBtb3ZlIC0gbGFzdCBtb3ZlKSAvICh0aGlzIHRpbWUgLSBsYXN0IHRpbWUpXG5cdFx0XHRcdGR0ID0gbiAtIG0udDtcblx0XHRcdFx0eDEgPSAobC54IC0gbS54KSAvIGR0O1xuXHRcdFx0XHR5MSA9IChsLnkgLSBtLnkpIC8gZHQ7XG5cdFx0XHRcdC8vIGVzdGFibGlzaCBmbGljayBkaXJlY3Rpb25cblx0XHRcdFx0c3ggPSBzeCB8fCAoeDEgPCAwID8gLTEgOiAoeDEgPiAwID8gMSA6IDApKTtcblx0XHRcdFx0c3kgPSBzeSB8fCAoeTEgPCAwID8gLTEgOiAoeTEgPiAwID8gMSA6IDApKTtcblx0XHRcdFx0Ly8gaWYgZWl0aGVyIGF4aXMgaXMgYSBncmVhdGVyIGZsaWNrIHRoYW4gcHJldmlvdXNseSByZWNvcmRlZCB1c2UgdGhpcyBvbmVcblx0XHRcdFx0aWYgKCh4MSAqIHN4ID4geCAqIHN4KSB8fCAoeTEgKiBzeSA+IHkgKiBzeSkpIHtcblx0XHRcdFx0XHR4ID0geDE7XG5cdFx0XHRcdFx0eSA9IHkxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgdiA9IE1hdGguc3FydCh4KnggKyB5KnkpO1xuXHRcdFx0aWYgKHYgPiB0aGlzLm1pbkZsaWNrKSB7XG5cdFx0XHRcdC8vIGdlbmVyYXRlIHRoZSBmbGljayB1c2luZyB0aGUgc3RhcnQgZXZlbnQgc28gaXQgaGFzIHRob3NlIGNvb3JkaW5hdGVzXG5cdFx0XHRcdHRoaXMuc2VuZEZsaWNrKHRpLnN0YXJ0RXZlbnQsIHgsIHksIHYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmZsaWNrSW5mbyA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY0RpcmVjdGlvbjogZnVuY3Rpb24oaW5OdW0sIGluRGVmYXVsdCkge1xuXHRcdHJldHVybiBpbk51bSA+IDAgPyAxIDogKGluTnVtIDwgMCA/IC0xIDogaW5EZWZhdWx0KTtcblx0fSxcblxuXHQvKipcblx0KiBUcmFuc2xhdGUgdGhlIG9sZCBmb3JtYXQgZm9yIGhvbGRQdWxzZUNvbmZpZyB0byB0aGUgbmV3IG9uZSwgdG9cblx0KiBwcmVzZXJ2ZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bm9ybWFsaXplSG9sZFB1bHNlQ29uZmlnOiBmdW5jdGlvbiAob2xkT3B0cykge1xuXHRcdHZhciBuT3B0cyA9IHV0aWxzLmNsb25lKG9sZE9wdHMpO1xuXHRcdG5PcHRzLmZyZXF1ZW5jeSA9IG5PcHRzLmRlbGF5O1xuXHRcdG5PcHRzLmV2ZW50cyA9IFt7bmFtZTogJ2hvbGQnLCB0aW1lOiBuT3B0cy5kZWxheX1dO1xuXHRcdHJldHVybiBuT3B0cztcblx0fSxcblxuXHQvKipcblx0KiBNZXRob2QgdG8gb3ZlcnJpZGUgaG9sZFB1bHNlQ29uZmlnIGZvciBhIGdpdmVuIGdlc3R1cmUuIFRoaXMgbWV0aG9kIGlzbid0XG5cdCogYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBnZXN0dXJlLmRyYWcsIGJ1dCBleHBvc2VkIGJ5IHRoZSBgZG93bmAgZXZlbnQuXG5cdCogU2VlIGBwcmVwYXJlSG9sZCgpYC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9jb25maWd1cmVIb2xkUHVsc2U6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHR2YXIgbk9wdHMgPSAob3B0cy5kZWxheSA9PT0gdW5kZWZpbmVkKSA/XG5cdFx0XHRvcHRzIDpcblx0XHRcdHRoaXMubm9ybWFsaXplSG9sZFB1bHNlQ29uZmlnKG9wdHMpO1xuXHRcdHV0aWxzLm1peGluKHRoaXMuaG9sZFB1bHNlQ29uZmlnLCBuT3B0cyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHJlcGFyZUhvbGQ6IGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBxdWljayBjb3B5IGFzIHRoZSBwcm90b3R5cGUgb2YgdGhlIG5ldyBvdmVycmlkYWJsZSBjb25maWdcblx0XHR0aGlzLmhvbGRQdWxzZUNvbmZpZyA9IHV0aWxzLmNsb25lKHRoaXMuaG9sZFB1bHNlRGVmYXVsdENvbmZpZywgdHJ1ZSk7XG5cblx0XHQvLyBleHBvc2UgbWV0aG9kIGZvciBjb25maWd1cmluZyBob2xkcHVsc2Ugb3B0aW9uc1xuXHRcdGUuY29uZmlndXJlSG9sZFB1bHNlID0gdGhpcy5fY29uZmlndXJlSG9sZFB1bHNlLmJpbmQodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YmVnaW5Ib2xkOiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIGNlO1xuXHRcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgaG9sZCBzaW5jZSBpdCdzIHBvc3NpYmxlIGluIGNvcm5lciBjYXNlcyB0byBnZXQgYSBkb3duIHdpdGhvdXQgYW4gdXBcblx0XHR0aGlzLmVuZEhvbGQoKTtcblx0XHR0aGlzLmhvbGRTdGFydCA9IHV0aWxzLnBlcmZOb3coKTtcblx0XHR0aGlzLl9ob2xkSm9iRnVuY3Rpb24gPSB1dGlscy5iaW5kKHRoaXMsICdoYW5kbGVIb2xkUHVsc2UnKTtcblx0XHQvLyBjbG9uZSB0aGUgZXZlbnQgdG8gZW5zdXJlIGl0IHN0YXlzIGFsaXZlIG9uIElFIHVwb24gcmV0dXJuaW5nIHRvIGV2ZW50IGxvb3Bcblx0XHRjZSA9IHRoaXMuX2hvbGRKb2JFdmVudCA9IHV0aWxzLmNsb25lKGUpO1xuXHRcdGNlLnNyY0V2ZW50ID0gdXRpbHMuY2xvbmUoZS5zcmNFdmVudCk7XG5cdFx0dGhpcy5fcHVsc2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuX3Vuc2VudCA9IHV0aWxzLmNsb25lKHRoaXMuaG9sZFB1bHNlQ29uZmlnLmV2ZW50cyk7XG5cdFx0dGhpcy5fdW5zZW50LnNvcnQodGhpcy5zb3J0RXZlbnRzKTtcblx0XHR0aGlzLl9uZXh0ID0gdGhpcy5fdW5zZW50LnNoaWZ0KCk7XG5cdFx0aWYgKHRoaXMuX25leHQpIHtcblx0XHRcdHRoaXMuaG9sZEpvYiA9IHNldEludGVydmFsKHRoaXMuX2hvbGRKb2JGdW5jdGlvbiwgdGhpcy5ob2xkUHVsc2VDb25maWcuZnJlcXVlbmN5KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVzdW1lSG9sZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVIb2xkUHVsc2UoKTtcblx0XHR0aGlzLmhvbGRKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLl9ob2xkSm9iRnVuY3Rpb24sIHRoaXMuaG9sZFB1bHNlQ29uZmlnLmZyZXF1ZW5jeSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c29ydEV2ZW50czogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0aWYgKGEudGltZSA8IGIudGltZSkgcmV0dXJuIC0xO1xuXHRcdFx0aWYgKGEudGltZSA+IGIudGltZSkgcmV0dXJuIDE7XG5cdFx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlbmRIb2xkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMuX2hvbGRKb2JFdmVudDtcblx0XHR0aGlzLnN1c3BlbmRIb2xkKCk7XG5cdFx0aWYgKGUgJiYgdGhpcy5fcHVsc2luZykge1xuXHRcdFx0dGhpcy5zZW5kUmVsZWFzZShlKTtcblx0XHR9XG5cdFx0dGhpcy5fcHVsc2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuX3Vuc2VudCA9IG51bGw7XG5cdFx0dGhpcy5faG9sZEpvYkZ1bmN0aW9uID0gbnVsbDtcblx0XHR0aGlzLl9ob2xkSm9iRXZlbnQgPSBudWxsO1xuXHRcdHRoaXMuX25leHQgPSBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN1c3BlbmRIb2xkOiBmdW5jdGlvbigpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuaG9sZEpvYik7XG5cdFx0dGhpcy5ob2xkSm9iID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVIb2xkUHVsc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob2xkVGltZSA9IHV0aWxzLnBlcmZOb3coKSAtIHRoaXMuaG9sZFN0YXJ0LFxuXHRcdFx0aGplID0gdGhpcy5faG9sZEpvYkV2ZW50LFxuXHRcdFx0ZTtcblx0XHR0aGlzLm1heWJlU2VuZEhvbGQoaGplLCBob2xkVGltZSk7XG5cdFx0aWYgKHRoaXMuX3B1bHNpbmcpIHtcblx0XHRcdGUgPSBnZXN0dXJlLm1ha2VFdmVudCgnaG9sZHB1bHNlJywgaGplKTtcblx0XHRcdGUuaG9sZFRpbWUgPSBob2xkVGltZTtcblx0XHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1heWJlU2VuZEhvbGQ6IGZ1bmN0aW9uKGluRXZlbnQsIGluSG9sZFRpbWUpIHtcblx0XHR2YXIgbiA9IHRoaXMuX25leHQ7XG5cdFx0d2hpbGUgKG4gJiYgbi50aW1lIDw9IGluSG9sZFRpbWUpIHtcblx0XHRcdHZhciBlID0gZ2VzdHVyZS5tYWtlRXZlbnQobi5uYW1lLCBpbkV2ZW50KTtcblx0XHRcdHRoaXMuX3B1bHNpbmcgPSB0cnVlO1xuXHRcdFx0ZGlzcGF0Y2hlci5kaXNwYXRjaChlKTtcblx0XHRcdG4gPSB0aGlzLl9uZXh0ID0gdGhpcy5fdW5zZW50LnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNlbmRSZWxlYXNlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG5cdFx0dmFyIGUgPSBnZXN0dXJlLm1ha2VFdmVudCgncmVsZWFzZScsIGluRXZlbnQpO1xuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2VuZEZsaWNrOiBmdW5jdGlvbihpbkV2ZW50LCBpblgsIGluWSwgaW5WKSB7XG5cdFx0dmFyIGUgPSBnZXN0dXJlLm1ha2VFdmVudCgnZmxpY2snLCBpbkV2ZW50KTtcblx0XHRlLnhWZWxvY2l0eSA9IGluWDtcblx0XHRlLnlWZWxvY2l0eSA9IGluWTtcblx0XHRlLnZlbG9jaXR5ID0gaW5WO1xuXHRcdGRpc3BhdGNoZXIuZGlzcGF0Y2goZSk7XG5cdH1cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9kaXNwYXRjaGVyXCI6NTcsXCIuL2dlc3R1cmVcIjo2MixcIi4vcGxhdGZvcm1cIjo3MSxcIi4vdXRpbHNcIjo3NX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpO1xudmFyXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuL0NvbnRyb2wnKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkFuY2hvcn0gaW1wbGVtZW50cyBhbiBIVE1MIFthbmNob3Jde0BnbG9zc2FyeSBBbmNob3J9ICgmbHQ7YSZndDspIHRhZy5cbiogUHVibGlzaGVkIHByb3BlcnRpZXMgYWxsb3cgeW91IHRvIFtiaW5kXXtAbGluayBlbnlvLkJpbmRpbmdTdXBwb3J0fSB0aGUgYW5jaG9yJ3NcbiogW2hyZWZde0BsaW5rIGVueW8uQW5jaG9yI2hyZWZ9IGFuZCBbdGl0bGVde0BsaW5rIGVueW8uQW5jaG9yI3RpdGxlfVxuKiBbYXR0cmlidXRlc117QGdsb3NzYXJ5IEF0dHJpYnV0ZX0gdG8gYXBwcm9wcmlhdGUgZmllbGRzIG9uIGRhdGFcbiogW29iamVjdHNde0BnbG9zc2FyeSBPYmplY3R9LlxuKiBcbiogQGNsYXNzIGVueW8uQW5jaG9yXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkFuY2hvci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLkFuY2hvcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6ICdhJyxcblxuXHQvKiogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOiBcblx0XHQvKiogQGxlbmRzIGVueW8uQW5jaG9yLnByb3RvdHlwZSAqLyB7XG5cdFx0XG5cdFx0LyoqIFxuXHRcdCogTWFwcyB0byB0aGUgYGhyZWZgIFthdHRyaWJ1dGVde0BnbG9zc2FyeSBBdHRyaWJ1dGV9IG9mIHRoZSAmbHQ7YSZndDsgdGFnLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGhyZWY6ICcnLFxuXG5cdFx0LyoqXG5cdFx0KiBNYXBzIHRvIHRoZSBgdGl0bGVgIFthdHRyaWJ1dGVde0BnbG9zc2FyeSBBdHRyaWJ1dGV9IG9mIHRoZSAmbHQ7YSZndDsgdGFnLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgICcnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR0aXRsZTogJydcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5ocmVmQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy50aXRsZUNoYW5nZWQoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRocmVmQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy5ocmVmKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0aXRsZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aGlzLnRpdGxlKTtcblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db250cm9sXCI6MTYsXCIuL2tpbmRcIjo2Nn1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXJcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4vQ29udHJvbCcpLFxuXHRSZXBlYXRlckNoaWxkU3VwcG9ydCA9IHJlcXVpcmUoJy4vUmVwZWF0ZXJDaGlsZFN1cHBvcnQnKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0gaXRlcmF0ZXMgb3ZlciB0aGUgaXRlbXMgaW4gYW4ge0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdG9cbiogcmVwZWF0ZWRseSByZW5kZXIgYW5kIHN5bmNocm9uaXplIHJlY29yZHMgKGluc3RhbmNlcyBvZiB7QGxpbmsgZW55by5Nb2RlbH0pIHRvIGl0c1xuKiBvd24gY2hpbGRyZW4uIEZvciBhbnkgcmVjb3JkIGluIHRoZSBjb2xsZWN0aW9uLCBhIG5ldyBjaGlsZCB3aWxsIGJlIHJlbmRlcmVkIGluXG4qIHRoZSByZXBlYXRlci4gSWYgdGhlIHJlY29yZCBpcyBkZXN0cm95ZWQsIHRoZSBjaGlsZCB3aWxsIGJlIGRlc3Ryb3llZC4gVGhlc2VcbiogW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9IHdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgd2hlbiBwcm9wZXJ0aWVzIG9uIHRoZVxuKiB1bmRlcmx5aW5nIHJlY29yZHMgYXJlIG1vZGlmaWVkIGlmIHRoZXkgaGF2ZSBiZWVuIGJvdW5kIHVzaW5nXG4qIFtiaW5kaW5nc117QGxpbmsgZW55by5CaW5kaW5nfS5cbipcbiogQGNsYXNzIGVueW8uRGF0YVJlcGVhdGVyXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbnZhciBEYXRhUmVwZWF0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5EYXRhUmVwZWF0ZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5EYXRhUmVwZWF0ZXInLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbnRyb2wsXG5cblx0LyoqXG5cdCogU2V0IHRoaXMgdG8gYHRydWVgIHRvIGVuYWJsZSBzZWxlY3Rpb24gc3VwcG9ydC4gTm90ZSB0aGF0IHNlbGVjdGlvbiBzdG9yZXMgYVxuXHQqIHJlZmVyZW5jZSB0byB0aGUgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSB0aGF0IGlzIHNlbGVjdGVkLCB2aWEgdGhlXG5cdCogW3NlbGVjdGVkXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlciNzZWxlY3RlZH0gbWV0aG9kLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0aW9uOiB0cnVlLFxuXG5cdC8qKlxuXHQqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBzZWxlY3Rpb24gKGlmIGVuYWJsZWQpLCB0aGF0IHdlIHdhbnQgdG8gZW5hYmxlLiBUaGUgcG9zc2libGUgdmFsdWVzXG5cdCogYXJlICdzaW5nbGUnLCAnbXVsdGknLCBhbmQgJ2dyb3VwJy4gVGhlIGRlZmF1bHQgaXMgJ3NpbmdsZScgc2VsZWN0aW9uIG1vZGUsIHdoaWNoIGVuYWJsZXNcblx0KiBzZWxlY3Rpb24gYW5kIGRlc2VsZWN0aW9uIG9mIGEgc2luZ2xlIGl0ZW0gYXQgYSB0aW1lLiBUaGUgJ211bHRpJyBzZWxlY3Rpb24gbW9kZSBhbGxvd3Ncblx0KiBtdWx0aXBsZSBjaGlsZHJlbiB0byBiZSBzZWxlY3RlZCBzaW11bHRhbmVvdXNseSwgd2hpbGUgdGhlICdncm91cCcgc2VsZWN0aW9uIG1vZGUgYWxsb3dzXG5cdCogZ3JvdXAtc2VsZWN0aW9uIGJlaGF2aW9yIHN1Y2ggdGhhdCBvbmx5IG9uZSBjaGlsZCBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lIGFuZCwgb25jZSBhXG5cdCogY2hpbGQgaXMgc2VsZWN0ZWQsIGl0IGNhbm5vdCBiZSBkZXNlbGVjdGVkIHZpYSB1c2VyIGlucHV0LiBUaGUgY2hpbGQgbWF5IHN0aWxsIGJlIFxuXHQqIGRlc2VsZWN0ZWQgdmlhIHRoZSBzZWxlY3Rpb24gQVBJIG1ldGhvZHMuXG5cdCogXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnc2luZ2xlJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0aW9uVHlwZTogJ3NpbmdsZScsXG5cblx0LyoqXG5cdCogU2V0IHRoaXMgdG8gYHRydWVgIHRvIGFsbG93IG11bHRpcGxlIGNoaWxkcmVuIHRvIGJlIHNlbGVjdGVkIHNpbXVsdGFuZW91c2x5LlxuXHQqXG5cdCogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjZcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bXVsdGlwbGVTZWxlY3Rpb246IGZhbHNlLFxuXG5cdC8qKlxuXHQqIFNldCB0aGlzIHRvIGB0cnVlYCB0byBhbGxvdyBncm91cC1zZWxlY3Rpb24gYmVoYXZpb3Igc3VjaCB0aGF0IG9ubHkgb25lIGNoaWxkXG5cdCogbWF5IGJlIHNlbGVjdGVkIGF0IGEgdGltZSBhbmQsIG9uY2UgYSBjaGlsZCBpcyBzZWxlY3RlZCwgaXQgY2Fubm90IGJlXG5cdCogZGVzZWxlY3RlZCB2aWEgdXNlciBpbnB1dC4gVGhlIGNoaWxkIG1heSBzdGlsbCBiZSBkZXNlbGVjdGVkIHZpYSB0aGUgc2VsZWN0aW9uXG5cdCogQVBJIG1ldGhvZHMuIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIHdpbGwgc2V0IHRoZVxuXHQqIFttdWx0aXBsZVNlbGVjdGlvbl17QGxpbmsgZW55by5EYXRhUmVwZWF0ZXIjbXVsdGlwbGVTZWxlY3Rpb259IHByb3BlcnR5IHRvXG5cdCogYGZhbHNlYC5cblx0KlxuXHQqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHVibGljXG5cdCovXG5cdGdyb3VwU2VsZWN0aW9uOiBmYWxzZSxcblxuXHQvKipcblx0KiBUaGlzIGNsYXNzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgW3JlcGVhdGVyXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0gd2hlblxuXHQqIFtzZWxlY3Rpb25de0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyI3NlbGVjdGlvbn0gaXMgZW5hYmxlZC4gSXQgd2lsbCBhbHNvIGJlXG5cdCogYXBwbGllZCBpZiBbbXVsdGlwbGVTZWxlY3Rpb25de0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyI211bHRpcGxlU2VsZWN0aW9ufVxuXHQqIGlzIGB0cnVlYC5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ3NlbGVjdGlvbi1lbmFibGVkJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0aW9uQ2xhc3M6ICdzZWxlY3Rpb24tZW5hYmxlZCcsXG5cblx0LyoqXG5cdCogVGhpcyBjbGFzcyB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIFtyZXBlYXRlcl17QGxpbmsgZW55by5EYXRhUmVwZWF0ZXJ9IHdoZW5cblx0KiBbc2VsZWN0aW9uVHlwZV17QGxpbmsgZW55by5EYXRhUmVwZWF0ZXIjc2VsZWN0aW9uVHlwZX0gaXMgYG11bHRpYC5cblx0KiBXaGVuIHRoYXQgaXMgdGhlIGNhc2UsIHRoZSBbc2VsZWN0aW9uQ2xhc3Nde0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyI3NlbGVjdGlvbkNsYXNzfVxuXHQqIHdpbGwgYWxzbyBiZSBhcHBsaWVkLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnbXVsdGlwbGUtc2VsZWN0aW9uLWVuYWJsZWQnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRtdWx0aXBsZVNlbGVjdGlvbkNsYXNzOiAnbXVsdGlwbGUtc2VsZWN0aW9uLWVuYWJsZWQnLFxuXG5cdC8qKlxuXHQqIEluIGNhc2VzIHdoZXJlIHNlbGVjdGlvbiBzaG91bGQgYmUgZGV0ZWN0ZWQgZnJvbSB0aGUgc3RhdGUgb2YgdGhlXG5cdCogW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSwgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IHRvIHRoZSBwcm9wZXJ0eSBvblxuXHQqIHRoZSBtb2RlbCB0aGF0IHRoZSBbcmVwZWF0ZXJde0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyfSBzaG91bGQgb2JzZXJ2ZSBmb3Jcblx0KiBjaGFuZ2VzLiBJZiB0aGUgbW9kZWwgY2hhbmdlcywgdGhlIHJlcGVhdGVyIHdpbGwgcmVmbGVjdCB0aGUgY2hhbmdlIHdpdGhvdXRcblx0KiBoYXZpbmcgdG8gaW50ZXJhY3QgZGlyZWN0bHkgd2l0aCB0aGUgbW9kZWwuIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5IG11c3QgYmVcblx0KiBwYXJ0IG9mIHRoZSBtb2RlbCdzIHNjaGVtYSwgb3IgZWxzZSBpdHMgY2hhbmdlcyB3aWxsIG5vdCBiZSBkZXRlY3RlZFxuXHQqIHByb3Blcmx5LlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0aW9uUHJvcGVydHk6ICcnLFxuXG5cdC8qKlxuXHQqIFNldCB0aGlzIHRvIGEgc3BhY2UtZGVsaW1pdGVkIHN0cmluZyBvZiBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IG9yIGFuXG5cdCogW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IHRoYXQgY2FuIHRyaWdnZXIgdGhlIHNlbGVjdGlvbiBvZiBhIHBhcnRpY3VsYXJcblx0KiBjaGlsZC4gVG8gcHJldmVudCBzZWxlY3Rpb24gZW50aXJlbHksIHNldFxuXHQqIFtzZWxlY3Rpb25de0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyI3NlbGVjdGlvbn0gdG8gYGZhbHNlYC5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ29udGFwJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2VsZWN0aW9uRXZlbnRzOiAnb250YXAnLFxuXG5cdC8qKlxuXHQqIFVzZSB0aGlzIFtoYXNoXXtAZ2xvc3NhcnkgT2JqZWN0fSB0byBkZWZpbmUgZGVmYXVsdCBbYmluZGluZ117QGxpbmsgZW55by5CaW5kaW5nfVxuXHQqIHByb3BlcnRpZXMgZm9yICoqYWxsKiogY2hpbGRyZW4gKGV2ZW4gY2hpbGRyZW4gb2YgY2hpbGRyZW4pIG9mIHRoaXNcblx0KiBbcmVwZWF0ZXJde0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyfS4gVGhpcyBjYW4gZWxpbWluYXRlIHRoZSBuZWVkIHRvIHdyaXRlIHRoZVxuXHQqIHNhbWUgcGF0aHMgb3ZlciBhbmQgb3Zlci4gWW91IG1heSBhbHNvIHVzZSBhbnkgYmluZGluZyBtYWNyb3MuIEFueSBwcm9wZXJ0eVxuXHQqIGRlZmluZWQgaGVyZSB3aWxsIGJlIHN1cGVyc2VkZWQgYnkgdGhlIHNhbWUgcHJvcGVydHkgaWYgZGVmaW5lZCBmb3IgYW4gaW5kaXZpZHVhbFxuXHQqIGJpbmRpbmcuXG5cdCpcblx0KiBAdHlwZSB7T2JqZWN0fVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdGNoaWxkQmluZGluZ0RlZmF1bHRzOiBudWxsLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluaXRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0Q29udGFpbmVyKCk7XG5cdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLmtpbmRDb21wb25lbnRzIHx8IHRoaXMuY29tcG9uZW50cyB8fCBbXSxcblx0XHRcdG93bmVyID0gdGhpcy5nZXRJbnN0YW5jZU93bmVyKCksXG5cdFx0XHRwcm9wcyA9IHRoaXMuZGVmYXVsdFByb3BzPyB1dGlscy5jbG9uZSh0aGlzLmRlZmF1bHRQcm9wcywgdHJ1ZSk6ICh0aGlzLmRlZmF1bHRQcm9wcyA9IHt9KTtcblx0XHQvLyBlbnN1cmUgdGhhdCBjaGlsZHJlbiBrbm93IHdobyB0aGVpciBiaW5kaW5nIG93bmVyIGlzXG5cdFx0cHJvcHMuYmluZGluZ1RyYW5zZm9ybU93bmVyID0gdGhpcztcblx0XHRwcm9wcy5iaW5kaW5nRGVmYXVsdHMgPSB0aGlzLmNoaWxkQmluZGluZ0RlZmF1bHRzO1xuXHRcdGlmIChjb21wb25lbnRzKSB7XG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29tcG9uZW50cyBpbiB0aGUgY29tcG9uZW50cyBibG9jayB0aGV5IHdpbGwgYmVjb21lIG5lc3RlZFxuXHRcdFx0Ly8gY2hpbGRyZW4gb2YgdGhlIGRlZmF1bHQga2luZCBzZXQgZm9yIHRoZSByZXBlYXRlclxuXHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRwcm9wcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNoaWxkLCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIHRoZSBkZWZhdWx0IGtpbmQgb2YgdGhlIHJlcGVhdGVyXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dXRpbHMubWl4aW4ocHJvcHMsIGNvbXBvbmVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0cHJvcHMucmVwZWF0ZXIgPSB0aGlzO1xuXHRcdFx0cHJvcHMub3duZXIgPSBvd25lcjtcblx0XHRcdHByb3BzLm1peGlucyA9IHByb3BzLm1peGlucz8gcHJvcHMubWl4aW5zLmNvbmNhdCh0aGlzLmNoaWxkTWl4aW5zKTogdGhpcy5jaGlsZE1peGlucztcblx0XHR9XG5cblx0XHR0aGlzLmRlZmF1bHRQcm9wcyA9IHByb3BzO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3Rvcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uID0gW107XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgb3VyIHNlbGVjdGlvbkV2ZW50cyBhcnJheVxuXHRcdFx0dmFyIHNlID0gdGhpcy5zZWxlY3Rpb25FdmVudHM7XG5cdFx0XHR0aGlzLnNlbGVjdGlvbkV2ZW50cyA9ICh0eXBlb2Ygc2UgPT0gJ3N0cmluZyc/IHNlLnNwbGl0KCcgJyk6IHNlKTtcblx0XHRcdC8vIHdlIG5lZWQgdG8gcHJlLWJpbmQgdGhlc2UgbWV0aG9kcyBzbyB0aGV5IGNhbiBlYXNpbHkgYmUgYWRkZWRcblx0XHRcdC8vIGFuZCByZW1vdmVkIGFzIGxpc3RlbmVycyBsYXRlclxuXHRcdFx0dmFyIGggPSB0aGlzLl9oYW5kbGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX2hhbmRsZXJzKTtcblx0XHRcdGZvciAodmFyIGUgaW4gaCkge1xuXHRcdFx0XHRoW2VdID0gdGhpcy5iaW5kU2FmZWx5KGhbZV0pO1xuXHRcdFx0fVxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmNvbGxlY3Rpb25DaGFuZ2VkKCk7XG5cdFx0XHQvLyBDb252ZXJ0aW5nIGRlcHJlY2F0ZWQgc2VsZWN0aW9uIHByb3BlcnRpZXMgdG8gb3VyIGN1cnJlbnQgc2VsZWN0aW9uIEFQSVxuXHRcdFx0dGhpcy5zZWxlY3Rpb25UeXBlID0gdGhpcy5tdWx0aXBsZVNlbGVjdGlvbiA/ICh0aGlzLmdyb3VwU2VsZWN0aW9uID8gJ2dyb3VwJyA6ICdtdWx0aScpIDogdGhpcy5zZWxlY3Rpb25UeXBlO1xuXHRcdFx0dGhpcy5zZWxlY3Rpb25UeXBlQ2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdyb3VwU2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0KCdzZWxlY3Rpb25UeXBlJywgdGhpcy5ncm91cFNlbGVjdGlvbiA/ICdncm91cCcgOiAnc2luZ2xlJyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bXVsdGlwbGVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXQoJ3NlbGVjdGlvblR5cGUnLCB0aGlzLm11bHRpcGxlU2VsZWN0aW9uID8gJ211bHRpJyA6ICdzaW5nbGUnKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZWxlY3Rpb25UeXBlQ2hhbmdlZDogZnVuY3Rpb24gKHdhcykge1xuXHRcdC8vIFN5bmNocm9uaXppbmcgb3VyIGRlcHJlY2F0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuZ3JvdXBTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvblR5cGUgPT0gJ2dyb3VwJztcblx0XHR0aGlzLm11bHRpcGxlU2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb25UeXBlID09ICdtdWx0aSc7XG5cblx0XHRpZiAod2FzID09ICdtdWx0aScpIHtcblx0XHRcdGlmICh0aGlzLl9zZWxlY3Rpb24ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLmRlc2VsZWN0QWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmFkZFJlbW92ZUNsYXNzKHRoaXMuc2VsZWN0aW9uQ2xhc3MsIHRoaXMuc2VsZWN0aW9uKTtcblx0XHR0aGlzLmFkZFJlbW92ZUNsYXNzKHRoaXMubXVsdGlwbGVTZWxlY3Rpb25DbGFzcywgdGhpcy5zZWxlY3Rpb25UeXBlID09ICdtdWx0aScgJiYgdGhpcy5zZWxlY3Rpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIERlc3Ryb3lzIGFueSBleGlzdGluZyBjaGlsZHJlbiBpbiB0aGUgW3JlcGVhdGVyXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0gYW5kIGNyZWF0ZXMgYWxsXG5cdCogbmV3IGNoaWxkcmVuIGJhc2VkIG9uIHRoZSBjdXJyZW50IFtkYXRhXXtAbGluayBlbnlvLlJlcGVhdGVyI2RhdGF9LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZSB0aGUgZmFjYWRlZCBkYXRhc2V0IGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhbnlcblx0XHQvLyBjb2xsZWN0aW9uIG9mIHJlY29yZHNcblx0XHR2YXIgZGQgPSB0aGlzLmdldCgnZGF0YScpO1xuXHRcdC8vIGRlc3Ryb3kgdGhlIGNsaWVudCBjb250cm9scyB3ZSBtaWdodCBhbHJlYWR5IGhhdmVcblx0XHR0aGlzLmRlc3Ryb3lDbGllbnRDb250cm9scygpO1xuXHRcdC8vIGFuZCBub3cgd2UgY3JlYXRlIG5ldyBvbmVzIGZvciBlYWNoIG5ldyByZWNvcmQgd2UgaGF2ZVxuXHRcdGZvciAodmFyIGk9MCwgcjsgKHI9ZGQuYXQoaSkpOyArK2kpIHtcblx0XHRcdHRoaXMuYWRkKHIsIGkpO1xuXHRcdH1cblx0XHR0aGlzLmhhc1Jlc2V0ID0gdHJ1ZTtcblx0fSxcblx0LyoqXG5cdCogUmVmcmVzaGVzIGVhY2ggW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gaW4gdGhlIGRhdGFzZXQuXG5cdCpcblx0KiBAcGFyYW0ge0Jvb2xlYW59IGltbWVkaWF0ZSAtIElmIGB0cnVlYCwgcmVmcmVzaCB3aWxsIG9jY3VyIGltbWVkaWF0ZWx5OyBvdGhlcndpc2UsXG5cdCogaXQgd2lsbCBiZSBxdWV1ZWQgdXAgYXMgYSBqb2IuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZWZyZXNoOiBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG5cdFx0aWYgKCF0aGlzLmhhc1Jlc2V0KSB7IHJldHVybiB0aGlzLnJlc2V0KCk7IH1cblx0XHR2YXIgcmVmcmVzaCA9IHRoaXMuYmluZFNhZmVseShmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZGQgPSB0aGlzLmdldCgnZGF0YScpLFxuXHRcdFx0XHRjYyA9IHRoaXMuZ2V0Q2xpZW50Q29udHJvbHMoKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYywgZDsgKGQ9ZGQuYXQoaSkpOyArK2kpIHtcblx0XHRcdFx0YyA9IGNjW2ldO1xuXHRcdFx0XHRpZiAoYykge1xuXHRcdFx0XHRcdGMuc2V0KCdtb2RlbCcsIGQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYWRkKGQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBydW5lKCk7XG5cdFx0fSk7XG5cblx0XHQvLyByZWZyZXNoIGlzIHVzZWQgYXMgdGhlIGV2ZW50IGhhbmRsZXIgZm9yXG5cdFx0Ly8gY29sbGVjdGlvbiByZXNldHMgc28gY2hlY2tpbmcgZm9yIHRydXRoeSBpc24ndFxuXHRcdC8vIGVub3VnaC4gaXQgbXVzdCBiZSB0cnVlLlxuXHRcdGlmKGltbWVkaWF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0cmVmcmVzaCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnN0YXJ0Sm9iKCdyZWZyZXNoaW5nJywgcmVmcmVzaCwgMTYpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKHRoaXMuY29sbGVjdGlvbiAmJiB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGFzUmVuZGVyZWQgPSB0cnVlO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEFkZHMgYSBbcmVjb3JkXXtAbGluayBlbnlvLk1vZGVsfSBhdCBhIHBhcnRpY3VsYXIgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uTW9kZWx9IHJlYyAtIFRoZSBbcmVjb3JkXXtAbGluayBlbnlvLk1vZGVsfSB0byBhZGQuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIFRoZSBpbmRleCBhdCB3aGljaCB0aGUgcmVjb3JkIHNob3VsZCBiZSBhZGRlZC5cblx0KiBAcHVibGljXG5cdCovXG5cdGFkZDogZnVuY3Rpb24gKHJlYywgaWR4KSB7XG5cdFx0dmFyIGMgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudCh7bW9kZWw6IHJlYywgaW5kZXg6IGlkeH0pO1xuXHRcdGlmICh0aGlzLmdlbmVyYXRlZCAmJiAhdGhpcy5iYXRjaGluZykge1xuXHRcdFx0Yy5yZW5kZXIoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUmVtb3ZlcyB0aGUgW3JlY29yZF17QGxpbmsgZW55by5Nb2RlbH0gYXQgYSBwYXJ0aWN1bGFyIGluZGV4LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIFRoZSBpbmRleCBvZiB0aGUgW3JlY29yZF17QGxpbmsgZW55by5Nb2RlbH0gdG8gYmUgcmVtb3ZlZC5cblx0KiBAcHVibGljXG5cdCovXG5cdHJlbW92ZTogZnVuY3Rpb24gKGlkeCkge1xuXHRcdHZhciBjb250cm9scyA9IHRoaXMuZ2V0Q2xpZW50Q29udHJvbHMoKVxuXHRcdFx0LCBjb250cm9sO1xuXG5cdFx0Y29udHJvbCA9IGNvbnRyb2xzW2lkeF07XG5cblx0XHRpZiAoY29udHJvbCkgY29udHJvbC5kZXN0cm95KCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVtb3ZlcyBhbnkgW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9IHRoYXQgYXJlIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlXG5cdCogW2RhdGFde0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyI2RhdGF9IFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259IGZvciB0aGVcblx0KiBbcmVwZWF0ZXJde0BsaW5rIGVueW8uRGF0YVJlcGVhdGVyfS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cHJ1bmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZyA9IHRoaXMuZ2V0Q2xpZW50Q29udHJvbHMoKVxuXHRcdFx0LCBsZW4gPSAodGhpcy5jb2xsZWN0aW9uPyB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoOiAwKVxuXHRcdFx0LCB4O1xuXHRcdGlmIChnLmxlbmd0aCA+IGxlbikge1xuXHRcdFx0eCA9IGcuc2xpY2UobGVuKTtcblx0XHRcdGZvciAodmFyIGk9MCwgYzsgKGM9eFtpXSk7ICsraSkge1xuXHRcdFx0XHRjLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHMgPSB0aGlzLmdldCgnY29udGFpbmVyT3B0aW9ucycpLFxuXHRcdFx0bm9tID0gb3BzLm5hbWUgfHwgKG9wcy5uYW1lID0gdGhpcy5jb250YWluZXJOYW1lKTtcblx0XHR0aGlzLmNyZWF0ZUNocm9tZShbb3BzXSk7XG5cdFx0dGhpcy5kaXNjb3ZlckNvbnRyb2xQYXJlbnQoKTtcblx0XHRpZiAobm9tICE9IHRoaXMuY29udGFpbmVyTmFtZSkge1xuXHRcdFx0dGhpcy4kW3RoaXMuY29udGFpbmVyTmFtZV0gPSB0aGlzLiRbbm9tXTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvblNlbGVjdGVkOiAnY2hpbGRTZWxlY3RlZCcsXG5cdFx0b25EZXNlbGVjdGVkOiAnY2hpbGREZXNlbGVjdGVkJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9oYW5kbGVyczoge1xuXHRcdGFkZDogJ21vZGVsc0FkZGVkJyxcblx0XHRyZW1vdmU6ICdtb2RlbHNSZW1vdmVkJyxcblx0XHRyZXNldDogJ3JlZnJlc2gnLFxuXHRcdHNvcnQ6ICdyZWZyZXNoJyxcblx0XHRmaWx0ZXI6ICdyZWZyZXNoJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbGxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBjID0gdGhpcy5jb2xsZWN0aW9uO1xuXHRcdGlmICh0eXBlb2YgYyA9PSAnc3RyaW5nJykge1xuXHRcdFx0YyA9IHRoaXMuY29sbGVjdGlvbiA9IGVueW8uZ2V0UGF0aChjKTtcblx0XHR9XG5cdFx0aWYgKGMpIHtcblx0XHRcdHRoaXMuaW5pdENvbGxlY3Rpb24oYywgcCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluaXRDb2xsZWN0aW9uOiBmdW5jdGlvbiAoYywgcCkge1xuXHRcdHZhciBlO1xuXHRcdGlmIChjICYmIGMuYWRkTGlzdGVuZXIpIHtcblx0XHRcdGZvciAoZSBpbiB0aGlzLl9oYW5kbGVycykge1xuXHRcdFx0XHRjLmFkZExpc3RlbmVyKGUsIHRoaXMuX2hhbmRsZXJzW2VdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHAgJiYgcC5yZW1vdmVMaXN0ZW5lcikge1xuXHRcdFx0Zm9yIChlIGluIHRoaXMuX2hhbmRsZXJzKSB7XG5cdFx0XHRcdHAucmVtb3ZlTGlzdGVuZXIoZSwgdGhpcy5faGFuZGxlcnNbZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtb2RlbHNBZGRlZDogZnVuY3Rpb24gKHNlbmRlciwgZSwgcHJvcHMpIHtcblx0XHRpZiAoc2VuZGVyID09PSB0aGlzLmNvbGxlY3Rpb24pIHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1vZGVsc1JlbW92ZWQ6IGZ1bmN0aW9uIChzZW5kZXIsIGUsIHByb3BzKSB7XG5cdFx0aWYgKHNlbmRlciA9PT0gdGhpcy5jb2xsZWN0aW9uKSB7XG5cdFx0XHR0aGlzLmRlc2VsZWN0UmVtb3ZlZE1vZGVscyhwcm9wcy5tb2RlbHMpO1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIERlc2VsZWN0IHJlbW92ZWQgbW9kZWxzIGZyb20gX3NlbGVjdGVkIGFycmF5LlxuXHQqIEFmdGVyIGNhbGxpbmcgaXQsIHdlIGNhbiBlbnN1cmUgdGhhdCB0aGUgcmVtb3ZlZCBtb2RlbHMgYXJlbid0IGN1cnJlbnRseSBzZWxlY3RlZC5cblx0KiBAcGFyYW0ge2FycmF5fSBtb2RlbHMgLSBUaGUgYXJyYXkgb2YgbW9kZWxzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBjb2xsZWN0aW9uLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc2VsZWN0UmVtb3ZlZE1vZGVsczogZnVuY3Rpb24obW9kZWxzKSB7XG5cdFx0dmFyIHNlbGVjdGVkID0gdGhpcy5fc2VsZWN0aW9uLFxuXHRcdFx0b3JpZyxcblx0XHRcdG1vZGVsLFxuXHRcdFx0aWR4LFxuXHRcdFx0bGVuID0gc2VsZWN0ZWQgJiYgc2VsZWN0ZWQubGVuZ3RoLFxuXHRcdFx0aSA9IG1vZGVscy5sZW5ndGggLSAxO1xuXG5cdFx0Ly8gV2UgaGF2ZSBzZWxlY3RlZCBtb2RlbHNcblx0XHRpZiAobGVuKSB7XG5cdFx0XHQvLyB1bmZvcnR1bmF0ZWx5IHdlIG5lZWQgdG8gbWFrZSBhIGNvcHkgdG8gcHJlc2VydmUgd2hhdCB0aGUgb3JpZ2luYWwgd2FzXG5cdFx0XHQvLyBzbyB3ZSBjYW4gcGFzcyBpdCB3aXRoIHRoZSBub3RpZmljYXRpb24gaWYgYW55IG9mIHRoZXNlIGFyZSBkZXNlbGVjdGVkXG5cdFx0XHRvcmlnID0gc2VsZWN0ZWQuc2xpY2UoKTtcblxuXHRcdFx0Ly8gd2UgaGF2ZSBfc2VsZWN0ZWQgYXJyYXkgdG8gdHJhY2sgY3VycmVudGx5IHNlbGVjdGVkIG1vZGVsc1xuXHRcdFx0Ly8gaWYgc29tZSByZW1vdmVkIG1vZGVscyBhcmUgaW4gX3NlbGVjdGVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZW0gZnJvbSBfc2VsZWN0ZWRcblx0XHRcdC8vIGNsZWFybHkgd2Ugd29uJ3QgbmVlZCB0byBjb250aW51ZSBjaGVja2luZyBpZiBzZWxlY3RlZCBkb2VzIG5vdCBoYXZlIGFueSBtb2RlbHNcblx0XHRcdGZvciAoOyAobW9kZWwgPSBtb2RlbHNbaV0pICYmIHNlbGVjdGVkLmxlbmd0aDsgLS1pKSB7XG5cdFx0XHRcdGlkeCA9IHNlbGVjdGVkLmluZGV4T2YobW9kZWwpO1xuXHRcdFx0XHRpZiAoaWR4ID4gLTEpIHNlbGVjdGVkLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb21lIHNlbGVjdGVkIG1vZGVscyBhcmUgZGlzY292ZXJlZCwgc28gd2UgbmVlZCB0byBub3RpZnlcblx0XHRcdGlmIChsZW4gIT0gc2VsZWN0ZWQubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNlbGVjdGlvbikge1xuXHRcdFx0XHRcdGlmICh0aGlzLnNlbGVjdGlvblR5cGUgPT0gJ211bHRpJykgdGhpcy5ub3RpZnkoJ3NlbGVjdGVkJywgb3JpZywgc2VsZWN0ZWQpO1xuXHRcdFx0XHRcdGVsc2UgdGhpcy5ub3RpZnkoJ3NlbGVjdGVkJywgb3JpZ1swXSwgc2VsZWN0ZWRbMF0gfHwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YmF0Y2hpbmdDaGFuZ2VkOiBmdW5jdGlvbiAocHJldiwgdmFsKSB7XG5cdFx0aWYgKHRoaXMuZ2VuZXJhdGVkICYmIGZhbHNlID09PSB2YWwpIHtcblx0XHRcdHRoaXMuJFt0aGlzLmNvbnRhaW5lck5hbWVdLnJlbmRlcigpO1xuXHRcdFx0dGhpcy5yZWZyZXNoKHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBDYWxscyBbY2hpbGRGb3JJbmRleCgpXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlciNnZXRDaGlsZEZvckluZGV4fS4gTGVhdmluZyBmb3IgcG9zdGVyaXR5LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmV0cmlldmUuXG5cdCogQHJldHVybnMge2VueW8uQ29udHJvbHx1bmRlZmluZWR9IFRoZSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSBhdCB0aGUgc3BlY2lmaWVkXG5cdCogaW5kZXgsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGNvdWxkIG5vdCBiZSBmb3VuZCBvciB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldENoaWxkRm9ySW5kZXg6IGZ1bmN0aW9uIChpZHgpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZEZvckluZGV4KGlkeCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSByZXByZXNlbnRhdGlvbiBhdCBhIHBhcnRpY3VsYXIgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaWR4IC0gVGhlIGluZGV4IG9mIHRoZSBjaGlsZCB0byByZXRyaWV2ZS5cblx0KiBAcmV0dXJucyB7ZW55by5Db250cm9sfHVuZGVmaW5lZH0gVGhlIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IGF0IHRoZSBzcGVjaWZpZWRcblx0KiBpbmRleCwgb3IgYHVuZGVmaW5lZGAgaWYgaXQgY291bGQgbm90IGJlIGZvdW5kIG9yIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2hpbGRGb3JJbmRleDogZnVuY3Rpb24gKGlkeCkge1xuXHRcdHJldHVybiB0aGlzLiQuY29udGFpbmVyLmNoaWxkcmVuW2lkeF07XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgW3JlcGVhdGVyXXtAbGluayBlbnlvLkRhdGFSZXBlYXRlcn0uXG5cdCpcblx0KiBAcmV0dXJucyB7ZW55by5Db2xsZWN0aW9ufSBUaGUge0BsaW5rIGVueW8uQ29sbGVjdGlvbn0gdGhhdCBjb21wcmlzZXMgdGhlIGRhdGEuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkYXRhOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29sbGVjdGlvbjtcblx0fSxcblxuXHQvKipcblx0KiBDb25zb2xpZGF0ZXMgc2VsZWN0aW9uIGxvZ2ljIGFuZCBhbGxvd3MgZm9yIGRlc2VsZWN0aW9uIG9mIGEgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfVxuXHQqIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X3NlbGVjdDogZnVuY3Rpb24gKGlkeCwgbW9kZWwsIHNlbGVjdCkge1xuXHRcdGlmICghdGhpcy5zZWxlY3Rpb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2hpbGRGb3JJbmRleChpZHgpLFxuXHRcdFx0cyA9IHRoaXMuX3NlbGVjdGlvbixcblx0XHRcdGkgPSB1dGlscy5pbmRleE9mKG1vZGVsLCBzKTtcblxuXHRcdGlmIChzZWxlY3QpIHtcblx0XHRcdGlmKGkgPT0gLTEpIHtcblx0XHRcdFx0aWYodGhpcy5zZWxlY3Rpb25UeXBlICE9ICdtdWx0aScpIHtcblx0XHRcdFx0XHR3aGlsZSAocy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGkgPSB0aGlzLmNvbGxlY3Rpb24uaW5kZXhPZihzLnBvcCgpKTtcblx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3QoaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cy5wdXNoKG1vZGVsKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoaSA+PSAwKSB7XG5cdFx0XHRcdHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjKSB7XG5cdFx0XHRjLnNldCgnc2VsZWN0ZWQnLCBzZWxlY3QpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zZWxlY3Rpb25Qcm9wZXJ0eSAmJiBtb2RlbCkge1xuXHRcdFx0KHM9dGhpcy5zZWxlY3Rpb25Qcm9wZXJ0eSkgJiYgbW9kZWwuc2V0KHMsIHNlbGVjdCk7XG5cdFx0fVxuXHRcdHRoaXMubm90aWZ5T2JzZXJ2ZXJzKCdzZWxlY3RlZCcpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNlbGVjdHMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byBzZWxlY3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZWxlY3Q6IGZ1bmN0aW9uIChpZHgpIHtcblx0XHR0aGlzLl9zZWxlY3QoaWR4LCB0aGlzLmNvbGxlY3Rpb24uYXQoaWR4KSwgdHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGVzZWxlY3RzIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gZGVzZWxlY3QuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkZXNlbGVjdDogZnVuY3Rpb24gKGlkeCkge1xuXHRcdHRoaXMuX3NlbGVjdChpZHgsIHRoaXMuY29sbGVjdGlvbi5hdChpZHgpLCBmYWxzZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uTW9kZWx9IG1vZGVsIC0gVGhlIFttb2RlbF17QGxpbmsgZW55by5Nb2RlbH0gd2hvc2Ugc2VsZWN0aW9uIHN0YXR1c1xuXHQqIGlzIHRvIGJlIGRldGVybWluZWQuXG5cdCogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbW9kZWwgaXMgc2VsZWN0ZWQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cblx0KiBAcHVibGljXG5cdCovXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChtb2RlbCkge1xuXHRcdHJldHVybiAhIX51dGlscy5pbmRleE9mKG1vZGVsLCB0aGlzLl9zZWxlY3Rpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYWxsIGl0ZW1zIChpZiBbc2VsZWN0aW9uVHlwZV17QGxpbmsgZW55by5EYXRhUmVwZWF0ZXIjc2VsZWN0aW9uVHlwZX0gaXMgYG11bHRpYCkuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNlbGVjdGlvblR5cGUgPT0gJ211bHRpJykge1xuXHRcdFx0dGhpcy5zdG9wTm90aWZpY2F0aW9ucygpO1xuXHRcdFx0dmFyIHMgPSB0aGlzLl9zZWxlY3Rpb25cblx0XHRcdFx0LCBsZW4gPSB0aGlzLmNvbGxlY3Rpb24/IHRoaXMuY29sbGVjdGlvbi5sZW5ndGg6IDA7XG5cdFx0XHRzLmxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcblx0XHRcdFx0dGhpcy5zZWxlY3QoaSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnN0YXJ0Tm90aWZpY2F0aW9ucygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBEZXNlbGVjdHMgYWxsIGl0ZW1zLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRkZXNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNlbGVjdGlvbikge1xuXHRcdFx0dGhpcy5zdG9wTm90aWZpY2F0aW9ucygpO1xuXHRcdFx0dmFyIHMgPSB0aGlzLl9zZWxlY3Rpb24sIG0sIGk7XG5cdFx0XHR3aGlsZSAocy5sZW5ndGgpIHtcblx0XHRcdFx0bSA9IHMucG9wKCk7XG5cdFx0XHRcdGkgPSB0aGlzLmNvbGxlY3Rpb24uaW5kZXhPZihtKTtcblx0XHRcdFx0dGhpcy5kZXNlbGVjdChpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhcnROb3RpZmljYXRpb25zKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgW21vZGVsXXtAbGluayBlbnlvLk1vZGVsfVxuXHQqIChpZiBbc2VsZWN0aW9uVHlwZV17QGxpbmsgZW55by5EYXRhUmVwZWF0ZXIjc2VsZWN0aW9uVHlwZX0gaXMgbm90IGBtdWx0aSdgKSxcblx0KiBvciBhbiBpbW11dGFibGUgW2FycmF5XXtAZ2xvc3NhcnkgQXJyYXl9IG9mIGFsbCBjdXJyZW50bHkgc2VsZWN0ZWQgbW9kZWxzIChpZlxuXHQqIGBzZWxlY3Rpb25UeXBlYCBpcyBgbXVsdGknYCkuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0byBlbnN1cmUgdGhhdCBiaW5kaW5ncyB3aWxsIGNsZWFyIHByb3Blcmx5IGFjY29yZGluZyB0byB0aGVpciBhcGlcblx0XHRyZXR1cm4gKHRoaXMuc2VsZWN0aW9uVHlwZSA9PSAnbXVsdGknID8gdGhpcy5fc2VsZWN0aW9uIDogdGhpcy5fc2VsZWN0aW9uWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRhdGFDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuY29sbGVjdGlvbiAmJiB0aGlzLmhhc1JlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbXB1dGVkOiBbXG5cdFx0e21ldGhvZDogJ3NlbGVjdGVkJ30sXG5cdFx0e21ldGhvZDogJ2RhdGEnLCBwYXRoOiBbJ2NvbnRyb2xsZXInLCAnY29sbGVjdGlvbiddfVxuXHRdLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjaGlsZE1peGluczogW1JlcGVhdGVyQ2hpbGRTdXBwb3J0XSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb250cm9sUGFyZW50TmFtZTogJ2NvbnRhaW5lcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29udGFpbmVyTmFtZTogJ2NvbnRhaW5lcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29udGFpbmVyT3B0aW9uczoge25hbWU6ICdjb250YWluZXInLCBjbGFzc2VzOiAnZW55by1maWxsIGVueW8tZGF0YS1yZXBlYXRlci1jb250YWluZXInfSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRiYXRjaGluZzogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X3NlbGVjdGlvbjogbnVsbFxufSk7XG5cbi8qKlxuKiBAc3RhdGljXG4qIEBwcml2YXRlXG4qL1xuRGF0YVJlcGVhdGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChjdG9yLCBwcm9wcykge1xuXHR2YXIgcCA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3I7XG5cdGlmIChwcm9wcy5jaGlsZE1peGlucykge1xuXHRcdHAuY2hpbGRNaXhpbnMgPSAocC5jaGlsZE1peGlucz8gdXRpbHMubWVyZ2UocC5jaGlsZE1peGlucywgcHJvcHMuY2hpbGRNaXhpbnMpOiBwcm9wcy5jaGlsZE1peGlucy5zbGljZSgpKTtcblx0XHRkZWxldGUgcHJvcHMuY2hpbGRNaXhpbnM7XG5cdH1cbn07XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db250cm9sXCI6MTYsXCIuL1JlcGVhdGVyQ2hpbGRTdXBwb3J0XCI6MzksXCIuL2tpbmRcIjo2NixcIi4vdXRpbHNcIjo3NX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKTtcbnZhclxuXHRDb250cm9sID0gcmVxdWlyZSgnLi9Db250cm9sJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBbYWN0aXZlIHN0YXRlXXtAbGluayBlbnlvLkdyb3VwSXRlbSNhY3RpdmV9IGhhcyBjaGFuZ2VkLlxuKlxuKiBAZXZlbnQgZW55by5Hcm91cEl0ZW0jb25BY3RpdmF0ZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uR3JvdXBJdGVtfSBpcyB0aGUgYmFzZSBba2luZF17QGdsb3NzYXJ5IGtpbmR9IGZvciB0aGVcbiogW0dyb3VwaW5nXXtAbGluayBlbnlvLkdyb3VwfSBBUEkuIEl0IG1hbmFnZXMgdGhlXG4qIFthY3RpdmUgc3RhdGVde0BsaW5rIGVueW8uR3JvdXBJdGVtI2FjdGl2ZX0gb2YgdGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fVxuKiAob3IgdGhlIFtpbmhlcml0aW5nXXtAZ2xvc3Nhcnkgc3Via2luZH0gY29tcG9uZW50KS4gQSBzdWJraW5kIG1heSBjYWxsIGBzZXRBY3RpdmUoKWAgXG4qIHRvIHNldCB0aGUgW2FjdGl2ZV17QGxpbmsgZW55by5Hcm91cEl0ZW0jYWN0aXZlfSBwcm9wZXJ0eSB0byB0aGUgZGVzaXJlZCBzdGF0ZTsgdGhpc1xuKiB3aWxsIGFkZGl0aW9uYWxseSBbYnViYmxlXXtAbGluayBlbnlvLkNvbXBvbmVudCNidWJibGV9IGFuIFxuKiBbb25BY3RpdmF0ZV17QGxpbmsgZW55by5Hcm91cEl0ZW0jb25BY3RpdmF0ZX0ge0BnbG9zc2FyeSBldmVudH0sIHdoaWNoIG1heVxuKiBiZSBoYW5kbGVkIGFzIG5lZWRlZCBieSB0aGUgY29udGFpbmluZyBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmdcbiogZ3JvdXBzIG9mIGl0ZW1zIHdob3NlIHN0YXRlIHNob3VsZCBiZSBtYW5hZ2VkIGNvbGxlY3RpdmVseS5cbipcbiogRm9yIGFuIGV4YW1wbGUgb2YgaG93IHRoaXMgd29ya3MsIHNlZSB0aGUge0BsaW5rIGVueW8uR3JvdXB9IGtpbmQsIHdoaWNoIGVuYWJsZXMgdGhlXG4qIGNyZWF0aW9uIG9mIHJhZGlvIGdyb3VwcyBmcm9tIGFyYml0cmFyeSBjb21wb25lbnRzIHRoYXRcdHN1cHBvcnQgdGhlIEdyb3VwaW5nIEFQSS5cbipcbiogQGNsYXNzIGVueW8uR3JvdXBJdGVtXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkdyb3VwaXRlbS5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLkdyb3VwSXRlbScsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgZW55by5Hcm91cGl0ZW0ucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogV2lsbCBiZSBgdHJ1ZWAgaWYgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRhY3RpdmU6IGZhbHNlXG5cdH0sXG5cdFxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmFjdGl2ZUNoYW5nZWQoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5Hcm91cEl0ZW0jb25BY3RpdmF0ZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFjdGl2ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmJ1YmJsZSgnb25BY3RpdmF0ZScpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0NvbnRyb2xcIjoxNixcIi4va2luZFwiOjY2fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uL2tpbmQnKSxcblx0cmkgPSByZXF1aXJlKCcuLi9yZXNvbHV0aW9uJyksXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyJyksXG5cdHBhdGggPSByZXF1aXJlKCcuLi9wYXRoUmVzb2x2ZXInKTtcbnZhclxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vQ29udHJvbCcpO1xuXG4vKipcbiogRmlyZXMgd2hlbiB0aGUgW2ltYWdlXXtAbGluayBlbnlvLkltYWdlfSBoYXMgbG9hZGVkLlxuKlxuKiBAZXZlbnQgZW55by5JbWFnZSNvbmxvYWRcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBldmVudCBpbmZvcm1hdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdGhlcmUgaGFzIGJlZW4gYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgW2ltYWdlXXtAbGluayBlbnlvLkltYWdlfS5cbipcbiogQGV2ZW50IGVueW8uSW1hZ2Ujb25lcnJvclxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uSW1hZ2V9IGltcGxlbWVudHMgYW4gSFRNTCBbJmx0O2ltZyZndDtde0BnbG9zc2FyeSBpbWd9IGVsZW1lbnQgYW5kLCBvcHRpb25hbGx5LFxuKiBbYnViYmxlc117QGxpbmsgZW55by5Db21wb25lbnQjYnViYmxlfSB0aGUgW29ubG9hZF17QGxpbmsgZW55by5JbWFnZSNvbmxvYWR9IGFuZFxuKiBbb25lcnJvcl17QGxpbmsgZW55by5JbWFnZSNvbmVycm9yfSBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9LiBJbWFnZSBkcmFnZ2luZyBpcyBzdXBwcmVzc2VkIGJ5XG4qIGRlZmF1bHQsIHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCB0b3VjaCBpbnRlcmZhY2VzLlxuKlxuKiB7QGxpbmsgZW55by5JbWFnZX0gYWxzbyBoYXMgc3VwcG9ydCBmb3IgbXVsdGktcmVzb2x1dGlvbiBpbWFnZXMuIElmIHlvdSBhcmUgZGV2ZWxvcGluZyBhc3NldHNcbiogZm9yIHNwZWNpZmljIHNjcmVlbiBzaXplcywgSEQgKDcyMHApLCBGSEQgKDEwODBwKSwgVUhEICg0ayksIGZvciBleGFtcGxlLCB5b3UgbWF5IHByb3ZpZGVcbiogc3BlY2lmaWMgaW1hZ2UgYXNzZXRzIGluIGEgaGFzaC9vYmplY3QgZm9ybWF0IHRvIHRoZSBgc3JjYCBwcm9wZXJ0eSwgaW5zdGVhZCBvZiB0aGUgdXN1YWxcbiogc3RyaW5nLiBUaGUgaW1hZ2Ugc291cmNlcyB3aWxsIGJlIHVzZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBzY3JlZW4gcmVzb2x1dGlvbiBpcyBsZXNzIHRoYW5cbiogb3IgZXF1YWwgdG8gdGhvc2Ugc2NyZWVuIHR5cGVzLiBGb3IgbW9yZSBpbmZvcm1hdG9uIG9uIG91ciByZXNvbHV0aW9uIHN1cHBvcnQsIGFuZCBob3cgdG9cbiogZW5hYmxlIHRoaXMgZmVhdHVyZSwgc2VlIG91ciBbcmVzb2x1dGlvbiBpbmRlcGVuZGVuY2UgZG9jc117QGxpbmsgZW55by5yaX0uXG4qXG4qIGBgYFxuKiAvLyBUYWtlIGFkdmFudGFnZSBvZiB0aGUgbXVsdGktcmV6IG1vZGVcbioge2tpbmQ6ICdlbnlvLkltYWdlJywgc3JjOiB7XG4qIFx0J2hkJzogJ2h0dHA6Ly9sb3JlbXBpeGVsLmNvbS82NC82NC9jaXR5LzEvJyxcbiogXHQnZmhkJzogJ2h0dHA6Ly9sb3JlbXBpeGVsLmNvbS8xMjgvMTI4L2NpdHkvMS8nLFxuKiBcdCd1aGQnOiAnaHR0cDovL2xvcmVtcGl4ZWwuY29tLzI1Ni8yNTYvY2l0eS8xLydcbiogfSwgYWx0OiAnTXVsdGktcmV6J30sXG4qIC8vIFN0YW5kYXJkIHN0cmluZyBgc3JjYFxuKiB7a2luZDogJ2VueW8uSW1hZ2UnLCBzcmM6IGh0dHA6Ly9sb3JlbXBpeGVsLmNvbS8xMjgvMTI4L2NpdHkvMS8nLCBhbHQ6ICdMYXJnZSd9LFxuKiBgYGBcbipcbiogQGNsYXNzIGVueW8uSW1hZ2VcbiogQGV4dGVuZHMgZW55by5Db250cm9sXG4qIEB1aVxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uSW1hZ2UucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5JbWFnZScsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBXaGVuIGB0cnVlYCwgbm8gW29ubG9hZF17QGxpbmsgZW55by5JbWFnZSNvbmxvYWR9IG9yXG5cdCogW29uZXJyb3Jde0BsaW5rIGVueW8uSW1hZ2Ujb25lcnJvcn0ge0BnbG9zc2FyeSBldmVudH0gaGFuZGxlcnMgd2lsbCBiZVxuXHQqIGNyZWF0ZWQuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bm9FdmVudHM6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDpcblx0XHQvKiogQGxlbmRzIGVueW8uSW1hZ2UucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogTWFwcyB0byB0aGUgYHNyY2AgYXR0cmlidXRlIG9mIGFuIFsmbHQ7aW1nJmd0OyB0YWdde0BnbG9zc2FyeSBpbWd9LiBUaGlzIGFsc28gc3VwcG9ydHNcblx0XHQqIGEgbXVsdGktcmVzb2x1dGlvbiBoYXNoIG9iamVjdC4gU2VlXG5cdFx0KiBbdGhlIGFib3ZlIGRlc2NyaXB0aW9uIG9mIGVueW8uSW1hZ2Vde0BsaW5rIGVueW8uSW1hZ2V9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzXG5cdFx0KiBvciBvdXIgW3Jlc29sdXRpb24gaW5kZXBlbmRlbmNlIGRvY3Nde0BsaW5rIGVueW8ucml9LlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c3JjOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogTWFwcyB0byB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIGFuIFsmbHQ7aW1nJmd0OyB0YWdde0BnbG9zc2FyeSBpbWd9LlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YWx0OiAnJyxcblxuXHRcdC8qKlxuXHRcdCogQnkgZGVmYXVsdCwgdGhlIFtpbWFnZV17QGxpbmsgZW55by5JbWFnZX0gaXMgcmVuZGVyZWQgdXNpbmcgYW4gYDxpbWc+YCB0YWcuXG5cdFx0KiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIGAnY292ZXInYCBvciBgJ2NvbnN0cmFpbidgLCB0aGUgaW1hZ2Ugd2lsbCBiZVxuXHRcdCogcmVuZGVyZWQgdXNpbmcgYSBgPGRpdj5gLCB1dGlsaXppbmcgYGJhY2tncm91bmQtaW1hZ2VgIGFuZCBgYmFja2dyb3VuZC1zaXplYC5cblx0XHQqXG5cdFx0KiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgJ2NvbnN0cmFpbidgIHRvIGxldHRlcmJveCB0aGUgaW1hZ2UgaW4gdGhlIGF2YWlsYWJsZVxuXHRcdCogc3BhY2UsIG9yIGAnY292ZXInYCB0byBjb3ZlciB0aGUgYXZhaWxhYmxlIHNwYWNlIHdpdGggdGhlIGltYWdlIChjcm9wcGluZyB0aGVcblx0XHQqIGxhcmdlciBkaW1lbnNpb24pLiAgTm90ZSB0aGF0IHdoZW4gYHNpemluZ2AgaXMgc2V0LCB0aGUgY29udHJvbCBtdXN0IGJlXG5cdFx0KiBleHBsaWNpdGx5IHNpemVkLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2l6aW5nOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogV2hlbiBbc2l6aW5nXXtAbGluayBlbnlvLkltYWdlI3NpemluZ30gaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBzZXRzIHRoZSBwb3NpdGlvbmluZyBvZlxuXHRcdCogdGhlIFtpbWFnZV17QGxpbmsgZW55by5JbWFnZX0gd2l0aGluIHRoZSBib3VuZHMsIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG5cdFx0KiBbYGJhY2tncm91bmQtcG9zaXRpb25gXXtAZ2xvc3NhcnkgYmFja2dyb3VuZFBvc2l0aW9ufSBDU1MgcHJvcGVydHkuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdjZW50ZXInXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRwb3NpdGlvbjogJ2NlbnRlcidcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6ICdpbWcnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsYXNzZXM6ICdlbnlvLWltYWdlJyxcblxuXHQvKipcblx0KiBAdHlwZSB7T2JqZWN0fVxuXHQqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZHJhZ2dhYmxlIC0gVGhpcyBhdHRyaWJ1dGUgd2lsbCB0YWtlIG9uZSBvZiB0aGUgZm9sbG93aW5nXG5cdCpcdFtTdHJpbmdde0BnbG9zc2FyeSBTdHJpbmd9IHZhbHVlczogJ3RydWUnLCAnZmFsc2UnICh0aGUgZGVmYXVsdCksIG9yICdhdXRvJy5cblx0KiBTZXR0aW5nIEJvb2xlYW4gYGZhbHNlYCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YXR0cmlidXRlczoge1xuXHRcdGRyYWdnYWJsZTogJ2ZhbHNlJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLm5vRXZlbnRzKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXMub25sb2FkO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzLm9uZXJyb3I7XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuYWx0Q2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5zaXppbmdDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLnNyY0NoYW5nZWQoKTtcblx0XHRcdHRoaXMucG9zaXRpb25DaGFuZ2VkKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3JjQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzcmMgPSByaS5zZWxlY3RTcmModGhpcy5zcmMpO1xuXHRcdGlmICh0aGlzLnNpemluZykge1xuXHRcdFx0dGhpcy5hcHBseVN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJywgc3JjID8gJ3VybCgnICsgcGF0aC5yZXdyaXRlKHNyYykgKyAnKScgOiAnbm9uZScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXNyYykge1xuXHRcdFx0XHQvLyBhbGxvdyB1cyB0byBjbGVhciB0aGUgc3JjIHByb3BlcnR5XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAnJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJywgcGF0aC5yZXdyaXRlKHNyYykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhbHRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRoaXMuYWx0KTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaXppbmdDaGFuZ2VkOiBmdW5jdGlvbiAod2FzKSB7XG5cdFx0dGhpcy50YWcgPSB0aGlzLnNpemluZyA/ICdkaXYnIDogJ2ltZyc7XG5cdFx0dGhpcy5hZGRSZW1vdmVDbGFzcygnc2l6ZWQnLCAhIXRoaXMuc2l6aW5nKTtcblx0XHRpZiAod2FzKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUNsYXNzKHdhcyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnNpemluZykge1xuXHRcdFx0dGhpcy5hZGRDbGFzcyh0aGlzLnNpemluZyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmdlbmVyYXRlZCkge1xuXHRcdFx0dGhpcy5zcmNDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwb3NpdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5zaXppbmcpIHtcblx0XHRcdHRoaXMuYXBwbHlTdHlsZSgnYmFja2dyb3VuZC1wb3NpdGlvbicsIHRoaXMucG9zaXRpb24pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5JbWFnZSNvbmxvYWRcblx0KiBAZmlyZXMgZW55by5JbWFnZSNvbmVycm9yXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0ZGlzcGF0Y2hlci5tYWtlQnViYmxlKHRoaXMsICdsb2FkJywgJ2Vycm9yJyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3RhdGljczoge1xuXHRcdC8qKlxuXHRcdFx0QSBnbG9iYWxseSBhY2Nlc3NpYmxlIGRhdGEgVVJMIHRoYXQgZGVzY3JpYmVzIGEgc2ltcGxlXG5cdFx0XHRwbGFjZWhvbGRlciBpbWFnZSB0aGF0IG1heSBiZSB1c2VkIGluIHNhbXBsZXMgYW5kIGFwcGxpY2F0aW9uc1xuXHRcdFx0dW50aWwgZmluYWwgZ3JhcGhpY3MgYXJlIHByb3ZpZGVkLiBBcyBhbiBTVkcgaW1hZ2UsIGl0IHdpbGxcblx0XHRcdGV4cGFuZCB0byBmaWxsIHRoZSBkZXNpcmVkIHdpZHRoIGFuZCBoZWlnaHQgc2V0IGluIHRoZSBzdHlsZS5cblx0XHQqL1xuXHRcdHBsYWNlaG9sZGVyOlxuXHRcdFx0J2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DJyArXG5cdFx0XHQnOXpkbWNpSUhodGJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJajQ4Y21WamRDQjNhV1IwYUQwaU1UQXcnICtcblx0XHRcdCdKU0lnYUdWcFoyaDBQU0l4TURBbElpQnpkSGxzWlQwaWMzUnliMnRsT2lBak5EUTBPeUJ6ZEhKdmEyVXRkMmxrZEdnNklERTdJR1pwYkd3NklDTmhZVycgK1xuXHRcdFx0J0U3SWlBdlBqeHNhVzVsSUhneFBTSXdJaUI1TVQwaU1DSWdlREk5SWpFd01DVWlJSGt5UFNJeE1EQWxJaUJ6ZEhsc1pUMGljM1J5YjJ0bE9pQWpORFEwJyArXG5cdFx0XHQnT3lCemRISnZhMlV0ZDJsa2RHZzZJREU3SWlBdlBqeHNhVzVsSUhneFBTSXhNREFsSWlCNU1UMGlNQ0lnZURJOUlqQWlJSGt5UFNJeE1EQWxJaUJ6ZEgnICtcblx0XHRcdCdsc1pUMGljM1J5YjJ0bE9pQWpORFEwT3lCemRISnZhMlV0ZDJsa2RHZzZJREU3SWlBdlBqd3ZjM1puUGc9PSdcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW9cIjoxLFwiLi4vQ29udHJvbFwiOjE2LFwiLi4vZGlzcGF0Y2hlclwiOjU3LFwiLi4va2luZFwiOjY2LFwiLi4vcGF0aFJlc29sdmVyXCI6NzAsXCIuLi9yZXNvbHV0aW9uXCI6NzN9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyksXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyk7XG52YXJcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4vQ29udHJvbCcpO1xuXG4vKipcbiogRmlyZXMgaW1tZWRpYXRlbHkgd2hlbiB0aGUgdGV4dCBjaGFuZ2VzLlxuKlxuKiBAZXZlbnQgZW55by5JbnB1dCNvbmlucHV0XG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseVxuKlx0cHJvcGFnYXRlZCB0aGUge0BnbG9zc2FyeSBldmVudH0uXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBldmVudCAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGNvbnRhaW5pbmcgZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSB0ZXh0IGhhcyBjaGFuZ2VkIGFuZCB0aGUgW2lucHV0XXtAbGluayBlbnlvLklucHV0fSBzdWJzZXF1ZW50bHkgbG9zZXNcbiogZm9jdXMuXG4qXG4qIEBldmVudCBlbnlvLklucHV0I29uY2hhbmdlXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseVxuKlx0cHJvcGFnYXRlZCB0aGUge0BnbG9zc2FyeSBldmVudH0uXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBldmVudCAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGNvbnRhaW5pbmcgZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBbaW5wdXRde0BsaW5rIGVueW8uSW5wdXR9IGlzIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4qXG4qIEBldmVudCBlbnlvLklucHV0I29uRGlzYWJsZWRDaGFuZ2VcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBldmVudCBpbmZvcm1hdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIHtAbGluayBlbnlvLklucHV0fSBpbXBsZW1lbnRzIGFuIEhUTUwgWyZsdDtpbnB1dCZndDtde0BnbG9zc2FyeSBpbnB1dH0gZWxlbWVudFxuKiB3aXRoIGNyb3NzLXBsYXRmb3JtIHN1cHBvcnQgZm9yIGNoYW5nZSBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9LlxuKlxuKiBZb3UgbWF5IGxpc3RlbiBmb3IgW29uaW5wdXRde0BsaW5rIGVueW8uSW5wdXQjb25pbnB1dH0gYW5kXG4qIFtvbmNoYW5nZV17QGxpbmsgZW55by5JbnB1dCNvbmNoYW5nZX0gW0RPTSBldmVudHNde0BnbG9zc2FyeSBET01FdmVudH0gZnJvbVxuKiB0aGlzIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHRvIGtub3cgd2hlbiB0aGUgdGV4dCBpbnNpZGUgaGFzIGJlZW4gbW9kaWZpZWQuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW1RleHQgRmllbGRzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9jb250cm9scy90ZXh0LWZpZWxkcy5odG1sfVxuKiBpbiB0aGUgRW55byBEZXZlbG9wZXIgR3VpZGUuXG4qXG4qIEBjbGFzcyBlbnlvLklucHV0XG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLklucHV0LnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uSW5wdXQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbnRyb2wsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOlxuXHRcdC8qKiBAbGVuZHMgZW55by5JbnB1dC5wcm90b3R5cGUgKi8ge1xuXG5cdFx0LyoqXG5cdFx0KiBWYWx1ZSBvZiB0aGUgW2lucHV0XXtAbGluayBlbnlvLklucHV0fS4gVXNlIHRoaXMgcHJvcGVydHkgb25seSB0byBpbml0aWFsaXplIHRoZVxuXHRcdCogdmFsdWUuIENhbGwgYGdldFZhbHVlKClgIGFuZCBgc2V0VmFsdWUoKWAgdG8gbWFuaXB1bGF0ZSB0aGUgdmFsdWUgYXQgcnVudGltZS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHZhbHVlOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogVGV4dCB0byBkaXNwbGF5IHdoZW4gdGhlIFtpbnB1dF17QGxpbmsgZW55by5JbnB1dH0gaXMgZW1wdHlcblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHBsYWNlaG9sZGVyOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogVHlwZSBvZiBbaW5wdXRde0BsaW5rIGVueW8uSW5wdXR9OyBpZiBub3Qgc3BlY2lmaWVkLCBpdCdzIHRyZWF0ZWQgYXMgYCd0ZXh0J2AuXG5cdFx0KiBUaGlzIG1heSBiZSBhbnl0aGluZyBzcGVjaWZpZWQgZm9yIHRoZSBgdHlwZWAgYXR0cmlidXRlIGluIHRoZSBIVE1MXG5cdFx0KiBzcGVjaWZpY2F0aW9uLCBpbmNsdWRpbmcgYCd1cmwnYCwgYCdlbWFpbCdgLCBgJ3NlYXJjaCdgLCBvciBgJ251bWJlcidgLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dHlwZTogJycsXG5cblx0XHQvKipcblx0XHQqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyBpbnB1dCBpbnRvIHRoZSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfS4gVGhpcyBtYXBzXG5cdFx0KiB0byB0aGUgYGRpc2FibGVkYCBET00gYXR0cmlidXRlLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogV2hlbiBgdHJ1ZWAsIHRoZSBjb250ZW50cyBvZiB0aGUgW2lucHV0XXtAbGluayBlbnlvLklucHV0fSB3aWxsIGJlIHNlbGVjdGVkXG5cdFx0KiB3aGVuIHRoZSBpbnB1dCBnYWlucyBmb2N1cy5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRzZWxlY3RPbkZvY3VzOiBmYWxzZVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uRGlzYWJsZWRDaGFuZ2U6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogU2V0IHRvIGB0cnVlYCB0byBmb2N1cyB0aGlzIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHdoZW4gaXQgaXMgcmVuZGVyZWQuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVmYXVsdEZvY3VzOiBmYWxzZSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6ICdpbnB1dCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8taW5wdXQnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZXJzOiB7XG5cdFx0b25mb2N1czogJ2ZvY3VzZWQnLFxuXHRcdG9uaW5wdXQ6ICdpbnB1dCcsXG5cdFx0b25jbGVhcjogJ2NsZWFyJyxcblx0XHRvbmRyYWdzdGFydDogJ2RyYWdzdGFydCdcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChwbGF0Zm9ybS5pZSkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZXJzLm9ua2V5dXAgPSAnaWVrZXl1cCc7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGxhdGZvcm0ud2luZG93c1Bob25lKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlcnMub25rZXlkb3duID0gJ2lla2V5ZG93bic7XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMucGxhY2Vob2xkZXJDaGFuZ2VkKCk7XG5cdFx0XHQvLyBwcmV2ZW50IG92ZXJyaWRpbmcgYSBjdXN0b20gYXR0cmlidXRlIHdpdGggbnVsbFxuXHRcdFx0aWYgKHRoaXMudHlwZSkge1xuXHRcdFx0XHR0aGlzLnR5cGVDaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRkaXNwYXRjaGVyLm1ha2VCdWJibGUodGhpcywgJ2ZvY3VzJywgJ2JsdXInKTtcblxuXHRcdFx0Ly9Gb3JjZSBvbmNoYW5nZSBldmVudCB0byBiZSBidWJibGVkIGluc2lkZSBFbnlvIGZvciBJRThcblx0XHRcdGlmKHBsYXRmb3JtLmllID09IDgpe1xuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnb25jaGFuZ2UnLCBlbnlvLmJ1YmJsZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRpc2FibGVkQ2hhbmdlZCgpO1xuXHRcdFx0aWYgKHRoaXMuZGVmYXVsdEZvY3VzKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0eXBlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJywgdGhpcy50eXBlKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwbGFjZWhvbGRlckNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCB0aGlzLnBsYWNlaG9sZGVyKTtcblx0XHR0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBmaXJlcyBlbnlvLklucHV0I29uRGlzYWJsZWRDaGFuZ2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkaXNhYmxlZENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0aGlzLmRpc2FibGVkKTtcblx0XHR0aGlzLmJ1YmJsZSgnb25EaXNhYmxlZENoYW5nZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBub2RlID0gdGhpcy5oYXNOb2RlKCksXG5cdFx0XHRhdHRycyA9IHRoaXMuYXR0cmlidXRlcztcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0aWYgKG5vZGUudmFsdWUgIT09IHRoaXMudmFsdWUpIHtcblx0XHRcdFx0bm9kZS52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyB3ZSBtYW51YWxseSB1cGRhdGUgdGhlIGNhY2hlZCB2YWx1ZSBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgdGhlXG5cdFx0XHQvLyBhdHRyaWJ1dGUgaXMgcmVxdWVzdGVkIG9yIHRoZSBjb250cm9sIGlzIHJlLXJlbmRlcmVkIGl0IHdpbGxcblx0XHRcdC8vIGhhdmUgdGhlIGNvcnJlY3QgdmFsdWUgLSB0aGlzIGlzIGJlY2F1c2UgY2FsbGluZyBzZXRBdHRyaWJ1dGUoKVxuXHRcdFx0Ly8gaW4gc29tZSBjYXNlcyBkb2VzIG5vdCByZWNlaXZlIGFuIGFwcHJvcHJpYXRlIHJlc3BvbnNlIGZyb20gdGhlXG5cdFx0XHQvLyBicm93c2VyXG5cdFx0XHRhdHRycy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRoaXMudmFsdWUpO1xuXHRcdH1cblx0XHR0aGlzLmRldGVjdFRleHREaXJlY3Rpb25hbGl0eSgodGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSAwKSA/IHRoaXMudmFsdWUgOiB0aGlzLmdldCgncGxhY2Vob2xkZXInKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aWVrZXl1cDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdHZhciBpZSA9IHBsYXRmb3JtLmllLCBrYyA9IGUua2V5Q29kZTtcblx0XHQvLyBpbnB1dCBldmVudCBtaXNzaW5nIG9uIGllIDgsIGZhaWxzIHRvIGZpcmUgb24gYmFja3NwYWNlIGFuZCBkZWxldGUga2V5cyBpbiBpZSA5XG5cdFx0aWYgKGllIDw9IDggfHwgKGllID09IDkgJiYgKGtjID09IDggfHwga2MgPT0gNDYpKSkge1xuXHRcdFx0dGhpcy5idWJibGUoJ29uaW5wdXQnLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aWVrZXlkb3duOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0dmFyIHdwID0gcGxhdGZvcm0ud2luZG93c1Bob25lLCBrYyA9IGUua2V5Q29kZSwgZHQgPSBlLmRpc3BhdGNoVGFyZ2V0O1xuXHRcdC8vIG9uY2hhbmdlIGV2ZW50IGZhaWxzIHRvIGZpcmUgb24gZW50ZXIga2V5IGZvciBXaW5kb3dzIFBob25lIDgsIHNvIHdlIGZvcmNlIGJsdXJcblx0XHRpZiAod3AgPD0gOCAmJiBrYyA9PSAxMyAmJiB0aGlzLnRhZyA9PSAnaW5wdXQnICYmIGR0Lmhhc05vZGUoKSkge1xuXHRcdFx0ZHQubm9kZS5ibHVyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRWYWx1ZSgnJyk7XG5cdH0sXG5cblx0Ly8gbm90ZTogd2UgZGlzYWxsb3cgZHJhZ2dpbmcgb2YgYW4gaW5wdXQgdG8gYWxsb3cgdGV4dCBzZWxlY3Rpb24gb24gYWxsIHBsYXRmb3Jtc1xuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5oYXNGb2N1cygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZvY3VzZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5zZWxlY3RPbkZvY3VzKSB7XG5cdFx0XHRlbnlvLmFzeW5jTWV0aG9kKHRoaXMsICdzZWxlY3RDb250ZW50cycpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZWxlY3RDb250ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuID0gdGhpcy5oYXNOb2RlKCk7XG5cblx0XHRpZiAobiAmJiBuLnNldFNlbGVjdGlvblJhbmdlKSB7XG5cdFx0XHRuLnNldFNlbGVjdGlvblJhbmdlKDAsIG4udmFsdWUubGVuZ3RoKTtcblx0XHR9IGVsc2UgaWYgKG4gJiYgbi5jcmVhdGVUZXh0UmFuZ2UpIHtcblx0XHRcdHZhciByID0gbi5jcmVhdGVUZXh0UmFuZ2UoKTtcblx0XHRcdHIuZXhwYW5kKCd0ZXh0ZWRpdCcpO1xuXHRcdFx0ci5zZWxlY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5wdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsID0gdGhpcy5nZXROb2RlUHJvcGVydHkoJ3ZhbHVlJyk7XG5cdFx0dGhpcy5zZXRWYWx1ZSh2YWwpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0NvbnRyb2xcIjoxNixcIi4vZGlzcGF0Y2hlclwiOjU3LFwiLi9raW5kXCI6NjYsXCIuL3BsYXRmb3JtXCI6NzF9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuLi8uLi9lbnlvJyk7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi9raW5kJyk7XG52YXJcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4vQ29udHJvbCcpO1xuXG4vKipcbioge0BsaW5rIGVueW8uT3B0aW9ufSBpbXBsZW1lbnRzIHRoZSBbb3B0aW9uc117QGdsb3NzYXJ5IG9wdGlvbn0gaW4gYW5cbioge0BsaW5rIGVueW8uU2VsZWN0fSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfS5cbipcbiogQGNsYXNzIGVueW8uT3B0aW9uXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLk9wdGlvbi5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLk9wdGlvbicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IHtcblx0XHQvKipcblx0XHQqIFZhbHVlIG9mIHRoZSBbb3B0aW9uXXtAbGluayBlbnlvLk9wdGlvbn0uXG5cdFx0KiBcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQG1lbWJlcm9mIGVueW8uT3B0aW9uLnByb3RvdHlwZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dmFsdWU6ICcnLFxuXG5cdFx0LyoqXG5cdFx0KiBTZXQgdG8gYHRydWVgIGlmIHRoaXMgW29wdGlvbl17QGxpbmsgZW55by5PcHRpb259IGlzIHNlbGVjdGVkIChkZWZhdWx0IGlzIGBmYWxzZWApLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAbWVtYmVyb2YgZW55by5PcHRpb24ucHJvdG90eXBlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRzZWxlY3RlZDogZmFsc2Vcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRhZzogJ29wdGlvbicsXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMudmFsdWVDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkQ2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRoaXMudmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNlbGVjdGVkQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIHRoaXMuc2VsZWN0ZWQpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0NvbnRyb2xcIjoxNixcIi4va2luZFwiOjY2fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhclxuXHRDb250cm9sID0gcmVxdWlyZSgnLi9Db250cm9sJyk7XG5cbi8qKlxuKiBUaGUgZXh0ZW5kZWQge0BnbG9zc2FyeSBldmVudH0gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdGhhdCBpcyBwcm92aWRlZFxuKiB3aGVuIHRoZSBbb25TZXR1cEl0ZW1de0BsaW5rIGVueW8uUmVwZWF0ZXIjb25TZXR1cEl0ZW19IGV2ZW50IGlzIGZpcmVkLlxuKlxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLlJlcGVhdGVyflNldHVwSXRlbUV2ZW50XG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpdGVtJ3MgaW5kZXguXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBpdGVtIC0gVGhlIGl0ZW0gY29udHJvbCwgZm9yIGRlY29yYXRpb24uXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBlYWNoIGl0ZW0gaXMgY3JlYXRlZC5cbipcbiogQGV2ZW50IGVueW8uUmVwZWF0ZXIjb25TZXR1cEl0ZW1cbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtlbnlvLlJlcGVhdGVyflNldHVwSXRlbUV2ZW50fSBldmVudCAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGNvbnRhaW5pbmdcbipcdGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXHRcbi8qKlxuKiBTb21ldGltZXMgY2xpZW50IFtjb250cm9sc117QGxpbmsgZW55by5Db250cm9sfSBhcmUgaW50ZXJtZWRpYXRlZCB3aXRoIG51bGwtY29udHJvbHMuXG4qIFRoZXNlIG92ZXJyaWRlcyByZXJvdXRlIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0gZnJvbSBzdWNoIGNvbnRyb2xzIHRvIHRoZSBub21pbmFsXG4qIFtkZWxlZ2F0ZV17QGdsb3NzYXJ5IGRlbGVnYXRlfSwgYXMgd291bGQgaGFwcGVuIGluIHRoZSBhYnNlbmNlIG9mIGludGVybWVkaWF0aW9uLlxuKiBcbiogQGNsYXNzIGVueW8uT3duZXJQcm94eVxuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHByaXZhdGVcbiovXG52YXIgT3duZXJQcm94eSA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Pd25lclByb3h5LnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6IG51bGwsXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlY29yYXRlRXZlbnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGluRXZlbnROYW1lLCBpbkV2ZW50LCBpblNlbmRlcikge1xuXHRcdFx0aWYgKGluRXZlbnQpIHtcblx0XHRcdFx0Ly8gcHJlc2VydmUgYW4gZXhpc3RpbmcgaW5kZXggcHJvcGVydHkuXG5cdFx0XHRcdGlmICh1dGlscy5leGlzdHMoaW5FdmVudC5pbmRleCkpIHtcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbmVzdGVkIGluZGljZXMsIHN0b3JlIGFsbCBvZiB0aGVtIGluIGFuIGFycmF5XG5cdFx0XHRcdFx0Ly8gYnV0IGxlYXZlIHRoZSBpbm5lcm1vc3Qgb25lIGluIHRoZSBpbmRleCBwcm9wZXJ0eVxuXHRcdFx0XHRcdGluRXZlbnQuaW5kaWNlcyA9IGluRXZlbnQuaW5kaWNlcyB8fCBbaW5FdmVudC5pbmRleF07XG5cdFx0XHRcdFx0aW5FdmVudC5pbmRpY2VzLnB1c2godGhpcy5pbmRleCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZm9yIGEgc2luZ2xlIGxldmVsLCBqdXN0IGRlY29yYXRlIHRoZSBpbmRleCBwcm9wZXJ0eVxuXHRcdFx0XHRcdGluRXZlbnQuaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVwZGF0ZSBkZWxlZ2F0ZSBkdXJpbmcgYnViYmxpbmcgdG8gYWNjb3VudCBmb3IgcHJveHlcblx0XHRcdFx0Ly8gYnkgbW92aW5nIHRoZSBkZWxlZ2F0ZSB1cCB0byB0aGUgcmVwZWF0ZXIgbGV2ZWxcblx0XHRcdFx0aWYgKGluRXZlbnQuZGVsZWdhdGUgJiYgaW5FdmVudC5kZWxlZ2F0ZS5vd25lciA9PT0gdGhpcykge1xuXHRcdFx0XHRcdGluRXZlbnQuZGVsZWdhdGUgPSB0aGlzLm93bmVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KVxufSk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5SZXBlYXRlcn0gaXMgYSBzaW1wbGUgW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gZm9yIG1ha2luZyBsaXN0cyBvZiBpdGVtcy5cbipcbiogVGhlIFtjb21wb25lbnRzXXtAbGluayBlbnlvLkNvbXBvbmVudH0gb2YgYSByZXBlYXRlciBhcmUgY29waWVkIGZvciBlYWNoIGl0ZW0gY3JlYXRlZCxcbiogYW5kIGFyZSB3cmFwcGVkIGluIGEgY29udHJvbCB0aGF0IGtlZXBzIHRoZSBzdGF0ZSBvZiB0aGUgaXRlbSBpbmRleC5cbiogXG4qIGBgYGphdmFzY3JpcHRcbioge2tpbmQ6ICdSZXBlYXRlcicsIGNvdW50OiAyLCBvblNldHVwSXRlbTogJ3NldEltYWdlU291cmNlJywgY29tcG9uZW50czogW1xuKlx0e2tpbmQ6ICdJbWFnZSd9XG4qIF19XG4qIFxuKiBzZXRJbWFnZVNvdXJjZTogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcbipcdHZhciBpbmRleCA9IGluRXZlbnQuaW5kZXg7XG4qXHR2YXIgaXRlbSA9IGluRXZlbnQuaXRlbTtcbipcdGl0ZW0uJC5pbWFnZS5zZXRTcmModGhpcy5pbWFnZVNvdXJjZXNbaW5kZXhdKTtcbipcdHJldHVybiB0cnVlO1xuKiB9XG4qIGBgYFxuKiBcbiogQmUgc3VyZSB0byByZXR1cm4gYHRydWVgIGZyb20geW91ciBgb25TZXR1cEl0ZW1gIGhhbmRsZXIgdG8gYXZvaWQgaGF2aW5nIG90aGVyIFxuKiB7QGdsb3NzYXJ5IGV2ZW50fSBoYW5kbGVycyBmdXJ0aGVyIHVwIHRoZSB0cmVlIHRyeSB0byBtb2RpZnkgeW91ciBpdGVtIGNvbnRyb2wuXG4qIFxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtMaXN0c117QGxpbmtwbGFpbiAkZGV2LWd1aWRlL2J1aWxkaW5nLWFwcHMvbGF5b3V0L2xpc3RzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uUmVwZWF0ZXJcbiogQGV4dGVuZHMgZW55by5Db250cm9sXG4qIEB1aVxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uUmVwZWF0ZXIucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5SZXBlYXRlcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgZW55by5SZXBlYXRlci5wcm90b3R5cGUgKi8ge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCogVGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXBlYXRlZC5cblx0XHQqIFxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IDBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGNvdW50OiAwXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiB7XG5cdFx0b25TZXR1cEl0ZW06ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuY291bnRDaGFuZ2VkKCk7XG5cdFx0fTtcblx0fSksXG5cdFxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdENvbXBvbmVudHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5pdGVtQ29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cyB8fCB0aGlzLmtpbmRDb21wb25lbnRzO1xuXHRcdFx0dGhpcy5jb21wb25lbnRzID0gdGhpcy5raW5kQ29tcG9uZW50cyA9IG51bGw7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb3VudENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmJ1aWxkKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXRlbUF0SW5kZXg6IGZ1bmN0aW9uIChpZHgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sQXRJbmRleChpZHgpO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBSZW5kZXJzIHRoZSBbY29sbGVjdGlvbl17QGxpbmsgZW55by5Db2xsZWN0aW9ufSBvZiBpdGVtcy4gVGhpcyB3aWxsIGRlbGV0ZSBhbnlcblx0KiBleGlzdGluZyBpdGVtcyBhbmQgcmVjcmVhdGUgdGhlIFtyZXBlYXRlcl17QGxpbmsgZW55by5SZXBlYXRlcn0gaWYgY2FsbGVkIGFmdGVyXG5cdCogdGhlIHJlcGVhdGVyIGhhcyBiZWVuIHJlbmRlcmVkLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlXG5cdCogW2NvdW50XXtAbGluayBlbnlvLlJlcGVhdGVyI2NvdW50fSBwcm9wZXJ0eSBjaGFuZ2VzLiBUbyBzZXQgdGhlIGBjb3VudGAgcHJvcGVydHlcblx0KiBhbmQgZm9yY2UgYSByZS1yZW5kZXIsIHN1Y2ggYXMgd2hlbiBhIFtkYXRhIG1vZGVsXXtAbGluayBlbnlvLk1vZGVsfSBjaGFuZ2VzLFxuXHQqIHVzZSBgc2V0KCdjb3VudCcsIG5ld0NvdW50LCB0cnVlKWAsIHdoZXJlIHRoZSBsYXN0IHBhcmFtZXRlciBmb3JjZXMgdGhlIGNoYW5nZVxuXHQqIGhhbmRsZXIgdG8gYmUgY2FsbGVkLCBldmVuIGlmIHRoZSBgY291bnRgIHJlbWFpbnMgdGhlIHNhbWUuXG5cdCpcblx0KiBAZmlyZXMgZW55by5SZXBlYXRlciNvblNldHVwSXRlbVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YnVpbGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmRlc3Ryb3lDbGllbnRDb250cm9scygpO1xuXHRcdGZvciAodmFyIGk9MCwgYzsgaTx0aGlzLmNvdW50OyBpKyspIHtcblx0XHRcdGMgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudCh7a2luZDogT3duZXJQcm94eSwgaW5kZXg6IGl9KTtcblx0XHRcdC8vIGRvIHRoaXMgYXMgYSBzZWNvbmQgc3RlcCBzbyAnYycgaXMgdGhlIG93bmVyIG9mIHRoZSBjcmVhdGVkIGNvbXBvbmVudHNcblx0XHRcdGMuY3JlYXRlQ29tcG9uZW50cyh0aGlzLml0ZW1Db21wb25lbnRzKTtcblx0XHRcdC8vIGludm9rZSB1c2VyJ3Mgc2V0dXAgY29kZVxuXHRcdFx0dGhpcy5kb1NldHVwSXRlbSh7aW5kZXg6IGksIGl0ZW06IGN9KTtcblx0XHR9XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fSxcblx0LyoqXG5cdCogUmVuZGVycyBhIHNwZWNpZmljIGl0ZW0gaW4gdGhlIFtjb2xsZWN0aW9uXXtAbGluayBlbnlvLkNvbGxlY3Rpb259LiBUaGlzIGRvZXMgbm90XG5cdCogZGVzdHJveSB0aGUgaXRlbSwgYnV0IGp1c3QgY2FsbHMgdGhlIGBvblNldHVwSXRlbWAge0BnbG9zc2FyeSBldmVudH0gaGFuZGxlciBhZ2FpblxuXHQqIGZvciBpdCwgc28gYW55IHN0YXRlIHN0b3JlZCBpbiB0aGUgaXRlbSBpcyBwcmVzZXJ2ZWQuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaWR4IC0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIHRvIHJlbmRlci5cblx0KiBAZmlyZXMgZW55by5SZXBlYXRlciNvblNldHVwSXRlbVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cmVuZGVyUm93OiBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0dmFyIGMgPSB0aGlzLml0ZW1BdEluZGV4KGlkeCk7XG5cdFx0dGhpcy5kb1NldHVwSXRlbSh7aW5kZXg6IGlkeCwgaXRlbTogY30pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEEgbGVnYWN5IG1ldGhvZCB0aGF0IHNldHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXBlYXRlZCBhbmQgZWZmZWN0aXZlbHkgZm9yY2VzIGEgXG5cdCogcmVidWlsZCBvZiB0aGUgW3JlcGVhdGVyXXtAbGluayBlbnlvLlJlcGVhdGVyfSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgY291bnQgaGFzXG5cdCogY2hhbmdlZC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmVwZWF0ZWQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRDb3VudDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdFx0dGhpcy5zZXQoJ2NvdW50JywgY291bnQsIHtmb3JjZTogdHJ1ZX0pO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL0NvbnRyb2xcIjoxNixcIi4va2luZFwiOjY2LFwiLi91dGlsc1wiOjc1fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vLi4vZW55bycpO1xuXG5cblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi9raW5kJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcblx0ZmxvYXRpbmdMYXllciA9IHJlcXVpcmUoJy4uL2Zsb2F0aW5nTGF5ZXInKTtcbnZhclxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vQ29udHJvbCcpO1xuXG4vKipcbioge0BsaW5rIGVueW8uU2NyaW19IHByb3ZpZGVzIGFuIG92ZXJsYXkgdGhhdCB3aWxsIHByZXZlbnQgdGFwcyBmcm9tIHByb3BhZ2F0aW5nXG4qIHRvIHRoZSBjb250cm9scyB0aGF0IGl0IGNvdmVycy4gIEEgc2NyaW0gbWF5IGJlIFwiZmxvYXRpbmdcIiBvciBcIm5vbi1mbG9hdGluZ1wiLlxuKiBBIGZsb2F0aW5nIHNjcmltIHdpbGwgZmlsbCB0aGUgZW50aXJlIHZpZXdwb3J0LCB3aGlsZSBhIG5vbi1mbG9hdGluZyBzY3JpbSB3aWxsXG4qIGJlIGNvbnN0cmFpbmVkIGJ5IHRoZSBkaW1lbnNpb25zIG9mIGl0cyBjb250YWluZXIuXG4qXG4qIFRoZSBzY3JpbSBzaG91bGQgaGF2ZSBhIENTUyBjbGFzcyBvZiBgZW55by1zY3JpbS10cmFuc3BhcmVudGAsXG4qIGBlbnlvLXNjcmltLXRyYW5zbHVjZW50YCwgb3IgYW55IG90aGVyIGNsYXNzIHRoYXQgaGFzXG4qIGBwb2ludGVyLWV2ZW50czogYXV0b2AgaW4gaXRzIHN0eWxlIHByb3BlcnRpZXMuXG4qXG4qIFlvdSBtYXkgc3BlY2lmeSB0aGUgYHotaW5kZXhgIGF0IHdoaWNoIHlvdSB3YW50IHRoZSBzY3JpbSB0byBhcHBlYXIgYnkgY2FsbGluZ1xuKiBbc2hvd0F0WkluZGV4KClde0BsaW5rIGVueW8uU2NyaW0jc2hvd0F0WkluZGV4fS4gSWYgeW91IGRvIHNvLCB5b3UgbXVzdCBjYWxsXG4qIFtoaWRlQXRaSW5kZXgoKV17QGxpbmsgZW55by5TY3JpbSNoaWRlQXRaSW5kZXh9IHdpdGggdGhlIHNhbWUgdmFsdWUgdG8gaGlkZSB0aGVcbiogc2NyaW0uXG4qXG4qIEBjbGFzcyAgZW55by5TY3JpbVxuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHVpXG4qIEBwdWJsaWNcbiovXG52YXIgU2NyaW0gPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5TY3JpbS5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLlNjcmltJyxcblxuXHRraW5kOiBDb250cm9sLFxuXG5cdC8qKlxuXHQqIEN1cnJlbnQgdmlzaWJpbGl0eSBzdGF0ZVxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd2luZzogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8tc2NyaW0gZW55by1maXQnLFxuXG5cdC8qKlxuXHQqIElmIGB0cnVlYCwgdGhlIHNjcmltIGlzIHJlbmRlcmVkIGluIGEgZmxvYXRpbmcgbGF5ZXIgb3V0c2lkZSBvZiBvdGhlclxuXHQqIGNvbnRyb2xzLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZSBzY3JpbSB3aWxsIGJlIHNob3duXG5cdCogb24gdG9wIG9mIG90aGVyIGNvbnRyb2xzLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgIGZhbHNlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmbG9hdGluZzogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnpTdGFjayA9IFtdO1xuXHRcdGlmICh0aGlzLmZsb2F0aW5nKSB7XG5cdFx0XHR0aGlzLnNldFBhcmVudChmbG9hdGluZ0xheWVyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd2luZ0NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhdXRvIHJlbmRlciB3aGVuIHNob3duLlxuXHRcdGlmICh0aGlzLmZsb2F0aW5nICYmIHRoaXMuc2hvd2luZyAmJiAhdGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0fVxuXHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0Ly90aGlzLmFkZFJlbW92ZUNsYXNzKHRoaXMuc2hvd2luZ0NsYXNzTmFtZSwgdGhpcy5zaG93aW5nKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhZGRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHRpZiAodXRpbHMuaW5kZXhPZih6SW5kZXgsIHRoaXMuelN0YWNrKSA8IDApIHtcblx0XHRcdHRoaXMuelN0YWNrLnB1c2goekluZGV4KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVtb3ZlWkluZGV4OiBmdW5jdGlvbiAoY29udHJvbCkge1xuXHRcdHV0aWxzLnJlbW92ZShjb250cm9sLCB0aGlzLnpTdGFjayk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2hvd3Mgc2NyaW0gYXQgdGhlIHNwZWNpZmllZCB6LWluZGV4LiBOb3RlIHRoYXQgaWYgeW91IGNhbGxcblx0KiBgc2hvd0F0WkluZGV4KClgLCB5b3UgbXVzdCBjYWxsIFtoaWRlQXRaSW5kZXgoKV17QGxpbmsgZW55by5TY3JpbSNoaWRlQXRaSW5kZXh9XG5cdCogdG8gcHJvcGVybHkgdW53aW5kIHRoZSB6LWluZGV4IHN0YWNrLlxuXHQqXG5cdCogQHBhcmFtICB7TnVtYmVyfSB6SW5kZXggLSB6LWluZGV4IGZvciB0aGUgc2NyaW1cblx0KiBAcHVibGljXG5cdCovXG5cdHNob3dBdFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMuYWRkWkluZGV4KHpJbmRleCk7XG5cdFx0aWYgKHpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFpJbmRleCh6SW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLnNob3coKTtcblx0fSxcblxuXHQvKipcblx0KiBIaWRlcyBzY3JpbSBhdCB0aGUgc3BlY2lmaWVkIHotaW5kZXguXG5cdCpcblx0KiBAcGFyYW0gIHtOdW1iZXJ9IHpJbmRleCAtIHotaW5kZXggb2YgdGhlIHNjcmltXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRoaWRlQXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLnJlbW92ZVpJbmRleCh6SW5kZXgpO1xuXHRcdGlmICghdGhpcy56U3RhY2subGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHogPSB0aGlzLnpTdGFja1t0aGlzLnpTdGFjay5sZW5ndGgtMV07XG5cdFx0XHR0aGlzLnNldFpJbmRleCh6KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5hcHBseVN0eWxlKCd6LWluZGV4JywgekluZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtYWtlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG4vKipcbiogU2NyaW0gc2luZ2xldG9uIGV4cG9zaW5nIGEgc3Vic2V0IG9mIHRoZSBTY3JpbSBBUEk7XG4qIGl0IGlzIHJlcGxhY2VkIHdpdGggYSBwcm9wZXIge0BsaW5rIGVueW8uU2NyaW19IGluc3RhbmNlLlxuKlxuKiBAY2xhc3MgIGVueW8uc2NyaW1TaW5nbGV0b25cbiogQHByaXZhdGVcbiovXG52YXIgU2NyaW1TaW5nbGV0b24gPSBraW5kKFxuXHQvKiogQGxlbmRzICBlbnlvLnNjcmltU2luZ2xldG9uLnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogbnVsbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0dGhpcy5pbnN0YW5jZU5hbWUgPSBuYW1lO1xuXHRcdHRoaXMucHJvcHMgPSBwcm9wcyB8fCB7fTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtYWtlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSBuZXcgU2NyaW0odGhpcy5wcm9wcyk7XG5cdFx0cmV0dXJuIHM7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd0F0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dmFyIHMgPSB0aGlzLm1ha2UoKTtcblx0XHRzLnNob3dBdFpJbmRleCh6SW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEluIGNhc2Ugc29tZWJvZHkgZG9lcyB0aGlzIG91dCBvZiBvcmRlclxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGlkZUF0WkluZGV4OiB1dGlscy5ub3AsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5tYWtlKCk7XG5cdFx0cy5zaG93KCk7XG5cdH1cbn0pO1xuXG5TY3JpbS5zY3JpbSA9IG5ldyBTY3JpbVNpbmdsZXRvbih7ZmxvYXRpbmc6IHRydWUsIGNsYXNzZXM6ICdlbnlvLXNjcmltLXRyYW5zbHVjZW50J30pO1xuU2NyaW0uc2NyaW1UcmFuc3BhcmVudCA9IG5ldyBTY3JpbVNpbmdsZXRvbih7ZmxvYXRpbmc6IHRydWUsIGNsYXNzZXM6ICdlbnlvLXNjcmltLXRyYW5zcGFyZW50J30pO1xuU2NyaW0uU2NyaW1TaW5nbGV0b24gPSBTY3JpbVNpbmdsZXRvbjtcbn0se1wiLi4vLi4vLi4vZW55b1wiOjEsXCIuLi9Db250cm9sXCI6MTYsXCIuLi9mbG9hdGluZ0xheWVyXCI6NjAsXCIuLi9raW5kXCI6NjYsXCIuLi91dGlsc1wiOjc1fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHRkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyk7XG5cbnZhclxuXHRDb250cm9sID0gcmVxdWlyZSgnLi9Db250cm9sJyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5TY3JvbGxTdHJhdGVneX0gaXMgYSBoZWxwZXIgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB0aGF0IGltcGxlbWVudHMgYSBkZWZhdWx0IFxuKiBzY3JvbGxpbmcgc3RyYXRlZ3kgZm9yIGFuIHtAbGluayBlbnlvLlNjcm9sbGVyfS5cbiogXG4qIGBlbnlvLlNjcm9sbFN0cmF0ZWd5YCBpcyBub3QgdHlwaWNhbGx5IGNyZWF0ZWQgaW4gYXBwbGljYXRpb24gY29kZS4gSW5zdGVhZCwgaXQgaXMgc3BlY2lmaWVkIFxuKiBhcyB0aGUgdmFsdWUgb2YgdGhlIFtzdHJhdGVneUtpbmRde0BsaW5rIGVueW8uU2Nyb2xsZXIjc3RyYXRlZ3lLaW5kfSBwcm9wZXJ0eSBvZiBhblxuKiBgZW55by5TY3JvbGxlcmAgb3Ige0BsaW5rIGVueW8uTGlzdH0sIG9yIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayBpbXBsaWNpdGx5LlxuKlxuKiBAY2xhc3MgZW55by5TY3JvbGxTdHJhdGVneVxuKiBAcHJvdGVjdGVkXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlICovIHtcblxuXHRuYW1lOiAnZW55by5TY3JvbGxTdHJhdGVneScsXG5cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6IG51bGwsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOiBcblx0XHQvKiogQGxlbmRzIGVueW8uU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlICovIHtcblx0XHRcblx0XHQvKipcblx0XHQqIFNwZWNpZmllcyBob3cgdG8gdmVydGljYWxseSBzY3JvbGwuICBBY2NlcHRhYmxlIHZhbHVlcyBhcmUgYCdzY3JvbGwnYCwgYCdhdXRvJ2AsXG5cdFx0KiBgJ2hpZGRlbidgLCBhbmQgYCdkZWZhdWx0J2AuIFRoZSBwcmVjaXNlIGVmZmVjdCBvZiB0aGUgc2V0dGluZyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuXHRcdCogc2Nyb2xsIHN0cmF0ZWd5LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJ2RlZmF1bHQnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR2ZXJ0aWNhbDogJ2RlZmF1bHQnLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCogU3BlY2lmaWVzIGhvdyB0byBob3Jpem9udGFsbHkgc2Nyb2xsLiAgQWNjZXB0YWJsZSB2YWx1ZXMgYXJlIGAnc2Nyb2xsJ2AsIGAnYXV0bydgLFxuXHRcdCogYCdoaWRkZW4nYCwgYW5kIGAnZGVmYXVsdCdgLiBUaGUgcHJlY2lzZSBlZmZlY3Qgb2YgdGhlIHNldHRpbmcgaXMgZGV0ZXJtaW5lZCBieSB0aGVcblx0XHQqIHNjcm9sbCBzdHJhdGVneS5cblx0XHQqIFxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdkZWZhdWx0J1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0aG9yaXpvbnRhbDogJ2RlZmF1bHQnLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCogVGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2Nyb2xsTGVmdDogMCxcblx0XHRcblx0XHQvKipcblx0XHQqIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG5cdFx0KiBcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCAwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRzY3JvbGxUb3A6IDAsXG5cdFx0XG5cdFx0LyoqXG5cdFx0KiBNYXhpbXVtIGhlaWdodCBvZiB0aGUgc2Nyb2xsIGNvbnRlbnQuXG5cdFx0KiBcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCBudWxsXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRtYXhIZWlnaHQ6IG51bGwsXG5cdFx0XG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciBtb3VzZSB3aGVlbCBtYXkgYmUgdXNlZCB0byBtb3ZlIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHVzZU1vdXNlV2hlZWw6IHRydWVcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uU2Nyb2xsU3RhcnQ6ICcnLFxuXHRcdG9uU2Nyb2xsU3RvcDogJydcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVyczoge1xuXHRcdG9uZHJhZ3N0YXJ0OiAnZHJhZ3N0YXJ0Jyxcblx0XHRvbmRyYWdmaW5pc2g6ICdkcmFnZmluaXNoJyxcblx0XHRvbmRvd246ICdkb3duJyxcblx0XHRvbm1vdmU6ICdtb3ZlJyxcblx0XHRvbm1vdXNld2hlZWw6ICdtb3VzZXdoZWVsJyxcblx0XHRvbnNjcm9sbDogJ2RvbVNjcm9sbCdcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5ob3Jpem9udGFsQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy52ZXJ0aWNhbENoYW5nZWQoKTtcblx0XHRcdHRoaXMubWF4SGVpZ2h0Q2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGRpc3BhdGNoZXIubWFrZUJ1YmJsZSh0aGlzLmNvbnRhaW5lciwgJ3Njcm9sbCcpO1xuXHRcdFx0dGhpcy5zY3JvbGxOb2RlID0gdGhpcy5jYWxjU2Nyb2xsTm9kZSgpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0ZWFyZG93blJlbmRlcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuc2Nyb2xsTm9kZSA9IG51bGw7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY1Njcm9sbE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuaGFzTm9kZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhvcml6b250YWxDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jb250YWluZXIuYXBwbHlTdHlsZSgnb3ZlcmZsb3cteCcsIHRoaXMuaG9yaXpvbnRhbCA9PSAnZGVmYXVsdCcgPyAnYXV0bycgOiB0aGlzLmhvcml6b250YWwpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZlcnRpY2FsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGx5U3R5bGUoJ292ZXJmbG93LXknLCB0aGlzLnZlcnRpY2FsID09ICdkZWZhdWx0JyA/ICdhdXRvJyA6IHRoaXMudmVydGljYWwpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1heEhlaWdodENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBseVN0eWxlKCdtYXgtaGVpZ2h0JywgdGhpcy5tYXhIZWlnaHQpO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBgeGAgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIGB5YCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAodGhpcy5zY3JvbGxOb2RlKSB7XG5cdFx0XHR0aGlzLnNldFNjcm9sbExlZnQoeCk7XG5cdFx0XHR0aGlzLnNldFNjcm9sbFRvcCh5KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqIFxuXHQqIEVuc3VyZXMgdGhhdCB0aGUgZ2l2ZW4gbm9kZSBpcyB2aXNpYmxlIGluIHRoZSBbc2Nyb2xsZXInc117QGxpbmsgZW55by5TY3JvbGxlcn0gdmlld3BvcnQuXG5cdCpcblx0KiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBtYWtlIHZpc2libGUgaW4gdGhlIFtzY3JvbGxlcidzXXtAbGluayBlbnlvLlNjcm9sbGVyfVxuXHQqXHR2aWV3cG9ydC5cblx0KiBAcGFyYW0ge0Jvb2xlYW59IGFsaWduV2l0aFRvcCAtIElmIGB0cnVlYCwgdGhlIG5vZGUgaXMgYWxpZ25lZCB3aXRoIHRoZSB0b3Agb2YgdGhlXG5cdCpcdHNjcm9sbGVyLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsVG9Ob2RlOiBmdW5jdGlvbiAobm9kZSwgYWxpZ25XaXRoVG9wKSB7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsTm9kZSkge1xuXHRcdFx0dmFyIHNiID0gdGhpcy5nZXRTY3JvbGxCb3VuZHMoKTtcblx0XHRcdHZhciBuID0gbm9kZTtcblx0XHRcdHZhciBiID0ge2hlaWdodDogbi5vZmZzZXRIZWlnaHQsIHdpZHRoOiBuLm9mZnNldFdpZHRoLCB0b3A6IDAsIGxlZnQ6IDB9O1xuXHRcdFx0d2hpbGUgKG4gJiYgbi5wYXJlbnROb2RlICYmIG4uaWQgIT0gdGhpcy5zY3JvbGxOb2RlLmlkKSB7XG5cdFx0XHRcdGIudG9wICs9IG4ub2Zmc2V0VG9wO1xuXHRcdFx0XHRiLmxlZnQgKz0gbi5vZmZzZXRMZWZ0O1xuXHRcdFx0XHRuID0gbi5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsZWQgdG8gYWxpZ24gd2l0aCB0aGUgdG9wIG9mIHRoZSBzY3JvbGwgYXJlYS5cblx0XHRcdHRoaXMuc2V0U2Nyb2xsVG9wKE1hdGgubWluKHNiLm1heFRvcCwgYWxpZ25XaXRoVG9wID09PSBmYWxzZSA/IGIudG9wIC0gc2IuY2xpZW50SGVpZ2h0ICsgYi5oZWlnaHQgOiBiLnRvcCkpO1xuXHRcdFx0dGhpcy5zZXRTY3JvbGxMZWZ0KE1hdGgubWluKHNiLm1heExlZnQsIGFsaWduV2l0aFRvcCA9PT0gZmFsc2UgPyBiLmxlZnQgLSBzYi5jbGllbnRXaWR0aCArIGIud2lkdGggOiBiLmxlZnQpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU2Nyb2xscyB0aGUgZ2l2ZW4gW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0gaW50byB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLkNvbnRyb2x9IGN0bCAtIFRoZSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSB0byBtYWtlIHZpc2libGUgaW4gdGhlXG5cdCpcdFtzY3JvbGxlcidzXXtAbGluayBlbnlvLlNjcm9sbGVyfSB2aWV3cG9ydC5cblx0KiBAcGFyYW0ge0Jvb2xlYW59IGFsaWduV2l0aFRvcCAtIElmIGB0cnVlYCwgdGhlIG5vZGUgaXMgYWxpZ25lZCB3aXRoIHRoZSB0b3Agb2YgdGhlXG5cdCpcdHNjcm9sbGVyLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uIChjdGwsIGFsaWduV2l0aFRvcCkge1xuXHRcdGlmIChjdGwuaGFzTm9kZSgpKSB7XG5cdFx0XHRjdGwubm9kZS5zY3JvbGxJbnRvVmlldyhhbGlnbldpdGhUb3ApO1xuXHRcdH1cblx0fSxcblx0aXNJblZpZXc6IGZ1bmN0aW9uKGluTm9kZSkge1xuXHRcdHZhciBzYiA9IHRoaXMuZ2V0U2Nyb2xsQm91bmRzKCk7XG5cdFx0dmFyIG90ID0gaW5Ob2RlLm9mZnNldFRvcDtcblx0XHR2YXIgb2ggPSBpbk5vZGUub2Zmc2V0SGVpZ2h0O1xuXHRcdHZhciBvbCA9IGluTm9kZS5vZmZzZXRMZWZ0O1xuXHRcdHZhciBvdyA9IGluTm9kZS5vZmZzZXRXaWR0aDtcblx0XHRyZXR1cm4gKG90ID49IHNiLnRvcCAmJiBvdCArIG9oIDw9IHNiLnRvcCArIHNiLmNsaWVudEhlaWdodCkgJiYgKG9sID49IHNiLmxlZnQgJiYgb2wgKyBvdyA8PSBzYi5sZWZ0ICsgc2IuY2xpZW50V2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNldHMgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSB0b3AgLSBUaGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNjcm9sbFRvcDogZnVuY3Rpb24gKHRvcCkge1xuXHRcdHRoaXMuc2Nyb2xsVG9wID0gdG9wO1xuXHRcdGlmICh0aGlzLnNjcm9sbE5vZGUpIHtcblx0XHRcdHRoaXMuc2Nyb2xsTm9kZS5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gbGVmdCAtIFRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbiAobGVmdCkge1xuXHRcdHRoaXMuc2Nyb2xsTGVmdCA9IGxlZnQ7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsTm9kZSkge1xuXHRcdFx0dGhpcy5zY3JvbGxOb2RlLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbE5vZGUgPyB0aGlzLnNjcm9sbE5vZGUuc2Nyb2xsTGVmdCA6IHRoaXMuc2Nyb2xsTGVmdDtcblx0fSxcblxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cblx0KlxuXHQqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFNjcm9sbFRvcDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbE5vZGUgPyB0aGlzLnNjcm9sbE5vZGUuc2Nyb2xsVG9wIDogdGhpcy5zY3JvbGxUb3A7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2dldFNjcm9sbEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5nZXRTY3JvbGxTaXplKCksIGNuID0gdGhpcy5jb250YWluZXIuaGFzTm9kZSgpO1xuXHRcdHZhciBiID0ge1xuXHRcdFx0bGVmdDogdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG5cdFx0XHR0b3A6IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG5cdFx0XHRjbGllbnRIZWlnaHQ6IGNuID8gY24uY2xpZW50SGVpZ2h0IDogMCxcblx0XHRcdGNsaWVudFdpZHRoOiBjbiA/IGNuLmNsaWVudFdpZHRoIDogMCxcblx0XHRcdGhlaWdodDogcy5oZWlnaHQsXG5cdFx0XHR3aWR0aDogcy53aWR0aFxuXHRcdH07XG5cdFx0Yi5tYXhMZWZ0ID0gTWF0aC5tYXgoMCwgYi53aWR0aCAtIGIuY2xpZW50V2lkdGgpO1xuXHRcdGIubWF4VG9wID0gTWF0aC5tYXgoMCwgYi5oZWlnaHQgLSBiLmNsaWVudEhlaWdodCk7XG5cdFx0cmV0dXJuIGI7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0U2Nyb2xsU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuID0gdGhpcy5zY3JvbGxOb2RlO1xuXHRcdHJldHVybiB7d2lkdGg6IG4gPyBuLnNjcm9sbFdpZHRoIDogMCwgaGVpZ2h0OiBuID8gbi5zY3JvbGxIZWlnaHQgOiAwfTtcblx0fSxcblxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIHNjcm9sbCBib3VuZGFyaWVzIG9mIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LlxuXHQqIFxuXHQqIEByZXR1cm5zIHtlbnlvLlNjcm9sbGVyfkJvdW5kYXJ5T2JqZWN0fSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBkZXNjcmliaW5nIHRoZSBcblx0Klx0c2Nyb2xsIGJvdW5kYXJpZXMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTY3JvbGxCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U2Nyb2xsQm91bmRzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY1N0YXJ0SW5mbzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzYiA9IHRoaXMuZ2V0U2Nyb2xsQm91bmRzKCk7XG5cdFx0dmFyIHkgPSB0aGlzLmdldFNjcm9sbFRvcCgpLCB4ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCk7XG5cdFx0dGhpcy5jYW5WZXJ0aWNhbCA9IHNiLm1heFRvcCA+IDAgJiYgdGhpcy52ZXJ0aWNhbCAhPSAnaGlkZGVuJztcblx0XHR0aGlzLmNhbkhvcml6b250YWwgPSBzYi5tYXhMZWZ0ID4gMCAmJiB0aGlzLmhvcml6b250YWwgIT0gJ2hpZGRlbic7XG5cdFx0dGhpcy5zdGFydEVkZ2VzID0ge1xuXHRcdFx0dG9wOiB5ID09PSAwLFxuXHRcdFx0Ym90dG9tOiB5ID09PSBzYi5tYXhUb3AsXG5cdFx0XHRsZWZ0OiB4ID09PSAwLFxuXHRcdFx0cmlnaHQ6IHggPT09IHNiLm1heExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIE5PVEU6IGRvd24sIG1vdmUsIGFuZCBkcmFnIGhhbmRsZXJzIGFyZSBuZWVkZWQgb25seSBmb3IgbmF0aXZlIHRvdWNoIHNjcm9sbGVyc1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNob3VsZERyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHJlcXVlc3RWID0gZS52ZXJ0aWNhbDtcblx0XHRyZXR1cm4gKHJlcXVlc3RWICYmIHRoaXMuY2FuVmVydGljYWwgIHx8ICFyZXF1ZXN0ViAmJiB0aGlzLmNhbkhvcml6b250YWwpIC8qJiYgIXRoaXMuaXNPb2JWZXJ0aWNhbFNjcm9sbChldmVudCkqLztcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnc3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHR0aGlzLmRyYWdnaW5nID0gdGhpcy5zaG91bGREcmFnKGUpO1xuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcmV2ZW50RHJhZ1Byb3BhZ2F0aW9uO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnZmluaXNoOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdGUucHJldmVudFRhcCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBBdm9pZCBhbGxvd2luZyBzY3JvbGwgd2hlbiBzdGFydGluZyBhdCBhIHZlcnRpY2FsIGJvdW5kYXJ5IHRvIHByZXZlbnQgaU9TIGZyb20gd2luZG93IFxuXHQqIHNjcm9sbGluZy5cblx0KiBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkb3duOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0aWYgKHRoaXMuaXNTY3JvbGxpbmcoKSkge1xuXHRcdFx0ZS5wcmV2ZW50VGFwKCk7XG5cdFx0fVxuXHRcdHRoaXMuY2FsY1N0YXJ0SW5mbygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE5PVEU6IE1vYmlsZSBuYXRpdmUgW3Njcm9sbGVyc117QGxpbmsgZW55by5TY3JvbGxlcn0gbmVlZCBgdG91Y2htb3ZlYC4gSW5kaWNhdGUgdGhpcyBieSBcblx0KiBzZXR0aW5nIHRoZSBgcmVxdWlyZVRvdWNobW92ZWAgcHJvcGVydHkgdG8gYHRydWVgLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1vdmU6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRpZiAoZS53aGljaCAmJiAodGhpcy5jYW5WZXJ0aWNhbCAmJiBlLnZlcnRpY2FsIHx8IHRoaXMuY2FuSG9yaXpvbnRhbCAmJiBlLmhvcml6b250YWwpKSB7XG5cdFx0XHRlLmRpc2FibGVQcmV2ZW50aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1vdXNld2hlZWw6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHQvLyogV2UgZGlzYWJsZSBtb3VzZSB3aGVlbCBzY3JvbGxpbmcgYnkgcHJldmVudGluZyB0aGUgZGVmYXVsdFxuXHRcdGlmICghdGhpcy51c2VNb3VzZVdoZWVsKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvbVNjcm9sbDogZnVuY3Rpb24oc2VuZGVyLCBlKSB7XG5cdFx0aWYgKCF0aGlzLl9zY3JvbGxpbmcpIHtcblx0XHRcdHRoaXMuZG9TY3JvbGxTdGFydCgpO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xuXHRcdHRoaXMuc3RhcnRKb2IoJ3N0b3BTY3JvbGxpbmcnLCBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3Njcm9sbGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kb1Njcm9sbFN0b3AoKTtcblx0XHR9LCAxMDApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNTY3JvbGxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY3JvbGxpbmc7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vQ29udHJvbFwiOjE2LFwiLi9kaXNwYXRjaGVyXCI6NTcsXCIuL2tpbmRcIjo2Nn1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uLy4uL2VueW8nKTtcblxuXG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4va2luZCcpO1xuXG52YXJcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4uL0NvbnRyb2wnKSxcblx0RG9tID0gcmVxdWlyZSgnLi4vZG9tJyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5TY3JvbGxUaHVtYn0gaXMgYSBoZWxwZXIgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB1c2VkIGJ5IFxuKiB7QGxpbmsgZW55by5Ub3VjaFNjcm9sbFN0cmF0ZWd5fSBhbmQge0BsaW5rIGVueW8uVHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3l9IHRvXG4qIGRpc3BsYXkgYSBzbWFsbCB2aXN1YWwgc2Nyb2xsIGluZGljYXRvci5cbiogXG4qIGBlbnlvLlNjcm9sbFRodW1iYCBpcyBub3QgdHlwaWNhbGx5IGNyZWF0ZWQgaW4gYXBwbGljYXRpb24gY29kZS5cbipcbiogQGNsYXNzIGVueW8uU2Nyb2xsVGh1bWJcbiogQHByb3RlY3RlZFxuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlNjcm9sbFRodW1iLnByb3RvdHlwZSAqLyB7XG5cdFxuXHRuYW1lOiAnZW55by5TY3JvbGxUaHVtYicsXG5cdFxuXHRraW5kOiBDb250cm9sLFxuXG5cdC8qKlxuXHQqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc2Nyb2xsIGluZGljYXRvciBiYXI7ICd2JyBmb3IgdmVydGljYWwgb3IgJ2gnIGZvciBob3Jpem9udGFsLlxuXHQqIFxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ3YnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRheGlzOiAndicsXG5cblx0LyoqXG5cdCogTWluaW11bSBzaXplIG9mIHRoZSBpbmRpY2F0b3IuXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bWluU2l6ZTogNCxcblxuXHQvKipcblx0KiBTaXplIG9mIHRoZSBpbmRpY2F0b3IncyBjb3JuZXJzLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvcm5lclNpemU6IDYsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8tdGh1bWInLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdiA9IHRoaXMuYXhpcyA9PSAndic7XG5cdFx0XHR0aGlzLmRpbWVuc2lvbiA9IHYgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cdFx0XHR0aGlzLm9mZnNldCA9IHYgPyAndG9wJyA6ICdsZWZ0Jztcblx0XHRcdHRoaXMudHJhbnNsYXRpb24gPSB2ID8gJ3RyYW5zbGF0ZVknIDogJ3RyYW5zbGF0ZVgnO1xuXHRcdFx0dGhpcy5wb3NpdGlvbk1ldGhvZCA9IHYgPyAnZ2V0U2Nyb2xsVG9wJyA6ICdnZXRTY3JvbGxMZWZ0Jztcblx0XHRcdHRoaXMuc2l6ZURpbWVuc2lvbiA9IHYgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG5cdFx0XHR0aGlzLmFkZENsYXNzKCdlbnlvLScgKyB0aGlzLmF4aXMgKyAndGh1bWInKTtcblx0XHRcdHRoaXMudHJhbnNmb3JtID0gRG9tLmNhblRyYW5zZm9ybSgpO1xuXHRcdFx0aWYgKERvbS5jYW5BY2NlbGVyYXRlKCkpIHtcblx0XHRcdFx0RG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMsICd0cmFuc2xhdGVaJywgMCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqIFxuXHQqIFN5bmNzIHRoZSBzY3JvbGwgaW5kaWNhdG9yIGJhciB0byB0aGUgW3Njcm9sbGVyXXtAbGluayBlbnlvLlNjcm9sbGVyfSBzaXplIGFuZCBwb3NpdGlvbixcblx0KiBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBwYXNzZWQtaW4gc2Nyb2xsIHN0cmF0ZWd5LlxuXHQqXG5cdCogQHBhcmFtIHtlbnlvLlNjcm9sbFN0cmF0ZWd5fSBzdHJhdGVneSAtIFRoZSBzY3JvbGwgc3RyYXRlZ3kgdG8gYmUgc3luY2VkIHdpdGguXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzeW5jOiBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcblx0XHR0aGlzLnNjcm9sbEJvdW5kcyA9IHN0cmF0ZWd5Ll9nZXRTY3JvbGxCb3VuZHMoKTtcblx0XHR0aGlzLnVwZGF0ZShzdHJhdGVneSk7XG5cdH0sXG5cblx0LyoqXG5cdCogVXBkYXRlcyB0aGUgc2Nyb2xsIGluZGljYXRvciBiYXIgYmFzZWQgb24gdGhlIHNjcm9sbCBib3VuZHMgb2YgdGhlIHN0cmF0ZWd5LCB0aGUgYXZhaWxhYmxlXG5cdCogc2Nyb2xsIGFyZWEsIGFuZCB3aGV0aGVyIHRoZXJlIGlzIG92ZXJzY3JvbGxpbmcuIElmIHRoZSBzY3JvbGwgaW5kaWNhdG9yIGJhciBpcyBub3Rcblx0KiBuZWVkZWQsIGl0IHdpbGwgYmUgbm90IGJlIGRpc3BsYXllZC5cblx0KiBcblx0KiBAcGFyYW0ge2VueW8uU2Nyb2xsU3RyYXRlZ3l9IHN0cmF0ZWd5IC0gVGhlIHNjcm9sbCBzdHJhdGVneSB0byB1cGRhdGUgZnJvbS5cblx0KiBAcHVibGljXG5cdCovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG5cdFx0aWYgKHRoaXMuc2hvd2luZykge1xuXHRcdFx0dmFyIGQgPSB0aGlzLmRpbWVuc2lvbiwgbyA9IHRoaXMub2Zmc2V0O1xuXHRcdFx0dmFyIGJkID0gdGhpcy5zY3JvbGxCb3VuZHNbdGhpcy5zaXplRGltZW5zaW9uXSwgc2JkID0gdGhpcy5zY3JvbGxCb3VuZHNbZF07XG5cdFx0XHR2YXIgb3ZlcnMgPSAwLCBvdmVycCA9IDAsIG92ZXIgPSAwO1xuXHRcdFx0aWYgKGJkID49IHNiZCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0cmF0ZWd5LmlzT3ZlcnNjcm9sbGluZygpKSB7XG5cdFx0XHRcdG92ZXIgPSBzdHJhdGVneS5nZXRPdmVyU2Nyb2xsQm91bmRzKClbJ292ZXInICsgb107XG5cdFx0XHRcdG92ZXJzID0gTWF0aC5hYnMob3Zlcik7XG5cdFx0XHRcdG92ZXJwID0gTWF0aC5tYXgob3ZlciwgMCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2JvID0gc3RyYXRlZ3lbdGhpcy5wb3NpdGlvbk1ldGhvZF0oKSAtIG92ZXI7XG5cdFx0XHQvLyBjYWxjIHNpemUgJiBwb3NpdGlvblxuXHRcdFx0dmFyIGJkYyA9IGJkIC0gdGhpcy5jb3JuZXJTaXplO1xuXHRcdFx0dmFyIHMgPSBNYXRoLmZsb29yKChiZCAqIGJkIC8gc2JkKSAtIG92ZXJzKTtcblx0XHRcdHMgPSBNYXRoLm1heCh0aGlzLm1pblNpemUsIHMpO1xuXHRcdFx0dmFyIHAgPSBNYXRoLmZsb29yKChiZGMgKiBzYm8gLyBzYmQpICsgb3ZlcnApO1xuXHRcdFx0cCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGJkYyAtIHRoaXMubWluU2l6ZSwgcCkpO1xuXHRcdFx0Ly8gYXBwbHkgdGh1bWIgc3R5bGluZ1xuXHRcdFx0dGhpcy5uZWVkZWQgPSBzIDwgYmQ7XG5cdFx0XHRpZiAodGhpcy5uZWVkZWQgJiYgdGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3BvcyAhPT0gcCkge1xuXHRcdFx0XHRcdHRoaXMuX3BvcyA9IHA7XG5cdFx0XHRcdFx0aWYoIXRoaXMudHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHQvL2FkanVzdCB0b3AvbGVmdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRyYW5zbGF0aW9uc1xuXHRcdFx0XHRcdFx0aWYodGhpcy5heGlzPT0ndicpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRCb3VuZHMoe3RvcDpwICsgJ3B4J30pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRCb3VuZHMoe2xlZnQ6cCArICdweCd9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0RG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMsIHRoaXMudHJhbnNsYXRpb24sIHAgKyAncHgnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3NpemUgIT09IHMpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplID0gcztcblx0XHRcdFx0XHR0aGlzLmFwcGx5U3R5bGUoZCwgcyArICdweCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogV2UgaW1wbGVtZW50IGBzZXRTaG93aW5nKClgIGFuZCBjYW5jZWwgdGhlIFtkZWxheUhpZGUoKV17QGxpbmsgZW55by5TY3JvbGxUaHVtYiNkZWxheUhpZGV9IFxuXHQqIGJlY2F1c2UgW3Nob3dpbmdde0BsaW5rIGVueW8uQ29udHJvbCNzaG93aW5nfSBpcyBub3QgY2hhbmdlZCB3aGlsZSB3ZSBleGVjdXRlXG5cdCogYGRlbGF5SGlkZSgpYC5cblx0KlxuXHQqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd2luZyAtIElmIGB0cnVlYCwgZGlzcGxheXMgdGhlIHtAbGluayBlbnlvLlNjcm9sbFRodW1ifSBpZiBhcHByb3ByaWF0ZTtcblx0Klx0b3RoZXJ3aXNlLCBoaWRlcyB0aGUgU2Nyb2xsVGh1bWIuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRTaG93aW5nOiBmdW5jdGlvbiAoc2hvd2luZykge1xuXHRcdGlmIChzaG93aW5nICYmIHNob3dpbmcgIT0gdGhpcy5zaG93aW5nKSB7XG5cdFx0XHRpZiAodGhpcy5zY3JvbGxCb3VuZHNbdGhpcy5zaXplRGltZW5zaW9uXSA+PSB0aGlzLnNjcm9sbEJvdW5kc1t0aGlzLmRpbWVuc2lvbl0pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdHRoaXMuY2FuY2VsRGVsYXlIaWRlKCk7XG5cdFx0fVxuXHRcdGlmIChzaG93aW5nICE9IHRoaXMuc2hvd2luZykge1xuXHRcdFx0dmFyIGxhc3QgPSB0aGlzLnNob3dpbmc7XG5cdFx0XHR0aGlzLnNob3dpbmcgPSBzaG93aW5nO1xuXHRcdFx0dGhpcy5zaG93aW5nQ2hhbmdlZChsYXN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogRGVsYXlzIGF1dG9tYXRpYyBoaWRpbmcgb2YgdGhlIHtAbGluayBlbnlvLlNjcm9sbFRodW1ifS5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGhpZGluZyBvZiB0aGVcblx0Klx0e0BsaW5rIGVueW8uU2Nyb2xsVGh1bWJ9LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVsYXlIaWRlOiBmdW5jdGlvbiAoZGVsYXkpIHtcblx0XHRpZiAodGhpcy5zaG93aW5nKSB7XG5cdFx0XHR0aGlzLnN0YXJ0Sm9iKCdoaWRlJywgdGhpcy5oaWRlLCBkZWxheSB8fCAwKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FuY2VscyBhbnkgcGVuZGluZyBbZGVsYXlIaWRlKClde0BsaW5rIGVueW8uU2Nyb2xsVGh1bWIjZGVsYXlIaWRlfSBqb2JzLlxuXHQqIFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y2FuY2VsRGVsYXlIaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zdG9wSm9iKCdoaWRlJyk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvXCI6MSxcIi4uL0NvbnRyb2xcIjoxNixcIi4uL2RvbVwiOjU4LFwiLi4va2luZFwiOjY2fV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdGRvbSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2RvbScpLFxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ29udHJvbCcpXG5cdExheW91dCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0xheW91dCcpO1xuXG52YXIgZGV0ZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0ZmxleEF2YWlsYWJsZSA9XG5cdFx0KGRldGVjdG9yLnN0eWxlLmZsZXhCYXNpcyAhPT0gdW5kZWZpbmVkKSB8fFxuXHRcdChkZXRlY3Rvci5zdHlsZS53ZWJraXRGbGV4QmFzaXMgIT09IHVuZGVmaW5lZCkgfHxcblx0XHQoZGV0ZWN0b3Iuc3R5bGUubW96RmxleEJhc2lzICE9PSB1bmRlZmluZWQpIHx8XG5cdFx0KGRldGVjdG9yLnN0eWxlLm1zRmxleEJhc2lzICE9PSB1bmRlZmluZWQpO1xuXG4vKipcbioge0BsaW5rIGVueW8uRml0dGFibGVMYXlvdXR9IHByb3ZpZGVzIHRoZSBiYXNlIHBvc2l0aW9uaW5nIGFuZCBib3VuZGFyeSBsb2dpYyBmb3JcbiogdGhlIGZpdHRhYmxlIGxheW91dCBzdHJhdGVneS4gVGhlIGZpdHRhYmxlIGxheW91dCBzdHJhdGVneSBpcyBiYXNlZCBvblxuKiBsYXlpbmcgb3V0IGl0ZW1zIGluIGVpdGhlciBhIHNldCBvZiByb3dzIG9yIGEgc2V0IG9mIGNvbHVtbnMsIHdpdGggbW9zdCBvZlxuKiB0aGUgaXRlbXMgaGF2aW5nIG5hdHVyYWwgc2l6ZSwgYnV0IG9uZSBpdGVtIGV4cGFuZGluZyB0byBmaWxsIHRoZSByZW1haW5pbmdcbiogc3BhY2UuIFRoZSBpdGVtIHRoYXQgZXhwYW5kcyBpcyBsYWJlbGVkIHdpdGggdGhlIGF0dHJpYnV0ZSBgZml0OiB0cnVlYC5cbipcbiogVGhlIHN1YmtpbmRzIHtAbGluayBlbnlvLkZpdHRhYmxlQ29sdW1uc0xheW91dH0gYW5kIHtAbGluayBlbnlvLkZpdHRhYmxlUm93c0xheW91dH1cbiogKG9yIF90aGVpcl8gc3Via2luZHMpIGFyZSB1c2VkIGZvciBsYXlvdXQgcmF0aGVyIHRoYW4gYGVueW8uRml0dGFibGVMYXlvdXRgIGJlY2F1c2VcbiogdGhleSBzcGVjaWZ5IHByb3BlcnRpZXMgdGhhdCB0aGUgZnJhbWV3b3JrIGV4cGVjdHMgdG8gYmUgYXZhaWxhYmxlIHdoZW4gbGF5aW5nIGl0ZW1zXG4qIG91dC5cbipcbiogV2hlbiBhdmFpbGFibGUgb24gdGhlIHBsYXRmb3JtLCB5b3UgY2FuIG9wdC1pbiB0byBoYXZlIGBlbnlvLkZpdHRhYmxlTGF5b3V0YCB1c2UgQ1NTXG4qIGZsZXhpYmxlIGJveCAoZmxleGJveCkgdG8gaW1wbGVtZW50IGZpdHRpbmcgYmVoYXZpb3Igb24gdGhlIHBsYXRmb3JtIGZvciBiZXR0ZXJcbiogcGVyZm9ybWFuY2U7IEVueW8gd2lsbCBmYWxsIGJhY2sgdG8gSmF2YVNjcmlwdC1iYXNlZCBsYXlvdXQgb24gb2xkZXIgcGxhdGZvcm1zLlxuKiBUaHJlZSBzdWJ0bGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgZmxleGJveCBhbmQgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbnNcbiogc2hvdWxkIGJlIG5vdGVkOlxuXG4qIC0gV2hlbiB1c2luZyBmbGV4Ym94LCB2ZXJ0aWNhbCBtYXJnaW5zIChpLmUuLCBgbWFyZ2luLXRvcGAsIGBtYXJnaW4tYm90dG9tYCkgd2lsbFxuKiBub3QgY29sbGFwc2U7IHdoZW4gdXNpbmcgSmF2YVNjcmlwdCBsYXlvdXQsIHZlcnRpY2FsIG1hcmdpbnMgd2lsbCBjb2xsYXBzZSBhY2NvcmRpbmdcbiogdG8gc3RhdGljIGxheW91dCBydWxlcy5cbipcbiogLSBXaGVuIHVzaW5nIGZsZXhib3gsIG5vbi1maXR0aW5nIGNoaWxkcmVuIG9mIHRoZSBGaXR0YWJsZSBtdXN0IG5vdCBiZSBzaXplZFxuKiB1c2luZyBwZXJjZW50YWdlcyBvZiB0aGUgY29udGFpbmVyIChldmVuIGlmIHNldCB0byBgcG9zaXRpb246IHJlbGF0aXZlYCk7XG4qIHRoaXMgaXMgZXhwbGljaXRseSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBmbGV4Ym94IDIwMTMgc3BlYy5cbipcbiogLSBUaGUgZmxleGJveC1iYXNlZCBGaXR0YWJsZSBpbXBsZW1lbnRhdGlvbiB3aWxsIHJlc3BlY3QgbXVsdGlwbGUgY2hpbGRyZW5cbiogd2l0aCBgZml0OiB0cnVlYCAodGhlIGZpdHRpbmcgc3BhY2Ugd2lsbCBiZSBkaXZpZGVkIGVxdWFsbHkgYmV0d2VlbiB0aGVtKS5cbiogVGhpcyBpcyBOT1Qgc3VwcG9ydGVkIGJ5IHRoZSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uLCBhbmQgeW91IHNob3VsZCBub3QgcmVseVxuKiB1cG9uIHRoaXMgYmVoYXZpb3IgaWYgeW91IGFyZSBkZXBsb3lpbmcgdG8gcGxhdGZvcm1zIHdpdGhvdXQgZmxleGJveCBzdXBwb3J0LlxuKlxuKiBUaGUgZmxleGJveCBpbXBsZW1lbnRhdGlvbiB3YXMgYWRkZWQgdG8gRW55byAyLjUuMCBhcyBhbiBvcHRpb25hbCBwZXJmb3JtYW5jZVxuKiBvcHRpbWl6YXRpb247IHRvIHVzZSB0aGUgb3B0aW1pemF0aW9uLCBzZXQgYHVzZUZsZXg6IHRydWVgIG9uIHRoZSBGaXR0YWJsZVxuKiBjb250YWluZXIuICBUaGlzIHdpbGwgY2F1c2UgZmxleGJveCB0byBiZSB1c2VkIHdoZW4gcG9zc2libGUuXG4qXG4qIEBjbGFzcyAgZW55by5GaXR0YWJsZUxheW91dFxuKiBAZXh0ZW5kcyBlbnlvLkxheW91dFxuKiBAcHVibGljXG4qL1xudmFyIEZpdHRhYmxlTGF5b3V0ID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKC8qKiBAbGVuZHMgIGVueW8uRml0dGFibGVMYXlvdXQucHJvdG90eXBlICove1xuXHRuYW1lOiAnZW55by5GaXR0YWJsZUxheW91dCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogTGF5b3V0LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5vRGVmZXI6IHRydWUsXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0TGF5b3V0LnByb3RvdHlwZS5fY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdC8vIEFkZCB0aGUgZm9yY2UtbHRyIGNsYXNzIGlmIHdlJ3JlIGluIFJUTCBtb2RlLCBidXQgdGhpcyBjb250cm9sIGlzIHNldCBleHBsaWNpdGx5IHRvIE5PVCBiZSBpbiBSVEwgbW9kZS5cblx0XHR0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnZm9yY2UtbGVmdC10by1yaWdodCcsIChDb250cm9sLnByb3RvdHlwZS5ydGwgJiYgIXRoaXMuY29udGFpbmVyLmdldCgncnRsJykpICk7XG5cblx0XHQvLyBGbGV4Ym94IG9wdGltaXphdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGdsb2JhbCBmbGV4QXZhaWxhYmxlIGFuZCBwZXItaW5zdGFuY2Ugb3B0LWluIHVzZUZsZXggZmxhZ1xuXHRcdHRoaXMudXNlRmxleCA9IGZsZXhBdmFpbGFibGUgJiYgKHRoaXMuY29udGFpbmVyLnVzZUZsZXggPT09IHRydWUpO1xuXHRcdGlmICh0aGlzLnVzZUZsZXgpIHtcblx0XHRcdHRoaXMuY29udGFpbmVyLmFkZENsYXNzKHRoaXMuZmxleExheW91dENsYXNzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5maXRMYXlvdXRDbGFzcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNGaXRJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhQ2hpbGRyZW4gPSB0aGlzLmNvbnRhaW5lci5jaGlsZHJlbixcblx0XHRcdG9DaGlsZCxcblx0XHRcdG47XG5cblx0XHRmb3IgKG49MDsgbjxhQ2hpbGRyZW4ubGVuZ3RoOyBuKyspIHtcblx0XHRcdG9DaGlsZCA9IGFDaGlsZHJlbltuXTtcblx0XHRcdGlmIChvQ2hpbGQuZml0ICYmIG9DaGlsZC5zaG93aW5nKSB7XG5cdFx0XHRcdHJldHVybiBuO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRGaXRDb250cm9sOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGFDaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyLmNoaWxkcmVuLFxuXHRcdFx0b0ZpdENoaWxkID0gYUNoaWxkcmVuW3RoaXMuZml0SW5kZXhdO1xuXG5cdFx0aWYgKCEob0ZpdENoaWxkICYmIG9GaXRDaGlsZC5maXQgJiYgb0ZpdENoaWxkLnNob3dpbmcpKSB7XG5cdFx0XHR0aGlzLmZpdEluZGV4ID0gdGhpcy5jYWxjRml0SW5kZXgoKTtcblx0XHRcdG9GaXRDaGlsZCA9IGFDaGlsZHJlblt0aGlzLmZpdEluZGV4XTtcblx0XHR9XG5cdFx0cmV0dXJuIG9GaXRDaGlsZDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGRSZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyLnJ0bCAmJiB0aGlzLm9yaWVudCA9PT0gJ2gnO1xuXHR9LFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdExheW91dC5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmNvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy51c2VGbGV4ID8gdGhpcy5mbGV4TGF5b3V0Q2xhc3MgOiB0aGlzLmZpdExheW91dENsYXNzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFDaGlsZHJlbiA9IHRoaXMuZ2V0U2hvd2luZ0NoaWxkcmVuKCk7XG5cblx0XHRpZiAodGhpcy5zaG91bGRSZXZlcnNlKCkpIHtcblx0XHRcdHJldHVybiBhQ2hpbGRyZW5bYUNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYUNoaWxkcmVuWzBdO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRMYXN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhQ2hpbGRyZW4gPSB0aGlzLmdldFNob3dpbmdDaGlsZHJlbigpO1xuXG5cdFx0aWYgKHRoaXMuc2hvdWxkUmV2ZXJzZSgpKSB7XG5cdFx0XHRyZXR1cm4gYUNoaWxkcmVuWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYUNoaWxkcmVuW2FDaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0U2hvd2luZ0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0biA9IDAsXG5cdFx0XHRhQ2hpbGRyZW4gPSB0aGlzLmNvbnRhaW5lci5jaGlsZHJlbixcblx0XHRcdG5MZW5ndGggICA9IGFDaGlsZHJlbi5sZW5ndGg7XG5cblx0XHRmb3IgKDtuPG5MZW5ndGg7IG4rKykge1xuXHRcdFx0aWYgKGFDaGlsZHJlbltuXS5zaG93aW5nKSB7XG5cdFx0XHRcdGEucHVzaChhQ2hpbGRyZW5bbl0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9yZWZsb3c6IGZ1bmN0aW9uKHNNZWFzdXJlTmFtZSwgc0NsaWVuTWVhc3VyZSwgc0F0dHJCZWZvcmUsIHNBdHRyQWZ0ZXIpIHtcblx0XHR0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnZW55by1zdHJldGNoJywgIXRoaXMuY29udGFpbmVyLm5vU3RyZXRjaCk7XG5cblx0XHR2YXIgb0ZpdENoaWxkICAgICAgID0gdGhpcy5nZXRGaXRDb250cm9sKCksXG5cdFx0XHRvQ29udGFpbmVyTm9kZSAgPSB0aGlzLmNvbnRhaW5lci5oYXNOb2RlKCksICAvLyBDb250YWluZXIgbm9kZVxuXHRcdFx0blRvdGFsU2l6ZSAgICAgPSAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgY29udGFpbmVyIHdpZHRoIG9yIGhlaWdodCB3aXRob3V0IHBhZGRpbmdcblx0XHRcdG5CZWZvcmVPZmZzZXQgICA9IDAsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCBiZWZvcmUgZml0IGNoaWxkXG5cdFx0XHRuQWZ0ZXJPZmZzZXQgICAgPSAwLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgYWZ0ZXIgZml0IGNoaWxkXG5cdFx0XHRvUGFkZGluZywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3QgY29udGFpbmluZyB0LGIscixsIHBhZGRpbmdzXG5cdFx0XHRvQm91bmRzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3VuZHMgb2JqZWN0IG9mIGZpdCBjb250cm9sXG5cdFx0XHRvTGFzdENoaWxkLFxuXHRcdFx0b0ZpcnN0Q2hpbGQsXG5cdFx0XHRuRml0U2l6ZTtcblxuXHRcdGlmICghb0ZpdENoaWxkIHx8ICFvQ29udGFpbmVyTm9kZSkgeyByZXR1cm47IH1cblxuXHRcdG9QYWRkaW5nICAgPSBkb20uY2FsY1BhZGRpbmdFeHRlbnRzKG9Db250YWluZXJOb2RlKTtcblx0XHRvQm91bmRzICAgID0gb0ZpdENoaWxkLmdldEJvdW5kcygpO1xuXHRcdG5Ub3RhbFNpemUgPSBvQ29udGFpbmVyTm9kZVtzQ2xpZW5NZWFzdXJlXSAtIChvUGFkZGluZ1tzQXR0ckJlZm9yZV0gKyBvUGFkZGluZ1tzQXR0ckFmdGVyXSk7XG5cblx0XHRpZiAodGhpcy5zaG91bGRSZXZlcnNlKCkpIHtcblx0XHRcdG9GaXJzdENoaWxkICA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdFx0bkFmdGVyT2Zmc2V0ID0gblRvdGFsU2l6ZSAtIChvQm91bmRzW3NBdHRyQmVmb3JlXSArIG9Cb3VuZHNbc01lYXN1cmVOYW1lXSk7XG5cblx0XHRcdHZhciBuTWFyZ2luQmVmb3JlRmlyc3RDaGlsZCA9IGRvbS5nZXRDb21wdXRlZEJveFZhbHVlKG9GaXJzdENoaWxkLmhhc05vZGUoKSwgJ21hcmdpbicsIHNBdHRyQmVmb3JlKSB8fCAwO1xuXG5cdFx0XHRpZiAob0ZpcnN0Q2hpbGQgPT0gb0ZpdENoaWxkKSB7XG5cdFx0XHRcdG5CZWZvcmVPZmZzZXQgPSBuTWFyZ2luQmVmb3JlRmlyc3RDaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvRmlyc3RDaGlsZEJvdW5kcyAgICAgID0gb0ZpcnN0Q2hpbGQuZ2V0Qm91bmRzKCksXG5cdFx0XHRcdFx0blNwYWNlQmVmb3JlRmlyc3RDaGlsZCA9IG9GaXJzdENoaWxkQm91bmRzW3NBdHRyQmVmb3JlXTtcblxuXHRcdFx0XHRuQmVmb3JlT2Zmc2V0ID0gb0JvdW5kc1tzQXR0ckJlZm9yZV0gKyBuTWFyZ2luQmVmb3JlRmlyc3RDaGlsZCAtIG5TcGFjZUJlZm9yZUZpcnN0Q2hpbGQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9MYXN0Q2hpbGQgICAgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdFx0bkJlZm9yZU9mZnNldCA9IG9Cb3VuZHNbc0F0dHJCZWZvcmVdIC0gKG9QYWRkaW5nW3NBdHRyQmVmb3JlXSB8fCAwKTtcblxuXHRcdFx0dmFyIG5NYXJnaW5BZnRlckxhc3RDaGlsZCA9IGRvbS5nZXRDb21wdXRlZEJveFZhbHVlKG9MYXN0Q2hpbGQuaGFzTm9kZSgpLCAnbWFyZ2luJywgc0F0dHJBZnRlcikgfHwgMDtcblxuXHRcdFx0aWYgKG9MYXN0Q2hpbGQgPT0gb0ZpdENoaWxkKSB7XG5cdFx0XHRcdG5BZnRlck9mZnNldCA9IG5NYXJnaW5BZnRlckxhc3RDaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvTGFzdENoaWxkQm91bmRzID0gb0xhc3RDaGlsZC5nZXRCb3VuZHMoKSxcblx0XHRcdFx0XHRuRml0Q2hpbGRFbmQgICAgID0gb0JvdW5kc1tzQXR0ckJlZm9yZV0gKyBvQm91bmRzW3NNZWFzdXJlTmFtZV0sXG5cdFx0XHRcdFx0bkxhc3RDaGlsZEVuZCAgICA9IG9MYXN0Q2hpbGRCb3VuZHNbc0F0dHJCZWZvcmVdICsgb0xhc3RDaGlsZEJvdW5kc1tzTWVhc3VyZU5hbWVdICsgIG5NYXJnaW5BZnRlckxhc3RDaGlsZDtcblxuXHRcdFx0XHRuQWZ0ZXJPZmZzZXQgPSBuTGFzdENoaWxkRW5kIC0gbkZpdENoaWxkRW5kO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG5GaXRTaXplID0gblRvdGFsU2l6ZSAtIChuQmVmb3JlT2Zmc2V0ICsgbkFmdGVyT2Zmc2V0KTtcblx0XHRvRml0Q2hpbGQuYXBwbHlTdHlsZShzTWVhc3VyZU5hbWUsIG5GaXRTaXplICsgJ3B4Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQXNzaWducyBhbnkgc3RhdGljIGxheW91dCBwcm9wZXJ0aWVzIG5vdCBkZXBlbmRlbnQgb24gY2hhbmdlcyB0byB0aGVcblx0KiByZW5kZXJlZCBjb21wb25lbnQgb3IgY29udGFpbmVyIHNpemVzLCBldGMuXG5cdCogXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmbG93OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy51c2VGbGV4KSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0Y2hpbGRyZW4gPSB0aGlzLmNvbnRhaW5lci5jaGlsZHJlbixcblx0XHRcdFx0Y2hpbGQ7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmZsZXhMYXlvdXRDbGFzcyk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5hZGRSZW1vdmVDbGFzcygnbm9zdHJldGNoJywgdGhpcy5jb250YWluZXIubm9TdHJldGNoKTtcblx0XHRcdGZvciAoaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdGNoaWxkLmFkZENsYXNzKCdlbnlvLWZsZXgtaXRlbScpO1xuXHRcdFx0XHRjaGlsZC5hZGRSZW1vdmVDbGFzcygnZmxleCcsIGNoaWxkLmZpdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgdGhlIGxheW91dCB0byByZWZsZWN0IGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIGxheW91dCBjb250YWluZXIgb3Jcblx0KiB0aGUgY29udGFpbmVkIGNvbXBvbmVudHMuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHJlZmxvdzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLnVzZUZsZXgpIHtcblx0XHRcdGlmICh0aGlzLm9yaWVudCA9PSAnaCcpIHtcblx0XHRcdFx0dGhpcy5fcmVmbG93KCd3aWR0aCcsICdjbGllbnRXaWR0aCcsICdsZWZ0JywgJ3JpZ2h0Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yZWZsb3coJ2hlaWdodCcsICdjbGllbnRIZWlnaHQnLCAndG9wJywgJ2JvdHRvbScpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqIEBsZW5kcyAgZW55by5GaXR0YWJsZUxheW91dC5wcm90b3R5cGVcblx0Ki9cblx0c3RhdGljczoge1xuXHRcdC8qKlxuXHRcdCogSW5kaWNhdGVzIHdoZXRoZXIgZmxleGJveCBvcHRpbWl6YXRpb24gY2FuIGJlIHVzZWQuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgZmFsc2Vcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRmbGV4QXZhaWxhYmxlOiBmbGV4QXZhaWxhYmxlXG5cdH1cbn0pO1xuXG4vKipcbioge0BsaW5rIGVueW8uRml0dGFibGVDb2x1bW5zTGF5b3V0fSBwcm92aWRlcyBhIGNvbnRhaW5lciBpbiB3aGljaCBpdGVtcyBhcmUgbGFpZFxuKiBvdXQgaW4gYSBzZXQgb2YgdmVydGljYWwgY29sdW1ucywgd2l0aCBtb3N0IG9mIHRoZSBpdGVtcyBoYXZpbmcgbmF0dXJhbFxuKiBzaXplLCBidXQgb25lIGV4cGFuZGluZyB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2UuIFRoZSBvbmUgdGhhdCBleHBhbmRzIGlzXG4qIGxhYmVsZWQgd2l0aCB0aGUgYXR0cmlidXRlIGBmaXQ6IHRydWVgLlxuKlxuKiBgZW55by5GaXR0YWJsZUNvbHVtbnNMYXlvdXRgIGlzIG1lYW50IHRvIGJlIHVzZWQgYXMgYSB2YWx1ZSBmb3IgdGhlXG4qIGBsYXlvdXRLaW5kYCBwcm9wZXJ0eSBvZiBvdGhlciBraW5kcy4gYGxheW91dEtpbmRgIHByb3ZpZGVzIGEgd2F5IHRvIGFkZFxuKiBsYXlvdXQgYmVoYXZpb3IgaW4gYSBwbHVnZ2FibGUgZmFzaGlvbiB3aGlsZSByZXRhaW5pbmcgdGhlIGFiaWxpdHkgdG8gdXNlIGFcbiogc3BlY2lmaWMgYmFzZSBraW5kLlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtGaXR0YWJsZXNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9maXR0YWJsZXMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAY2xhc3MgIGVueW8uRml0dGFibGVDb2x1bW5zTGF5b3V0XG4qIEBleHRlbmRzIGVueW8uRml0dGFibGVMYXlvdXRcbiogQHB1YmxpY1xuKi9cbkZpdHRhYmxlTGF5b3V0LkNvbHVtbnMgPSBraW5kKC8qKiBAbGVuZHMgIGVueW8uRml0dGFibGVDb2x1bW5zTGF5b3V0LnByb3RvdHlwZSAqL3tcblx0bmFtZSAgICAgICAgOiAnZW55by5GaXR0YWJsZUNvbHVtbnNMYXlvdXQnLFxuXHRraW5kICAgICAgICA6IEZpdHRhYmxlTGF5b3V0LFxuXHRvcmllbnQgICAgICA6ICdoJyxcblx0Zml0TGF5b3V0Q2xhc3MgOiAnZW55by1maXR0YWJsZS1jb2x1bW5zLWxheW91dCcsXG5cdGZsZXhMYXlvdXRDbGFzczogJ2VueW8tZmxleC1jb250YWluZXIgY29sdW1ucydcbn0pO1xuXG5cbi8qKlxuKiB7QGxpbmsgZW55by5GaXR0YWJsZVJvd3NMYXlvdXR9IHByb3ZpZGVzIGEgY29udGFpbmVyIGluIHdoaWNoIGl0ZW1zIGFyZSBsYWlkIG91dFxuKiBpbiBhIHNldCBvZiBob3Jpem9udGFsIHJvd3MsIHdpdGggbW9zdCBvZiB0aGUgaXRlbXMgaGF2aW5nIG5hdHVyYWwgc2l6ZSwgYnV0XG4qIG9uZSBleHBhbmRpbmcgdG8gZmlsbCB0aGUgcmVtYWluaW5nIHNwYWNlLiBUaGUgb25lIHRoYXQgZXhwYW5kcyBpcyBsYWJlbGVkXG4qIHdpdGggdGhlIGF0dHJpYnV0ZSBgZml0OiB0cnVlYC5cbipcbiogYGVueW8uRml0dGFibGVSb3dzTGF5b3V0YCBpcyBtZWFudCB0byBiZSB1c2VkIGFzIGEgdmFsdWUgZm9yIHRoZVxuKiBgbGF5b3V0S2luZGAgcHJvcGVydHkgb2Ygb3RoZXIga2luZHMuIGBsYXlvdXRLaW5kYCBwcm92aWRlcyBhIHdheSB0byBhZGRcbiogbGF5b3V0IGJlaGF2aW9yIGluIGEgcGx1Z2dhYmxlIGZhc2hpb24gd2hpbGUgcmV0YWluaW5nIHRoZSBhYmlsaXR5IHRvIHVzZSBhXG4qIHNwZWNpZmljIGJhc2Uga2luZC5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbRml0dGFibGVzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvZml0dGFibGVzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzICBlbnlvLkZpdHRhYmxlUm93c0xheW91dFxuKiBAZXh0ZW5kcyBlbnlvLkZpdHRhYmxlTGF5b3V0XG4qIEBwdWJsaWNcbiovXG5GaXR0YWJsZUxheW91dC5Sb3dzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkZpdHRhYmxlUm93c0xheW91dC5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWUgICAgICAgIDogJ2VueW8uRml0dGFibGVSb3dzTGF5b3V0JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kICAgICAgICA6IEZpdHRhYmxlTGF5b3V0LFxuXG5cdC8qKlxuXHQqIExheW91dCBDU1MgY2xhc3MgdXNlZCB0byBmaXQgcm93cy5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ2VueW8tZml0dGFibGUtcm93cy1sYXlvdXQnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmaXRMYXlvdXRDbGFzcyA6ICdlbnlvLWZpdHRhYmxlLXJvd3MtbGF5b3V0JyxcblxuXHQvKipcblx0KiBUaGUgb3JpZW50YXRpb24gb2YgdGhlIGxheW91dC5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJ3YnXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRvcmllbnQgICAgICA6ICd2JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmbGV4TGF5b3V0Q2xhc3M6ICdlbnlvLWZsZXgtY29udGFpbmVyIHJvd3MnXG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQ29udHJvbFwiOjE2LFwiLi4vLi4vLi4vZW55by9saWIvTGF5b3V0XCI6MjYsXCIuLi8uLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2Nn1dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9kb20nKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi91dGlscycpLFxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIvQ29udHJvbCcpLFxuXHRIVE1MU3RyaW5nRGVsZWdhdGUgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9IVE1MU3RyaW5nRGVsZWdhdGUnKSxcblx0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIvU2VsZWN0aW9uJyk7XG5cbnZhciBGbHl3ZWlnaHRSZXBlYXRlckRlbGVnYXRlID0gT2JqZWN0LmNyZWF0ZShIVE1MU3RyaW5nRGVsZWdhdGUpO1xuXG5GbHl3ZWlnaHRSZXBlYXRlckRlbGVnYXRlLmdlbmVyYXRlSW5uZXJIdG1sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcblx0dmFyIGggPSAnJztcblx0Y29udHJvbC5pbmRleCA9IG51bGw7XG5cdC8vIG5vdGU6IGNhbiBzdXBwbHkgYSByb3dPZmZzZXRcblx0Ly8gYW5kIGluZGljYXRlIGlmIHJvd3Mgc2hvdWxkIGJlIHJlbmRlcmVkIHRvcCBkb3duIG9yIGJvdHRvbVVwXG5cdGZvciAodmFyIGk9MCwgcj0wOyBpPGNvbnRyb2wuY291bnQ7IGkrKykge1xuXHRcdHIgPSBjb250cm9sLnJvd09mZnNldCArICh0aGlzLmJvdHRvbVVwID8gY29udHJvbC5jb3VudCAtIGktMSA6IGkpO1xuXHRcdGNvbnRyb2wuc2V0dXBJdGVtKHIpO1xuXHRcdGNvbnRyb2wuJC5jbGllbnQuc2V0QXR0cmlidXRlKCdkYXRhLWVueW8taW5kZXgnLCByKTtcblx0XHRpZiAoY29udHJvbC5vcmllbnQgPT0gJ2gnKSB7XG5cdFx0XHRjb250cm9sLiQuY2xpZW50LnNldFN0eWxlKCdkaXNwbGF5OmlubGluZS1ibG9jazsnKTtcblx0XHR9XG5cdFx0aCArPSBIVE1MU3RyaW5nRGVsZWdhdGUuZ2VuZXJhdGVDaGlsZEh0bWwoY29udHJvbCk7XG5cdFx0Y29udHJvbC4kLmNsaWVudC50ZWFyZG93blJlbmRlcigpO1xuXHR9XG5cdHJldHVybiBoO1xufTtcblxuLyoqXG4qIEZpcmVzIG9uY2UgcGVyIHJvdyBhdCByZW5kZXIgdGltZS5cbipcbiogQGV2ZW50IGVueW8uRmx5d2VpZ2h0UmVwZWF0ZXIjb25TZXR1cEl0ZW1cbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtOdW1iZXJ9IGluZGV4ICAgICAtIFRoZSBpbmRleCBvZiB0aGUgcm93IGJlaW5nIHJlbmRlcmVkLlxuKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlbGVjdGVkIC0gYHRydWVgIGlmIHRoZSByb3cgaXMgc2VsZWN0ZWQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIGFmdGVyIGFuIGluZGl2aWR1YWwgcm93IGhhcyBiZWVuIHJlbmRlcmVkLlxuKlxuKiBAZXZlbnQgZW55by5GbHl3ZWlnaHRSZXBlYXRlciNvblJlbmRlclJvd1xuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge051bWJlcn0gcm93SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0aGF0IHdhcyByZW5kZXJlZC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIHtAbGluayBlbnlvLkZseXdlaWdodFJlcGVhdGVyfSBpcyBhIGNvbnRyb2wgdGhhdCBkaXNwbGF5cyBhIHJlcGVhdGluZyBsaXN0IG9mXG4qIHJvd3MsIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIG1lZGl1bS1zaXplZCBsaXN0cyAodXAgdG8gfjEwMCBpdGVtcykuIEFcbiogZmx5d2VpZ2h0IHN0cmF0ZWd5IGlzIGVtcGxveWVkIHRvIHJlbmRlciBvbmUgc2V0IG9mIHJvdyBjb250cm9scywgYXMgbmVlZGVkLFxuKiBmb3IgYXMgbWFueSByb3dzIGFzIGFyZSBjb250YWluZWQgaW4gdGhlIHJlcGVhdGVyLlxuKlxuKiBUaGUgRmx5d2VpZ2h0UmVwZWF0ZXIncyBgY29tcG9uZW50c2AgYmxvY2sgY29udGFpbnMgdGhlIGNvbnRyb2xzIHRvIGJlIHVzZWRcbiogZm9yIGEgc2luZ2xlIHJvdy4gVGhpcyBzZXQgb2YgY29udHJvbHMgd2lsbCBiZSByZW5kZXJlZCBmb3IgZWFjaCByb3cuIFlvdVxuKiBtYXkgY3VzdG9taXplIHJvdyByZW5kZXJpbmcgYnkgaGFuZGxpbmcgdGhlXG4qIFtvblNldHVwSXRlbV17QGxpbmsgZW55by5GbHl3ZWlnaHRSZXBlYXRlciNvblNldHVwSXRlbX0gZXZlbnQuXG4qXG4qIFRoZSBjb250cm9scyBpbnNpZGUgYSBGbHl3ZWlnaHRSZXBlYXRlciBhcmUgbm9uLWludGVyYWN0aXZlLiBUaGlzIG1lYW5zIHRoYXRcbiogY2FsbGluZyBtZXRob2RzIHRoYXQgd291bGQgbm9ybWFsbHkgY2F1c2UgcmVuZGVyaW5nIHRvIG9jY3VyIChlLmcuLFxuKiBgc2V0KCdjb250ZW50JywgPHZhbHVlPilgKSB3aWxsIG5vdCBkbyBzby4gSG93ZXZlciwgeW91IG1heSBmb3JjZSBhIHJvdyB0b1xuKiByZW5kZXIgYnkgY2FsbGluZyBbcmVuZGVyUm93KClde0BsaW5rIGVueW8uRmx5d2VpZ2h0UmVwZWF0ZXIjcmVuZGVyUm93fS5cbipcbiogSW4gYWRkaXRpb24sIHlvdSBtYXkgZm9yY2UgYSByb3cgdG8gYmUgdGVtcG9yYXJpbHkgaW50ZXJhY3RpdmUgYnkgY2FsbGluZ1xuKiBbcHJlcGFyZVJvdygpXXtAbGluayBlbnlvLkZseXdlaWdodFJlcGVhdGVyI3ByZXBhcmVSb3d9LiBDYWxsXG4qIFtsb2NrUm93KClde0BsaW5rIGVueW8uRmx5d2VpZ2h0UmVwZWF0ZXIjbG9ja1Jvd30gd2hlbiB0aGUgaW50ZXJhY3Rpb25cbiogaXMgY29tcGxldGUuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0xpc3RzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvbGlzdHMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAdWlcbiogQGNsYXNzIGVueW8uRmx5d2VpZ2h0UmVwZWF0ZXJcbiogQGV4dGVuZHMgZW55by5Db250cm9sXG4qIEBwdWJsaWNcbiovXG52YXIgRmx5d2VpZ2h0UmVwZWF0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5GbHl3ZWlnaHRSZXBlYXRlci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLkZseXdlaWdodFJlcGVhdGVyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBDb250cm9sLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLkZseXdlaWdodFJlcGVhdGVyLnByb3RvdHlwZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygcm93cyB0byByZW5kZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0Y291bnQ6IDAsXG5cblx0XHQvKipcblx0XHQqIElmIGB0cnVlYCwgdGhlIHNlbGVjdGlvbiBtZWNoYW5pc20gaXMgZGlzYWJsZWQuIFRhcCBldmVudHMgYXJlIHN0aWxsXG5cdFx0KiBzZW50LCBidXQgaXRlbXMgd29uJ3QgYmUgYXV0b21hdGljYWxseSByZS1yZW5kZXJlZCB3aGVuIHRhcHBlZC5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRub1NlbGVjdDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBJZiBgdHJ1ZWAsIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBhbGxvd2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bXVsdGlTZWxlY3Q6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogSWYgYHRydWVgLCB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIHRvZ2dsZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRvZ2dsZVNlbGVjdGVkOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogVXNlZCB0byBzcGVjaWZ5IENTUyBjbGFzc2VzIGZvciB0aGUgcmVwZWF0ZXIncyB3cmFwcGVyIGNvbXBvbmVudCAoY2xpZW50KS5cblx0XHQqIElucHV0IGlzIGlkZW50aWNhbCB0byB0aGF0IG9mIHtAbGluayBlbnlvLkNvbnRyb2wjc2V0Q2xhc3Nlc30uXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICcnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRjbGllbnRDbGFzc2VzOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogVXNlZCB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsaW5nIGZvciB0aGUgcmVwZWF0ZXIncyB3cmFwcGVyIGNvbXBvbmVudFxuXHRcdCogKGNsaWVudCkuIElucHV0IGlzIGlkZW50aWNhbCB0byB0aGF0IG9mIHtAbGluayBlbnlvLkNvbnRyb2wjc2V0U3R5bGV9LlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y2xpZW50U3R5bGU6ICcnLFxuXG5cdFx0LyoqXG5cdFx0KiBOdW1lcmljYWwgb2Zmc2V0IGFwcGxpZWQgdG8gcm93IG51bWJlciBkdXJpbmcgcm93IGdlbmVyYXRpb24uIEFsbG93cyBpdGVtc1xuXHRcdCogdG8gaGF2ZSBuYXR1cmFsIGluZGljZXMgaW5zdGVhZCBvZiBgMGAtYmFzZWQgb25lcy4gVGhpcyB2YWx1ZSBtdXN0IGJlXG5cdFx0KiBwb3NpdGl2ZSwgYXMgcm93IG51bWJlciBgLTFgIGlzIHVzZWQgdG8gcmVwcmVzZW50IHVuZGVmaW5lZCByb3dzIGluIHRoZVxuXHRcdCogZXZlbnQgc3lzdGVtLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCAwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRyb3dPZmZzZXQ6IDAsXG5cblx0XHQvKipcblx0XHQqIERpcmVjdGlvbiBpbiB3aGljaCBpdGVtcyB3aWxsIGJlIGxhaWQgb3V0LiBWYWxpZCB2YWx1ZXMgYXJlIGAndidgIGZvclxuXHRcdCogdmVydGljYWwgb3IgYCdoJ2AgZm9yIGhvcml6b250YWwuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdoJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0b3JpZW50OiAndidcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblNldHVwSXRlbTogJycsXG5cdFx0b25SZW5kZXJSb3c6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogU2V0dGluZyBjYWNoZVBvaW50OiB0cnVlIGVuc3VyZXMgdGhhdCBldmVudHMgZnJvbSB0aGUgcmVwZWF0ZXIncyBzdWJ0cmVlIHdpbGxcblx0KiBhbHdheXMgYnViYmxlIHVwIHRocm91Z2ggdGhlIHJlcGVhdGVyLCBhbGxvd2luZyB0aGUgZXZlbnRzIHRvIGJlIGRlY29yYXRlZCB3aXRoIHJlcGVhdGVyLVxuXHQqIHJlbGF0ZWQgbWV0YWRhdGEgYW5kIHJlZmVyZW5jZXMuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCB0cnVlXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FjaGVQb2ludDogdHJ1ZSxcblxuXHQvKipcblx0KiBEZXNpZ24tdGltZSBhdHRyaWJ1dGUgaW5kaWNhdGluZyB3aGV0aGVyIHJvdyBpbmRpY2VzIHJ1blxuXHQqIGZyb20gYDBgIHRvIFtgY291bnRgXXtAbGluayBlbnlvLkZseXdlaWdodFJlcGVhdGVyI2NvdW50fWAtMWAgYChmYWxzZSlgIG9yXG5cdCogZnJvbSBbYGNvdW50YF17QGxpbmsgZW55by5GbHl3ZWlnaHRSZXBlYXRlciNjb3VudH1gLTFgIHRvIGAwYCBgKHRydWUpYC5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IGZhbHNlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRib3R0b21VcDogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyRGVsZWdhdGU6IEZseXdlaWdodFJlcGVhdGVyRGVsZWdhdGUsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBTZWxlY3Rpb24sIG9uU2VsZWN0OiAnc2VsZWN0RGVzZWxlY3QnLCBvbkRlc2VsZWN0OiAnc2VsZWN0RGVzZWxlY3QnfSxcblx0XHR7bmFtZTogJ2NsaWVudCd9XG5cdF0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdENvbnRyb2wucHJvdG90eXBlLmNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMubm9TZWxlY3RDaGFuZ2VkKCk7XG5cdFx0dGhpcy5tdWx0aVNlbGVjdENoYW5nZWQoKTtcblx0XHR0aGlzLmNsaWVudENsYXNzZXNDaGFuZ2VkKCk7XG5cdFx0dGhpcy5jbGllbnRTdHlsZUNoYW5nZWQoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRub1NlbGVjdENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5ub1NlbGVjdCkge1xuXHRcdFx0dGhpcy4kLnNlbGVjdGlvbi5jbGVhcigpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtdWx0aVNlbGVjdENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuc2VsZWN0aW9uLnNldE11bHRpKHRoaXMubXVsdGlTZWxlY3QpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsaWVudENsYXNzZXNDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLmNsaWVudC5zZXRDbGFzc2VzKHRoaXMuY2xpZW50Q2xhc3Nlcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xpZW50U3R5bGVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLmNsaWVudC5zZXRTdHlsZSh0aGlzLmNsaWVudFN0eWxlKTtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5GbHl3ZWlnaHRSZXBlYXRlciNvblNldHVwSXRlbVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldHVwSXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0dGhpcy5kb1NldHVwSXRlbSh7aW5kZXg6IGluZGV4LCBzZWxlY3RlZDogdGhpcy5pc1NlbGVjdGVkKGluZGV4KX0pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlbmRlcnMgdGhlIGxpc3QuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZW5lcmF0ZUNoaWxkSHRtbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckRlbGVnYXRlLmdlbmVyYXRlSW5uZXJIdG1sKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEB0b2RvIGFkZCBsaW5rIHRvIHByZXZpZXcuanNcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcmV2aWV3RG9tRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBpID0gdGhpcy5pbmRleCA9IHRoaXMucm93Rm9yRXZlbnQoZXZlbnQpO1xuXHRcdGV2ZW50LnJvd0luZGV4ID0gZXZlbnQuaW5kZXggPSBpO1xuXHRcdGV2ZW50LmZseXdlaWdodCA9IHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlY29yYXRlRXZlbnQ6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50LCBzZW5kZXIpIHtcblx0XHQvLyBkZWNvcmF0ZSBldmVudCB3aXRoIGluZGV4IGZvdW5kIHZpYSBkb20gaWZmIGV2ZW50IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBhbiBpbmRleC5cblx0XHR2YXIgaSA9IChldmVudCAmJiBldmVudC5pbmRleCAhPSBudWxsKSA/IGV2ZW50LmluZGV4IDogdGhpcy5pbmRleDtcblx0XHRpZiAoZXZlbnQgJiYgaSAhPSBudWxsKSB7XG5cdFx0XHRldmVudC5pbmRleCA9IGk7XG5cdFx0XHRldmVudC5mbHl3ZWlnaHQgPSB0aGlzO1xuXHRcdH1cblx0XHRDb250cm9sLnByb3RvdHlwZS5kZWNvcmF0ZUV2ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGFwOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdC8vIGlnbm9yZSB0YXBzIGlmIHNlbGVjdGluZyBpcyBkaXNhYmxlZCBvciBpZiB0aGV5IGRvbid0IHRhcmdldCBhIHJvd1xuXHRcdGlmICh0aGlzLm5vU2VsZWN0IHx8IGV2ZW50LmluZGV4ID09PSAtMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy50b2dnbGVTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy4kLnNlbGVjdGlvbi50b2dnbGUoZXZlbnQuaW5kZXgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiQuc2VsZWN0aW9uLnNlbGVjdChldmVudC5pbmRleCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXIgZm9yIHNlbGVjdGlvbiBhbmQgZGVzZWxlY3Rpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZWxlY3REZXNlbGVjdDogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLnJlbmRlclJvdyhldmVudC5rZXkpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHVybnMgdGhlIHJlcGVhdGVyJ3MgW3NlbGVjdGlvbl17QGxpbmsgZW55by5TZWxlY3Rpb259IGNvbXBvbmVudC5cblx0KlxuXHQqIEByZXR1cm4ge2VueW8uU2VsZWN0aW9ufSBUaGUgcmVwZWF0ZXIncyBzZWxlY3Rpb24gY29tcG9uZW50LlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuJC5zZWxlY3Rpb247XG5cdH0sXG5cblx0LyoqXG5cdCogR2V0cyB0aGUgc2VsZWN0aW9uIHN0YXRlIGZvciB0aGUgZ2l2ZW4gcm93IGluZGV4LlxuXHQqXG5cdCogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByb3cgaXMgY3VycmVudGx5IHNlbGVjdGVkOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb24oKS5pc1NlbGVjdGVkKGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0KiBSZW5kZXJzIHRoZSByb3cgd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSByb3cgdG8gcmVuZGVyLlxuXHQqIEBmaXJlcyBlbnlvLkZseXdlaWdodFJlcGVhdGVyI29uUmVuZGVyUm93XG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW5kZXJSb3c6IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdC8vIGRvIG5vdGhpbmcgaWYgaW5kZXggaXMgb3V0LW9mLXJhbmdlXG5cdFx0aWYgKGluZGV4IDwgdGhpcy5yb3dPZmZzZXQgfHwgaW5kZXggPj0gdGhpcy5jb3VudCArIHRoaXMucm93T2Zmc2V0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vdGhpcy5pbmRleCA9IG51bGw7XG5cdFx0Ly8gYWx3YXlzIGNhbGwgdGhlIHNldHVwSXRlbSBjYWxsYmFjaywgYXMgd2UgbWF5IHJlbHkgb24gdGhlIHBvc3QtcmVuZGVyIHN0YXRlXG5cdFx0dGhpcy5zZXR1cEl0ZW0oaW5kZXgpO1xuXHRcdHZhciBub2RlID0gdGhpcy5mZXRjaFJvd05vZGUoaW5kZXgpO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHQvLyBoYWNrIHRvIGtlZXAgdGhpcyB3b3JraW5nLi4uXG5cdFx0XHR2YXIgZGVsZWdhdGUgPSBIVE1MU3RyaW5nRGVsZWdhdGU7XG5cblx0XHRcdGRvbS5zZXRJbm5lckh0bWwobm9kZSwgZGVsZWdhdGUuZ2VuZXJhdGVDaGlsZEh0bWwodGhpcy4kLmNsaWVudCkpO1xuXHRcdFx0dGhpcy4kLmNsaWVudC50ZWFyZG93bkNoaWxkcmVuKCk7XG5cdFx0XHR0aGlzLmRvUmVuZGVyUm93KHtyb3dJbmRleDogaW5kZXh9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogRmV0Y2hlcyB0aGUgRE9NIG5vZGUgZm9yIHRoZSBnaXZlbiByb3cgaW5kZXguXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB3aG9zZSBET00gbm9kZSBpcyB0byBiZSBmZXRjaGVkLlxuXHQqIEByZXR1cm4ge05vZGV9IFRoZSBET00gbm9kZSBmb3IgdGhlIHNwZWNpZmllZCByb3cuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRmZXRjaFJvd05vZGU6IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdGlmICh0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1lbnlvLWluZGV4PVwiJyArIGluZGV4ICsgJ1wiXScpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBGZXRjaGVzIHRoZSByb3cgbnVtYmVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCBvZiBhIGdpdmVuIGV2ZW50LlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0LlxuXHQqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByb3cgY29ycmVzcG9uZGluZyB0byB0aGUgZXZlbnQncyB0YXJnZXQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyb3dGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHR2YXIgbiA9IGV2ZW50LnRhcmdldDtcblx0XHR3aGlsZSAobiAmJiBuICE9PSB0aGlzLm5vZGUpIHtcblx0XHRcdHZhciBpID0gbi5nZXRBdHRyaWJ1dGUgJiYgbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW55by1pbmRleCcpO1xuXHRcdFx0aWYgKGkgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIE51bWJlcihpKTtcblx0XHRcdH1cblx0XHRcdG4gPSBuLnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHQvKipcblx0KiBQcmVwYXJlcyB0aGUgc3BlY2lmaWVkIHJvdyBzdWNoIHRoYXQgY2hhbmdlcyBtYWRlIHRvIHRoZSBjb250cm9scyBpbnNpZGVcblx0KiB0aGUgcmVwZWF0ZXIgd2lsbCBiZSByZW5kZXJlZCBmb3IgdGhlIHJvdy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgcm93IHRvIGJlIHByZXBhcmVkLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cHJlcGFyZVJvdzogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0Ly8gZG8gbm90aGluZyBpZiBpbmRleCBpcyBvdXQtb2YtcmFuZ2Vcblx0XHRpZiAoaW5kZXggPCB0aGlzLnJvd09mZnNldCB8fCBpbmRleCA+PSB0aGlzLmNvdW50ICsgdGhpcy5yb3dPZmZzZXQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly8gdXBkYXRlIHJvdyBpbnRlcm5hbHMgdG8gbWF0Y2ggbW9kZWxcblx0XHR0aGlzLnNldHVwSXRlbShpbmRleCk7XG5cdFx0dmFyIG4gPSB0aGlzLmZldGNoUm93Tm9kZShpbmRleCk7XG5cdFx0Rmx5d2VpZ2h0UmVwZWF0ZXIuY2xhaW1Ob2RlKHRoaXMuJC5jbGllbnQsIG4pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFByZXZlbnRzIHJlbmRlcmluZyBvZiBjaGFuZ2VzIG1hZGUgdG8gY29udHJvbHMgaW5zaWRlIHRoZSByZXBlYXRlci5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bG9ja1JvdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5jbGllbnQudGVhcmRvd25DaGlsZHJlbigpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFByZXBhcmVzIHRoZSBzcGVjaWZpZWQgcm93IHN1Y2ggdGhhdCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGNvbnRyb2xzIGluIHRoZVxuXHQqIHJlcGVhdGVyIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIHJvdzsgdGhlbiBwZXJmb3JtcyB0aGUgZnVuY3Rpb24gYGZ1bmNgXG5cdCogYW5kLCBmaW5hbGx5LCBsb2NrcyB0aGUgcm93LlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0byBiZSBhY3RlZCB1cG9uLlxuXHQqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgIC0gVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0uXG5cdCogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB3aGljaCBgZnVuY2AgaXMgYm91bmQuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cGVyZm9ybU9uUm93OiBmdW5jdGlvbiAoaW5kZXgsIGZ1bmMsIGNvbnRleHQpIHtcblx0XHQvLyBkbyBub3RoaW5nIGlmIGluZGV4IGlzIG91dC1vZi1yYW5nZVxuXHRcdGlmIChpbmRleCA8IHRoaXMucm93T2Zmc2V0IHx8IGluZGV4ID49IHRoaXMuY291bnQgKyB0aGlzLnJvd09mZnNldCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoZnVuYykge1xuXHRcdFx0dGhpcy5wcmVwYXJlUm93KGluZGV4KTtcblx0XHRcdHV0aWxzLmNhbGwoY29udGV4dCB8fCBudWxsLCBmdW5jKTtcblx0XHRcdHRoaXMubG9ja1JvdygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAbGVuZHMgZW55by5GbHl3ZWlnaHRSZXBlYXRlclxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0YXRpY3M6IHtcblx0XHQvKipcblx0XHQqIEFzc29jaWF0ZXMgYSBmbHl3ZWlnaHQgcmVuZGVyZWQgY29udHJvbCAoYGNvbnRyb2xgKSB3aXRoIGFcblx0XHQqIHJlbmRlcmluZyBjb250ZXh0IHNwZWNpZmllZCBieSBgbm9kZWAuXG5cdFx0KlxuXHRcdCogQHBhcmFtIHtlbnlvLkNvbnRyb2x9IGNvbnRyb2wgLSBBIGZseXdlaWdodC1yZW5kZXJlZCBjb250cm9sLlxuXHRcdCogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIERPTSBub2RlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBgY29udHJvbGAuXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRjbGFpbU5vZGU6IGZ1bmN0aW9uIChjb250cm9sLCBub2RlKSB7XG5cdFx0XHR2YXIgbjtcblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdGlmIChub2RlLmlkICE9PSBjb250cm9sLmlkKSB7XG5cdFx0XHRcdFx0biA9IG5vZGUucXVlcnlTZWxlY3RvcignIycgKyBjb250cm9sLmlkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBub2RlIGlzIGFscmVhZHkgdGhlIHJpZ2h0IG5vZGUsIHNvIGp1c3QgdXNlIGl0XG5cdFx0XHRcdFx0biA9IG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEZJWE1FOiBjb25zaWRlciBjb250cm9scyBnZW5lcmF0ZWQgaWYgd2UgZm91bmQgYSBub2RlIG9yIHRhZzogbnVsbCwgdGhlIGxhdGVyIHNvIGNhbiB0ZWFyZG93biByZW5kZXJcblx0XHRcdGNvbnRyb2wuZ2VuZXJhdGVkID0gQm9vbGVhbihuIHx8ICFjb250cm9sLnRhZyk7XG5cdFx0XHRjb250cm9sLm5vZGUgPSBuO1xuXHRcdFx0aWYgKGNvbnRyb2wubm9kZSkge1xuXHRcdFx0XHRjb250cm9sLnJlbmRlcmVkKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvL2VueW8ubG9nKCdGYWlsZWQgdG8gZmluZCBub2RlIGZvcicsICBjb250cm9sLmlkLCBjb250cm9sLmdlbmVyYXRlZCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgY29udHJvbCdzIGNsYXNzIGNhY2hlIGJhc2VkIG9uIHRoZSBub2RlIGNvbnRlbnRzXG5cdFx0XHRmb3IgKHZhciBpPTAsIGMkPWNvbnRyb2wuY2hpbGRyZW4sIGM7IChjPWMkW2ldKTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY2xhaW1Ob2RlKGMsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW8vbGliL0NvbnRyb2xcIjoxNixcIi4uLy4uL2VueW8vbGliL0hUTUxTdHJpbmdEZWxlZ2F0ZVwiOjIyLFwiLi4vLi4vZW55by9saWIvU2VsZWN0aW9uXCI6NDYsXCIuLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uL2VueW8vbGliL3V0aWxzXCI6NzV9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0NvbnRyb2wnKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkltYWdlVmlld1Bpbn0gaXMgYSBjb250cm9sIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheVxuKiBub24tem9vbWluZyBjb250ZW50IGluc2lkZSBvZiBhIHpvb21hYmxlIHtAbGluayBlbnlvLkltYWdlVmlld30gY29udHJvbC4gVGhlXG4qIFthbmNob3Jde0BsaW5rIGVueW8uSW1hZ2VWaWV3UGluI2FuY2hvcn0gYW5kXG4qIFtwb3NpdGlvbl17QGxpbmsgZW55by5JbWFnZVZpZXdQaW4jcG9zaXRpb259IHByb3BlcnRpZXMgbWF5IGJlIHVzZWQgdG9cbiogcG9zaXRpb24gYm90aCB0aGUgSW1hZ2VWaWV3UGluIGFuZCBpdHMgY29udGVudCBpbiBhIHNwZWNpZmljIGxvY2F0aW9uIHdpdGhpblxuKiB0aGUgSW1hZ2VWaWV3LlxuKlxuKiBAdWlcbiogQGNsYXNzIGVueW8uSW1hZ2VWaWV3UGluXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uSW1hZ2VWaWV3UGluLnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uSW1hZ2VWaWV3UGluJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBDb250cm9sLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLkltYWdlVmlld1Bpbi5wcm90b3R5cGVcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IHtcblx0XHQvKipcblx0XHQqIElmIGB0cnVlYCwgdGhlIGFuY2hvciBwb2ludCBmb3IgdGhpcyBwaW4gd2lsbCBiZSBoaWdobGlnaHRlZCBpbiB5ZWxsb3csXG5cdFx0KiB3aGljaCBjYW4gYmUgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0aGlnaGxpZ2h0QW5jaG9yUG9pbnQ6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBUaGUgY29vcmRpbmF0ZXMgYXQgd2hpY2ggdGhpcyBjb250cm9sIHNob3VsZCBiZSBhbmNob3JlZCBpbnNpZGVcblx0XHQqIG9mIHRoZSBwYXJlbnQgSW1hZ2VWaWV3IGNvbnRyb2wuIFRoaXMgcG9zaXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlXG5cdFx0KiBJbWFnZVZpZXcgY29udHJvbCdzIG9yaWdpbmFsIHNpemUuIFdvcmtzIGxpa2Ugc3RhbmRhcmQgQ1NTIHBvc2l0aW9uaW5nLFxuXHRcdCogYW5kIGFjY2VwdHMgYm90aCBweCBhbmQgcGVyY2VudGFnZSB2YWx1ZXMuXG5cdFx0KlxuXHRcdCogKiBgdG9wYDogRGlzdGFuY2UgZnJvbSB0aGUgcGFyZW50J3MgdG9wIGVkZ2UuXG5cdFx0KiAqIGBib3R0b21gOiBEaXN0YW5jZSBmcm9tIHRoZSBwYXJlbnQncyBib3R0b20gZWRnZSAob3ZlcnJpZGVzIGB0b3BgKS5cblx0XHQqICogYGxlZnRgOiBEaXN0YW5jZSBmcm9tIHRoZSBwYXJlbnQncyBsZWZ0IGVkZ2UuXG5cdFx0KiAqIGByaWdodGA6IERpc3RhbmNlIGZyb20gdGhlIHBhcmVudCdzIHJpZ2h0IGVkZ2UgKG92ZXJyaWRlcyBgbGVmdGApLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtPYmplY3R9XG5cdFx0KiBAZGVmYXVsdCB7dG9wOiAwcHgsIGxlZnQ6IDBweH1cblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGFuY2hvcjoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0bGVmdDogMFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQqIFRoZSBjb29yZGluYXRlcyBhdCB3aGljaCB0aGUgY29udGVudHMgb2YgdGhpcyBjb250cm9sIHNob3VsZCBiZVxuXHRcdCogcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgSW1hZ2VWaWV3UGluIGl0c2VsZi4gV29ya3MgbGlrZSBzdGFuZGFyZFxuXHRcdCogQ1NTIHBvc2l0aW9uaW5nLiBPbmx5IGFjY2VwdHMgcHggdmFsdWVzLiBEZWZhdWx0cyB0b1xuXHRcdCogYHt0b3A6IDBweCwgbGVmdDogMHB4fWAuXG5cdFx0KlxuXHRcdCogKiBgdG9wYDogRGlzdGFuY2UgZnJvbSB0aGUgSW1hZ2VWaWV3UGluJ3MgdG9wIGVkZ2UuXG5cdFx0KiAqIGBib3R0b21gOiBEaXN0YW5jZSBmcm9tIHRoZSBJbWFnZVZpZXdQaW4ncyBib3R0b20gZWRnZS5cblx0XHQqICogYGxlZnRgOiBEaXN0YW5jZSBmcm9tIHRoZSBJbWFnZVZpZXdQaW4ncyBsZWZ0IGVkZ2UuXG5cdFx0KiAqIGByaWdodGA6IERpc3RhbmNlIGZyb20gdGhlIEltYWdlVmlld1BpbidzIHJpZ2h0IGVkZ2UuXG5cdFx0KlxuXHRcdCogQHR5cGUge09iamVjdH1cblx0XHQqIEBkZWZhdWx0IHt0b3A6IDBweCwgbGVmdDogMHB4fVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdHRvcDogMCxcblx0XHRcdGxlZnQ6IDBcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3R5bGU6ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwMDA7d2lkdGg6MHB4O2hlaWdodDowcHg7JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVyczoge1xuXHRcdG9uUG9zaXRpb25QaW46ICdyZUFuY2hvcidcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Q29udHJvbC5wcm90b3R5cGUuY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zdHlsZUNsaWVudENvbnRyb2xzKCk7XG5cdFx0dGhpcy5wb3NpdGlvbkNsaWVudENvbnRyb2xzKCk7XG5cdFx0dGhpcy5oaWdobGlnaHRBbmNob3JQb2ludENoYW5nZWQoKTtcblx0XHR0aGlzLmFuY2hvckNoYW5nZWQoKTtcblx0fSxcblxuXHQvKipcblx0KiBBYnNvbHV0ZWx5IHBvc2l0aW9ucyBjbGllbnQgY29udHJvbHMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdHlsZUNsaWVudENvbnRyb2xzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRyb2xzID0gdGhpcy5nZXRDbGllbnRDb250cm9scygpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29udHJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnRyb2xzW2ldLmFwcGx5U3R5bGUoJ3Bvc2l0aW9uJywnYWJzb2x1dGUnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQXBwbGllcyBzcGVjaWZpZWQgcG9zaXRpb25pbmcgdG8gY2xpZW50IGNvbnRyb2xzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cG9zaXRpb25DbGllbnRDb250cm9sczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250cm9scyA9IHRoaXMuZ2V0Q2xpZW50Q29udHJvbHMoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRyb2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBwIGluIHRoaXMucG9zaXRpb24pIHtcblx0XHRcdFx0Y29udHJvbHNbaV0uYXBwbHlTdHlsZShwLCB0aGlzLnBvc2l0aW9uW3BdKydweCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBVcGRhdGVzIHN0eWxpbmcgb2YgYW5jaG9yIHBvaW50LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGlnaGxpZ2h0QW5jaG9yUG9pbnRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5hZGRSZW1vdmVDbGFzcygncGluRGVidWcnLCB0aGlzLmhpZ2hsaWdodEFuY2hvclBvaW50KTtcblx0fSxcblxuXHQvKipcblx0KiBDcmVhdGVzIGBjb29yZHNgIG9iamVjdCBmb3IgZWFjaCBhbmNob3IsIGNvbnRhaW5pbmcgdmFsdWUgYW5kIHVuaXRzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YW5jaG9yQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb29yZHMgPSBudWxsLCBhID0gbnVsbDtcblx0XHRmb3IgKGEgaW4gdGhpcy5hbmNob3IpIHtcblx0XHRcdGNvb3JkcyA9IHRoaXMuYW5jaG9yW2FdLnRvU3RyaW5nKCkubWF0Y2goL14oXFxkKyg/OlxcLlxcZCspPykoLiopJC8pO1xuXHRcdFx0aWYgKCFjb29yZHMpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFuY2hvclthKydDb29yZHMnXSA9IHtcblx0XHRcdFx0dmFsdWU6IGNvb3Jkc1sxXSxcblx0XHRcdFx0dW5pdHM6IGNvb3Jkc1syXSB8fCAncHgnXG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblxuXHQvKlxuXHQqIEFwcGxpZXMgcG9zaXRpb25pbmcgdG8gSW1hZ2VWaWV3UGluIHNwZWNpZmllZCBpbiBgdGhpcy5hbmNob3JgLlxuXHQqIENhbGxlZCBhbnl0aW1lIHRoZSBwYXJlbnQgSW1hZ2VWaWV3IGlzIHJlc2NhbGVkLiBJZiBgcmlnaHQvYm90dG9tYFxuXHQqIGFyZSBzcGVjaWZpZWQsIHRoZXkgb3ZlcnJpZGUgYHRvcC9sZWZ0YC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlQW5jaG9yOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBzY2FsZSA9IGV2ZW50LnNjYWxlO1xuXHRcdHZhciBib3VuZHMgPSBldmVudC5ib3VuZHM7XG5cdFx0dmFyIGxlZnQgPSAodGhpcy5hbmNob3IucmlnaHQpXG5cdFx0XHQvLyBSaWdodFxuXHRcdFx0PyAodGhpcy5hbmNob3IucmlnaHRDb29yZHMudW5pdHMgPT0gJ3B4Jylcblx0XHRcdFx0PyAoYm91bmRzLndpZHRoICsgYm91bmRzLnggLSB0aGlzLmFuY2hvci5yaWdodENvb3Jkcy52YWx1ZSpzY2FsZSlcblx0XHRcdFx0OiAoYm91bmRzLndpZHRoKigxMDAtdGhpcy5hbmNob3IucmlnaHRDb29yZHMudmFsdWUpLzEwMCArIGJvdW5kcy54KVxuXHRcdFx0Ly8gTGVmdFxuXHRcdFx0OiAodGhpcy5hbmNob3IubGVmdENvb3Jkcy51bml0cyA9PSAncHgnKVxuXHRcdFx0XHQ/ICh0aGlzLmFuY2hvci5sZWZ0Q29vcmRzLnZhbHVlKnNjYWxlICsgYm91bmRzLngpXG5cdFx0XHRcdDogKGJvdW5kcy53aWR0aCp0aGlzLmFuY2hvci5sZWZ0Q29vcmRzLnZhbHVlLzEwMCArIGJvdW5kcy54KTtcblx0XHR2YXIgdG9wID0gKHRoaXMuYW5jaG9yLmJvdHRvbSlcblx0XHRcdC8vIEJvdHRvbVxuXHRcdFx0PyAodGhpcy5hbmNob3IuYm90dG9tQ29vcmRzLnVuaXRzID09ICdweCcpXG5cdFx0XHRcdD8gKGJvdW5kcy5oZWlnaHQgKyBib3VuZHMueSAtIHRoaXMuYW5jaG9yLmJvdHRvbUNvb3Jkcy52YWx1ZSpzY2FsZSlcblx0XHRcdFx0OiAoYm91bmRzLmhlaWdodCooMTAwLXRoaXMuYW5jaG9yLmJvdHRvbUNvb3Jkcy52YWx1ZSkvMTAwICsgYm91bmRzLnkpXG5cdFx0XHQvLyBUb3Bcblx0XHRcdDogKHRoaXMuYW5jaG9yLnRvcENvb3Jkcy51bml0cyA9PSAncHgnKVxuXHRcdFx0XHQ/ICh0aGlzLmFuY2hvci50b3BDb29yZHMudmFsdWUqc2NhbGUgKyBib3VuZHMueSlcblx0XHRcdFx0OiAoYm91bmRzLmhlaWdodCp0aGlzLmFuY2hvci50b3BDb29yZHMudmFsdWUvMTAwICsgYm91bmRzLnkpO1xuXHRcdHRoaXMuYXBwbHlTdHlsZSgnbGVmdCcsIGxlZnQrJ3B4Jyk7XG5cdFx0dGhpcy5hcHBseVN0eWxlKCd0b3AnLCB0b3ArJ3B4Jyk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9Db250cm9sXCI6MTYsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjZ9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9Db250cm9sJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBQdWxsZXIgaXMgY3JlYXRlZC5cbipcbiogQGV2ZW50IGVueW8uUHVsbGVyI29uQ3JlYXRlXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiB7QGxpbmsgZW55by5QdWxsZXJ9IGlzIGEgY29udHJvbCBkaXNwbGF5ZWQgd2l0aGluIGFuIHtAbGluayBlbnlvLlB1bGxkb3duTGlzdH1cbiogdG8gaW5kaWNhdGUgdGhhdCB0aGUgbGlzdCBpcyByZWZyZXNoaW5nIGR1ZSB0byBhIHB1bGwtdG8tcmVmcmVzaC5cbipcbiogQHVpXG4qIEBjbGFzcyBlbnlvLlB1bGxlclxuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlB1bGxlci5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLlB1bGxlcicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGFzc2VzOiAnZW55by1wdWxsZXInLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLlB1bGxlci5wcm90b3R5cGVcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IHtcblx0XHQvKipcblx0XHQqIFRleHQgdG8gZGlzcGxheSBiZWxvdyBpY29uLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAnJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dGV4dDogJycsXG5cblx0XHQvKipcblx0XHQqIENTUyBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBpY29uIGNvbnRyb2wuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICcnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRpY29uQ2xhc3M6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiB7XG5cdFx0b25DcmVhdGU6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnaWNvbid9LFxuXHRcdHtuYW1lOiAndGV4dCcsIHRhZzogJ3NwYW4nLCBjbGFzc2VzOiAnZW55by1wdWxsZXItdGV4dCd9XG5cdF0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdENvbnRyb2wucHJvdG90eXBlLmNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMuZG9DcmVhdGUoKTtcblx0XHR0aGlzLnRleHRDaGFuZ2VkKCk7XG5cdFx0dGhpcy5pY29uQ2xhc3NDaGFuZ2VkKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGV4dENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQudGV4dC5zZXRDb250ZW50KHRoaXMudGV4dCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aWNvbkNsYXNzQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5pY29uLnNldENsYXNzZXModGhpcy5pY29uQ2xhc3MpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQ29udHJvbFwiOjE2LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2fV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9kb20nKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9wbGF0Zm9ybScpLFxuXHRBbmltYXRvciA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL0FuaW1hdG9yJyksXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9Db250cm9sJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBTbGlkZWFibGUgZmluaXNoZXMgYW5pbWF0aW5nLlxuKlxuKiBAZXZlbnQgZW55by5TbGlkZWFibGUjb25BbmltYXRlRmluaXNoXG4qIEB0eXBlIHtlbnlvLkFuaW1hdG9yfVxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiB0aGUgcG9zaXRpb24gKGkuZS4sIFt2YWx1ZV17QGxpbmsgZW55by5TbGlkZWFibGUjdmFsdWV9KSBvZiB0aGVcbiogU2xpZGVhYmxlIGNoYW5nZXMuXG4qXG4qIEBldmVudCBlbnlvLlNsaWRlYWJsZSNvbkNoYW5nZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uU2xpZGVhYmxlfSBpcyBhIGNvbnRyb2wgdGhhdCBtYXkgYmUgZHJhZ2dlZCBlaXRoZXIgaG9yaXpvbnRhbGx5XG4qIG9yIHZlcnRpY2FsbHkgYmV0d2VlbiBhIG1pbmltdW0gYW5kIGEgbWF4aW11bSB2YWx1ZS4gV2hlbiByZWxlYXNlZCBmcm9tXG4qIGRyYWdnaW5nLCBhIFNsaWRlYWJsZSB3aWxsIGFuaW1hdGUgdG8gaXRzIG1pbmltdW0gb3IgbWF4aW11bSBwb3NpdGlvbixcbiogZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGRyYWcuXG4qXG4qIFRoZSBbbWluXXtAbGluayBlbnlvLlNsaWRlYWJsZSNtaW59IHZhbHVlIHNwZWNpZmllcyBhIHBvc2l0aW9uIHRvIHRoZSBsZWZ0IG9mLFxuKiBvciBhYm92ZSwgdGhlIGluaXRpYWwgcG9zaXRpb24sIHRvIHdoaWNoIHRoZSBTbGlkZWFibGUgbWF5IGJlIGRyYWdnZWQuXG4qIFRoZSBbbWF4XXtAbGluayBlbnlvLlNsaWRlYWJsZSNtYXh9IHZhbHVlIHNwZWNpZmllcyBhIHBvc2l0aW9uIHRvIHRoZSByaWdodCBvZixcbiogb3IgYmVsb3csIHRoZSBpbml0aWFsIHBvc2l0aW9uLCB0byB3aGljaCB0aGUgU2xpZGVhYmxlIG1heSBiZSBkcmFnZ2VkLlxuKiBUaGUgW3ZhbHVlXXtAbGluayBlbnlvLlNsaWRlYWJsZSN2YWx1ZX0gcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4qIG9mIHRoZSBTbGlkZWFibGUsIGJldHdlZW4gdGhlIG1pbmltdW0gYW5kIG1heGltdW0gcG9zaXRpb25zLlxuKlxuKiBgbWluYCwgYG1heGAsIGFuZCBgdmFsdWVgIG1heSBiZSBzcGVjaWZpZWQgaW4gdW5pdHMgb2YgJ3B4JyBvciAnJScuXG4qXG4qIFRoZSBbYXhpc117QGxpbmsgZW55by5TbGlkZWFibGUjYXhpc30gcHJvcGVydHkgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBTbGlkZWFibGVcbiogc2xpZGVzIGxlZnQtdG8tcmlnaHQgKCdoJykgb3IgdXAtYW5kLWRvd24gKCd2JykuXG4qXG4qIFRoZSBmb2xsb3dpbmcgY29udHJvbCBpcyBwbGFjZWQgOTAlIG9mZiB0aGUgc2NyZWVuIHRvIHRoZSByaWdodCwgYW5kIHNsaWRlc1xuKiB0byBpdHMgbmF0dXJhbCBwb3NpdGlvbjpcbipcbiogYGBgXG4qIHtraW5kOiAnZW55by5TbGlkZWFibGUnLCB2YWx1ZTogLTkwLCBtaW46IC05MCwgdW5pdDogJyUnLFxuKiBcdGNsYXNzZXM6ICdlbnlvLWZpdCcsIHN0eWxlOiAnd2lkdGg6IDMwMHB4OycsXG4qIFx0Y29tcG9uZW50czogW1xuKiBcdFx0e2NvbnRlbnQ6ICdzdHVmZid9XG4qIFx0XVxuKiB9XG4qIGBgYFxuKlxuKiBAdWlcbiogQGNsYXNzICBlbnlvLlNsaWRlYWJsZVxuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyAgZW55by5TbGlkZWFibGUucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5TbGlkZWFibGUnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IENvbnRyb2wsXG5cblx0LyoqXG5cdCogQGxlbmRzIGVueW8uU2xpZGVhYmxlLnByb3RvdHlwZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXHRcdC8qKlxuXHRcdCogRGlyZWN0aW9uIG9mIHNsaWRpbmc7IHZhbGlkIHZhbHVlcyBhcmUgYCdoJ2AgZm9yIGhvcml6b25hbCBvciBgJ3YnYCBmb3IgdmVydGljYWwuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdoJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YXhpczogJ2gnLFxuXG5cdFx0LyoqXG5cdFx0KiBDdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBTbGlkZWFibGUgKGEgdmFsdWUgYmV0d2VlblxuXHRcdCogW21pbl17QGxpbmsgZW55by5TbGlkZWFibGUjbWlufSBhbmQgW21heF17QGxpbmsgZW55by5TbGlkZWFibGUjbWF4fSkuXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0ICAwXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR2YWx1ZTogMCxcblxuXHRcdC8qKlxuXHRcdCogVW5pdCBmb3IgW21pbl17QGxpbmsgZW55by5TbGlkZWFibGUjbWlufSwgW21heF17QGxpbmsgZW55by5TbGlkZWFibGUjbWF4fSxcblx0XHQqIGFuZCBbdmFsdWVde0BsaW5rIGVueW8uU2xpZGVhYmxlI3ZhbHVlfTsgdmFsaWQgdmFsdWVzIGFyZSBgJ3B4J2Agb3IgYCclJ2AuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICAncHgnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR1bml0OiAncHgnLFxuXG5cdFx0LyoqXG5cdFx0KiBUaGUgbWluaW11bSB2YWx1ZSB0byBzbGlkZSB0by5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0bWluOiAwLFxuXG5cdFx0LyoqXG5cdFx0KiBUaGUgbWF4aW11bSB2YWx1ZSB0byBzbGlkZSB0by5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgIDBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG1heDogMCxcblxuXHRcdC8qKlxuXHRcdCogV2hlbiB0cnV0aHksIGFwcGxpZXMgQ1NTIHN0eWxlcyB0byBhbGxvdyBHUFUgY29tcG9zaXRpbmcgb2Ygc2xpZGVhYmxlXG5cdFx0KiBjb250ZW50LCBpZiBhbGxvd2VkIGJ5IHRoZSBwbGF0Zm9ybS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgICdhdXRvJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YWNjZWxlcmF0ZWQ6ICdhdXRvJyxcblxuXHRcdC8qKlxuXHRcdCogU2V0IHRvIGBmYWxzZWAgdG8gcHJldmVudCB0aGUgU2xpZGVhYmxlIGZyb20gZHJhZ2dpbmcgd2l0aCBlbGFzdGljaXR5XG5cdFx0KiBwYXN0IGl0cyBbbWluXXtAbGluayBlbnlvLlNsaWRlYWJsZSNtaW59IG9yIFttYXhde0BsaW5rIGVueW8uU2xpZGVhYmxlI21heH1cblx0XHQqIHZhbHVlLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgIHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG92ZXJNb3Zpbmc6IHRydWUsXG5cblx0XHQvKipcblx0XHQqIEluZGljYXRlcyB3aGV0aGVyIGRyYWdnaW5nIGlzIGFsbG93ZWQuIFNldCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZHJhZ2dpbmcuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0ZHJhZ2dhYmxlOiB0cnVlXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiB7XG5cdFx0b25BbmltYXRlRmluaXNoOiAnJyxcblx0XHRvbkNoYW5nZTogJydcblx0fSxcblxuXHQvKipcblx0KiBTZXQgdG8gYHRydWVgIHRvIHByZXZlbnQgZHJhZyBldmVudHMgZnJvbSBidWJibGluZyBiZXlvbmQgdGhlIFNsaWRlYWJsZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHByZXZlbnREcmFnUHJvcGFnYXRpb246IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRvb2xzOiBbXG5cdFx0e2tpbmQ6IEFuaW1hdG9yLCBvblN0ZXA6ICdhbmltYXRvclN0ZXAnLCBvbkVuZDogJ2FuaW1hdG9yQ29tcGxldGUnfVxuXHRdLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZXJzOiB7XG5cdFx0b25kcmFnc3RhcnQ6ICdkcmFnc3RhcnQnLFxuXHRcdG9uZHJhZzogJ2RyYWcnLFxuXHRcdG9uZHJhZ2ZpbmlzaDogJ2RyYWdmaW5pc2gnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a0RyYWdTY2FsYXI6IDEsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ0V2ZW50UHJvcDogJ2R4JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR1bml0TW9kaWZpZXI6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhblRyYW5zZm9ybTogZmFsc2UsXG5cblx0LyoqXG5cdCogSW5kaWNhdGVzIHdoaWNoIHByb3BlcnR5IG9mIHRoZSBkcmFnIGV2ZW50IGlzIHVzZWQgdG8gcG9zaXRpb24gdGhlIGNvbnRyb2wuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnTW92ZVByb3A6ICdkeCcsXG5cblx0LyoqXG5cdCogSW5kaWNhdGVzIHdoaWNoIHByb3BlcnR5IG9mIHRoZSBkcmFnIGV2ZW50IGlzIHVzZWQgdG8gYWxsb3cgZHJhZ2dpbmcuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGREcmFnUHJvcDogJ2hvcml6b250YWwnLFxuXG5cdC8qKlxuXHQqIFRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gbW9kaWZ5LCBwcm92aWRlZCB0aGF0XG5cdCogW2NhblRyYW5zZm9ybV17QGxpbmsgZW55by5TbGlkZWFibGUjY2FuVHJhbnNmb3JtfSBpcyBgdHJ1ZWAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0cmFuc2Zvcm06ICd0cmFuc2xhdGVYJyxcblxuXHQvKipcblx0KiBUaGUgZGltZW5zaW9uIGF0dHJpYnV0ZSB0byBtb2RpZnk7IHdpbGwgYmUgZWl0aGVyIGAnaGVpZ2h0J2Agb3IgYCd3aWR0aCdgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGltZW5zaW9uOiAnd2lkdGgnLFxuXG5cdC8qKlxuXHQqIFRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgdG8gbW9kaWZ5OyB3aWxsIGJlIGVpdGhlciBgJ3RvcCdgIG9yIGAnbGVmdCdgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Ym91bmRhcnk6ICdsZWZ0JyxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuYWNjZWxlcmF0ZWRDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybUNoYW5nZWQoKTtcblx0XHRcdHRoaXMuYXhpc0NoYW5nZWQoKTtcblx0XHRcdHRoaXMudmFsdWVDaGFuZ2VkKCk7XG5cdFx0XHR0aGlzLmFkZENsYXNzKCdlbnlvLXNsaWRlYWJsZScpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbml0Q29tcG9uZW50czoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jcmVhdGVDb21wb25lbnRzKHRoaXMudG9vbHMpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuY2FuTW9kaWZ5VW5pdCgpO1xuXHRcdFx0dGhpcy51cGRhdGVEcmFnU2NhbGFyKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZVJlc2l6ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnVwZGF0ZURyYWdTY2FsYXIoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBJZiB0cmFuc2Zvcm1zIGNhbid0IGJlIHVzZWQgYW5kIGlubGluZSBzdHlsZSBpcyB1c2luZyAncHgnIHdoaWxlXG5cdCogW3VuaXRde0BsaW5rIGVueW8uU2xpZGVhYmxlI3VuaXR9IGlzIGAnJSdgLCB0aGlzIHNldHMgdGhlXG5cdCogW3VuaXRNb2RpZmllcl17QGxpbmsgZW55by5TbGlkZWFibGUjdW5pdE1vZGlmaWVyfSBwcm9wZXJ0eSB0byB0aGUgY3VycmVudFxuXHQqIHZhbHVlIG9mIFtkaW1lbnNpb25de0BsaW5rIGVueW8uU2xpZGVhYmxlI2RpbWVuc2lvbn0uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYW5Nb2RpZnlVbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmNhblRyYW5zZm9ybSkge1xuXHRcdFx0dmFyIGIgPSB0aGlzLmdldEluaXRpYWxTdHlsZVZhbHVlKHRoaXMuaGFzTm9kZSgpLCB0aGlzLmJvdW5kYXJ5KTtcblx0XHRcdC8vIElmIGlubGluZSBzdHlsZSBvZiAncHgnIGV4aXN0cywgd2hpbGUgdW5pdCBpcyAnJSdcblx0XHRcdGlmIChiLm1hdGNoKC9weC9pKSAmJiAodGhpcy51bml0ID09PSAnJScpKSB7XG5cdFx0XHRcdC8vIFNldCB1bml0TW9kaWZpZXIgLSB1c2VkIHRvIG92ZXItcmlkZSAnJSdcblx0XHRcdFx0dGhpcy51bml0TW9kaWZpZXIgPSB0aGlzLmdldEJvdW5kcygpW3RoaXMuZGltZW5zaW9uXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0SW5pdGlhbFN0eWxlVmFsdWU6IGZ1bmN0aW9uIChub2RlLCBib3VuZGFyeSkge1xuXHRcdHZhciBzID0gZG9tLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdFx0aWYgKHMpIHtcblx0XHRcdHJldHVybiBzLmdldFByb3BlcnR5VmFsdWUoYm91bmRhcnkpO1xuXHRcdH0gZWxzZSBpZiAobm9kZSAmJiBub2RlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0cmV0dXJuIG5vZGUuY3VycmVudFN0eWxlW2JvdW5kYXJ5XTtcblx0XHR9XG5cdFx0cmV0dXJuICcwJztcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR1cGRhdGVCb3VuZHM6IGZ1bmN0aW9uIChpblZhbHVlLCBpbkRpbWVuc2lvbnMpIHtcblx0XHR2YXIgaW5Cb3VuZHMgPSB7fTtcblx0XHRpbkJvdW5kc1t0aGlzLmJvdW5kYXJ5XSA9IGluVmFsdWU7XG5cdFx0dGhpcy5zZXRCb3VuZHMoaW5Cb3VuZHMsIHRoaXMudW5pdCk7XG5cblx0XHR0aGlzLnNldElubGluZVN0eWxlcyhpblZhbHVlLCBpbkRpbWVuc2lvbnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZURyYWdTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy51bml0ID09ICclJykge1xuXHRcdFx0dmFyIGQgPSB0aGlzLmdldEJvdW5kcygpW3RoaXMuZGltZW5zaW9uXTtcblx0XHRcdHRoaXMua0RyYWdTY2FsYXIgPSBkID8gMTAwIC8gZCA6IDE7XG5cblx0XHRcdGlmICghdGhpcy5jYW5UcmFuc2Zvcm0pIHtcblx0XHRcdFx0dGhpcy51cGRhdGVCb3VuZHModGhpcy52YWx1ZSwgMTAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dHJhbnNmb3JtQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuVHJhbnNmb3JtID0gZG9tLmNhblRyYW5zZm9ybSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFjY2VsZXJhdGVkQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghcGxhdGZvcm0uYW5kcm9pZCB8fCBwbGF0Zm9ybS5hbmRyb2lkIDw9IDIpIHtcblx0XHRcdGRvbS5hY2NlbGVyYXRlKHRoaXMsIHRoaXMuYWNjZWxlcmF0ZWQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRheGlzQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoID0gdGhpcy5heGlzID09ICdoJztcblx0XHR0aGlzLmRyYWdNb3ZlUHJvcCA9IGggPyAnZHgnIDogJ2R5Jztcblx0XHR0aGlzLnNob3VsZERyYWdQcm9wID0gaCA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG5cdFx0dGhpcy50cmFuc2Zvcm0gPSBoID8gJ3RyYW5zbGF0ZVgnIDogJ3RyYW5zbGF0ZVknO1xuXHRcdHRoaXMuZGltZW5zaW9uID0gaCA/ICd3aWR0aCcgOiAnaGVpZ2h0Jztcblx0XHR0aGlzLmJvdW5kYXJ5ID0gaCA/ICdsZWZ0JyA6ICd0b3AnO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldElubGluZVN0eWxlczogZnVuY3Rpb24gKHZhbHVlLCBkaW1lbnNpb25zKSB7XG5cdFx0dmFyIGluQm91bmRzID0ge307XG5cblx0XHRpZiAodGhpcy51bml0TW9kaWZpZXIpIHtcblx0XHRcdGluQm91bmRzW3RoaXMuYm91bmRhcnldID0gdGhpcy5wZXJjZW50VG9QaXhlbHModmFsdWUsIHRoaXMudW5pdE1vZGlmaWVyKTtcblx0XHRcdGluQm91bmRzW3RoaXMuZGltZW5zaW9uXSA9IHRoaXMudW5pdE1vZGlmaWVyO1xuXHRcdFx0dGhpcy5zZXRCb3VuZHMoaW5Cb3VuZHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZGltZW5zaW9ucykge1xuXHRcdFx0XHRpbkJvdW5kc1t0aGlzLmRpbWVuc2lvbl0gPSBkaW1lbnNpb25zO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5Cb3VuZHNbdGhpcy5ib3VuZGFyeV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2V0Qm91bmRzKGluQm91bmRzLCB0aGlzLnVuaXQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5TbGlkZWFibGUjb25DaGFuZ2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR2YWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uIChpbkxhc3QpIHtcblx0XHR2YXIgdiA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKHRoaXMuaXNPb2IodikgJiYgIXRoaXMuaXNBbmltYXRpbmcoKSkge1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMub3Zlck1vdmluZyA/IHRoaXMuZGFtcFZhbHVlKHYpIDogdGhpcy5jbGFtcFZhbHVlKHYpO1xuXHRcdH1cblx0XHQvLyBGSVhNRTogYW5kcm9pZCBjYW5ub3QgaGFuZGxlIG5lc3RlZCBjb21wb3NpdGluZyB3ZWxsIHNvIGFwcGx5IGFjY2VsZXJhdGlvbiBvbmx5IGlmIG5lZWRlZFxuXHRcdC8vIGRlc2t0b3AgY2hyb21lIGRvZXNuJ3QgbGlrZSB0aGlzIGNvZGUgcGF0aCBzbyBhdm9pZC4uLlxuXHRcdGlmIChwbGF0Zm9ybS5hbmRyb2lkID4gMikge1xuXHRcdFx0aWYgKHRoaXMudmFsdWUpIHtcblx0XHRcdFx0aWYgKGluTGFzdCA9PT0gMCB8fCBpbkxhc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRvbS5hY2NlbGVyYXRlKHRoaXMsIHRoaXMuYWNjZWxlcmF0ZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uYWNjZWxlcmF0ZSh0aGlzLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgcGxhdGZvcm0gc3VwcG9ydHMgdHJhbnNmb3Jtc1xuXHRcdGlmICh0aGlzLmNhblRyYW5zZm9ybSkge1xuXHRcdFx0ZG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMsIHRoaXMudHJhbnNmb3JtLCB0aGlzLnZhbHVlICsgdGhpcy51bml0KTtcblx0XHQvLyBlbHNlIHVwZGF0ZSBpbmxpbmUgc3R5bGVzXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0SW5saW5lU3R5bGVzKHRoaXMudmFsdWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5kb0NoYW5nZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldEFuaW1hdG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuJC5hbmltYXRvcjtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpc0F0TWluOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgPD0gdGhpcy5jYWxjTWluKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNBdE1heDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlID49IHRoaXMuY2FsY01heCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNNaW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5taW47XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY01heDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm1heDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGFtcFZhbHVlOiBmdW5jdGlvbiAoaW5WYWx1ZSkge1xuXHRcdHZhciBtaW4gPSB0aGlzLmNhbGNNaW4oKTtcblx0XHR2YXIgbWF4ID0gdGhpcy5jYWxjTWF4KCk7XG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oaW5WYWx1ZSwgbWF4KSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGFtcFZhbHVlOiBmdW5jdGlvbiAoaW5WYWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmRhbXBCb3VuZCh0aGlzLmRhbXBCb3VuZChpblZhbHVlLCB0aGlzLm1pbiwgMSksIHRoaXMubWF4LCAtMSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGFtcEJvdW5kOiBmdW5jdGlvbiAoaW5WYWx1ZSwgaW5Cb3VuZGFyeSwgaW5TaWduKSB7XG5cdFx0dmFyIHYgPSBpblZhbHVlO1xuXHRcdGlmICh2ICogaW5TaWduIDwgaW5Cb3VuZGFyeSAqIGluU2lnbikge1xuXHRcdFx0diA9IGluQm91bmRhcnkgKyAodiAtIGluQm91bmRhcnkpIC8gNDtcblx0XHR9XG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsY3VsYXRlcyB0aGUgcGl4ZWwgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIGBwZXJjZW50YCBhbmRcblx0KiBgZGltZW5zaW9uYC5cblx0KlxuXHQqIEBwYXJhbSAge051bWJlcn0gcGVyY2VudFxuXHQqIEBwYXJhbSAge051bWJlcn0gZGltZW5zaW9uXG5cdCpcblx0KiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0cGVyY2VudFRvUGl4ZWxzOiBmdW5jdGlvbiAocGVyY2VudCwgZGltZW5zaW9uKSB7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoKGRpbWVuc2lvbiAvIDEwMCkgKiBwZXJjZW50KTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwaXhlbHNUb1BlcmNlbnQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBib3VuZGFyeSA9IHRoaXMudW5pdE1vZGlmaWVyID8gdGhpcy5nZXRCb3VuZHMoKVt0aGlzLmRpbWVuc2lvbl0gOiB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZHMoKVt0aGlzLmRpbWVuc2lvbl07XG5cdFx0cmV0dXJuICh2YWx1ZSAvIGJvdW5kYXJ5KSAqIDEwMDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGREcmFnOiBmdW5jdGlvbiAoaW5FdmVudCkge1xuXHRcdHJldHVybiB0aGlzLmRyYWdnYWJsZSAmJiBpbkV2ZW50W3RoaXMuc2hvdWxkRHJhZ1Byb3BdO1xuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG91dCBvZiBib3VuZHMgKGkuZS4sIGdyZWF0ZXIgdGhhblxuXHQqIFttYXhde0BsaW5rIGVueW8uU2xpZGVhYmxlI21heH0gb3IgbGVzcyB0aGFuIFttaW5de0BsaW5rIGVueW8uU2xpZGVhYmxlI21pbn0pLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGluVmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBpblZhbHVlYCBpcyBvdXQgb2YgYm91bmRzOyBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNPb2I6IGZ1bmN0aW9uIChpblZhbHVlKSB7XG5cdFx0cmV0dXJuIGluVmFsdWUgPiB0aGlzLmNhbGNNYXgoKSB8fCBpblZhbHVlIDwgdGhpcy5jYWxjTWluKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ3N0YXJ0OiBmdW5jdGlvbiAoaW5TZW5kZXIsIGluRXZlbnQpIHtcblx0XHRpZiAodGhpcy5zaG91bGREcmFnKGluRXZlbnQpKSB7XG5cdFx0XHRpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLiQuYW5pbWF0b3Iuc3RvcCgpO1xuXHRcdFx0aW5FdmVudC5kcmFnSW5mbyA9IHt9O1xuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdFx0XHR0aGlzLmRyYWcwID0gdGhpcy52YWx1ZTtcblx0XHRcdHRoaXMuZHJhZ2QwID0gMDtcblx0XHRcdHJldHVybiB0aGlzLnByZXZlbnREcmFnUHJvcGFnYXRpb247XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgW3ZhbHVlXXtAbGluayBlbnlvLlNsaWRlYWJsZSN2YWx1ZX0gZHVyaW5nIGEgZHJhZyBhbmQgZGV0ZXJtaW5lcyB0aGVcblx0KiBkaXJlY3Rpb24gb2YgdGhlIGRyYWcuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnOiBmdW5jdGlvbiAoaW5TZW5kZXIsIGluRXZlbnQpIHtcblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xuXHRcdFx0aW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIGQgPSB0aGlzLmNhblRyYW5zZm9ybSA/IGluRXZlbnRbdGhpcy5kcmFnTW92ZVByb3BdICogdGhpcy5rRHJhZ1NjYWxhciA6IHRoaXMucGl4ZWxzVG9QZXJjZW50KGluRXZlbnRbdGhpcy5kcmFnTW92ZVByb3BdKTtcblx0XHRcdHZhciB2ID0gdGhpcy5kcmFnMCArIGQ7XG5cdFx0XHR2YXIgZGQgPSBkIC0gdGhpcy5kcmFnZDA7XG5cdFx0XHR0aGlzLmRyYWdkMCA9IGQ7XG5cdFx0XHRpZiAoZGQpIHtcblx0XHRcdFx0aW5FdmVudC5kcmFnSW5mby5taW5pbWl6aW5nID0gZGQgPCAwO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRWYWx1ZSh2KTtcblx0XHRcdHJldHVybiB0aGlzLnByZXZlbnREcmFnUHJvcGFnYXRpb247XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRyYWdmaW5pc2g6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuY29tcGxldGVEcmFnKGV2ZW50KTtcblx0XHRcdGV2ZW50LnByZXZlbnRUYXAoKTtcblx0XHRcdHJldHVybiB0aGlzLnByZXZlbnREcmFnUHJvcGFnYXRpb247XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEFuaW1hdGVzIHRoZSBjb250cm9sIHRvIGVpdGhlciB0aGUgW21pbl17QGxpbmsgZW55by5TbGlkZWFibGUjbWlufSBvclxuXHQqIFttYXhde0BsaW5rIGVueW8uU2xpZGVhYmxlI21heH0gdmFsdWUgd2hlbiBkcmFnZ2luZyBjb21wbGV0ZXMsIGJhc2VkIG9uIHRoZVxuXHQqIGRpcmVjdGlvbiBvZiB0aGUgZHJhZyAoZGV0ZXJtaW5lZCBpbiBbZHJhZygpXXtAbGluayBlbnlvLlNsaWRlYWJsZSNkcmFnfSkuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZURyYWc6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmNhbGNNYXgoKSAmJiB0aGlzLnZhbHVlICE9IHRoaXMuY2FsY01pbigpKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGVUb01pbk1heChldmVudC5kcmFnSW5mby5taW5pbWl6aW5nKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aXNBbmltYXRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy4kLmFuaW1hdG9yLmlzQW5pbWF0aW5nKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cGxheTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcblx0XHR0aGlzLiQuYW5pbWF0b3IucGxheSh7XG5cdFx0XHRzdGFydFZhbHVlOiBzdGFydCxcblx0XHRcdGVuZFZhbHVlOiBlbmQsXG5cdFx0XHRub2RlOiB0aGlzLmhhc05vZGUoKVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFuaW1hdGVzIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0KlxuXHQqIEBwYXJhbSAgIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGFuaW1hdGUgdG8uXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhbmltYXRlVG86IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMucGxheSh0aGlzLnZhbHVlLCB2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQW5pbWF0ZXMgdG8gdGhlIFttaW5pbXVtXXtAbGluayBlbnlvLlNsaWRlYWJsZSNtaW59IHZhbHVlLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhbmltYXRlVG9NaW46IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmFuaW1hdGVUbyh0aGlzLmNhbGNNaW4oKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQW5pbWF0ZXMgdG8gdGhlIFttYXhpbXVtXXtAbGluayBlbnlvLlNsaWRlYWJsZSNtYXh9IHZhbHVlLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhbmltYXRlVG9NYXg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmFuaW1hdGVUbyh0aGlzLmNhbGNNYXgoKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogSGVscGVyIG1ldGhvZCB0byB0b2dnbGUgYW5pbWF0aW9uIHRvIGVpdGhlciB0aGUgW21pbl17QGxpbmsgZW55by5TbGlkZWFibGUjbWlufVxuXHQqIG9yIFttYXhde0BsaW5rIGVueW8uU2xpZGVhYmxlI21heH0gdmFsdWUuXG5cdCpcblx0KiBAcGFyYW0gIHtCb29sZWFufSBtaW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YW5pbWF0ZVRvTWluTWF4OiBmdW5jdGlvbiAobWluKSB7XG5cdFx0aWYgKG1pbikge1xuXHRcdFx0dGhpcy5hbmltYXRlVG9NaW4oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hbmltYXRlVG9NYXgoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogVXBkYXRlcyB0aGUgW3ZhbHVlXXtAbGluayBlbnlvLlNsaWRlYWJsZSN2YWx1ZX0gcHJvcGVydHkgZHVyaW5nIGFuaW1hdGlvbi5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFuaW1hdG9yU3RlcDogZnVuY3Rpb24gKHNlbmRlcikge1xuXHRcdHRoaXMuc2V0VmFsdWUoc2VuZGVyLnZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5TbGlkZWFibGUjb25BbmltYXRlRmluaXNoXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YW5pbWF0b3JDb21wbGV0ZTogZnVuY3Rpb24gKHNlbmRlcikge1xuXHRcdHRoaXMuZG9BbmltYXRlRmluaXNoKHNlbmRlcik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogVG9nZ2xlcyBhbmltYXRpb24gdG8gZWl0aGVyIHRoZSBbbWluXXtAbGluayBlbnlvLlNsaWRlYWJsZSNtaW59IG9yXG5cdCogW21heF17QGxpbmsgZW55by5TbGlkZWFibGUjbWF4fSB2YWx1ZS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0dG9nZ2xlTWluTWF4OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5hbmltYXRlVG9NaW5NYXgoIXRoaXMuaXNBdE1pbigpKTtcblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW8vbGliL0FuaW1hdG9yXCI6NSxcIi4uLy4uL2VueW8vbGliL0NvbnRyb2xcIjoxNixcIi4uLy4uL2VueW8vbGliL2RvbVwiOjU4LFwiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vZW55by9saWIvcGxhdGZvcm1cIjo3MX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uLy4uL2VueW8nKTtcblxuXG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4va2luZCcpO1xudmFyXG5cdEdyb3VwSXRlbSA9IHJlcXVpcmUoJy4uL0dyb3VwSXRlbScpO1xuXG4vKipcbioge0BsaW5rIGVueW8uVG9vbERlY29yYXRvcn0gbGluZXMgdXAgW2NvbXBvbmVudHNde0BsaW5rIGVueW8uQ29tcG9uZW50fSBpbiBhIHJvdyxcbiogY2VudGVyZWQgdmVydGljYWxseS5cbipcbiogQGNsYXNzIGVueW8uVG9vbERlY29yYXRvclxuKiBAZXh0ZW5kcyBlbnlvLkdyb3VwSXRlbVxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlRvb2xEZWNvcmF0b3IucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Ub29sRGVjb3JhdG9yJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBHcm91cEl0ZW0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8tdG9vbC1kZWNvcmF0b3InXG59KTtcbn0se1wiLi4vLi4vLi4vZW55b1wiOjEsXCIuLi9Hcm91cEl0ZW1cIjoyMSxcIi4uL2tpbmRcIjo2Nn1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ29udHJvbCcpLFxuXHRJbWFnZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0ltYWdlJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBOb2RlIGlzIHRhcHBlZC4gTm8gYWRkaXRpb25hbCBkYXRhIGlzIHNlbnQgd2l0aCB0aGlzIGV2ZW50LlxuKlxuKiBAZXZlbnQgZW55by5Ob2RlI29uTm9kZVRhcFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiB0aGUgTm9kZSBpcyBkb3VibGUtY2xpY2tlZC4gTm8gYWRkaXRpb25hbCBkYXRhIGlzIHNlbnQgd2l0aCB0aGlzIGV2ZW50LlxuKlxuKiBAZXZlbnQgZW55by5Ob2RlI29uTm9kZURibENsaWNrXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHRoZSBOb2RlIGV4cGFuZHMgb3IgY29udHJhY3RzLCBhcyBpbmRpY2F0ZWQgYnkgdGhlXG4qIGBleHBhbmRlZGAgcHJvcGVydHkgaW4gdGhlIGV2ZW50IGRhdGEuXG4qXG4qIEBldmVudCBlbnlvLk5vZGUjb25FeHBhbmRcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtCb29sZWFufSBleHBhbmRlZCAtIGB0cnVlYCBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgZXhwYW5kZWQ7XG4qIG90aGVyd2lzZSwgYGZhbHNlYC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdGhlIE5vZGUgaXMgZGVzdHJveWVkLiBObyBhZGRpdGlvbmFsIGRhdGEgaXMgc2VudCB3aXRoIHRoaXMgZXZlbnQuXG4qXG4qIEBldmVudCBlbnlvLk5vZGUjb25EZXN0cm95ZWRcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIHtAbGluayBlbnlvLk5vZGV9IGlzIGEgY29udHJvbCB0aGF0IGNyZWF0ZXMgc3RydWN0dXJlZCB0cmVlcyBiYXNlZCBvbiBFbnlvJ3MgY2hpbGRcbiogY29tcG9uZW50IGhpZXJhcmNoeSBmb3JtYXQsIGUuZy46XG4qXG4qIGBgYFxuKiB7a2luZDogJ05vZGUnLCBpY29uOiAnaW1hZ2VzL2ZvbGRlci1vcGVuLnBuZycsIGNvbnRlbnQ6ICdUcmVlJyxcbiogXHRleHBhbmRhYmxlOiB0cnVlLCBleHBhbmRlZDogdHJ1ZSwgY29tcG9uZW50czogW1xuKiBcdFx0e2ljb246ICdpbWFnZXMvZmlsZS5wbmcnLCBjb250ZW50OiAnQWxwaGEnfSxcbiogXHRcdHtpY29uOiAnaW1hZ2VzL2ZvbGRlci1vcGVuLnBuZycsIGNvbnRlbnQ6ICdCcmF2bycsXG4qIFx0XHRcdGV4cGFuZGFibGU6IHRydWUsIGV4cGFuZGVkOiBmYWxzZSwgY29tcG9uZW50czogW1xuKiBcdFx0XHRcdHtpY29uOiAnaW1hZ2VzL2ZpbGUucG5nJywgY29udGVudDogJ0JyYXZvLUFscGhhJ30sXG4qIFx0XHRcdFx0e2ljb246ICdpbWFnZXMvZmlsZS5wbmcnLCBjb250ZW50OiAnQnJhdm8tQnJhdm8nfSxcbiogXHRcdFx0XHR7aWNvbjogJ2ltYWdlcy9maWxlLnBuZycsIGNvbnRlbnQ6ICdCcmF2by1DaGFybGllJ31cbiogXHRcdFx0XVxuKiBcdFx0fVxuKiBcdF1cbiogfVxuKiBgYGBcbipcbiogVGhlIGRlZmF1bHQga2luZCBvZiBjb21wb25lbnRzIHdpdGhpbiBhIG5vZGUgaXMgaXRzZWxmIHtAbGluayBlbnlvLk5vZGV9LCBzbyBvbmx5XG4qIHRoZSB0b3AtbGV2ZWwgbm9kZSBvZiB0aGUgdHJlZSBuZWVkcyB0byBiZSBleHBsaWNpdGx5IGRlZmluZWQgYXMgc3VjaC5cbipcbiogV2hlbiBhbiBleHBhbmRhYmxlIHRyZWUgbm9kZSBleHBhbmRzLCBhbiBbb25FeHBhbmRde0BsaW5rIGVueW8uTm9kZSNvbkV4cGFuZH1cbiogZXZlbnQgaXMgc2VudDsgd2hlbiBpdCBpcyB0YXBwZWQsIGFuIFtvbk5vZGVUYXBde0BsaW5rIGVueW8uTm9kZSNvbk5vZGVUYXB9XG4qIGV2ZW50IGlzIHNlbnQuXG4qXG4qIFdoZW4gdGhlIG9wdGlvbmFsIFtvbmx5SWNvbkV4cGFuZHNde0BsaW5rIGVueW8uTm9kZSNvbmx5SWNvbkV4cGFuZHN9IHByb3BlcnR5IGlzXG4qIHNldCB0byBgdHJ1ZWAsIGV4cGFuZGFibGUgbm9kZXMgbWF5IG9ubHkgYmUgb3BlbmVkIGJ5IHRhcHBpbmcgdGhlIGljb247IHRhcHBpbmcgdGhlXG4qIGNvbnRlbnQgbGFiZWwgd2lsbCBmaXJlIHRoZSBgb25Ob2RlVGFwYCBldmVudCwgYnV0IHdpbGwgbm90IGV4cGFuZCB0aGUgbm9kZS5cbipcbiogQHVpXG4qIEBjbGFzcyAgZW55by5Ob2RlXG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAcHVibGljXG4qL1xudmFyIFRyZWVOb2RlID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzICBlbnlvLk5vZGUucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Ob2RlJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBDb250cm9sLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLk5vZGUucHJvdG90eXBlXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOiB7XG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgTm9kZSBpcyBleHBhbmRhYmxlIGFuZCBoYXMgY2hpbGQgYnJhbmNoZXMuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGV4cGFuZGFibGU6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgTm9kZSBpcyBjdXJyZW50bHkgZXhwYW5kZWQgKG9wZW4pLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgIGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRleHBhbmRlZDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQqIFBhdGggdG8gYW4gaW1hZ2UgdG8gYmUgdXNlZCBhcyB0aGUgaWNvbiBmb3IgdGhpcyBOb2RlLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGljb246ICcnLFxuXG5cdFx0LyoqXG5cdFx0KiBPcHRpb25hbCBmbGFnIHRoYXQsIHdoZW4gYHRydWVgLCBjYXVzZXMgdGhlIE5vZGUgdG8gZXhwYW5kIG9ubHkgd2hlblxuXHRcdCogdGhlIGljb24gaXMgdGFwcGVkIChub3Qgd2hlbiB0aGUgY29udGVudHMgYXJlIHRhcHBlZCkuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0Ki9cblx0XHRvbmx5SWNvbkV4cGFuZHM6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJZiBgdHJ1ZWAsIGFkZHMgdGhlIGAnZW55by1zZWxlY3RlZCdgIENTUyBjbGFzczsgY2hhbmdpbmcgdmFsdWUgZnJvbSBgdHJ1ZWBcblx0XHQqIHRvIGBmYWxzZWAgcmVtb3ZlcyB0aGUgY2xhc3MuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHNlbGVjdGVkOiBmYWxzZVxuXHR9LFxuXG5cdC8qKlxuXHQqIEB0b2RvIHJlbW92ZSBpbmxpbmUgc3R5bGVzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3R5bGU6ICdwYWRkaW5nOiAwIDAgMCAxNnB4OycsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29udGVudDogJ05vZGUnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlZmF1bHRLaW5kOiBUcmVlTm9kZSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGFzc2VzOiAnZW55by1ub2RlJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICdpY29uJywga2luZDogSW1hZ2UsIHNob3dpbmc6IGZhbHNlfSxcblx0XHR7bmFtZTogJ2NhcHRpb24nLCBraW5kOiBDb250cm9sLCBYdGFnOiAnc3BhbicsIHN0eWxlOiAnZGlzcGxheTogaW5saW5lLWJsb2NrOyBwYWRkaW5nOiA0cHg7JywgYWxsb3dIdG1sOiB0cnVlfSxcblx0XHR7bmFtZTogJ2V4dHJhJywga2luZDogQ29udHJvbCwgdGFnOiAnc3BhbicsIGFsbG93SHRtbDogdHJ1ZX1cblx0XSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjaGlsZENsaWVudDogW1xuXHRcdHtuYW1lOiAnYm94Jywga2luZDogQ29udHJvbCwgY2xhc3NlczogJ2VueW8tbm9kZS1ib3gnLCBYc3R5bGU6ICdib3JkZXI6IDFweCBzb2xpZCBvcmFuZ2U7JywgY29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICdjbGllbnQnLCBraW5kOiBDb250cm9sLCBjbGFzc2VzOiAnZW55by1ub2RlLWNsaWVudCcsIFhzdHlsZTogJ2JvcmRlcjogMXB4IHNvbGlkIGxpZ2h0Ymx1ZTsnfVxuXHRcdF19XG5cdF0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbmRibGNsaWNrOiAnZGJsY2xpY2snXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXZlbnRzOiB7XG5cdFx0b25Ob2RlVGFwOiAnbm9kZVRhcCcsXG5cdFx0b25Ob2RlRGJsQ2xpY2s6ICdub2RlRGJsQ2xpY2snLFxuXHRcdG9uRXhwYW5kOiAnbm9kZUV4cGFuZCcsXG5cdFx0b25EZXN0cm95ZWQ6ICdub2RlRGVzdHJveWVkJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly90aGlzLmV4cGFuZGVkQ2hhbmdlZCgpO1xuXHRcdFx0Ly90aGlzLmxldmVsQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcblx0XHRcdHRoaXMuaWNvbkNoYW5nZWQoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQGZpcmVzIGVueW8uTm9kZSNvbkRlc3Ryb3llZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZG9EZXN0cm95ZWQoKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbml0Q29tcG9uZW50czoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gVE9ETzogb3B0aW1pemUgdG8gY3JlYXRlIHRoZSBjaGlsZENsaWVudCBvbiBkZW1hbmRcblx0XHRcdC8vdGhpcy5oYXNDaGlsZHJlbiA9IHRoaXMuY29tcG9uZW50cztcblx0XHRcdGlmICh0aGlzLmV4cGFuZGFibGUpIHtcblx0XHRcdFx0dGhpcy5raW5kQ29tcG9uZW50cyA9IHRoaXMua2luZENvbXBvbmVudHMuY29uY2F0KHRoaXMuY2hpbGRDbGllbnQpO1xuXHRcdFx0fVxuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y29udGVudENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvL3RoaXMuJC5jYXB0aW9uLnNldENvbnRlbnQoKHRoaXMuZXhwYW5kYWJsZSA/ICh0aGlzLmV4cGFuZGVkID8gJy0nIDogJysnKSA6ICcnKSArIHRoaXMuY29udGVudCk7XG5cdFx0dGhpcy4kLmNhcHRpb24uc2V0Q29udGVudCh0aGlzLmNvbnRlbnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGljb25DaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLmljb24uc2V0U3JjKHRoaXMuaWNvbik7XG5cdFx0dGhpcy4kLmljb24uc2V0U2hvd2luZyhCb29sZWFuKHRoaXMuaWNvbikpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNlbGVjdGVkQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuYWRkUmVtb3ZlQ2xhc3MoJ2VueW8tc2VsZWN0ZWQnLCB0aGlzLnNlbGVjdGVkKTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKHRoaXMuZXhwYW5kYWJsZSAmJiAhdGhpcy5leHBhbmRlZCkge1xuXHRcdFx0XHR0aGlzLnF1aWNrQ29sbGFwc2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBBZGRzIG5vZGVzIGFzIGNoaWxkcmVuIG9mIHRoaXMgY29udHJvbC5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0W119IG5vZGVzIC0gQW4gYXJyYXkgb2YgY29tcG9uZW50IGNvbmZpZ3VyYXRpb25zLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkTm9kZXM6IGZ1bmN0aW9uIChub2Rlcykge1xuXHRcdHRoaXMuZGVzdHJveUNsaWVudENvbnRyb2xzKCk7XG5cdFx0Zm9yICh2YXIgaT0wLCBuOyAobj1ub2Rlc1tpXSk7IGkrKykge1xuXHRcdFx0dGhpcy5jcmVhdGVDb21wb25lbnQobik7XG5cdFx0fVxuXHRcdHRoaXMuJC5jbGllbnQucmVuZGVyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQWRkcyBuZXcgTm9kZXMgYXMgY2hpbGRyZW4gb2YgdGhpcyBOb2RlOyBlYWNoIHZhbHVlIGluIHRoZSBgbm9kZXNgIGFycmF5XG5cdCogYmVjb21lcyB0aGUgY29udGVudCBvZiBhIG5ldyBjaGlsZCBOb2RlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmdbXX0gbm9kZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWRkVGV4dE5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHtcblx0XHR0aGlzLmRlc3Ryb3lDbGllbnRDb250cm9scygpO1xuXHRcdGZvciAodmFyIGk9MCwgbjsgKG49bm9kZXNbaV0pOyBpKyspIHtcblx0XHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50KHtjb250ZW50OiBufSk7XG5cdFx0fVxuXHRcdHRoaXMuJC5jbGllbnQucmVuZGVyKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQGZpcmVzIGVueW8uTm9kZSNvbk5vZGVUYXBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YXA6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYoIXRoaXMub25seUljb25FeHBhbmRzKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZUV4cGFuZGVkKCk7XG5cdFx0XHR0aGlzLmRvTm9kZVRhcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZigoZXZlbnQudGFyZ2V0PT10aGlzLiQuaWNvbi5oYXNOb2RlKCkpKSB7XG5cdFx0XHRcdHRoaXMudG9nZ2xlRXhwYW5kZWQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZG9Ob2RlVGFwKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBmaXJlcyBlbnlvLk5vZGUjb25Ob2RlRGJsQ2xpY2tcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkYmxjbGljazogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLmRvTm9kZURibENsaWNrKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogVG9nZ2xlcyB0aGUgdmFsdWUgb2YgW2V4cGFuZGVkXXtAbGluayBlbnlvLk5vZGUjZXhwYW5kZWR9LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0b2dnbGVFeHBhbmRlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0RXhwYW5kZWQoIXRoaXMuZXhwYW5kZWQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEltbWVkaWF0ZWx5IGNvbGxhcHNlcyB0aGUgY29udHJvbCdzIGNoaWxkcmVuLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cXVpY2tDb2xsYXBzZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlQ2xhc3MoJ2VueW8tYW5pbWF0ZScpO1xuXHRcdHRoaXMuJC5ib3guYXBwbHlTdHlsZSgnaGVpZ2h0JywgJzAnKTtcblx0XHR2YXIgaCA9IHRoaXMuJC5jbGllbnQuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuXHRcdHRoaXMuJC5jbGllbnQuc2V0Qm91bmRzKHt0b3A6IC1ofSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQW5pbWF0ZXMgdGhlIGV4cGFuc2lvbiAodXNpbmcgQ1NTIHRyYW5zaXRpb25zKS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmFkZENsYXNzKCdlbnlvLWFuaW1hdGUnKTtcblx0XHR2YXIgaCA9IHRoaXMuJC5jbGllbnQuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuXHRcdHRoaXMuJC5ib3guc2V0Qm91bmRzKHtoZWlnaHQ6IGh9KTtcblx0XHR0aGlzLiQuY2xpZW50LnNldEJvdW5kcyh7dG9wOiAwfSk7XG5cdFx0c2V0VGltZW91dCh0aGlzLmJpbmRTYWZlbHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gdGhpbmdzIG1heSBoYXZlIGhhcHBlbmVkIGluIHRoZSBpbnRlcmltLCBtYWtlIHN1cmVcblx0XHRcdC8vIHdlIG9ubHkgZml4IGhlaWdodCBpZiB3ZSBhcmUgc3RpbGwgZXhwYW5kZWRcblx0XHRcdGlmICh0aGlzLmV4cGFuZGVkKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2xhc3MoJ2VueW8tYW5pbWF0ZScpO1xuXHRcdFx0XHR0aGlzLiQuYm94LmFwcGx5U3R5bGUoJ2hlaWdodCcsICdhdXRvJyk7XG5cdFx0XHR9XG5cdFx0fSksIDIyNSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQW5pbWF0ZXMgdGhlIGNvbGxhcHNpbmcgKHVzaW5nIENTUyB0cmFuc2l0aW9ucykuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkaXNhYmxlIHRyYW5zaXRpb25zXG5cdFx0dGhpcy5yZW1vdmVDbGFzcygnZW55by1hbmltYXRlJyk7XG5cdFx0Ly8gZml4IHRoZSBoZWlnaHQgb2Ygb3VyIGJveCAocmF0aGVyIHRoYW4gJ2F1dG8nKSwgdGhpc1xuXHRcdC8vIGdpdmVzIHdlYmtpdCBzb21ldGhpbmcgdG8gbGVycCBmcm9tXG5cdFx0dmFyIGggPSB0aGlzLiQuY2xpZW50LmdldEJvdW5kcygpLmhlaWdodDtcblx0XHR0aGlzLiQuYm94LnNldEJvdW5kcyh7aGVpZ2h0OiBofSk7XG5cdFx0Ly8geWllbGQgdGhlIHRoZWFkIHNvIERPTSBjYW4gbWFrZSB0aG9zZSBjaGFuZ2VzICh3aXRob3V0IHRyYW5zaXRpb25zKVxuXHRcdHNldFRpbWVvdXQodGhpcy5iaW5kU2FmZWx5KGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGVuYWJsZSB0cmFuc2l0aW9uc1xuXHRcdFx0dGhpcy5hZGRDbGFzcygnZW55by1hbmltYXRlJyk7XG5cdFx0XHQvLyBzaHJpbmsgb3VyIGJveCB0byAwXG5cdFx0XHR0aGlzLiQuYm94LmFwcGx5U3R5bGUoJ2hlaWdodCcsICcwJyk7XG5cdFx0XHQvLyBzbGlkZSB0aGUgY29udGVudHMgdXBcblx0XHRcdHRoaXMuJC5jbGllbnQuc2V0Qm91bmRzKHt0b3A6IC1ofSk7XG5cdFx0fSksIDI1KTtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5Ob2RlI29uRXhwYW5kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZXhwYW5kZWRDaGFuZ2VkOiBmdW5jdGlvbiAob2xkKSB7XG5cdFx0aWYgKCF0aGlzLmV4cGFuZGFibGUpIHtcblx0XHRcdHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50ID0ge2V4cGFuZGVkOiB0aGlzLmV4cGFuZGVkfTtcblx0XHRcdHRoaXMuZG9FeHBhbmQoZXZlbnQpO1xuXHRcdFx0aWYgKCFldmVudC53YWl0KSB7XG5cdFx0XHRcdHRoaXMuZWZmZWN0RXhwYW5kZWQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZWZmZWN0RXhwYW5kZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy4kLmNsaWVudCkge1xuXHRcdFx0aWYgKCF0aGlzLmV4cGFuZGVkKSB7XG5cdFx0XHRcdHRoaXMuX2NvbGxhcHNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9leHBhbmQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly90aGlzLmNvbnRlbnRDaGFuZ2VkKCk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9Db250cm9sXCI6MTYsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZVwiOjIzLFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyk7XG52YXJcblx0SW5wdXQgPSByZXF1aXJlKCcuL0lucHV0Jyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIGNoZWNrYm94IGlzIHRhcHBlZC5cbipcbiogQGV2ZW50IGVueW8uQ2hlY2tib3gjb25BY3RpdmF0ZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge09iamVjdH0gZXZlbnQgLSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBjb250YWluaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uQ2hlY2tib3h9IGltcGxlbWVudHMgYW4gSFRNTCBjaGVja2JveCBbaW5wdXRde0BnbG9zc2FyeSBpbnB1dH0sIHdpdGhcbiogc3VwcG9ydCBmb3IgZ3JvdXBpbmcgdXNpbmcge0BsaW5rIGVueW8uR3JvdXB9LlxuKlxuKiBAY2xhc3MgZW55by5DaGVja2JveFxuKiBAZXh0ZW5kcyBlbnlvLklucHV0XG4qIEB1aVxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uQ2hlY2tib3gucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5DaGVja2JveCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogSW5wdXQsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8tY2hlY2tib3gnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50czoge1xuXHRcdG9uQWN0aXZhdGU6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOiBcblx0XHQvKiogQGxlbmRzIGVueW8uQ2hlY2tib3gucHJvdG90eXBlICovIHtcblx0XHRcblx0XHQvKipcblx0XHQqIFZhbHVlIG9mIHRoZSBjaGVja2JveDsgd2lsbCBiZSBgdHJ1ZWAgaWYgY2hlY2tlZC5cblx0XHQqIFxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y2hlY2tlZDogZmFsc2UsXG5cdFx0XG5cdFx0LyoqXG5cdFx0KiBBIFtHcm91cCBBUElde0BsaW5rIGVueW8uR3JvdXB9IHJlcXVpcmVtZW50IGZvciBkZXRlcm1pbmluZyB0aGUgc2VsZWN0ZWQgaXRlbS5cblx0XHQqIFxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YWN0aXZlOiBmYWxzZSxcblx0XHRcblx0XHQvKipcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHR0eXBlOiAnY2hlY2tib3gnXG5cdH0sXG5cdFxuXHQvKipcblx0KiBEaXNhYmxlIGNsYXNzZXMgaW5oZXJpdGVkIGZyb20ge0BsaW5rIGVueW8uSW5wdXR9LlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmRDbGFzc2VzOiBcIlwiLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZXJzOiB7XG5cdFx0b25jaGFuZ2U6ICdjaGFuZ2UnLFxuXHRcdG9uY2xpY2s6ICdjbGljaydcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAodGhpcy5hY3RpdmUpIHtcblx0XHRcdFx0dGhpcy5hY3RpdmVDaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmNoZWNrZWRDaGFuZ2VkKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2hlY2tlZENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldE5vZGVQcm9wZXJ0eSgnY2hlY2tlZCcsIHRoaXMuY2hlY2tlZCk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCB0aGlzLmNoZWNrZWQgPyAnY2hlY2tlZCcgOiAnJyk7XG5cdFx0dGhpcy5zZXRBY3RpdmUodGhpcy5jaGVja2VkKTtcblx0fSxcblxuXHQvKipcblx0KiBUaGUgW2FjdGl2ZV17QGxpbmsgZW55by5DaGVja2JveCNhY3RpdmV9IHByb3BlcnR5IGFuZCBgb25BY3RpdmF0ZWBcblx0KiB7QGdsb3NzYXJ5IGV2ZW50fSBhcmUgcGFydCBvZiB0aGUgW0dyb3VwSXRlbV17QGxpbmsgZW55by5Hcm91cEl0ZW19XG5cdCogaW50ZXJmYWNlIHN1cHBvcnRlZCBieSB0aGlzIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9LlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFjdGl2ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmFjdGl2ZSA9IHV0aWxzLmlzVHJ1ZSh0aGlzLmFjdGl2ZSk7XG5cdFx0dGhpcy5zZXRDaGVja2VkKHRoaXMuYWN0aXZlKTtcblx0XHR0aGlzLmJ1YmJsZSgnb25BY3RpdmF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFsbCBbaW5wdXRde0BsaW5rIGVueW8uSW5wdXR9IHR5cGUgW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9IHN1cHBvcnQgdGhlIFxuXHQqIFt2YWx1ZV17QGxpbmsgZW55by5JbnB1dCN2YWx1ZX0gcHJvcGVydHkuXG5cdCpcblx0KiBAcGFyYW0ge0Jvb2xlYW59IHZhbCAtIFdoZXRoZXIgb3Igbm90IHRoZSBbY2hlY2tib3hde0BsaW5rIGVueW8uQ2hlY2tib3h9IHNob3VsZFxuXHQqIGJlIGNoZWNrZWQuIFRoZSB2YWx1ZSB3aWxsIGJlIHRyZWF0ZWQgYXMgYHRydWVgIGlmIGl0IGlzIHRydXRoeTsgb3RoZXJ3aXNlLFxuXHQqIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHRoaXMuc2V0Q2hlY2tlZCh1dGlscy5pc1RydWUodmFsKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBjdXJyZW50IFt2YWx1ZV17QGxpbmsgZW55by5JbnB1dCN2YWx1ZX0gb2YgdGhlXG5cdCogW2NoZWNrYm94XXtAbGluayBlbnlvLkNoZWNrYm94fS5cblx0KlxuXHQqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFtjaGVja2JveF17QGxpbmsgZW55by5DaGVja2JveH0gaXMgY2hlY2tlZDtcblx0KiBvdGhlcndpc2UsIGBmYWxzZWAuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldENoZWNrZWQoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR2YWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHQvLyBpbmhlcml0ZWQgYmVoYXZpb3IgaXMgdG8gc2V0IFwidmFsdWVcIiBhdHRyaWJ1dGUgYW5kIG5vZGUtcHJvcGVydHlcblx0Ly8gd2hpY2ggZG9lcyBub3QgYXBwbHkgdG8gY2hlY2tib3ggKHVzZXMgXCJjaGVja2VkXCIpIHNvXG5cdC8vIHdlIHNxdWVsY2ggdGhlIGluaGVyaXRlZCBtZXRob2Rcblx0fSxcblx0Y2hhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG5vZGVDaGVja2VkID0gdXRpbHMuaXNUcnVlKHRoaXMuZ2V0Tm9kZVByb3BlcnR5KCdjaGVja2VkJykpO1xuXHRcdHRoaXMuc2V0QWN0aXZlKG5vZGVDaGVja2VkKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGljazogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIFZhcmlvdXMgdmVyc2lvbnMgb2YgSUUgKG5vdGFibHkgSUU4KSBkbyBub3QgZmlyZSAnb25jaGFuZ2UnIGZvclxuXHRcdC8vIGNoZWNrYm94ZXMsIHNvIHdlIGRpc2Nlcm4gY2hhbmdlIHZpYSAnY2xpY2snLlxuXHRcdC8vIE5vdGU6IGtleWJvYXJkIGludGVyYWN0aW9uIChlLmcuIHByZXNzaW5nIHNwYWNlIHdoZW4gZm9jdXNlZCkgZmlyZXNcblx0XHQvLyBhIGNsaWNrIGV2ZW50LlxuXHRcdGlmIChwbGF0Zm9ybS5pZSA8PSA4KSB7XG5cdFx0XHR0aGlzLmJ1YmJsZSgnb25jaGFuZ2UnLCBlKTtcblx0XHR9XG5cdH1cbn0pO1xufSx7XCIuLi8uLi9lbnlvXCI6MSxcIi4vSW5wdXRcIjoyNCxcIi4va2luZFwiOjY2LFwiLi9wbGF0Zm9ybVwiOjcxLFwiLi91dGlsc1wiOjc1fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vcGxhdGZvcm0nKSxcblx0ZGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpO1xudmFyXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuL0NvbnRyb2wnKSxcblx0T3B0aW9uID0gcmVxdWlyZSgnLi9PcHRpb24nKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLlNlbGVjdH0gaW1wbGVtZW50cyBhbiBIVE1MIFtzZWxlY3Rpb25de0BnbG9zc2FyeSBzZWxlY3R9IHdpZGdldCwgdXNpbmdcbioge0BsaW5rIGVueW8uT3B0aW9ufSBpbnN0YW5jZXMgYnkgZGVmYXVsdC5cbipcbiogYGBgXG4qIHtraW5kOiAnU2VsZWN0Jywgb25jaGFuZ2U6ICdzZWxlY3RDaGFuZ2VkJywgY29tcG9uZW50czogW1xuKlx0e2NvbnRlbnQ6ICdEZXNjZW5kaW5nJywgdmFsdWU6ICdkJ30sXG4qXHR7Y29udGVudDogJ0FzY2VuZGluZycsIHZhbHVlOiAnYSd9XG4qIF19XG4qIFxuKiBzZWxlY3RDaGFuZ2VkOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuKlx0dmFyIHMgPSBpblNlbmRlci5nZXRWYWx1ZSgpO1xuKlx0aWYgKHMgPT0gJ2QnKSB7XG4qXHRcdHRoaXMuc29ydExpc3REZXNjZW5kaW5nKCk7XG4qXHR9IGVsc2Uge1xuKlx0XHR0aGlzLnNvcnRMaXN0QXNjZW5kaW5nKCk7XG4qXHR9XG4qIH1cbiogYGBgXG4qIFxuKiBOb3RlOiBUaGlzIHVzZXMgdGhlIFsmbHQ7c2VsZWN0Jmd0O117QGdsb3NzYXJ5IHNlbGVjdH0gdGFnLCB3aGljaCBpc24ndCBpbXBsZW1lbnRlZCBmb3JcbiogbmF0aXZlIHdlYk9TIGFwcGxpY2F0aW9ucywgYWx0aG91Z2ggaXQgZG9lcyB3b3JrIGluIHRoZSB3ZWJPUyBXZWIgYnJvd3Nlci5cbipcbiogQGNsYXNzIGVueW8uU2VsZWN0XG4qIEBleHRlbmRzIGVueW8uQ29udHJvbFxuKiBAdWlcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlNlbGVjdC5wcm90b3R5cGUgKi8ge1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLlNlbGVjdCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6IFxuXHRcdC8qKiBAbGVuZHMgZW55by5TZWxlY3QucHJvdG90eXBlICovIHtcblx0XHRcblx0XHQvKipcblx0XHQqIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgW29wdGlvbl17QGxpbmsgZW55by5PcHRpb259IGluIHRoZSBsaXN0LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2VsZWN0ZWQ6IDAsXG5cblx0XHQvKipcblx0XHQqIFRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgW29wdGlvbl17QGxpbmsgZW55by5PcHRpb259LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7T2JqZWN0fVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dmFsdWU6IG51bGxcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhhbmRsZXJzOiB7XG5cdFx0b25jaGFuZ2U6ICdjaGFuZ2UnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGFnOiAnc2VsZWN0JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZWZhdWx0S2luZDogT3B0aW9uLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdC8vVHJpY2sgdG8gZm9yY2UgSUU4IG9uY2hhbmdlIGV2ZW50IGJ1YmJsZVxuXHRcdFx0aWYocGxhdGZvcm0uaWUgPT0gOCl7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdvbmNoYW5nZScsIGRpc3BhdGNoZXIuYnViYmxlcik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmNoYW5nZSgpO1xuXHRcdFx0dGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBOdW1iZXIodGhpcy5nZXROb2RlUHJvcGVydHkoJ3NlbGVjdGVkSW5kZXgnLCB0aGlzLnNlbGVjdGVkKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2VsZWN0ZWRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXROb2RlUHJvcGVydHkoJ3NlbGVjdGVkSW5kZXgnLCB0aGlzLnNlbGVjdGVkKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjaGFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNlbGVjdGVkID0gdGhpcy5nZXRTZWxlY3RlZCgpO1xuXHRcdGlmICh0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0dGhpcy5zZXQoJ3ZhbHVlJywgdGhpcy5ub2RlLnZhbHVlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2l0aCBpbm5lckhUTUwgc2V0dGluZyBvZiA8c2VsZWN0PiwgcmVyZW5kZXIgcGFyZW50IGluc3RlYWRcblx0XHRcdC8vIGh0dHA6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20vZGVmYXVsdC5hc3B4P3NjaWQ9a2I7ZW4tdXM7Mjc2MjI4XG5cdFx0XHRpZiAocGxhdGZvcm0uaWUpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQucmVuZGVyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KVxufSk7XG59LHtcIi4uLy4uL2VueW9cIjoxLFwiLi9Db250cm9sXCI6MTYsXCIuL09wdGlvblwiOjM1LFwiLi9kaXNwYXRjaGVyXCI6NTcsXCIuL2tpbmRcIjo2NixcIi4vcGxhdGZvcm1cIjo3MX1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJy4uLy4uLy4uL2VueW8nKTtcblxuXG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG5cdGRpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyJyk7XG52YXJcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4uL0NvbnRyb2wnKSxcblx0U2lnbmFscyA9IHJlcXVpcmUoJy4uL1NpZ25hbHMnKSxcblx0U2NyaW0gPSByZXF1aXJlKCcuLi9TY3JpbScpLFxuXHREb20gPSByZXF1aXJlKCcuLi9kb20nKTtcblxuLyoqXG4qIEZpcmVzIGFmdGVyIHRoZSBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9IGlzIHNob3duLlxuKlxuKiBAZXZlbnQgZW55by5Qb3B1cCNvblNob3dcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtPYmplY3R9IHNlbmRlciAtIFRoZSBbY29tcG9uZW50XXtAbGluayBlbnlvLkNvbXBvbmVudH0gdGhhdCBtb3N0IHJlY2VudGx5XG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBldmVudCBpbmZvcm1hdGlvbi5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIGFmdGVyIHRoZSBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9IGlzIGhpZGRlbi5cbipcbiogQGV2ZW50IGVueW8uUG9wdXAjb25IaWRlXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseVxuKlx0cHJvcGFnYXRlZCB0aGUge0BnbG9zc2FyeSBldmVudH0uXG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBldmVudCAtIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IGNvbnRhaW5pbmcgZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiB7QGxpbmsgZW55by5Qb3B1cH0gaXMgYSBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSB1c2VkIHRvIGRpc3BsYXkgY2VydGFpbiBjb250ZW50XG4qIG9uIHRvcCBvZiBvdGhlciBjb250ZW50LlxuKlxuKiBQb3B1cHMgYXJlIGluaXRpYWxseSBoaWRkZW4gb24gY3JlYXRpb247IHRoZXkgbWF5IGJlIHNob3duIGJ5IGNhbGxpbmcgdGhlXG4qIFtzaG93KClde0BsaW5rIGVueW8uQ29udHJvbCNzaG93fSBtZXRob2QgYW5kIHJlLWhpZGRlbiBieSBjYWxsaW5nXG4qIFtoaWRlKClde0BsaW5rIGVueW8uQ29udHJvbCNoaWRlfS4gUG9wdXBzIG1heSBiZSBjZW50ZXJlZCB1c2luZyB0aGVcbiogW2NlbnRlcmVkXXtAbGluayBlbnlvLlBvcHVwI2NlbnRlcmVkfSBwcm9wZXJ0eTsgaWYgbm90IGNlbnRlcmVkLCB0aGV5IHNob3VsZFxuKiBiZSBnaXZlbiBhIHNwZWNpZmljIHBvc2l0aW9uLlxuKlxuKiBBIHBvcHVwIG1heSBiZSBvcHRpb25hbGx5IGZsb2F0ZWQgYWJvdmUgYWxsXG4qIFthcHBsaWNhdGlvbl17QGxpbmsgZW55by5BcHBsaWNhdGlvbn0gY29udGVudCBieSBzZXR0aW5nIGl0c1xuKiBbZmxvYXRpbmdde0BsaW5rIGVueW8uUG9wdXAjZmxvYXRpbmd9IHByb3BlcnR5IHRvIGB0cnVlYC4gVGhpcyBoYXMgdGhlXG4qIGFkdmFudGFnZSBvZiBndWFyYW50ZWVpbmcgdGhhdCB0aGUgcG9wdXAgd2lsbCBiZSBkaXNwbGF5ZWQgb24gdG9wIG9mIG90aGVyXG4qIGNvbnRlbnQuIFRoaXMgdXNhZ2UgaXMgYXBwcm9wcmlhdGUgd2hlbiB0aGUgcG9wdXAgZG9lcyBub3QgbmVlZCB0byBzY3JvbGxcbiogYWxvbmcgd2l0aCBvdGhlciBjb250ZW50LlxuKlxuKiBUbyBhdm9pZCBvYnNjdXJpbmcgcG9wdXAgY29udGVudHMsIHNjcmltcyByZXF1aXJlIHRoZSBkaWFsb2cgdG8gYmUgZmxvYXRpbmc7XG4qIG90aGVyd2lzZSwgdGhleSB3b24ndCByZW5kZXIuIEEgbW9kYWwgcG9wdXAgd2lsbCBnZXQgYSB0cmFuc3BhcmVudCBzY3JpbVxuKiB1bmxlc3MgdGhlIHBvcHVwIGlzbid0IGZsb2F0aW5nLiBUbyBnZXQgYSB0cmFuc2x1Y2VudCBzY3JpbSB3aGVuIG1vZGFsLFxuKiBzcGVjaWZ5IGBbc2NyaW1de0BsaW5rIGVueW8uUG9wdXAjc2NyaW19OiB0cnVlYCBhbmRcbiogYFtzY3JpbVdoZW5Nb2RhbF17QGxpbmsgZW55by5Qb3B1cCNzY3JpbVdoZW5Nb2RhbH06IGZhbHNlYC5cbipcbiogRmluYWxseSwgdGhlcmUgaXMgYSBXZWJLaXQgYnVnIGFmZmVjdGluZyB0aGUgYmVoYXZpb3Igb2YgcG9wdXBzIHRoYXQgYXJlXG4qIGRpc3BsYXllZCBvbiB0b3Agb2YgdGV4dCBpbnB1dCBjb250cm9scy4gIEZvciBtb3JlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgYVxuKiB3b3JrYXJvdW5kLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW1BvcHVwc117QGxpbmtwbGFpbiAkZGV2LWd1aWRlL2J1aWxkaW5nLWFwcHMvY29udHJvbHMvcG9wdXBzLmh0bWx9XG4qIGluIHRoZSBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uUG9wdXBcbiogQGV4dGVuZHMgZW55by5Db250cm9sXG4qIEB1aVxuKiBAcHVibGljXG4qL1xudmFyIFBvcHVwID0gbW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uUG9wdXAucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Qb3B1cCcsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogQ29udHJvbCxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2xhc3NlczogJ2VueW8tcG9wdXAgZW55by1uby10b3VjaC1hY3Rpb24nLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDpcblx0XHQvKiogQGxlbmRzIGVueW8uUG9wdXAucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogU2V0IHRvIGB0cnVlYCB0byBwcmV2ZW50IFtjb250cm9sc117QGxpbmsgZW55by5Db250cm9sfSBvdXRzaWRlIHRoZVxuXHRcdCogW3BvcHVwXXtAbGluayBlbnlvLlBvcHVwfSBmcm9tIHJlY2VpdmluZyBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IHdoaWxlIHRoZVxuXHRcdCogcG9wdXAgaXMgc2hvd2luZy5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRtb2RhbDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQqIEJ5IGRlZmF1bHQsIHRoZSBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9IHdpbGwgaGlkZSB3aGVuIHRoZSB1c2VyIHRhcHMgb3V0c2lkZSBpdCBvclxuXHRcdCogcHJlc3NlcyBgRVNDYC4gIFNldCB0byBgZmFsc2VgIHRvIHByZXZlbnQgdGhpcyBiZWhhdmlvci5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGF1dG9EaXNtaXNzOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBTZXQgdG8gYHRydWVgIHRvIHJlbmRlciB0aGUgW3BvcHVwXXtAbGluayBlbnlvLlBvcHVwfSBpbiBhXG5cdFx0KiBbZmxvYXRpbmcgbGF5ZXJde0BsaW5rIGVueW8uRmxvYXRpbmdMYXllcn0gb3V0c2lkZSBvZiBvdGhlclxuXHRcdCogW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9LiAgVGhpcyBtYXkgYmUgdXNlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVcblx0XHQqIHBvcHVwIHdpbGwgYmUgc2hvd24gb24gdG9wIG9mIG90aGVyIGNvbnRyb2xzLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGZsb2F0aW5nOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogU2V0IHRvIGB0cnVlYCB0byBhdXRvbWF0aWNhbGx5IGNlbnRlciB0aGUgW3BvcHVwXXtAbGluayBlbnlvLlBvcHVwfSBpblxuXHRcdCogdGhlIG1pZGRsZSBvZiB0aGUgdmlld3BvcnQuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y2VudGVyZWQ6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBTZXQgdG8gYHRydWVgIHRvIGJlIGFibGUgdG8gc2hvdyB0cmFuc2l0aW9uIG9uIHRoZSBzdHlsZSBtb2RpZmljYXRpb25zO1xuXHRcdCogb3RoZXJ3aXNlIHRoZSB0cmFuc2l0aW9uIGlzIGludmlzaWJsZSBgKHZpc2liaWxpdHk6IGhpZGRlbilgLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHNob3dUcmFuc2l0aW9uczogZmFsc2UsXG5cblx0XHQvKipcblx0XHQqIFNldCB0byBgdHJ1ZWAgdG8gc3RvcCBgcHJldmVudERlZmF1bHQoKWAgZnJvbSBiZWluZyBjYWxsZWQgb24gY2FwdHVyZWRcblx0XHQqIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0uXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0YWxsb3dEZWZhdWx0OiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogQm9vbGVhbiB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgYSBzY3JpbSB3aWxsIGFwcGVhciB3aGVuIHRoZSBkaWFsb2cgaXNcblx0XHQqIG1vZGFsLiBOb3RlIHRoYXQgbW9kYWwgc2NyaW1zIGFyZSB0cmFuc3BhcmVudCwgc28geW91IHdvbid0IHNlZSB0aGVtLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2NyaW1XaGVuTW9kYWw6IHRydWUsXG5cblx0XHQvKipcblx0XHQqIEJvb2xlYW4gdGhhdCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCBhIHNjcmltIHdpbGwgYmUgZGlzcGxheWVkLiBTY3JpbXMgYXJlXG5cdFx0KiBvbmx5IGRpc3BsYXllZCB3aGVuIHRoZSBkaWFsb2cgaXMgZmxvYXRpbmcuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCAgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHNjcmltOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogT3B0aW9uYWwgY2xhc3MgbmFtZSB0byBhcHBseSB0byB0aGUgc2NyaW0uIEJlIGF3YXJlIHRoYXQgdGhlIHNjcmltXG5cdFx0KiBpcyBhIHNpbmdsZXRvbiBhbmQgeW91IHdpbGwgYmUgbW9kaWZ5aW5nIHRoZSBzY3JpbSBpbnN0YW5jZSB1c2VkIGZvclxuXHRcdCogb3RoZXIgcG9wdXBzLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAgJydcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHNjcmltQ2xhc3NOYW1lOiAnJyxcblxuXHRcdC8qKlxuXHRcdCogTG93ZXN0IHotaW5kZXggdGhhdCBtYXkgYmUgYXBwbGllZCB0byBhIHBvcHVwXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0ICAxMjBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGRlZmF1bHRaOiAxMjBcblx0fSxcblxuXHQvKipcblx0KiBAbGVuZHMgIGVueW8uUG9wdXBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwcm90ZWN0ZWRTdGF0aWNzOiB7XG5cdFx0LyoqXG5cdFx0KiBDb3VudCBvZiBjdXJyZW50bHkgc2hvd2luZyBwb3B1cHNcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAc3RhdGljXG5cdFx0KiBAcHJpdmF0ZVxuXHRcdCovXG5cdFx0Y291bnQ6IDAsXG5cblx0XHQvKipcblx0XHQqIEhpZ2hlc3QgcG9zc2libGUgei1pbmRleCBmb3IgYSBwb3B1cFxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBzdGF0aWNcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRoaWdoZXN0WjogMTIwXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvd2luZzogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbmtleWRvd246ICdrZXlkb3duJyxcblx0XHRvbmRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG5cdFx0b25mb2N1czogJ2ZvY3VzJyxcblx0XHRvbmJsdXI6ICdibHVyJyxcblx0XHRvblJlcXVlc3RTaG93OiAncmVxdWVzdFNob3cnLFxuXHRcdG9uUmVxdWVzdEhpZGU6ICdyZXF1ZXN0SGlkZSdcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYXB0dXJlRXZlbnRzOiB0cnVlLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGV2ZW50c1RvQ2FwdHVyZToge1xuXHRcdG9uZG93bjogJ2NhcHR1cmVkRG93bicsXG5cdFx0b250YXA6ICdjYXB0dXJlZFRhcCdcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblNob3c6ICcnLFxuXHRcdG9uSGlkZTogJydcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0b29sczogW1xuXHRcdHtraW5kOiBTaWduYWxzLCBvbktleWRvd246ICdrZXlkb3duJ31cblx0XSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzaG93aW5nID0gdGhpcy5zaG93aW5nO1xuXHRcdFx0dGhpcy5zaG93aW5nID0gZmFsc2U7XG5cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5jYW5HZW5lcmF0ZSA9ICF0aGlzLmZsb2F0aW5nO1xuXG5cdFx0XHQvLyBpZiB0aGUgc2hvd2luZyBmbGFnIHdhcyB0cnVlIHdlIGtub3cgdGhlIGludGVudCB3YXMgdG8gYXV0b21hdGljYWxseSBzaG93IHRoZVxuXHRcdFx0Ly8gcG9wdXAgb24gcmVuZGVyLi4uYnV0IGl0IGNhbid0IGJlIHJlbmRlcmVkIGluIHRoZSBub3JtYWwgZmxvdy4uLmJ1dCB0aGUgcmVuZGVyZWRcblx0XHRcdC8vIG1ldGhvZCB3b24ndCBiZSBjYWxsZWQgYmVjYXVzZSBpdCB3YXNuJ3QgZ2VuZXJhdGVkLi4uU08uLi53ZSBhcmJpdHJhcmlseSBmbGFnXG5cdFx0XHQvLyBpdCBhcyBnZW5lcmF0ZWQgZXZlbiB0aG91Z2ggaXQgd2Fzbid0IHRvIGVuc3VyZSB0aGF0IGl0cyByZW5kZXJlZCBtZXRob2Qgd2lsbFxuXHRcdFx0Ly8gYmUgY2FsbGVkIGFuZCB3ZSB0aGVuIGNoZWNrIGZvciB0aGlzIHNjZW5hcmlvIGluIHJlbmRlcmVkXG5cdFx0XHR0aGlzLmdlbmVyYXRlZCA9IHNob3dpbmc7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5mbG9hdGluZykge1xuXHRcdFx0XHRpZiAoIUNvbnRyb2wuZmxvYXRpbmdMYXllci5oYXNOb2RlKCkpIHtcblx0XHRcdFx0XHRDb250cm9sLmZsb2F0aW5nTGF5ZXIucmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlID0gQ29udHJvbC5mbG9hdGluZ0xheWVyLmhhc05vZGUoKTtcblx0XHRcdH1cblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0ZWFyZG93blJlbmRlcjoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIHJlbmRlcmVkIGZsb2F0aW5nIHBvcHVwLCByZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGVcblx0XHRcdC8vIGZsb2F0aW5nIGxheWVyIGJlY2F1c2UgaXQgd29uJ3QgYmUgcmVtb3ZlZCBvdGhlcndpc2Vcblx0XHRcdHZhciBub2RlID0gdGhpcy5oYXNOb2RlKCk7XG5cdFx0XHRpZih0aGlzLmZsb2F0aW5nICYmIG5vZGUpIHtcblx0XHRcdFx0dGhpcy5ub2RlLnJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVzdHJveToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlbGVhc2UoKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZWZsb3c6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY1ZpZXdwb3J0U2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmIChnbG9iYWwuaW5uZXJXaWR0aCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0d2lkdGg6IGdsb2JhbC5pbm5lcldpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGdsb2JhbC5pbm5lckhlaWdodFxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR3aWR0aDogZS5vZmZzZXRXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBlLm9mZnNldEhlaWdodFxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZCA9IHRoaXMuY2FsY1ZpZXdwb3J0U2l6ZSgpLFxuXHRcdFx0YiA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cblx0XHRpZiAodGhpcy50YXJnZXRQb3NpdGlvbikge1xuXHRcdFx0Ly8gRm9yIGJyZXZpdHkncyBzYWtlLi4uXG5cdFx0XHR2YXIgcCA9IHRoaXMudGFyZ2V0UG9zaXRpb247XG5cblx0XHRcdC8vIFRlc3QgYW5kIG9wdGlvbmFsbHkgYWRqdXN0IG91ciB0YXJnZXQgYm91bmRzIChvbmx5IGZpcnN0IGlzIGNvbW1lbnRlZCwgYmVjYXVzZSBsb2dpYyBpcyBlZmZlY3RpdmVseSBpZGVudGljYWwgZm9yIGFsbCBzY2VuYXJpb3MpXG5cdFx0XHRpZiAodHlwZW9mIHAubGVmdCA9PSAnbnVtYmVyJykge1xuXHRcdFx0XHQvLyBJZiBwb3B1cCB3aWxsIGJlIG91dHNpZGUgZ2xvYmFsIGJvdW5kcywgc3dpdGNoIGFuY2hvclxuXHRcdFx0XHRpZiAocC5sZWZ0ICsgYi53aWR0aCA+IGQud2lkdGgpIHtcblx0XHRcdFx0XHRpZiAocC5sZWZ0IC0gYi53aWR0aCA+PSAwKSB7XG5cdFx0XHRcdFx0XHQvLyBTd2l0Y2hpbmcgdG8gcmlnaHQgY29ybmVyIHdpbGwgZml0IGluIGdsb2JhbFxuXHRcdFx0XHRcdFx0cC5yaWdodCA9IGQud2lkdGggLSBwLmxlZnQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE5laXRoZXIgY29ybmVyIHdpbGwgd29yazsgc3RpY2sgYXQgc2lkZSBvZiBnbG9iYWxcblx0XHRcdFx0XHRcdHAucmlnaHQgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwLmxlZnQgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAucmlnaHQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBwLnJpZ2h0ID09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmIChwLnJpZ2h0ICsgYi53aWR0aCA+IGQud2lkdGgpIHtcblx0XHRcdFx0XHRpZiAocC5yaWdodCAtIGIud2lkdGggPj0gMCkge1xuXHRcdFx0XHRcdFx0cC5sZWZ0ID0gZC53aWR0aCAtIHAucmlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHAubGVmdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHAucmlnaHQgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAubGVmdCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBwLnRvcCA9PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAocC50b3AgKyBiLmhlaWdodCA+IGQuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0aWYgKHAudG9wIC0gYi5oZWlnaHQgPj0gMCkge1xuXHRcdFx0XHRcdFx0cC5ib3R0b20gPSBkLmhlaWdodCAtIHAudG9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwLmJvdHRvbSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHAudG9wID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwLmJvdHRvbSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHAuYm90dG9tID09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmIChwLmJvdHRvbSArIGIuaGVpZ2h0ID4gZC5oZWlnaHQpIHtcblx0XHRcdFx0XHRpZiAocC5ib3R0b20gLSBiLmhlaWdodCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRwLnRvcCA9IGQuaGVpZ2h0IC0gcC5ib3R0b207XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHAudG9wID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cC5ib3R0b20gPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAudG9wID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyAnaW5pdGlhbCcgdmFsdWVzIGFyZSBuZWNlc3NhcnkgdG8gb3ZlcnJpZGUgcG9zaXRpb25pbmcgcnVsZXMgaW4gdGhlIENTU1xuXHRcdFx0dGhpcy5hZGRTdHlsZXMoJ2xlZnQ6ICcgKyAocC5sZWZ0ICE9PSBudWxsID8gcC5sZWZ0ICsgJ3B4JyA6ICdpbml0aWFsJykgKyAnOyByaWdodDogJyArIChwLnJpZ2h0ICE9PSBudWxsID8gcC5yaWdodCArICdweCcgOiAnaW5pdGlhbCcpICsgJzsgdG9wOiAnICsgKHAudG9wICE9PSBudWxsID8gcC50b3AgKyAncHgnIDogJ2luaXRpYWwnKSArICc7IGJvdHRvbTogJyArIChwLmJvdHRvbSAhPT0gbnVsbCA/IHAuYm90dG9tICsgJ3B4JyA6ICdpbml0aWFsJykgKyAnOycpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5jZW50ZXJlZCkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLmZsb2F0aW5nID8gZCA6IHRoaXMuZ2V0SW5zdGFuY2VPd25lcigpLmdldEJvdW5kcygpO1xuXHRcdFx0dGhpcy5hZGRTdHlsZXMoICd0b3A6ICcgKyBNYXRoLm1heCggKCAoIG8uaGVpZ2h0IC0gYi5oZWlnaHQgKSAvIDIgKSwgMCApICsgJ3B4OyBsZWZ0OiAnICsgTWF0aC5tYXgoICggKCBvLndpZHRoIC0gYi53aWR0aCApIC8gMiApLCAwICkgKyAncHg7JyApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGdlbmVyYXRlZCB3b24ndCBiZSB0cnVlIHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkIHdpdGggc2hvd2luZyBmYWxzZSB1bmxlc3Ncblx0XHRcdC8vIHdlIHNldCBpdCB0aGF0IHdheSBzbyB3ZSBuZWVkIHRvIGdvIGFoZWFkIGFuZCBkbyBvdXIgYWN0dWFsIHJlbmRlciBub3cgdGhhdCB0aGUgY29udGFpbmVyIChwYXJlbnQpXG5cdFx0XHQvLyBoYXMgYmVlbiByZW5kZXJlZCBhbmQgdGhlIGZsb2F0aW5nIGxheWVyIGNhbiBiZSByZW5kZXJlZCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gY2Fycnkgb24gbm9ybWFsbHlcblx0XHRcdGlmICh0aGlzLmdlbmVyYXRlZCAmJiAhdGhpcy5zaG93aW5nICYmICF0aGlzLmhhc05vZGUoKSkge1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnNob3dpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnNob3dpbmdDaGFuZ2VkKCk7XG5cdFx0XHR9IGVsc2Ugc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBmaXJlcyBlbnlvLlBvcHVwI29uU2hvd1xuXHQqIEBmaXJlcyBlbnlvLlBvcHVwI29uSGlkZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNob3dpbmdDaGFuZ2VkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGF1dG8gcmVuZGVyIHdoZW4gc2hvd24uXG5cdFx0XHRpZiAodGhpcy5mbG9hdGluZyAmJiB0aGlzLnNob3dpbmcgJiYgIXRoaXMuaGFzTm9kZSgpKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBoaWRlIHdoaWxlIHNpemluZywgYW5kIG1vdmUgdG8gdG9wIGNvcm5lciBmb3IgYWNjdXJhdGUgc2l6aW5nXG5cdFx0XHRpZiAodGhpcy5jZW50ZXJlZCB8fCB0aGlzLnRhcmdldFBvc2l0aW9uKSB7XG5cdFx0XHRcdGlmICghdGhpcy5zaG93VHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHR0aGlzLmFwcGx5U3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRTdHlsZXMoJ3RvcDogMHB4OyBsZWZ0OiAwcHg7IHJpZ2h0OiBpbml0aWFsOyBib3R0b206IGluaXRpYWw7Jyk7XG5cdFx0XHR9XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmICh0aGlzLnNob3dpbmcpIHtcblx0XHRcdFx0dGhpcy5yZXNpemUoKTtcblx0XHRcdFx0UG9wdXAuY291bnQrKztcblx0XHRcdFx0dGhpcy5hcHBseVpJbmRleCgpO1xuXHRcdFx0XHRpZiAodGhpcy5jYXB0dXJlRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5jYXB0dXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKFBvcHVwLmNvdW50ID4gMCkge1xuXHRcdFx0XHRcdFBvcHVwLmNvdW50LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuY2FwdHVyZUV2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNob3dIaWRlU2NyaW0odGhpcy5zaG93aW5nKTtcblx0XHRcdC8vIHNob3cgYWZ0ZXIgc2l6aW5nXG5cdFx0XHRpZiAodGhpcy5jZW50ZXJlZCB8fCB0aGlzLnRhcmdldFBvc2l0aW9uICYmICF0aGlzLnNob3dUcmFuc2l0aW9ucykge1xuXHRcdFx0XHR0aGlzLmFwcGx5U3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKTtcblx0XHRcdH1cblx0XHRcdC8vIGV2ZW50cyBkZXNpcmVkIGR1ZSB0byBwcm9ncmFtbWF0aWMgc2hvdy9oaWRlXG5cdFx0XHRpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdFx0dGhpc1t0aGlzLnNob3dpbmcgPyAnZG9TaG93JyA6ICdkb0hpZGUnXSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhcHR1cmU6IGZ1bmN0aW9uICgpIHtcblx0XHRkaXNwYXRjaGVyLmNhcHR1cmUodGhpcywgdGhpcy5ldmVudHNUb0NhcHR1cmUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbGVhc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRkaXNwYXRjaGVyLnJlbGVhc2UodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FwdHVyZWREb3duOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0Ly9yZWNvcmQgdGhlIGRvd24gZXZlbnQgdG8gdmVyaWZ5IGluIHRhcFxuXHRcdHRoaXMuZG93bkV2ZW50ID0gZTtcblxuXHRcdC8vIHByZXZlbnQgZm9jdXMgZnJvbSBzaGlmdGluZyBvdXRzaWRlIHRoZSBwb3B1cCB3aGVuIG1vZGFsLlxuXHRcdGlmICh0aGlzLm1vZGFsICYmICF0aGlzLmFsbG93RGVmYXVsdCkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tb2RhbDtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYXB0dXJlZFRhcDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIGRpc21pc3Mgb24gdGFwIGlmIHByb3BlcnR5IGlzIHNldCBhbmQgY2xpY2sgc3RhcnRlZCAmIGVuZGVkIG91dHNpZGUgdGhlIHBvcHVwXG5cdFx0aWYgKHRoaXMuYXV0b0Rpc21pc3MgJiYgKCFlLmRpc3BhdGNoVGFyZ2V0LmlzRGVzY2VuZGFudE9mKHRoaXMpKSAmJiB0aGlzLmRvd25FdmVudCAmJlxuXHRcdFx0KCF0aGlzLmRvd25FdmVudC5kaXNwYXRjaFRhcmdldC5pc0Rlc2NlbmRhbnRPZih0aGlzKSkpIHtcblx0XHRcdHRoaXMuZG93bkV2ZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tb2RhbDtcblx0fSxcblxuXHQvKipcblx0KiBJZiBhIGRyYWcgZXZlbnQgb2NjdXJzIG91dHNpZGUgYSBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9LCBoaWRlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ3N0YXJ0OiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0dmFyIGluU2NvcGUgPSAoZS5kaXNwYXRjaFRhcmdldCA9PT0gdGhpcyB8fCBlLmRpc3BhdGNoVGFyZ2V0LmlzRGVzY2VuZGFudE9mKHRoaXMpKTtcblx0XHRpZiAoc2VuZGVyLmF1dG9EaXNtaXNzICYmICFpblNjb3BlKSB7XG5cdFx0XHRzZW5kZXIuc2V0U2hvd2luZyhmYWxzZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtleWRvd246IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRpZiAodGhpcy5zaG93aW5nICYmIHRoaXMuYXV0b0Rpc21pc3MgJiYgZS5rZXlDb2RlID09IDI3IC8qIGVzY2FwZSAqLykge1xuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIElmIHNvbWV0aGluZyBpbnNpZGUgdGhlIFtwb3B1cF17QGxpbmsgZW55by5Qb3B1cH0gYmx1cnJlZCwga2VlcCB0cmFjayBvZiBpdC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGJsdXI6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRpZiAoZS5kaXNwYXRjaFRhcmdldC5pc0Rlc2NlbmRhbnRPZih0aGlzKSkge1xuXHRcdFx0dGhpcy5sYXN0Rm9jdXMgPSBlLm9yaWdpbmF0b3I7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFdoZW4gc29tZXRoaW5nIG91dHNpZGUgdGhlIFtwb3B1cF17QGxpbmsgZW55by5Qb3B1cH0gZm9jdXNlcyAoZS5nLiwgZHVlIHRvIHRhYiBrZXkpLCBmb2N1c1xuXHQqIG91ciBsYXN0IGZvY3VzZWQgW2NvbnRyb2xde0BsaW5rIGVueW8uQ29udHJvbH0uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmb2N1czogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdHZhciBkdCA9IGUuZGlzcGF0Y2hUYXJnZXQ7XG5cdFx0aWYgKHRoaXMubW9kYWwgJiYgIWR0LmlzRGVzY2VuZGFudE9mKHRoaXMpKSB7XG5cdFx0XHRpZiAoZHQuaGFzTm9kZSgpKSB7XG5cdFx0XHRcdGR0Lm5vZGUuYmx1cigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG4gPSAodGhpcy5sYXN0Rm9jdXMgJiYgdGhpcy5sYXN0Rm9jdXMuaGFzTm9kZSgpKSB8fCB0aGlzLmhhc05vZGUoKTtcblx0XHRcdGlmIChuKSB7XG5cdFx0XHRcdG4uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVxdWVzdFNob3c6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNob3coKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZXF1ZXN0SGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaGlkZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE9wZW5zIHRoZSBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9IGF0IHRoZSBsb2NhdGlvbiBvZiBhIG1vdXNlXG5cdCoge0BnbG9zc2FyeSBldmVudH0uIFRoZSBwb3B1cCdzIHBvc2l0aW9uIGlzIGF1dG9tYXRpY2FsbHkgY29uc3RyYWluZWQgc29cblx0KiB0aGF0IGl0IGRvZXMgbm90IGRpc3BsYXkgb3V0c2lkZSB0aGUgdmlld3BvcnQsIGFuZCBkZWZhdWx0cyB0byBhbmNob3Jpbmdcblx0KiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBwb3B1cCB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGV2ZW50LlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IGUgLSBUaGUgbW91c2Uge0BnbG9zc2FyeSBldmVudH0gdGhhdCBpbml0aWF0ZWQgdGhpcyBjYWxsLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbb2Zmc2V0XSAtIEFuIG9wdGlvbmFsIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHRoYXQgbWF5XG5cdCogY29udGFpbiBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMgdG8gc3BlY2lmeSBhbiBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlXG5cdCogbG9jYXRpb24gd2hlcmUgdGhlIFtwb3B1cF17QGxpbmsgZW55by5Qb3B1cH0gd291bGQgb3RoZXJ3aXNlIGJlIHBvc2l0aW9uZWQuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzaG93QXRFdmVudDogZnVuY3Rpb24gKGUsIG9mZnNldCkge1xuXHRcdC8vIENhbGN1bGF0ZSBvdXIgaWRlYWwgdGFyZ2V0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvbiBhbmQgb2Zmc2V0XG5cdFx0dmFyIHAgPSB7XG5cdFx0XHRsZWZ0OiBlLmNlbnRlclggfHwgZS5jbGllbnRYIHx8IGUucGFnZVgsXG5cdFx0XHR0b3A6IGUuY2VudGVyWSB8fCBlLmNsaWVudFkgfHwgZS5wYWdlWVxuXHRcdH07XG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0cC5sZWZ0ICs9IG9mZnNldC5sZWZ0IHx8IDA7XG5cdFx0XHRwLnRvcCArPSBvZmZzZXQudG9wIHx8IDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5zaG93QXRQb3NpdGlvbihwKTtcblx0fSxcblxuXHQvKipcblx0KiBPcGVucyB0aGUgW3BvcHVwXXtAbGluayBlbnlvLlBvcHVwfSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLiBUaGUgZmluYWxcblx0KiBsb2NhdGlvbiBvZiB0aGUgcG9wdXAgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnN0cmFpbmVkIHNvIHRoYXQgaXQgZG9lc1xuXHQqIG5vdCBkaXNwbGF5IG91dHNpZGUgdGhlIHZpZXdwb3J0LlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IHBvcyBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSB0aGF0IG1heSBjb250YWluIGBsZWZ0YCxcblx0KiBgdG9wYCwgYGJvdHRvbWAsIGFuZCBgcmlnaHRgIHByb3BlcnRpZXMgdG8gc3BlY2lmeSB3aGVyZSB0aGVcblx0KiBbcG9wdXBde0BsaW5rIGVueW8uUG9wdXB9IHdpbGwgYmUgYW5jaG9yZWQuIElmIGJvdGggYGxlZnRgIGFuZCBgcmlnaHRgIGFyZVxuXHQqIGluY2x1ZGVkLCB0aGUgcHJlZmVyZW5jZSB3aWxsIGJlIHRvIGFuY2hvciBvbiB0aGUgbGVmdDsgc2ltaWxhcmx5LCBpZiBib3RoXG5cdCogYHRvcGAgYW5kIGBib3R0b21gIGFyZSBzcGVjaWZpZWQsIHRoZSBwcmVmZXJlbmNlIHdpbGwgYmUgdG8gYW5jaG9yIGF0IHRoZVxuXHQqIHRvcC5cblx0KiBAcHVibGljXG5cdCovXG5cdHNob3dBdFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0Ly8gU2F2ZSBvdXIgdGFyZ2V0IHBvc2l0aW9uIGZvciBsYXRlciBwcm9jZXNzaW5nXG5cdFx0dGhpcy50YXJnZXRQb3NpdGlvbiA9IHBvcztcblxuXHRcdC8vIFNob3cgdGhlIGRpYWxvZ1xuXHRcdHRoaXMuc2hvdygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFRvZ2dsZXMgdGhlIGRpc3BsYXkgb2YgdGhlIHNjcmltXG5cdCpcblx0KiBAcGFyYW0gIHtCb29sZWFufSBzaG93IC0gU2hvdyB0aGUgc2NyaW1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG93SGlkZVNjcmltOiBmdW5jdGlvbiAoc2hvdykge1xuXHRcdGlmICh0aGlzLmZsb2F0aW5nICYmICh0aGlzLnNjcmltIHx8ICh0aGlzLm1vZGFsICYmIHRoaXMuc2NyaW1XaGVuTW9kYWwpKSkge1xuXHRcdFx0dmFyIHNjcmltID0gdGhpcy5nZXRTY3JpbSgpO1xuXHRcdFx0aWYgKHNob3cpIHtcblx0XHRcdFx0Ly8gbW92ZSBzY3JpbSB0byBqdXN0IHVuZGVyIHRoZSBwb3B1cCB0byBvYnNjdXJlIHJlc3Qgb2Ygc2NyZWVuXG5cdFx0XHRcdHZhciBpID0gdGhpcy5nZXRTY3JpbVpJbmRleCgpO1xuXHRcdFx0XHR0aGlzLl9zY3JpbVogPSBpO1xuXHRcdFx0XHRzY3JpbS5zaG93QXRaSW5kZXgoaSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY3JpbS5oaWRlQXRaSW5kZXgodGhpcy5fc2NyaW1aKTtcblx0XHRcdH1cblx0XHRcdHV0aWxzLmNhbGwoc2NyaW0sICdhZGRSZW1vdmVDbGFzcycsIFt0aGlzLnNjcmltQ2xhc3NOYW1lLCBzY3JpbS5zaG93aW5nXSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGN1bGF0ZXMgdGhlIHotaW5kZXggZm9yIHRoZSBzY3JpbSBzbyBpdCdzIGRpcmVjdGx5IGJlbG93IHRoZSBwb3B1cFxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0U2NyaW1aSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gUG9wdXAuaGlnaGVzdFogPj0gdGhpcy5fekluZGV4ID8gdGhpcy5fekluZGV4IC0gMSA6IFBvcHVwLmhpZ2hlc3RaO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNob3cgYSB0cmFuc3BhcmVudCBzY3JpbSBmb3IgbW9kYWwgcG9wdXBzIGlmIHtAbGluayBlbnlvLlBvcHVwI3NjcmltV2hlbk1vZGFsfSBpcyBgdHJ1ZWBcblx0KiBpZiB7QGxpbmsgZW55by5Qb3B1cCNzY3JpbX0gaXMgYHRydWVgLCB0aGVuIHNob3cgYSByZWd1bGFyIHNjcmltLlxuXHQqXG5cdCogQHJldHVybiB7ZW55by5TY3JpbX1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRTY3JpbTogZnVuY3Rpb24gKCkge1xuXHRcdC8vXG5cdFx0aWYgKHRoaXMubW9kYWwgJiYgdGhpcy5zY3JpbVdoZW5Nb2RhbCAmJiAhdGhpcy5zY3JpbSkge1xuXHRcdFx0cmV0dXJuIFNjcmltLnNjcmltVHJhbnNwYXJlbnQubWFrZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gU2NyaW0uc2NyaW0ubWFrZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEFkanVzdCB0aGUgekluZGV4IHNvIHRoYXQgcG9wdXBzIHdpbGwgcHJvcGVybHkgc3RhY2sgb24gZWFjaCBvdGhlci5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFwcGx5WkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fekluZGV4ID0gKFBvcHVwLmNvdW50ICogMikgKyB0aGlzLmZpbmRaSW5kZXgoKSArIDE7XG5cdFx0aWYgKHRoaXMuX3pJbmRleCA8PSBQb3B1cC5oaWdoZXN0Wikge1xuXHRcdFx0dGhpcy5fekluZGV4ID0gUG9wdXAuaGlnaGVzdFogKyAxO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fekluZGV4ID4gUG9wdXAuaGlnaGVzdFopIHtcblx0XHRcdFBvcHVwLmhpZ2hlc3RaID0gdGhpcy5fekluZGV4O1xuXHRcdH1cblx0XHQvLyBsZWF2ZSByb29tIGZvciBzY3JpbVxuXHRcdHRoaXMuYXBwbHlTdHlsZSgnei1pbmRleCcsIHRoaXMuX3pJbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRmluZCB0aGUgei1pbmRleCBmb3IgdGhpcyBwb3B1cCwgY2xhbXBlZCBieSB7QGxpbmsgZW55by5Qb3B1cCNkZWZhdWx0Wn1cblx0KlxuXHQqIEByZXR1cm4ge051bWJlcn0gei1pbmRleCB2YWx1ZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGZpbmRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhIGRlZmF1bHQgeiB2YWx1ZVxuXHRcdHZhciB6ID0gdGhpcy5kZWZhdWx0Wjtcblx0XHRpZiAodGhpcy5fekluZGV4KSB7XG5cdFx0XHR6ID0gdGhpcy5fekluZGV4O1xuXHRcdH0gZWxzZSBpZiAodGhpcy5oYXNOb2RlKCkpIHtcblx0XHRcdC8vIFJlLXVzZSBleGlzdGluZyB6SW5kZXggaWYgaXQgaGFzIG9uZVxuXHRcdFx0eiA9IE51bWJlcihEb20uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMubm9kZSwgJ3otaW5kZXgnKSkgfHwgejtcblx0XHR9XG5cdFx0aWYgKHogPCB0aGlzLmRlZmF1bHRaKSB7XG5cdFx0XHR6ID0gdGhpcy5kZWZhdWx0Wjtcblx0XHR9XG5cdFx0dGhpcy5fekluZGV4ID0gejtcblx0XHRyZXR1cm4gdGhpcy5fekluZGV4O1xuXHR9XG59KTtcblxuLyoqXG4qIEJ5IGRlZmF1bHQsIHdlIGNhcHR1cmUgYG9uZG93bmAgYW5kIGBvbnRhcGAgdG8gaW1wbGVtZW50IHRoZSBbcG9wdXAnc117QGxpbmsgZW55by5Qb3B1cH1cbiogbW9kYWwgYmVoYXZpb3IsIGJ1dCBpbiBjZXJ0YWluIGNpcmN1bXN0YW5jZXMgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBjYXB0dXJlIG90aGVyXG4qIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0gYXMgd2VsbCwgc28gd2UgcHJvdmlkZSB0aGlzIGhvb2sgdG8gZXh0ZW5kLiAoV2UgYXJlIGN1cnJlbnRseVxuKiB1c2luZyB0aGlzIGluIE1vb25zdG9uZSB0byBjYXB0dXJlIGBvblNwb3RsaWdodEZvY3VzYCBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9KS5cbipcbiogQHByaXZhdGVcbiovXG5Qb3B1cC5jb25jYXQgPSBmdW5jdGlvbiAoY3RvciwgcHJvcHMsIGluc3RhbmNlKSB7XG5cdHZhciBwcm90byA9IGN0b3IucHJvdG90eXBlIHx8IGN0b3IsXG5cdFx0ZXZ0cyA9IHByb3RvLmV2ZW50c1RvQ2FwdHVyZTtcblx0cHJvdG8uZXZlbnRzVG9DYXB0dXJlID0gZXZ0cyA/IHV0aWxzLm1peGluKHt9LCBbZXZ0cywgcHJvcHMuZXZlbnRzVG9DYXB0dXJlXSkgOiBwcm9wcy5ldmVudHNUb0NhcHR1cmU7XG5cdGRlbGV0ZSBwcm9wcy5ldmVudHNUb0NhcHR1cmU7XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uLy4uL2VueW9cIjoxLFwiLi4vQ29udHJvbFwiOjE2LFwiLi4vU2NyaW1cIjo0MCxcIi4uL1NpZ25hbHNcIjo0NyxcIi4uL2Rpc3BhdGNoZXJcIjo1NyxcIi4uL2RvbVwiOjU4LFwiLi4va2luZFwiOjY2LFwiLi4vdXRpbHNcIjo3NX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL2VueW8nKTtcblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi91dGlscycpLFxuXHRkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi9wbGF0Zm9ybScpO1xuXG52YXJcblx0U2Nyb2xsTWF0aCA9IHJlcXVpcmUoJy4vU2Nyb2xsTWF0aCcpLFxuXHRTY3JvbGxTdHJhdGVneSA9IHJlcXVpcmUoJy4vU2Nyb2xsU3RyYXRlZ3knKSxcblx0U2Nyb2xsVGh1bWIgPSByZXF1aXJlKCcuL1Njcm9sbFRodW1iJyksXG5cdERvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuIGRyYWdnaW5nIGhhcyBzdGFydGVkLCBhbGxvd2luZyBkcmFncyB0byBwcm9wYWdhdGUgdG8gcGFyZW50XG4qIFtzY3JvbGxlcnNde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LlxuKlxuKiBAZXZlbnQgZW55by5Ub3VjaFNjcm9sbFN0cmF0ZWd5I29uU2hvdWxkRHJhZ1xuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHlcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge2VueW8uU2Nyb2xsZXJ+U2Nyb2xsRXZlbnR9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZ1xuKlx0ZXZlbnQgaW5mb3JtYXRpb24uXG4qIEBwcml2YXRlXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneX0gaXMgYSBoZWxwZXIgW2tpbmRde0BnbG9zc2FyeSBraW5kfSBmb3IgaW1wbGVtZW50aW5nIGFcbiogdG91Y2gtYmFzZWQgW3Njcm9sbGVyXXtAbGluayBlbnlvLlNjcm9sbGVyfS4gSXQgaW50ZWdyYXRlcyB0aGUgc2Nyb2xsaW5nIHNpbXVsYXRpb24gcHJvdmlkZWRcbiogYnkge0BsaW5rIGVueW8uU2Nyb2xsTWF0aH0gaW50byBhbiBgZW55by5TY3JvbGxlcmAuXG4qXG4qIGBlbnlvLlRvdWNoU2Nyb2xsU3RyYXRlZ3lgIGlzIG5vdCB0eXBpY2FsbHkgY3JlYXRlZCBpbiBhcHBsaWNhdGlvbiBjb2RlLiBJbnN0ZWFkLCBpdCBpc1xuKiBzcGVjaWZpZWQgYXMgdGhlIHZhbHVlIG9mIHRoZSBbc3RyYXRlZ3lLaW5kXXtAbGluayBlbnlvLlNjcm9sbGVyI3N0cmF0ZWd5S2luZH0gcHJvcGVydHlcbiogb2YgYW4gYGVueW8uU2Nyb2xsZXJgIG9yIHtAbGluayBlbnlvLkxpc3R9LCBvciBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgaW1wbGljaXRseS5cbipcbiogQGNsYXNzIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneVxuKiBAZXh0ZW5kcyBlbnlvLlNjcm9sbFN0cmF0ZWd5XG4qIEBwcm90ZWN0ZWRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5Ub3VjaFNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZSAqLyB7XG5cblx0bmFtZTogJ2VueW8uVG91Y2hTY3JvbGxTdHJhdGVneScsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogU2Nyb2xsU3RyYXRlZ3ksXG5cblx0LyoqXG5cdFx0SWYgYHRydWVgICh0aGUgZGVmYXVsdCksIHRoZSBzY3JvbGxlciB3aWxsIG92ZXJzY3JvbGwgYW5kIGJvdW5jZSBiYWNrIGF0IHRoZSBlZGdlcy5cblx0Ki9cblx0b3ZlcnNjcm9sbDogdHJ1ZSxcblxuXHQvKipcblx0XHRJZiBgdHJ1ZWAgKHRoZSBkZWZhdWx0KSwgdGhlIHNjcm9sbGVyIHdpbGwgbm90IHByb3BhZ2F0ZSBgZHJhZ3N0YXJ0YFxuXHRcdGV2ZW50cyB0aGF0IGNhdXNlIGl0IHRvIHN0YXJ0IHNjcm9sbGluZy5cblx0Ki9cblx0cHJldmVudERyYWdQcm9wYWdhdGlvbjogdHJ1ZSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWJsaXNoZWQ6XG5cdFx0LyoqIEBsZW5kcyBlbnlvLlRvdWNoU2Nyb2xsU3RyYXRlZ3kucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogU3BlY2lmaWVzIGhvdyB0byB2ZXJ0aWNhbGx5IHNjcm9sbC4gIEFjY2VwdGFibGUgdmFsdWVzIGFyZSBgJ3Njcm9sbCdgLCBgJ2F1dG8nYCxcblx0XHQqIGAnaGlkZGVuJ2AsIGFuZCBgJ2RlZmF1bHQnYC4gVGhlIHByZWNpc2UgZWZmZWN0IG9mIHRoZSBzZXR0aW5nIGlzIGRldGVybWluZWQgYnkgdGhlXG5cdFx0KiBzY3JvbGwgc3RyYXRlZ3kuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdkZWZhdWx0J1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dmVydGljYWw6ICdkZWZhdWx0JyxcblxuXHRcdC8qKlxuXHRcdCogU3BlY2lmaWVzIGhvdyB0byBob3Jpem9udGFsbHkgc2Nyb2xsLiAgQWNjZXB0YWJsZSB2YWx1ZXMgYXJlIGAnc2Nyb2xsJ2AsIGAnYXV0bydgLFxuXHRcdCogYCdoaWRkZW4nYCwgYW5kIGAnZGVmYXVsdCdgLiBUaGUgcHJlY2lzZSBlZmZlY3Qgb2YgdGhlIHNldHRpbmcgaXMgZGV0ZXJtaW5lZCBieSB0aGVcblx0XHQqIHNjcm9sbCBzdHJhdGVneS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nfVxuXHRcdCogQGRlZmF1bHQgJ2RlZmF1bHQnXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRob3Jpem9udGFsOiAnZGVmYXVsdCcsXG5cblx0XHQvKipcblx0XHQqIFNldCB0byBgdHJ1ZWAgdG8gZGlzcGxheSBhIHNjcm9sbCB0aHVtYi5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHRodW1iOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBTZXQgdG8gYHRydWVgIHRvIGRpc3BsYXkgYSB0cmFuc3BhcmVudCBvdmVybGF5IHdoaWxlIHNjcm9sbGluZy4gVGhpcyBjYW4gaGVscCBpbXByb3ZlXG5cdFx0KiBwZXJmb3JtYW5jZSBvZiBjb21wbGV4LCBsYXJnZSBzY3JvbGwgcmVnaW9ucyBvbiBzb21lIHBsYXRmb3JtcyAoZS5nLiwgQW5kcm9pZCkuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2NyaW06IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJbmRpY2F0ZXMgd2hldGhlciB0byBhbGxvdyBkcmFnIFtldmVudHNde0BnbG9zc2FyeSBldmVudH0gdG8gYmUgc2VudCB3aGlsZSBnZXN0dXJlXG5cdFx0KiBldmVudHMgYXJlIGhhcHBlbmluZyBzaW11bHRhbmVvdXNseS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGRyYWdEdXJpbmdHZXN0dXJlOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBGYWNhZGVzIGFuaW1hdGlvbiB0aW1lIHN0ZXAgZnJvbSBbU2Nyb2xsTWF0aF17QGxpbmsgZW55by5TY3JvbGxNYXRofS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMjBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGludGVydmFsOiAyMCxcblxuXHRcdC8qKlxuXHRcdCogRmFjYWRlcyBhbmltYXRpb24gaW50ZXJ2YWwgdHlwZSBmcm9tIFtTY3JvbGxNYXRoXXtAbGluayBlbnlvLlNjcm9sbE1hdGh9LlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Zml4ZWRUaW1lOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0KiBGYWNhZGVzIG9uZSB1bml0IG9mIHRpbWUgZm9yIHNpbXVsYXRpb24gZnJvbSBbU2Nyb2xsTWF0aF17QGxpbmsgZW55by5TY3JvbGxNYXRofS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMTBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGZyYW1lOiAxMCxcblxuXHRcdC8qKlxuXHRcdCogSW5kaWNhdGVzIHdoZXRoZXIgZGVmYXVsdCBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IChlLmcuLCBuYXRpdmUgc2Nyb2xsaW5nXG5cdFx0KiBldmVudHMpIHNob3VsZCBiZSBzdXBwcmVzc2VkLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0cHJldmVudERlZmF1bHQ6IHRydWVcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblNob3VsZERyYWc6ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbmZsaWNrOiAnZmxpY2snLFxuXHRcdG9uU2hvdWxkRHJhZzogJ3Nob3VsZERyYWcnLFxuXHRcdG9uZHJhZzogJ2RyYWcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dG9vbHM6IFtcblx0XHR7a2luZDogU2Nyb2xsTWF0aCwgb25TY3JvbGxTdGFydDogJ3Njcm9sbE1hdGhTdGFydCcsIG9uU2Nyb2xsOiAnc2Nyb2xsTWF0aFNjcm9sbCcsIG9uU2Nyb2xsU3RvcDogJ3Njcm9sbE1hdGhTdG9wJywgb25TdGFiaWxpemU6ICdzY3JvbGxNYXRoU3RhYmlsaXplJ30sXG5cdFx0e25hbWU6ICd2dGh1bWInLCBraW5kOiBTY3JvbGxUaHVtYiwgYXhpczogJ3YnLCBzaG93aW5nOiBmYWxzZX0sXG5cdFx0e25hbWU6ICdodGh1bWInLCBraW5kOiBTY3JvbGxUaHVtYiwgYXhpczogJ2gnLCBzaG93aW5nOiBmYWxzZX1cblx0XSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JpbVRvb2xzOiBbe25hbWU6ICdzY3JpbScsIGNsYXNzZXM6ICdlbnlvLWZpdCcsIHN0eWxlOiAnei1pbmRleDogMTsnLCBzaG93aW5nOiBmYWxzZX1dLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbXBvbmVudHM6IFtcblx0XHR7bmFtZTogJ2NsaWVudCcsIGNsYXNzZXM6ICdlbnlvLXRvdWNoLXNjcm9sbGVyJ31cblx0XSxcblxuXHQvKipcblx0KiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbGlzdCBpcyBjdXJyZW50bHkgcmVvcmRlcmluZy5cblx0KlxuXHQqIEByZWFkb25seVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bGlzdFJlb3JkZXJpbmc6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybSA9IERvbS5jYW5UcmFuc2Zvcm0oKTtcblx0XHRcdGlmKCF0aGlzLnRyYW5zZm9ybSkge1xuXHRcdFx0XHRpZih0aGlzLm92ZXJzY3JvbGwpIHtcblx0XHRcdFx0XHQvL3NvIHdlIGNhbiBhZGp1c3QgdG9wL2xlZnQgaWYgYnJvd3NlciBjYW4ndCBoYW5kbGUgdHJhbnNsYXRpb25zXG5cdFx0XHRcdFx0dGhpcy4kLmNsaWVudC5hcHBseVN0eWxlKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFjY2VsID0gRG9tLmNhbkFjY2VsZXJhdGUoKTtcblx0XHRcdHZhciBjb250YWluZXJDbGFzc2VzID0gJ2VueW8tdG91Y2gtc3RyYXRlZ3ktY29udGFpbmVyJztcblx0XHRcdC8vIG5vdGU6IG5lZWRlZCBmb3IgaW9zIHRvIGF2b2lkIGluY29ycmVjdCBjbGlwcGluZyBvZiB0aHVtYlxuXHRcdFx0Ly8gYW5kIG5lZWQgdG8gYXZvaWQgb24gQW5kcm9pZCBhcyBpdCBjYXVzZXMgcHJvYmxlbXMgaGlkaW5nIHRoZSB0aHVtYlxuXHRcdFx0aWYgKHBsYXRmb3JtLmlvcyAmJiB0aGlzLmFjY2VsKSB7XG5cdFx0XHRcdGNvbnRhaW5lckNsYXNzZXMgKz0gJyBlbnlvLWNvbXBvc2l0ZSc7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNjcmltQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWQoKTtcblx0XHRcdHRoaXMuZml4ZWRUaW1lQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy5mcmFtZUNoYW5nZWQoKTtcblx0XHRcdHRoaXMuY29udGFpbmVyLmFkZENsYXNzKGNvbnRhaW5lckNsYXNzZXMpO1xuXHRcdFx0dGhpcy50cmFuc2xhdGlvbiA9IHRoaXMuYWNjZWwgPyAndHJhbnNsYXRlM2QnIDogJ3RyYW5zbGF0ZSc7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluaXRDb21wb25lbnRzOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY3JlYXRlQ2hyb21lKHRoaXMudG9vbHMpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRlc3Ryb3k6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2VueW8tdG91Y2gtc3RyYXRlZ3ktY29udGFpbmVyJyk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRkaXNwYXRjaGVyLm1ha2VCdWJibGUodGhpcy4kLmNsaWVudCwgJ3Njcm9sbCcpO1xuXHRcdFx0dGhpcy5jYWxjQm91bmRhcmllcygpO1xuXHRcdFx0dGhpcy5zeW5jU2Nyb2xsTWF0aCgpO1xuXHRcdFx0aWYgKHRoaXMudGh1bWIpIHtcblx0XHRcdFx0dGhpcy5hbGVydFRodW1icygpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcmltQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNjcmltICYmICF0aGlzLiQuc2NyaW0pIHtcblx0XHRcdHRoaXMubWFrZVNjcmltKCk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5zY3JpbSAmJiB0aGlzLiQuc2NyaW0pIHtcblx0XHRcdHRoaXMuJC5zY3JpbS5kZXN0cm95KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1ha2VTY3JpbTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHJlc2V0IGNvbnRyb2wgcGFyZW50IHNvIHNjcmltIGRvZXNuJ3QgZ28gaW50byBjbGllbnQuXG5cdFx0dmFyIGNwID0gdGhpcy5jb250cm9sUGFyZW50O1xuXHRcdHRoaXMuY29udHJvbFBhcmVudCA9IG51bGw7XG5cdFx0dGhpcy5jcmVhdGVDaHJvbWUodGhpcy5zY3JpbVRvb2xzKTtcblx0XHR0aGlzLmNvbnRyb2xQYXJlbnQgPSBjcDtcblx0XHR2YXIgY24gPSB0aGlzLmNvbnRhaW5lci5oYXNOb2RlKCk7XG5cdFx0Ly8gcmVuZGVyIHNjcmltIGluIGNvbnRhaW5lciwgc3RyYXRlZ3kgaGFzIG5vIGRvbS5cblx0XHRpZiAoY24pIHtcblx0XHRcdHRoaXMuJC5zY3JpbS5wYXJlbnROb2RlID0gY247XG5cdFx0XHR0aGlzLiQuc2NyaW0ucmVuZGVyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHNjcm9sbGVyIGlzIGFjdGl2ZWx5IG1vdmluZy5cblx0KlxuXHQqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBhY3RpdmVseSBtb3Zpbmc7IG90aGVyd2lzZSwgYGZhbHNlYC5cblx0KiBAcHVibGljXG5cdCovXG5cdGlzU2Nyb2xsaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG0gPSB0aGlzLiQuc2Nyb2xsTWF0aDtcblx0XHRyZXR1cm4gbSA/IG0uaXNTY3JvbGxpbmcoKSA6IHRoaXMuc2Nyb2xsaW5nO1xuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHNjcm9sbGVyIGlzIGluIG92ZXJzY3JvbGwuXG5cdCpcblx0KiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgaW4gb3ZlcnNjcm9sbDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aXNPdmVyc2Nyb2xsaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG0gPSB0aGlzLiQuc2Nyb2xsTWF0aCB8fCB0aGlzO1xuXHRcdHJldHVybiAodGhpcy5vdmVyc2Nyb2xsKSA/IEJvb2xlYW4obS5pc0luT3ZlclNjcm9sbCgpKSA6IGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvbVNjcm9sbDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5pc1Njcm9sbGluZygpKSB7XG5cdFx0XHR0aGlzLmNhbGNCb3VuZGFyaWVzKCk7XG5cdFx0XHR0aGlzLnN5bmNTY3JvbGxNYXRoKCk7XG5cdFx0XHRpZiAodGhpcy50aHVtYikge1xuXHRcdFx0XHR0aGlzLmFsZXJ0VGh1bWJzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhvcml6b250YWxDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnNjcm9sbE1hdGguaG9yaXpvbnRhbCA9ICh0aGlzLmhvcml6b250YWwgIT0gJ2hpZGRlbicpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHZlcnRpY2FsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5zY3JvbGxNYXRoLnZlcnRpY2FsID0gKHRoaXMudmVydGljYWwgIT0gJ2hpZGRlbicpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1heEhlaWdodENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuY2xpZW50LmFwcGx5U3R5bGUoJ21heC1oZWlnaHQnLCB0aGlzLm1heEhlaWdodCk7XG5cdFx0Ly8gbm90ZTogcHJldmlvdXNseSB1c2VkIGVueW8tZml0IGhlcmUgYnV0IElFIHdvdWxkIHJlc2V0IHNjcm9sbCBwb3NpdGlvbiB3aGVuIHRoZSBzY3JvbGwgdGh1bWJcblx0XHQvLyB3YXMgaGlkZGVuOyBpbiBnZW5lcmFsIElFIHJlc2V0cyBzY3JvbGxUb3Agd2hlbiB0aGVyZSBhcmUgMiBhYnMgcG9zaXRpb24gc2libGluZ3MsIG9uZSBoYXNcblx0XHQvLyBzY3JvbGxUb3AgYW5kIHRoZSBvdGhlciBpcyBoaWRkZW4uXG5cdFx0dGhpcy4kLmNsaWVudC5hZGRSZW1vdmVDbGFzcygnZW55by1zY3JvbGxlZS1maXQnLCAhdGhpcy5tYXhIZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRodW1iQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaGlkZVRodW1icygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGludGVydmFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLiQuc2Nyb2xsTWF0aCkge1xuXHRcdFx0dGhpcy4kLnNjcm9sbE1hdGguaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmaXhlZFRpbWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuJC5zY3JvbGxNYXRoKSB7XG5cdFx0XHR0aGlzLiQuc2Nyb2xsTWF0aC5maXhlZFRpbWUgPSB0aGlzLmZpeGVkVGltZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZnJhbWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuJC5zY3JvbGxNYXRoKSB7XG5cdFx0XHR0aGlzLiQuc2Nyb2xsTWF0aC5mcmFtZSA9IHRoaXMuZnJhbWU7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFN0b3BzIGFueSBhY3RpdmUgc2Nyb2xsIG1vdmVtZW50LlxuXHQqXG5cdCogQHRvZG8gRG9jIHVwZGF0ZSBtYWRlIHdoaWxlIG1lcmdpbmcsIG5lZWQgb2ZmaWNpYWwgZG9jdW1lbnRhdGlvbiB1cGRhdGUhXG5cdCpcblx0KiBAcGFyYW0ge0Jvb2xlYW59IGVtaXQgLSBXaGV0aGVyIG9yIG5vdCB0byBmaXJlIHRoZSBgb25TY3JvbGxTdG9wYCBldmVudC5cblx0KiBAcHVibGljXG5cdCovXG5cdHN0b3A6IGZ1bmN0aW9uIChlbWl0KSB7XG5cdFx0aWYgKHRoaXMuaXNTY3JvbGxpbmcoKSkge1xuXHRcdFx0dGhpcy4kLnNjcm9sbE1hdGguc3RvcChlbWl0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQWRqdXN0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIGJlIHZhbGlkLCBpZiBuZWNlc3NhcnkgKGUuZy4sIGFmdGVyIHRoZSBzY3JvbGwgY29udGVudHNcblx0KiBoYXZlIGNoYW5nZWQpLlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzdGFiaWxpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZih0aGlzLiQuc2Nyb2xsTWF0aCkge1xuXHRcdFx0dGhpcy4kLnNjcm9sbE1hdGguc3RhYmlsaXplKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIFNjcm9sbHMgdG8gYSBzcGVjaWZpYyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcm9sbCBhcmVhLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgYHhgIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSBgeWAgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsVG86IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0dGhpcy5zdG9wKHRydWUpO1xuXHRcdHRoaXMuJC5zY3JvbGxNYXRoLnNjcm9sbFRvKHgsIHkgfHwgeSA9PT0gMCA/IHkgOiBudWxsKTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRoZSBnaXZlbiBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSBpbnRvIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29udHJvbH0gY3RsIC0gVGhlIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHRvIG1ha2UgdmlzaWJsZSBpbiB0aGVcblx0Klx0W3Njcm9sbGVyJ3Nde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IHZpZXdwb3J0LlxuXHQqIEBwYXJhbSB7Qm9vbGVhbn0gYWxpZ25XaXRoVG9wIC0gSWYgYHRydWVgLCB0aGUgbm9kZSBpcyBhbGlnbmVkIHdpdGggdGhlIHRvcCBvZiB0aGVcblx0Klx0c2Nyb2xsZXIuXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsSW50b1ZpZXc6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wKHRydWUpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gbGVmdCAtIFRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0U2Nyb2xsTGVmdDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnN0b3AodHJ1ZSk7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBTZXRzIHRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gdG9wIC0gVGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQG1ldGhvZFxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0U2Nyb2xsVG9wOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0b3ApIHtcblx0XHRcdHRoaXMuc3RvcCh0cnVlKTtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdGdldFNjcm9sbExlZnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNTY3JvbGxpbmcoKSA/IHRoaXMuc2Nyb2xsTGVmdCA6IHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHQqXG5cdCogQHJldHVybnMge051bWJlcn0gVGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFNjcm9sbFRvcDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1Njcm9sbGluZygpID8gdGhpcy5zY3JvbGxUb3AgOiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYWxjU2Nyb2xsTm9kZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLiQuY2xpZW50Lmhhc05vZGUoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYWxjQXV0b1Njcm9sbGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ID0gKHRoaXMudmVydGljYWwgPT0gJ2F1dG8nKTtcblx0XHR2YXIgaCA9ICh0aGlzLmhvcml6b250YWwgPT0gJ2F1dG8nKSB8fCAodGhpcy5ob3Jpem9udGFsID09ICdkZWZhdWx0Jyk7XG5cdFx0aWYgKCh2IHx8IGgpICYmIHRoaXMuc2Nyb2xsTm9kZSkge1xuXHRcdFx0dmFyIGIgPSB0aGlzLmdldFNjcm9sbEJvdW5kcygpO1xuXHRcdFx0aWYgKHYpIHtcblx0XHRcdFx0dGhpcy4kLnNjcm9sbE1hdGgudmVydGljYWwgPSBiLmhlaWdodCA+IGIuY2xpZW50SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGgpIHtcblx0XHRcdFx0dGhpcy4kLnNjcm9sbE1hdGguaG9yaXpvbnRhbCA9IGIud2lkdGggPiBiLmNsaWVudFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG91bGREcmFnOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdFx0dGhpcy5jYWxjQXV0b1Njcm9sbGluZygpO1xuXHRcdHZhciByZXF1ZXN0ViA9IGUudmVydGljYWw7XG5cdFx0dmFyIGNhbkggPSB0aGlzLiQuc2Nyb2xsTWF0aC5ob3Jpem9udGFsICYmICFyZXF1ZXN0Vjtcblx0XHR2YXIgY2FuViA9IHRoaXMuJC5zY3JvbGxNYXRoLnZlcnRpY2FsICYmIHJlcXVlc3RWO1xuXHRcdHZhciBkb3duID0gZS5keSA8IDAsIHJpZ2h0ID0gZS5keCA8IDA7XG5cdFx0dmFyIG9vYlYgPSAoIWRvd24gJiYgdGhpcy5zdGFydEVkZ2VzLnRvcCB8fCBkb3duICYmIHRoaXMuc3RhcnRFZGdlcy5ib3R0b20pO1xuXHRcdHZhciBvb2JIID0gKCFyaWdodCAmJiB0aGlzLnN0YXJ0RWRnZXMubGVmdCB8fCByaWdodCAmJiB0aGlzLnN0YXJ0RWRnZXMucmlnaHQpO1xuXHRcdC8vIHdlIHdvdWxkIHNjcm9sbCBpZiBub3QgYXQgYSBib3VuZGFyeVxuXHRcdGlmICghZS5ib3VuZGFyeURyYWdnZXIgJiYgKGNhbkggfHwgY2FuVikpIHtcblx0XHRcdGUuYm91bmRhcnlEcmFnZ2VyID0gdGhpcztcblx0XHR9XG5cdFx0Ly8gaW5jbHVkZSBib3VuZGFyeSBleGNsdXNpb25cblx0XHRpZiAoKCFvb2JWICYmIGNhblYpIHx8ICghb29iSCAmJiBjYW5IKSkge1xuXHRcdFx0ZS5kcmFnZ2VyID0gdGhpcztcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmbGljazogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdHZhciBvbkF4aXMgPSBNYXRoLmFicyhlLnhWZWxvY2l0eSkgPiBNYXRoLmFicyhlLnlWZWxvY2l0eSkgPyB0aGlzLiQuc2Nyb2xsTWF0aC5ob3Jpem9udGFsIDogdGhpcy4kLnNjcm9sbE1hdGgudmVydGljYWw7XG5cdFx0aWYgKG9uQXhpcyAmJiB0aGlzLmRyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLiQuc2Nyb2xsTWF0aC5mbGljayhlKTtcblx0XHRcdHJldHVybiB0aGlzLnByZXZlbnREcmFnUHJvcGFnYXRpb247XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvd246IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRcdGlmICghdGhpcy5pc092ZXJzY3JvbGxpbmcoKSkge1xuXHRcdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRtb3ZlOiBmdW5jdGlvbiAoc2VuZGVyLCBlKSB7XG5cdH0sXG5cblx0Ly8gU3BlY2lhbCBzeW50aGV0aWMgRE9NIGV2ZW50cyBzZXJ2ZWQgdXAgYnkgdGhlIEdlc3R1cmUgc3lzdGVtXG5cblx0LyoqXG5cdCogQGZpcmVzIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneSNvblNob3VsZERyYWdcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnc3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHQvLyBJZ25vcmUgZHJhZ3Mgc2VudCBmcm9tIG11bHRpLXRvdWNoIGV2ZW50c1xuXHRcdGlmKCF0aGlzLmRyYWdEdXJpbmdHZXN0dXJlICYmIGUuc3JjRXZlbnQudG91Y2hlcyAmJiBlLnNyY0V2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8vIG5vdGU6IGFsbG93IGRyYWdzIHRvIHByb3BhZ2F0ZSB0byBwYXJlbnQgc2Nyb2xsZXJzIHZpYSBkYXRhIHJldHVybmVkIGluIHRoZSBzaG91bGREcmFnIGV2ZW50LlxuXHRcdHRoaXMuZG9TaG91bGREcmFnKGUpO1xuXHRcdHRoaXMuZHJhZ2dpbmcgPSAoZS5kcmFnZ2VyID09IHRoaXMgfHwgKCFlLmRyYWdnZXIgJiYgZS5ib3VuZGFyeURyYWdnZXIgPT0gdGhpcykpO1xuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XG5cdFx0XHRpZih0aGlzLnByZXZlbnREZWZhdWx0KXtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm90ZTogbmVlZGVkIGJlY2F1c2Ugc2hvdy9oaWRlIGNoYW5nZXNcblx0XHRcdC8vIHRoZSBwb3NpdGlvbiBzbyBzeW5jJ2luZyBpcyByZXF1aXJlZCB3aGVuXG5cdFx0XHQvLyBkcmFnZ2luZyBiZWdpbnMgKG5lZWRlZCBiZWNhdXNlIHNob3cvaGlkZSBkb2VzIG5vdCB0cmlnZ2VyIG9uc2Nyb2xsKVxuXHRcdFx0dGhpcy5zeW5jU2Nyb2xsTWF0aCgpO1xuXHRcdFx0dGhpcy4kLnNjcm9sbE1hdGguc3RhcnREcmFnKGUpO1xuXHRcdFx0aWYgKHRoaXMucHJldmVudERyYWdQcm9wYWdhdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZzogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIGlmIHRoZSBsaXN0IGlzIGRvaW5nIGEgcmVvcmRlciwgZG9uJ3Qgc2Nyb2xsXG5cdFx0aWYodGhpcy5saXN0UmVvcmRlcmluZykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xuXHRcdFx0aWYodGhpcy5wcmV2ZW50RGVmYXVsdCl7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuJC5zY3JvbGxNYXRoLmRyYWcoZSk7XG5cdFx0XHRpZiAodGhpcy5zY3JpbSkge1xuXHRcdFx0XHR0aGlzLiQuc2NyaW0uc2hvdygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZHJhZ2ZpbmlzaDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XG5cdFx0XHRlLnByZXZlbnRUYXAoKTtcblx0XHRcdHRoaXMuJC5zY3JvbGxNYXRoLmRyYWdGaW5pc2goKTtcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnNjcmltKSB7XG5cdFx0XHRcdHRoaXMuJC5zY3JpbS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1vdXNld2hlZWw6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgdGhpcy51c2VNb3VzZVdoZWVsKSB7XG5cdFx0XHR0aGlzLmNhbGNCb3VuZGFyaWVzKCk7XG5cdFx0XHR0aGlzLnN5bmNTY3JvbGxNYXRoKCk7XG5cdFx0XHR0aGlzLnN0YWJpbGl6ZSgpO1xuXHRcdFx0aWYgKHRoaXMuJC5zY3JvbGxNYXRoLm1vdXNld2hlZWwoZSkpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2Nyb2xsTWF0aFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsTm9kZSAmJiAhdGhpcy5pc1Njcm9sbGluZygpKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGluZyA9IHRydWU7XG5cdFx0XHRpZiAoIXRoaXMuaXNPdmVyc2Nyb2xsaW5nKCkpIHtcblx0XHRcdFx0dGhpcy5jYWxjQm91bmRhcmllcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGxNYXRoU2Nyb2xsOiBmdW5jdGlvbiAoc2VuZGVyKSB7XG5cdFx0aWYoIXRoaXMub3ZlcnNjcm9sbCkge1xuXHRcdFx0Ly9kb24ndCBvdmVyc2Nyb2xsIHBhc3QgZWRnZXNcblx0XHRcdHRoaXMuZWZmZWN0U2Nyb2xsKC1NYXRoLm1pbihzZW5kZXIubGVmdEJvdW5kYXJ5LCBNYXRoLm1heChzZW5kZXIucmlnaHRCb3VuZGFyeSwgc2VuZGVyLngpKSxcblx0XHRcdFx0XHQtTWF0aC5taW4oc2VuZGVyLnRvcEJvdW5kYXJ5LCBNYXRoLm1heChzZW5kZXIuYm90dG9tQm91bmRhcnksIHNlbmRlci55KSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVmZmVjdFNjcm9sbCgtc2VuZGVyLngsIC1zZW5kZXIueSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnRodW1iKSB7XG5cdFx0XHR0aGlzLnNob3dUaHVtYnMoKTtcblx0XHRcdHRoaXMuZGVsYXlIaWRlVGh1bWJzKDEwMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbE1hdGhTdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zY3JvbGxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmVmZmVjdFNjcm9sbFN0b3AoKTtcblx0XHRpZiAodGhpcy50aHVtYikge1xuXHRcdFx0dGhpcy5kZWxheUhpZGVUaHVtYnMoMTAwKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2Nyb2xsTWF0aFN0YWJpbGl6ZTogZnVuY3Rpb24gKHNlbmRlcikge1xuXHRcdHRoaXMuZWZmZWN0U2Nyb2xsKC1zZW5kZXIueCwgLXNlbmRlci55KTtcblx0XHRpZiAodGhpcy50aHVtYikge1xuXHRcdFx0dGhpcy5zaG93VGh1bWJzKCk7XG5cdFx0XHR0aGlzLmRlbGF5SGlkZVRodW1icygxMDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjYWxjQm91bmRhcmllczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy4kLnNjcm9sbE1hdGggfHwgdGhpcywgYiA9IHRoaXMuX2dldFNjcm9sbEJvdW5kcygpO1xuXHRcdHMuYm90dG9tQm91bmRhcnkgPSBiLmNsaWVudEhlaWdodCAtIGIuaGVpZ2h0O1xuXHRcdHMucmlnaHRCb3VuZGFyeSA9IGIuY2xpZW50V2lkdGggLSBiLndpZHRoO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN5bmNTY3JvbGxNYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG0gPSB0aGlzLiQuc2Nyb2xsTWF0aDtcblx0XHRpZihtKSB7XG5cdFx0XHRtLnNldFNjcm9sbFgoLXRoaXMuZ2V0U2Nyb2xsTGVmdCgpKTtcblx0XHRcdG0uc2V0U2Nyb2xsWSgtdGhpcy5nZXRTY3JvbGxUb3AoKSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGVmZmVjdFNjcm9sbDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAodGhpcy5zY3JvbGxOb2RlKSB7XG5cdFx0XHR0aGlzLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbE5vZGUuc2Nyb2xsTGVmdCA9IHg7XG5cdFx0XHR0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTm9kZS5zY3JvbGxUb3AgPSB5O1xuXHRcdFx0dGhpcy5lZmZlY3RPdmVyc2Nyb2xsKHggIT09IG51bGw/IE1hdGgucm91bmQoeCk6IHgsIHkgIT09IG51bGw/IE1hdGgucm91bmQoeSk6IHkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlZmZlY3RTY3JvbGxTdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lZmZlY3RPdmVyc2Nyb2xsKG51bGwsIG51bGwpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGVmZmVjdE92ZXJzY3JvbGw6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0dmFyIG4gPSB0aGlzLnNjcm9sbE5vZGU7XG5cdFx0dmFyIHh0ID0gJzAnLCB5dCA9ICcwJywgenQgPSB0aGlzLmFjY2VsID8gJywwJyA6ICcnO1xuXHRcdGlmICh5ICE9PSBudWxsICYmIE1hdGguYWJzKHkgLSBuLnNjcm9sbFRvcCkgPiAxKSB7XG5cdFx0XHR5dCA9IChuLnNjcm9sbFRvcCAtIHkpO1xuXHRcdH1cblx0XHRpZiAoeCAhPT0gbnVsbCAmJiBNYXRoLmFicyh4IC0gbi5zY3JvbGxMZWZ0KSA+IDEpIHtcblx0XHRcdHh0ID0gKG4uc2Nyb2xsTGVmdCAtIHgpO1xuXHRcdH1cblx0XHRpZighdGhpcy50cmFuc2Zvcm0pIHtcblx0XHRcdC8vYWRqdXN0IHRvcC9sZWZ0IGlmIGJyb3dzZXIgY2FuJ3QgaGFuZGxlIHRyYW5zbGF0aW9uc1xuXHRcdFx0dGhpcy4kLmNsaWVudC5zZXRCb3VuZHMoe2xlZnQ6eHQgKyAncHgnLCB0b3A6eXQgKyAncHgnfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbS50cmFuc2Zvcm1WYWx1ZSh0aGlzLiQuY2xpZW50LCB0aGlzLnRyYW5zbGF0aW9uLCB4dCArICdweCwgJyArIHl0ICsgJ3B4JyArIHp0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBvdmVyc2Nyb2xsIGJvdW5kYXJpZXMgb2YgdGhlIFtzY3JvbGxlcl17QGxpbmsgZW55by5TY3JvbGxlcn0uXG5cdCpcblx0KiBAcmV0dXJucyB7ZW55by5TY3JvbGxlcn5PdmVyc2Nyb2xsQm91bmRhcnlPYmplY3R9IEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9XG5cdCpcdGRlc2NyaWJpbmcgdGhlIG92ZXJzY3JvbGwgYm91bmRhcmllcy5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldE92ZXJTY3JvbGxCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbSA9IHRoaXMuJC5zY3JvbGxNYXRoIHx8IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG92ZXJsZWZ0OiBNYXRoLm1pbihtLmxlZnRCb3VuZGFyeSAtIG0ueCwgMCkgfHwgTWF0aC5tYXgobS5yaWdodEJvdW5kYXJ5IC0gbS54LCAwKSxcblx0XHRcdG92ZXJ0b3A6IE1hdGgubWluKG0udG9wQm91bmRhcnkgLSBtLnksIDApIHx8IE1hdGgubWF4KG0uYm90dG9tQm91bmRhcnkgLSBtLnksIDApXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2dldFNjcm9sbEJvdW5kczoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgciA9IHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dXRpbHMubWl4aW4ociwgdGhpcy5nZXRPdmVyU2Nyb2xsQm91bmRzKCkpO1xuXHRcdFx0cmV0dXJuIHI7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSBzY3JvbGwgYm91bmRhcmllcyBvZiB0aGUgW3Njcm9sbGVyXXtAbGluayBlbnlvLlNjcm9sbGVyfS5cblx0KlxuXHQqIEByZXR1cm5zIHtlbnlvLlNjcm9sbGVyfkJvdW5kYXJ5T2JqZWN0fSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBkZXNjcmliaW5nIHRoZVxuXHQqXHRzY3JvbGwgYm91bmRhcmllcy5cblx0KiBAbWV0aG9kXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTY3JvbGxCb3VuZHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wKHRydWUpO1xuXHRcdFx0cmV0dXJuIHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFRoaXMgbWV0aG9kIGV4aXN0cyBwcmltYXJpbHkgdG8gc3VwcG9ydCBhbiBpbnRlcm5hbCB1c2UgY2FzZSBmb3Jcblx0KiBbZW55by5EYXRhTGlzdF17QGxpbmsgZW55by5EYXRhTGlzdH0uIEl0IGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBieSB0aGVcblx0KiBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IHRoYXQgb3ducyB0aGlzIHN0cmF0ZWd5LlxuXHQqXG5cdCogVHJpZ2dlcnMgYSByZW1lYXN1cmVtZW50IG9mIHRoZSBzY3JvbGxlcidzIG1ldHJpY3MgKHNwZWNpZmljYWxseSwgdGhlXG5cdCogc2l6ZSBvZiBpdHMgdmlld3BvcnQsIHRoZSBzaXplIG9mIGl0cyBjb250ZW50cyBhbmQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuXHQqIHRoZSB0d28sIHdoaWNoIGRldGVybWluZXMgdGhlIGV4dGVudCB0byB3aGljaCB0aGUgc2Nyb2xsZXIgbWF5IHNjcm9sbCkuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHJlbWVhc3VyZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FsY0JvdW5kYXJpZXMoKTtcblx0XHRpZiAodGhpcy50aHVtYikge1xuXHRcdFx0dGhpcy5zeW5jVGh1bWJzKCk7XG5cdFx0fVxuXHRcdHRoaXMuc3RhYmlsaXplKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGlzcGxheXMgdGhlIHNjcm9sbCBpbmRpY2F0b3JzIGFuZCBzZXRzIHRoZSBhdXRvLWhpZGUgdGltZW91dC5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YWxlcnRUaHVtYnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNob3dUaHVtYnMoKTtcblx0XHR0aGlzLmRlbGF5SGlkZVRodW1icyg1MDApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFN5bmNzIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY3JvbGwgaW5kaWNhdG9ycy5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c3luY1RodW1iczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC52dGh1bWIuc3luYyh0aGlzKTtcblx0XHR0aGlzLiQuaHRodW1iLnN5bmModGhpcyk7XG5cdH0sXG5cdHVwZGF0ZVRodW1iczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC52dGh1bWIudXBkYXRlKHRoaXMpO1xuXHRcdHRoaXMuJC5odGh1bWIudXBkYXRlKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFN5bmNzIGFuZCBzaG93cyBib3RoIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY3JvbGwgaW5kaWNhdG9ycy4gV2Ugb25seSBzeW5jIGFmdGVyIHdlXG5cdCogaGF2ZSBjaGVja2VkIGlmIHRoZSB2ZXJ0aWNhbCBhbmQvb3IgaG9yaXpvbnRhbCBzY3JvbGwgaW5kaWNhdG9ycyBhcmUgdG8gYmUgc2hvd24sIHNvIHRoYXRcblx0KiB7QGxpbmsgZW55by5TY3JvbGxUaHVtYiN1cGRhdGV9IGFjY3VyYXRlbHkgbWFrZXMgY2FsY3VsYXRpb25zIHdoZW4gdGhlIGluZGljYXRvcnMgYXJlXG5cdCogdmlzaWJsZS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2hvd1RodW1iczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmhvcml6b250YWwgIT0gJ2hpZGRlbicpIHtcblx0XHRcdHRoaXMuJC5odGh1bWIuc2hvdygpO1xuXHRcdH1cblx0XHRpZiAodGhpcy52ZXJ0aWNhbCAhPSAnaGlkZGVuJykge1xuXHRcdFx0dGhpcy4kLnZ0aHVtYi5zaG93KCk7XG5cdFx0fVxuXHRcdHRoaXMuc3luY1RodW1icygpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhpZGVzIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY3JvbGwgaW5kaWNhdG9ycy5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0aGlkZVRodW1iczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC52dGh1bWIuaGlkZSgpO1xuXHRcdHRoaXMuJC5odGh1bWIuaGlkZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEhpZGVzIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY3JvbGwgaW5kaWNhdG9ycyBhc3luY2hyb25vdXNseS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGVsYXlIaWRlVGh1bWJzOiBmdW5jdGlvbiAoZGVsYXkpIHtcblx0XHR0aGlzLiQudnRodW1iLmRlbGF5SGlkZShkZWxheSk7XG5cdFx0dGhpcy4kLmh0aHVtYi5kZWxheUhpZGUoZGVsYXkpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuLi8uLi9lbnlvL2xpYi91dGlsc1wiOjc1LFwiLi9TY3JvbGxNYXRoXCI6NDEsXCIuL1Njcm9sbFN0cmF0ZWd5XCI6NDIsXCIuL1Njcm9sbFRodW1iXCI6NDMsXCIuL2Rpc3BhdGNoZXJcIjo1NyxcIi4vZG9tXCI6NTgsXCIuL2tpbmRcIjo2NixcIi4vcGxhdGZvcm1cIjo3MX1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0Rml0dGFibGVMYXlvdXQgPSByZXF1aXJlKCcuL0ZpdHRhYmxlTGF5b3V0JyksXG5cdEZpdHRhYmxlQ29sdW1uc0xheW91dCA9IEZpdHRhYmxlTGF5b3V0LkNvbHVtbnM7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5GaXR0YWJsZUNvbHVtbnN9IHByb3ZpZGVzIGEgY29udGFpbmVyIGluIHdoaWNoIGl0ZW1zIGFyZSBsYWlkIG91dCBpbiBhXG4qIHNldCBvZiB2ZXJ0aWNhbCBjb2x1bW5zLCB3aXRoIG1vc3QgaXRlbXMgaGF2aW5nIG5hdHVyYWwgc2l6ZSwgYnV0IG9uZVxuKiBleHBhbmRpbmcgdG8gZmlsbCB0aGUgcmVtYWluaW5nIHNwYWNlLiBUaGUgb25lIHRoYXQgZXhwYW5kcyBpcyBsYWJlbGVkIHdpdGhcbiogdGhlIGF0dHJpYnV0ZSBgZml0OiB0cnVlYC5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbRml0dGFibGVzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvZml0dGFibGVzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQHVpXG4qIEBjbGFzcyAgZW55by5GaXR0YWJsZUNvbHVtbnNcbiogQGV4dGVuZHMgZW55by5Db250cm9sXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoLyoqIEBsZW5kcyAgZW55by5GaXR0YWJsZUNvbHVtbnMucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5GaXR0YWJsZUNvbHVtbnMnLFxuXG5cdC8qKlxuXHQqIEEge0BnbG9zc2FyeSBraW5kfSB1c2VkIHRvIG1hbmFnZSB0aGUgc2l6ZSBhbmQgcGxhY2VtZW50IG9mIGNoaWxkXG5cdCogW2NvbXBvbmVudHNde0BsaW5rIGVueW8uQ29tcG9uZW50fS5cblx0KlxuXHQqIEB0eXBlIHtTdHJpbmd9XG5cdCogQGRlZmF1bHQgJydcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRsYXlvdXRLaW5kOiBGaXR0YWJsZUNvbHVtbnNMYXlvdXQsXG5cblx0LyoqXG5cdCogQnkgZGVmYXVsdCwgaXRlbXMgaW4gY29sdW1ucyBzdHJldGNoIHRvIGZpdCB2ZXJ0aWNhbGx5OyBzZXQgdG8gYHRydWVgIHRvXG5cdCogYXZvaWQgdGhpcyBiZWhhdmlvci5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IGZhbHNlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRub1N0cmV0Y2g6IGZhbHNlXG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9GaXR0YWJsZUxheW91dFwiOjg3fV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9raW5kJyk7XG5cbnZhclxuXHRGaXR0YWJsZUxheW91dCA9IHJlcXVpcmUoJy4vRml0dGFibGVMYXlvdXQnKSxcblx0Rml0dGFibGVDb2x1bW5zTGF5b3V0ID0gRml0dGFibGVMYXlvdXQuQ29sdW1ucztcblxuLyoqXG4qIHtAbGluayBlbnlvLkZpdHRhYmxlSGVhZGVyTGF5b3V0fSBleHRlbmRzIHtAbGluayBlbnlvLkZpdHRhYmxlQ29sdW1uc0xheW91dH0sXG4qIHByb3ZpZGluZyBhIGNvbnRhaW5lciBpbiB3aGljaCBpdGVtcyBhcmUgbGFpZCBvdXQgaW4gYSBzZXQgb2YgdmVydGljYWwgY29sdW1ucyxcbiogd2l0aCBtb3N0IGl0ZW1zIGhhdmluZyBuYXR1cmFsIHNpemUsIGJ1dCBvbmUgZXhwYW5kaW5nIHRvIGZpbGwgdGhlIHJlbWFpbmluZ1xuKiBzcGFjZS4gVGhlIG9uZSB0aGF0IGV4cGFuZHMgaXMgbGFiZWxlZCB3aXRoIHRoZSBhdHRyaWJ1dGUgYGZpdDogdHJ1ZWAuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0ZpdHRhYmxlc117QGxpbmtwbGFpbiAkZGV2LWd1aWRlL2J1aWxkaW5nLWFwcHMvbGF5b3V0L2ZpdHRhYmxlcy5odG1sfSBpbiB0aGVcbiogRW55byBEZXZlbG9wZXIgR3VpZGUuXG4qXG4qIEBjbGFzcyAgZW55by5GaXR0YWJsZUhlYWRlckxheW91dFxuKiBAZXh0ZW5kcyBlbnlvLkZpdHRhYmxlQ29sdW1uc0xheW91dFxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKC8qKiBAbGVuZHMgIGVueW8uRml0dGFibGVIZWFkZXJMYXlvdXQucHJvdG90eXBlICove1xuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5hbWU6ICdlbnlvLkZpdHRhYmxlSGVhZGVyTGF5b3V0JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBGaXR0YWJsZUNvbHVtbnNMYXlvdXQsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YXBwbHlGaXRTaXplOiBmdW5jdGlvbihtZWFzdXJlLCB0b3RhbCwgYmVmb3JlLCBhZnRlcikge1xuXHRcdHZhciBwYWRkaW5nID0gYmVmb3JlIC0gYWZ0ZXI7XG5cdFx0dmFyIGYgPSB0aGlzLmdldEZpdENvbnRyb2woKTtcblxuXHRcdGlmIChwYWRkaW5nIDwgMCkge1xuXHRcdFx0Zi5hcHBseVN0eWxlKCdwYWRkaW5nLWxlZnQnLCBNYXRoLmFicyhwYWRkaW5nKSArICdweCcpO1xuXHRcdFx0Zi5hcHBseVN0eWxlKCdwYWRkaW5nLXJpZ2h0JywgbnVsbCk7XG5cdFx0fSBlbHNlIGlmIChwYWRkaW5nID4gMCkge1xuXHRcdFx0Zi5hcHBseVN0eWxlKCdwYWRkaW5nLWxlZnQnLCBudWxsKTtcblx0XHRcdGYuYXBwbHlTdHlsZSgncGFkZGluZy1yaWdodCcsIE1hdGguYWJzKHBhZGRpbmcpICsgJ3B4Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGYuYXBwbHlTdHlsZSgncGFkZGluZy1sZWZ0JywgbnVsbCk7XG5cdFx0XHRmLmFwcGx5U3R5bGUoJ3BhZGRpbmctcmlnaHQnLCBudWxsKTtcblx0XHR9XG5cblx0XHRGaXR0YWJsZUNvbHVtbnNMYXlvdXQucHJvdG90eXBlLmFwcGx5Rml0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9GaXR0YWJsZUxheW91dFwiOjg3fV0sODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9raW5kJylcdDtcblxudmFyXG5cdEZpdHRhYmxlTGF5b3V0ID0gcmVxdWlyZSgnLi9GaXR0YWJsZUxheW91dCcpLFxuXHRGaXR0YWJsZVJvd3NMYXlvdXQgPSBGaXR0YWJsZUxheW91dC5Sb3dzO1xuXG4vKipcbioge0BsaW5rIGVueW8uRml0dGFibGVSb3dzfSBwcm92aWRlcyBhIGNvbnRhaW5lciBpbiB3aGljaCBpdGVtcyBhcmUgbGFpZCBvdXQgaW4gYVxuKiBzZXRcdG9mIGhvcml6b250YWwgcm93cywgd2l0aCBtb3N0IG9mIHRoZSBpdGVtcyBoYXZpbmcgbmF0dXJhbCBzaXplLCBidXQgb25lXG4qIGV4cGFuZGluZyB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2UuIFRoZSBvbmUgdGhhdCBleHBhbmRzIGlzIGxhYmVsZWQgd2l0aFxuKiB0aGUgYXR0cmlidXRlIGBmaXQ6IHRydWVgLlxuKlxuKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uXG4qIFtGaXR0YWJsZXNde0BsaW5rcGxhaW4gJGRldi1ndWlkZS9idWlsZGluZy1hcHBzL2xheW91dC9maXR0YWJsZXMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAdWlcbiogQGNsYXNzICBlbnlvLkZpdHRhYmxlUm93c1xuKiBAZXh0ZW5kcyBlbnlvLkNvbnRyb2xcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZCgvKiogQGxlbmRzICBlbnlvLkZpdHRhYmxlUm93cy5wcm90b3R5cGUgKi97XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uRml0dGFibGVSb3dzJyxcblxuXHQvKipcblx0KiBBIHtAZ2xvc3Nhcnkga2luZH0gdXNlZCB0byBtYW5hZ2UgdGhlIHNpemUgYW5kIHBsYWNlbWVudCBvZiBjaGlsZFxuXHQqIFtjb21wb25lbnRzXXtAbGluayBlbnlvLkNvbXBvbmVudH0uXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICcnXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGF5b3V0S2luZDogRml0dGFibGVSb3dzTGF5b3V0LFxuXG5cdC8qKlxuXHQqIEJ5IGRlZmF1bHQsIGl0ZW1zIGluIGNvbHVtbnMgc3RyZXRjaCB0byBmaXQgaG9yaXpvbnRhbGx5OyBzZXQgdG8gYHRydWVgIHRvXG5cdCogYXZvaWQgdGhpcyBiZWhhdmlvci5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IGZhbHNlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRub1N0cmV0Y2g6IGZhbHNlXG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi9GaXR0YWJsZUxheW91dFwiOjg3fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vLi4vZW55bycpO1xuXG5cblxudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi9raW5kJyk7XG52YXJcblx0VG9vbERlY29yYXRvciA9IHJlcXVpcmUoJy4uL1Rvb2xEZWNvcmF0b3InKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkJ1dHRvbn0gaW1wbGVtZW50cyBhbiBIVE1MIFtidXR0b25de0BnbG9zc2FyeSBidXR0b259LCB3aXRoIHN1cHBvcnRcbiogZm9yIGdyb3VwaW5nIHVzaW5nIHtAbGluayBlbnlvLkdyb3VwfS5cbipcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbQnV0dG9uc117QGxpbmtwbGFpbiAkZGV2LWd1aWRlL2J1aWxkaW5nLWFwcHMvY29udHJvbHMvYnV0dG9ucy5odG1sfSBpbiB0aGVcbiogRW55byBEZXZlbG9wZXIgR3VpZGUuXG4qXG4qIEBjbGFzcyBlbnlvLkJ1dHRvblxuKiBAZXh0ZW5kcyBlbnlvLlRvb2xEZWNvcmF0b3JcbiogQHVpXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5CdXR0b24ucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5CdXR0b24nLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogVG9vbERlY29yYXRvcixcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0YWc6ICdidXR0b24nLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGF0dHJpYnV0ZXM6IHtcblx0XHQvKipcblx0XHQgKiBTZXQgdG8gYCdidXR0b24nYDsgb3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3b3VsZCBiZSBgJ3N1Ym1pdCdgLCB3aGljaFxuXHRcdCAqIGNhbiBjYXVzZSB1bmV4cGVjdGVkIHByb2JsZW1zIHdoZW4gW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9IGFyZSB1c2VkXG5cdFx0ICogaW5zaWRlIG9mIGEgW2Zvcm1de0BnbG9zc2FyeSBmb3JtfS5cblx0XHQgKiBcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dHlwZTogJ2J1dHRvbidcblx0fSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDogXG5cdFx0LyoqIEBsZW5kcyBlbnlvLkJ1dHRvbi5wcm90b3R5cGUgKi8ge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gYHRydWVgLCB0aGUgW2J1dHRvbl17QGdsb3NzYXJ5IGJ1dHRvbn0gaXMgc2hvd24gYXMgZGlzYWJsZWQgYW5kIGRvZXMgbm90IFxuXHRcdCAqIGdlbmVyYXRlIHRhcCBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9LlxuXHRcdCAqIFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGRpc2FibGVkOiBmYWxzZVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuZGlzYWJsZWRDaGFuZ2VkKCk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGlzYWJsZWRDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdGhpcy5kaXNhYmxlZCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZWQpIHtcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGZvciBwbGF0Zm9ybXMgbGlrZSBDaHJvbWUgb24gQW5kcm9pZCBvciBPcGVyYSB0aGF0IHNlbmRcblx0XHRcdC8vIG1vdXNldXAgdG8gZGlzYWJsZWQgZm9ybSBjb250cm9sc1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuXHRcdH1cblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW9cIjoxLFwiLi4vVG9vbERlY29yYXRvclwiOjUyLFwiLi4va2luZFwiOjY2fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vZW55bycpO1xuXG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4va2luZCcpLFxuXHRkaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJyk7XG5cbnZhclxuXHRUb3VjaFNjcm9sbFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9Ub3VjaFNjcm9sbFN0cmF0ZWd5JyksXG5cdERvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5UcmFuc2xhdGVTY3JvbGxTdHJhdGVneX0gaXMgYSBoZWxwZXIgW2tpbmRde0BnbG9zc2FyeSBraW5kfSB0aGF0IGV4dGVuZHNcbioge0BsaW5rIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneX0sIG9wdGltaXppbmcgaXQgZm9yIHNjcm9sbGluZyBlbnZpcm9ubWVudHMgaW4gd2hpY2ggZWZmZWN0aW5nIFxuKiBzY3JvbGwgY2hhbmdlcyB3aXRoIHRyYW5zZm9ybXMgdXNpbmcgQ1NTIHRyYW5zbGF0aW9ucyBpcyBmYXN0ZXN0LlxuKiBcbiogYGVueW8uVHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3lgIGlzIG5vdCB0eXBpY2FsbHkgY3JlYXRlZCBpbiBhcHBsaWNhdGlvbiBjb2RlLiBJbnN0ZWFkLCBpdCBpcyBcbiogc3BlY2lmaWVkIGFzIHRoZSB2YWx1ZSBvZiB0aGUgW3N0cmF0ZWd5S2luZF17QGxpbmsgZW55by5TY3JvbGxlciNzdHJhdGVneUtpbmR9IHByb3BlcnR5IG9mIFxuKiBhbiB7QGxpbmsgZW55by5TY3JvbGxlcn0gb3Ige0BsaW5rIGVueW8uTGlzdH0sIG9yIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayBpbXBsaWNpdGx5LlxuKlxuKiBAY2xhc3MgZW55by5UcmFuc2xhdGVTY3JvbGxTdHJhdGVneVxuKiBAZXh0ZW5kcyBlbnlvLlRvdWNoU2Nyb2xsU3RyYXRlZ3lcbiogQHByb3RlY3RlZFxuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlRyYW5zbGF0ZVNjcm9sbFN0cmF0ZWd5LnByb3RvdHlwZSAqLyB7XG5cblx0bmFtZTogJ2VueW8uVHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3knLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IFRvdWNoU2Nyb2xsU3RyYXRlZ3ksXG5cblx0LyoqIFxuXHQqIFNldCB0byBgdHJ1ZWAgdG8gb3B0aW1pemUgdGhlIHN0cmF0ZWd5IHRvIG9ubHkgdXNlIHRyYW5zbGF0aW9uIHRvIHNjcm9sbDsgdGhpcyBpbmNyZWFzZXMgXG5cdCogZmx1aWRpdHkgb2Ygc2Nyb2xsaW5nIGFuaW1hdGlvbi4gSXQgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gdGhlIFxuXHQqIFtzY3JvbGxlcl17QGxpbmsgZW55by5TY3JvbGxlcn0gY29udGFpbnMgW2NvbnRyb2xzXXtAbGluayBlbnlvLkNvbnRyb2x9IHRoYXQgcmVxdWlyZSBcblx0KiBrZXlib2FyZCBpbnB1dC4gVGhpcyBpcyBiZWNhdXNlIHdoZW4gYHRyYW5zbGF0ZU9wdGltaXplZGAgaXMgYHRydWVgLCBpdCBpcyBwb3NzaWJsZSB0byBcblx0KiBwb3NpdGlvbiBpbnB1dHMgc3VjaCB0aGF0IHRoZXkgd2lsbCBub3QgYmVjb21lIHZpc2libGUgd2hlbiBmb2N1c2VkLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHVibGljXG5cdCovXG5cdHRyYW5zbGF0ZU9wdGltaXplZDogZmFsc2UsXG5cdFxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICdjbGllbnRDb250YWluZXInLCBjbGFzc2VzOiAnZW55by10b3VjaC1zY3JvbGxlcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnY2xpZW50J31cblx0XHRdfVxuXHRdLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGRpc3BhdGNoZXIubWFrZUJ1YmJsZSh0aGlzLiQuY2xpZW50Q29udGFpbmVyLCAnc2Nyb2xsJyk7XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdGVPcHRpbWl6ZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRTdGFydFBvc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldFN0YXJ0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RhcnRYID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCk7XG5cdFx0dGhpcy5zdGFydFkgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldFNjcm9sbFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbiA9IHRoaXMuJC5jbGllbnQuaGFzTm9kZSgpO1xuXHRcdHJldHVybiB7d2lkdGg6IG4gPyBuLnNjcm9sbFdpZHRoIDogMCwgaGVpZ2h0OiBuID8gbi5zY3JvbGxIZWlnaHQgOiAwfTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gYXBwbHkgaW5pdGlhbCB0cmFuc2Zvcm0gc28gd2UncmUgYWx3YXlzIGNvbXBvc2l0ZWRcblx0XHRcdERvbS50cmFuc2Zvcm1WYWx1ZSh0aGlzLiQuY2xpZW50LCB0aGlzLnRyYW5zbGF0aW9uLCAnMCwwLDAnKTtcblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNhbGNTY3JvbGxOb2RlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuJC5jbGllbnRDb250YWluZXIuaGFzTm9kZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG1heEhlaWdodENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjb250ZW50IHNob3VsZCBjb3ZlciBzY3JvbGxlciBhdCBhIG1pbmltdW0gaWYgdGhlcmUncyBubyBtYXgtaGVpZ2h0LlxuXHRcdHRoaXMuJC5jbGllbnQuYXBwbHlTdHlsZSgnbWluLWhlaWdodCcsIHRoaXMubWF4SGVpZ2h0ID8gbnVsbCA6ICcxMDAlJyk7XG5cdFx0dGhpcy4kLmNsaWVudC5hcHBseVN0eWxlKCdtYXgtaGVpZ2h0JywgdGhpcy5tYXhIZWlnaHQpO1xuXHRcdHRoaXMuJC5jbGllbnRDb250YWluZXIuYWRkUmVtb3ZlQ2xhc3MoJ2VueW8tc2Nyb2xsZWUtZml0JywgIXRoaXMubWF4SGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvdWxkRHJhZzoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oaW5FdmVudCkge1xuXHRcdFx0Ly8gc3RvcCBhbmQgdXBkYXRlIGRyYWcgaW5mbyBiZWZvcmUgY2hlY2tpbmcgZHJhZyBzdGF0dXNcblx0XHRcdHRoaXMuc3RvcCgpO1xuXHRcdFx0dGhpcy5jYWxjU3RhcnRJbmZvKCk7XG5cdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN5bmNTY3JvbGxNYXRoOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fdHJhbnNsYXRlZCkge1xuXHRcdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIFNldHMgdGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgLSBUaGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNjcm9sbExlZnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGluTGVmdCkge1xuXHRcdFx0dmFyIG0sIHA7XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdGVPcHRpbWl6ZWQpIHtcblx0XHRcdFx0cCA9IHRoaXMuc2Nyb2xsTGVmdDtcblx0XHRcdFx0bSA9IHRoaXMuJC5zY3JvbGxNYXRoO1xuXHRcdFx0XHR0aGlzLnN0b3AodHJ1ZSk7XG5cdFx0XHRcdG0uc2V0U2Nyb2xsWCgtaW5MZWZ0KTtcblx0XHRcdFx0bS5zdGFiaWxpemUoKTtcblx0XHRcdFx0aWYgKHAgIT0gLW0ueCkge1xuXHRcdFx0XHRcdC8vIFdlIHdvbid0IGdldCBhIG5hdGl2ZSBzY3JvbGwgZXZlbnQsXG5cdFx0XHRcdFx0Ly8gc28gbmVlZCB0byBtYWtlIG9uZSBvdXJzZWx2ZXNcblx0XHRcdFx0XHRtLmRvU2Nyb2xsKCk7XG5cdFx0XHRcdFx0dGhpcy5kZWxheUhpZGVUaHVtYnMoMTAwKTtcblx0XHRcdFx0fSBcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogU2V0cyB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHRvcCAtIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNjcm9sbFRvcDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oaW5Ub3ApIHtcblx0XHRcdHZhciBtLCBwO1xuXHRcdFx0aWYgKHRoaXMudHJhbnNsYXRlT3B0aW1pemVkKSB7XG5cdFx0XHRcdHAgPSB0aGlzLnNjcm9sbFRvcDtcblx0XHRcdFx0bSA9IHRoaXMuJC5zY3JvbGxNYXRoO1xuXHRcdFx0XHR0aGlzLnN0b3AodHJ1ZSk7XG5cdFx0XHRcdG0uc2V0U2Nyb2xsWSgtaW5Ub3ApO1xuXHRcdFx0XHRtLnN0YWJpbGl6ZSgpO1xuXHRcdFx0XHRpZiAocCAhPSAtbS55KSB7XG5cdFx0XHRcdFx0Ly8gV2Ugd29uJ3QgZ2V0IGEgbmF0aXZlIHNjcm9sbCBldmVudCxcblx0XHRcdFx0XHQvLyBzbyBuZWVkIHRvIG1ha2Ugb25lIG91cnNlbHZlc1xuXHRcdFx0XHRcdG0uZG9TY3JvbGwoKTtcblx0XHRcdFx0XHR0aGlzLmRlbGF5SGlkZVRodW1icygxMDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblx0XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBtZXRob2Rcblx0KiBAcHVibGljXG5cdCovXG5cdGdldFNjcm9sbExlZnQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYW5zbGF0ZWQgPyB0aGlzLnNjcm9sbExlZnQ6IHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0pLFxuXHRcblx0LyoqXG5cdCogUmV0cmlldmVzIHRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0U2Nyb2xsVG9wOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90cmFuc2xhdGVkID8gdGhpcy5zY3JvbGxUb3AgOiBzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY0JvdW5kYXJpZXM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdGVPcHRpbWl6ZWQgJiYgIXRoaXMuaXNTY3JvbGxpbmcoKSkgdGhpcy5zdGFiaWxpemUoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlUmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy50cmFuc2xhdGVPcHRpbWl6ZWQpIHtcblx0XHRcdHRoaXMuc3RhYmlsaXplKCk7XG5cdFx0fVxuXHR9LFxuXHRcblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbE1hdGhTdGFydDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmICghdGhpcy5fdHJhbnNsYXRlZCkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXJ0UG9zaXRpb24oKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGxNYXRoU2Nyb2xsOiBmdW5jdGlvbiAoc2VuZGVyKSB7XG5cdFx0aWYoIXRoaXMub3ZlcnNjcm9sbCkgeyAvL2Rvbid0IG92ZXJzY3JvbGwgcGFzdCBlZGdlc1xuXHRcdFx0dGhpcy5zY3JvbGxMZWZ0ID0gLU1hdGgubWluKHNlbmRlci5sZWZ0Qm91bmRhcnksIE1hdGgubWF4KHNlbmRlci5yaWdodEJvdW5kYXJ5LCBzZW5kZXIueCkpO1xuXHRcdFx0dGhpcy5zY3JvbGxUb3AgPSAtTWF0aC5taW4oc2VuZGVyLnRvcEJvdW5kYXJ5LCBNYXRoLm1heChzZW5kZXIuYm90dG9tQm91bmRhcnksIHNlbmRlci55KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2Nyb2xsTGVmdCA9IC1zZW5kZXIueDtcblx0XHRcdHRoaXMuc2Nyb2xsVG9wID0gLXNlbmRlci55O1xuXHRcdH1cblx0XHR0aGlzLmVmZmVjdFNjcm9sbCh0aGlzLnNjcm9sbExlZnQsIHRoaXMuc2Nyb2xsVG9wKTtcblx0XHRpZiAodGhpcy50aHVtYikge1xuXHRcdFx0dGhpcy5zaG93VGh1bWJzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbE1hdGhTdGFiaWxpemU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChzZW5kZXIpIHtcblx0XHRcdGlmICh0aGlzLl90cmFuc2xhdGVkKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsTGVmdCA9IC1zZW5kZXIueDtcblx0XHRcdFx0dGhpcy5zY3JvbGxUb3AgPSAtc2VuZGVyLnk7XG5cdFx0XHRcdHRoaXMuZWZmZWN0U2Nyb2xsKC1zZW5kZXIueCwgLXNlbmRlci55KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gc3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogV2hpbGUgbW92aW5nLCBzY3JvbGxlciB1c2VzIHRyYW5zbGF0ZS5cblx0KiBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRlZmZlY3RTY3JvbGw6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0XHR2YXIgbztcblx0XHRcdGlmICh0aGlzLnRyYW5zbGF0ZU9wdGltaXplZCB8fCB0aGlzLmlzU2Nyb2xsaW5nKCkpIHtcblx0XHRcdFx0eCA9IHRoaXMuc3RhcnRYIC0geDtcblx0XHRcdFx0eSA9IHRoaXMuc3RhcnRZIC0geTtcblx0XHRcdFx0byA9IHggKyAncHgsICcgKyB5ICsgJ3B4JyArICh0aGlzLmFjY2VsID8gJywwJyA6ICcnKTtcblx0XHRcdFx0RG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMuJC5jbGllbnQsIHRoaXMudHJhbnNsYXRpb24sIG8pO1xuXHRcdFx0XHR0aGlzLl90cmFuc2xhdGVkID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pLFxuXG5cdC8qKlxuXHQqIFdoZW4gc3RvcHBlZCwgd2UgdXNlIGBzY3JvbGxMZWZ0L3Njcm9sbFRvcGAgKG1ha2VzIGN1cnNvciBwb3NpdGlvbmluZyBhdXRvbWFnaWMpLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGVmZmVjdFNjcm9sbFN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMudHJhbnNsYXRlT3B0aW1pemVkKSB7XG5cdFx0XHR2YXIgdCA9ICcwLDAnICsgKHRoaXMuYWNjZWwgPyAnLDAnIDogJycpO1xuXHRcdFx0Ly8gRklYTUU6IG5vcm1hbGx5IHRyYW5zbGF0ZTNkIGNoYW5nZXMgbm90IGVmZmVjdCBzY3JvbGxIZWlnaHQ7IGhvd2V2ZXJcblx0XHRcdC8vIHRoZXJlIGFwcGVhciB0byBiZSBzb21lIGRvbSBjaGFuZ2VzIChlLmcuIHNob3dpbmcgYSBub2RlIGluc2lkZSB0aGUgc2Nyb2xsZXIsXG5cdFx0XHQvLyB3aGljaCBkbyBjYXVzZSB0aGUgc2Nyb2xsSGVpZ2h0IHRvIGJlIGNoYW5nZWQgZnJvbSB0aGUgdHJhbnNsYXRlM2QuXG5cdFx0XHQvLyBJbiB0aGlzIGNhc2Ugc2V0dGluZyB0aGUgdHJhbnNsYXRlM2QgYmFjayB0byAwIGRvZXMgbm90IHJlc3RvcmUgc2Nyb2xsSGVpZ2h0LlxuXHRcdFx0Ly8gVGhpcyBjYXVzZXMgYSBwcm9ibGVtIGJlY2F1c2Ugc2V0dGluZyBzY3JvbGxUb3AgY2FuIHByb2R1Y2VkIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGlmXG5cdFx0XHQvLyBzY3JvbGxIZWlnaHQgaXMgbGVzcyB0aGFuIGV4cGVjdGVkLlxuXHRcdFx0Ly8gV2UgZGV0ZWN0IHRoaXMgZmF1bHQgYnkgdmFsaWRhdGluZyBzY3JvbGwgYm91bmRzIGFuZCAoMSkgdW4tYXBwbHkgdGhlIHRyYW5zbGF0ZTNkLFxuXHRcdFx0Ly8gKDIpIHVwZGF0ZSBzY3JvbGxUb3AvTGVmdCwgYW5kICgzKSByZS1hcHBseSBhIDAsMCwwIHRyYW5zbGF0ZTNkIHRvIGVuc3VyZSBjb21wb3NpdGluZy5cblx0XHRcdC8vIEx1Y2tpbHkgdGhpcyBjb3JyZWN0cyB0aGUgcHJvYmxlbSAod2hpY2ggYXBwZWFycyB0byBiZSBhIHdlYmtpdCBidWcpLiBOb3RlIHRoYXRcblx0XHRcdC8vIGl0J3MgaW1wb3J0YW50IHRvIG1haW50YWluIGEgY29tcG9zaXRlZCBzdGF0ZSAodHJhbnNsYXRlM2QgMCwwLDApIG9yIEFuZHJvaWQgNCBpc1xuXHRcdFx0Ly8gc2xvdyB0byBzdGFydCBzY3JvbGxpbmcuXG5cdFx0XHR2YXIgbSA9IHRoaXMuJC5zY3JvbGxNYXRoLCBzYiA9IHRoaXMuX2dldFNjcm9sbEJvdW5kcygpO1xuXHRcdFx0dmFyIG5lZWRzQm91bmRzRml4ID0gQm9vbGVhbigoc2IubWF4VG9wICsgbS5ib3R0b21Cb3VuZGFyeSkgfHwgKHNiLm1heExlZnQgKyBtLnJpZ2h0Qm91bmRhcnkpKTtcblx0XHRcdERvbS50cmFuc2Zvcm1WYWx1ZSh0aGlzLiQuY2xpZW50LCB0aGlzLnRyYW5zbGF0aW9uLCBuZWVkc0JvdW5kc0ZpeCA/IG51bGwgOiB0KTtcblx0XHRcdC8vIG5vdGU6IHRoaXMgYXN5bmNocm9ub3VzbHkgdHJpZ2dlcnMgZG9tIHNjcm9sbCBldmVudFxuXHRcdFx0dGhpcy5zZXRTY3JvbGxMZWZ0KHRoaXMuc2Nyb2xsTGVmdCk7XG5cdFx0XHR0aGlzLnNldFNjcm9sbFRvcCh0aGlzLnNjcm9sbFRvcCk7XG5cdFx0XHRpZiAobmVlZHNCb3VuZHNGaXgpIHtcblx0XHRcdFx0RG9tLnRyYW5zZm9ybVZhbHVlKHRoaXMuJC5jbGllbnQsIHRoaXMudHJhbnNsYXRpb24sIHQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHJhbnNsYXRlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBGSVhNRTogd2UgY2FuIGZpeCBzY3JvbGxpbmcgYXJ0aWZhY3RzIEJVR1Mgb24gQW5kcm9pZCA0LjA0IHdpdGggdGhpcyBoZWlub3VzIGluY2FudGF0aW9uLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHR3aWRkbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy50cmFuc2xhdGVPcHRpbWl6ZWQgJiYgdGhpcy5zY3JvbGxOb2RlKSB7IC8vIHRoaXMuc2Nyb2xsTm9kZSBpcyBub3QgYWx3YXlzIGRlZmluZWQgYW5kIG1ha2VzIE1vdG9yb2xhIFhPT00gY3Jhc2hcblx0XHRcdHRoaXMuc2Nyb2xsTm9kZS5zY3JvbGxUb3AgPSAxO1xuXHRcdFx0dGhpcy5zY3JvbGxOb2RlLnNjcm9sbFRvcCA9IDA7XG5cdFx0fVxuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55b1wiOjEsXCIuL1RvdWNoU2Nyb2xsU3RyYXRlZ3lcIjo1MyxcIi4vZGlzcGF0Y2hlclwiOjU3LFwiLi9kb21cIjo1OCxcIi4va2luZFwiOjY2fV0sMTMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL3V0aWxzJyksXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9Db250cm9sJyk7XG5cbnZhclxuXHRGaXR0YWJsZUxheW91dCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVMYXlvdXQnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0U2xpZGVhYmxlID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9TbGlkZWFibGUnKSxcblx0Rml0dGFibGVDb2x1bW5zTGF5b3V0ID0gRml0dGFibGVMYXlvdXQuQ29sdW1ucyxcblx0Rml0dGFibGVSb3dzTGF5b3V0ID0gRml0dGFibGVMYXlvdXQuUm93cztcblxudmFyIFNsaWRlYWJsZUluZm8gPSBraW5kKHtcblx0a2luZDogQ29udHJvbCxcblx0cHVibGlzaGVkOiB7XG5cdFx0aW5mbzogbnVsbFxuXHR9LFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ3NsaWRlYWJsZWluZm8tc2FtcGxlJywgY29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICduYW1lJ30sXG5cdFx0XHR7bmFtZTogJ2F4aXMnfSxcblx0XHRcdHtuYW1lOiAndW5pdCd9LFxuXHRcdFx0e25hbWU6ICdtaW4nfSxcblx0XHRcdHtuYW1lOiAnbWF4J30sXG5cdFx0XHR7bmFtZTogJ3ZhbHVlJ31cblx0XHRdfVxuXHRdLFxuXHRoYW5kbGVyczoge1xuXHRcdG9uVXBkYXRlSW5mbzogJ3VwZGF0ZUluZm8nXG5cdH0sXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5pbmZvQ2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXHRpbmZvQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgcCBpbiB0aGlzLmluZm8pIHtcblx0XHRcdGlmICh0aGlzLiRbcF0pIHtcblx0XHRcdFx0dGhpcy4kW3BdLnNldENvbnRlbnQodXRpbHMuY2FwKHApICsgJzogJyArIHRoaXMuaW5mb1twXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHR1cGRhdGVJbmZvOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHRoaXMuc2V0SW5mbyhpbkV2ZW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5TbGlkZWFibGVTYW1wbGUnLFxuXHRjbGFzc2VzOiAnZW55by11bnNlbGVjdGFibGUgZW55by1maXQnLFxuXHRzdHlsZTogJ292ZXJmbG93OiBoaWRkZW47IGJhY2tncm91bmQtY29sb3I6ICMwMDA7Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAndG9wJywga2luZDogU2xpZGVhYmxlLCBheGlzOiAndicsIHVuaXQ6ICclJywgbWluOiAtOTAsIG1heDogMCwgY2xhc3NlczogJ2VueW8tZml0IHNsaWRlYWJsZS1zYW1wbGUgdG9wJywgb25DaGFuZ2U6ICd1cGRhdGVJbmZvJ30sXG5cdFx0e25hbWU6ICdyaWdodCcsIGtpbmQ6IFNsaWRlYWJsZSwgYXhpczogJ2gnLCB1bml0OiAnJScsIG1pbjogMCwgbWF4OiA5MCwgY2xhc3NlczogJ2VueW8tZml0IHNsaWRlYWJsZS1zYW1wbGUgcmlnaHQnLCBvbkNoYW5nZTogJ3VwZGF0ZUluZm8nfSxcblx0XHR7bmFtZTogJ2JvdHRvbScsIGtpbmQ6IFNsaWRlYWJsZSwgYXhpczogJ3YnLCB1bml0OiAnJScsIG1pbjogMCwgbWF4OiA5MCwgY2xhc3NlczogJ2VueW8tZml0IHNsaWRlYWJsZS1zYW1wbGUgYm90dG9tJywgb25DaGFuZ2U6ICd1cGRhdGVJbmZvJ30sXG5cdFx0e25hbWU6ICdsZWZ0Jywga2luZDogU2xpZGVhYmxlLCBheGlzOiAnaCcsIHVuaXQ6ICclJywgbWluOiAtOTAsIG1heDogMCwgY2xhc3NlczogJ2VueW8tZml0IHNsaWRlYWJsZS1zYW1wbGUgbGVmdCcsIG9uQ2hhbmdlOiAndXBkYXRlSW5mbyd9XG5cdF0sXG5cdGhhbmRsZXJzOiB7XG5cdFx0b25kcmFnc3RhcnQ6ICdzdXBwcmVzc1BhbmVsRHJhZydcblx0fSxcblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgc2xpZGVhYmxlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBjIGluIHRoaXMuJCkge1xuXHRcdFx0XHRpZiAodGhpcy4kW2NdLmtpbmQgPT09ICdTbGlkZWFibGUnKSB7XG5cdFx0XHRcdFx0c2xpZGVhYmxlcy5wdXNoKHRoaXMuJFtjXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucG9wdWxhdGUoc2xpZGVhYmxlcyk7XG5cdFx0fTtcblx0fSksXG5cdHBvcHVsYXRlOiBmdW5jdGlvbihpblNsaWRlYWJsZXMpIHtcblx0XHR2YXIgc2xpZGVhYmxlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5TbGlkZWFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzbGlkZWFibGUgPSBpblNsaWRlYWJsZXNbaV07XG5cdFx0XHRzbGlkZWFibGUuY3JlYXRlQ29tcG9uZW50cyhbXG5cdFx0XHRcdHtzdHlsZTogc2xpZGVhYmxlLmF4aXMgPT09ICdoJyA/ICdoZWlnaHQ6IDM4JTsnIDogJyd9LCAvLyBjaGVhdGluZyBoZXJlIGZvciB0aGUgaG9yaXpvbnRhbCBTbGlkZWFibGVzIHRvIG1ha2UgZXZlcnl0aGluZyBuaWNlIGFuZCAoYWxtb3N0KSBjZW50ZXJlZCB2ZXJ0aWNhbGx5XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRraW5kOiBTbGlkZWFibGVJbmZvLFxuXHRcdFx0XHRcdGxheW91dEtpbmQ6IChzbGlkZWFibGUuYXhpcyA9PT0gJ3YnKSA/IEZpdHRhYmxlQ29sdW1uc0xheW91dCA6IEZpdHRhYmxlUm93c0xheW91dCxcblx0XHRcdFx0XHRjbGFzc2VzOiAnZW55by1jZW50ZXInLCAvLyBjaGVhdGluZyBoZXJlIGZvciB0aGUgdmVydGljYWwgU2xpZGVhYmxlcyB0byBtYWtlIGV2ZXJ5dGhpbmcgbmljZSBhbmQgY2VudGVyZWQgaG9yaXpvbnRhbGx5IChubyBlZmZlY3Qgb24gaG9yaXpvbnRhbCBTbGlkZWFibGVzKVxuXHRcdFx0XHRcdGluZm86IHtcblx0XHRcdFx0XHRcdG5hbWU6IHNsaWRlYWJsZS5uYW1lLFxuXHRcdFx0XHRcdFx0YXhpczogc2xpZGVhYmxlLmF4aXMsXG5cdFx0XHRcdFx0XHR1bml0OiBzbGlkZWFibGUudW5pdCxcblx0XHRcdFx0XHRcdG1pbjogc2xpZGVhYmxlLm1pbixcblx0XHRcdFx0XHRcdG1heDogc2xpZGVhYmxlLm1heCxcblx0XHRcdFx0XHRcdHZhbHVlOiBzbGlkZWFibGUudmFsdWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdF0pO1xuXHRcdH1cblx0fSxcblx0dXBkYXRlSW5mbzogZnVuY3Rpb24oaW5TZW5kZXIpIHtcblx0XHRpblNlbmRlci53YXRlcmZhbGxEb3duKCdvblVwZGF0ZUluZm8nLCB7XG5cdFx0XHRuYW1lOiBpblNlbmRlci5uYW1lLFxuXHRcdFx0YXhpczogaW5TZW5kZXIuYXhpcyxcblx0XHRcdHVuaXQ6IGluU2VuZGVyLnVuaXQsXG5cdFx0XHRtaW46IGluU2VuZGVyLm1pbixcblx0XHRcdG1heDogaW5TZW5kZXIubWF4LFxuXHRcdFx0dmFsdWU6IE1hdGgucm91bmQoaW5TZW5kZXIudmFsdWUpXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdC8vIGtlZXBzIHRoZSB2aWV3IHBhbmVsIGZyb20gbW92aW5nIGluIFNhbXBsZXIgYXBwIHdoaWxlIGRyYWdnaW5nIHRoZSBTbGlkZWFibGVcblx0c3VwcHJlc3NQYW5lbERyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQ29udHJvbFwiOjE2LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVMYXlvdXRcIjo4NyxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL1NsaWRlYWJsZVwiOjEwMn1dLDEwNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0ZHJhZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2RyYWcnKSxcblx0QW5pbWF0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9BbmltYXRvcicpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKSxcblx0U2VsZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvU2VsZWN0Jyk7XG5cbnZhclxuXHRlYXNpbmcgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL2Vhc2luZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnbW9vbi5zYW1wbGUuRWFzaW5nU2FtcGxlJyxcblx0Y2xhc3NlczogJ2VueW8tdW5zZWxlY3RhYmxlIGVhc2luZy1zYW1wbGUnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2tpbmQ6IEFuaW1hdG9yLCBuYW1lOiAnYW5pbWF0b3InLCBvblN0ZXA6ICdhbmltYXRvclN0ZXAnLCBvbkVuZDogJ2FuaW1hdG9yQ29tcGxldGUnLCBlYXNpbmdGdW5jdGlvbjogZWFzaW5nLmxpbmVhcn0sXG5cdFx0e25hbWU6ICdjb250YWluZXInLCBjbGFzc2VzOiAnZWFzaW5nLXNhbXBsZS1iYWxsLWNvbnRhaW5lcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnYm94JywgY2xhc3NlczogJ2Vhc2luZy1zYW1wbGUtYmFsbCd9XG5cdFx0XX0sXG5cdFx0e2NsYXNzZXM6ICdlYXNpbmctc2FtcGxlLWNvbnRyb2wtY29udGFpbmVyJywgc3R5bGU6ICdkaXNwbGF5OmlubGluZS1ibG9jazsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ21lbnUnLCBraW5kOiBTZWxlY3QsIG9uY2hhbmdlOiAnaXRlbVNlbGVjdGVkJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7Y29udGVudDogJ0Vhc2luZyBUeXBlJ31cblx0XHRcdF19LFxuXHRcdFx0e25hbWU6ICdidG5BbmltYXRlJywga2luZDogQnV0dG9uLCBjb250ZW50OiAnQW5pbWF0ZScsIG9udGFwOiAncGxheSd9XG5cdFx0XX1cblx0XSxcblx0ZHVyYXRpb246IDEwMDAsXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuYnVpbGRNZW51KCk7XG5cdFx0fTtcblx0fSksXG5cdGl0ZW1TZWxlY3RlZDogZnVuY3Rpb24oc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBpdGVtID0gT2JqZWN0LmtleXMoZWFzaW5nKVtzZW5kZXIuc2VsZWN0ZWQgLSAxXTtcblx0XHR0aGlzLiQuYW5pbWF0b3Iuc2V0RWFzaW5nRnVuY3Rpb24oZWFzaW5nW2l0ZW1dIHx8IGVhc2luZy5saW5lYXIpO1xuXHRcdHRoaXMucGxheSgpO1xuXHR9LFxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLiQuYnRuQW5pbWF0ZS5zZXQoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdFx0dGhpcy4kLmFuaW1hdG9yLnBsYXkoe1xuXHRcdFx0c3RhcnRWYWx1ZTogMCxcblx0XHRcdGVuZFZhbHVlOiAxNTAsXG5cdFx0XHRub2RlOiB0aGlzLiQuYm94Lmhhc05vZGUoKSxcblx0XHRcdGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG5cdFx0fSk7XG5cdH0sXG5cdGFuaW1hdG9yU3RlcDogZnVuY3Rpb24oc2VuZGVyKSB7XG5cdFx0dGhpcy4kLmJveC5hcHBseVN0eWxlKCd0b3AnLCBzZW5kZXIudmFsdWUgKyAncHgnKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0YW5pbWF0b3JDb21wbGV0ZTogZnVuY3Rpb24oc2VuZGVyKSB7XG5cdFx0dGhpcy4kLmJ0bkFuaW1hdGUuc2V0KCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0YnVpbGRNZW51OiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBrIGluIGVhc2luZyl7XG5cdFx0XHR0aGlzLiQubWVudS5jcmVhdGVDb21wb25lbnQoe2NvbnRlbnQ6IGt9KTtcblx0XHR9XG5cdH1cbn0pO1xuXG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0FuaW1hdG9yXCI6NSxcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvU2VsZWN0XCI6NDUsXCIuLi8uLi8uLi9lbnlvL2xpYi9kcmFnXCI6NTksXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL2Vhc2luZ1wiOjEwNX1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0QnV0dG9uID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQnV0dG9uJyksXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9Db250cm9sJyksXG5cdElucHV0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW5wdXQnKTtcblxudmFyXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5GaXR0YWJsZUFwcExheW91dDEnLFxuXHRraW5kOiBGaXR0YWJsZVJvd3MsXG5cdGNsYXNzZXM6ICdlbnlvLWZpdCcsXG5cdGNvbXBvbmVudHM6IFtcblx0XHR7a2luZDogQ29udHJvbCwgY2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAnSGVhZGVyJ30sXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnQnV0dG9uJ30sXG5cdFx0XHR7a2luZDogJ2VueW8uVG9vbERlY29yYXRvcicsIHRhZzogJ2xhYmVsJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogSW5wdXR9XG5cdFx0XHRdfVxuXHRcdF19LFxuXHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGZpdDogdHJ1ZSwgY29tcG9uZW50czogW1xuXHRcdFx0e2NsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtY29sdW1uJ30sXG5cdFx0XHR7a2luZDogRml0dGFibGVSb3dzLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtc2hhZG93JywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7Y2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1yb3cgZml0dGFibGUtc2FtcGxlLXNoYWRvdzInfSxcblx0XHRcdFx0e2ZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1maXR0aW5nLWNvbG9yJ31cblx0XHRcdF19XG5cdFx0XX1cblx0XVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvQ29udHJvbFwiOjE2LFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zXCI6ODUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4fV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKTtcblxudmFyXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5GaXR0YWJsZUFwcExheW91dDInLFxuXHRraW5kOiBGaXR0YWJsZUNvbHVtbnMsXG5cdGNsYXNzZXM6ICdlbnlvLWZpdCcsXG5cdGNvbXBvbmVudHM6IFtcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWNvbHVtbicsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtmaXQ6IHRydWV9LFxuXHRcdFx0e2NsYXNzZXM6ICdsYXlvdXQtc2FtcGxlLXRvb2xiYXInLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICcxJ31cblx0XHRcdF19XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1jb2x1bW4gZml0dGFibGUtc2FtcGxlLXNoYWRvdycsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtmaXQ6IHRydWUsIHN0eWxlOiAnJ30sXG5cdFx0XHR7Y2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJzInfVxuXHRcdFx0XX1cblx0XHRdfSxcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtc2hhZG93JywgY29tcG9uZW50czogW1xuXHRcdFx0e2ZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1maXR0aW5nLWNvbG9yJ30sXG5cdFx0XHR7Y2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJzMnfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdXG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1uc1wiOjg1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3NcIjo4OH1dLDExMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0QnV0dG9uID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQnV0dG9uJyk7XG5cbnZhclxuXHRGaXR0YWJsZUNvbHVtbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1ucycpLFxuXHRGaXR0YWJsZVJvd3MgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuRml0dGFibGVBcHBMYXlvdXQzJyxcblx0a2luZDogRml0dGFibGVDb2x1bW5zLFxuXHRjbGFzc2VzOiAnZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgZml0OiB0cnVlLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Zml0OiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWZpdHRpbmctY29sb3InfSxcblx0XHRcdHtjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLXJvdyBmaXR0YWJsZS1zYW1wbGUtc2hhZG93Myd9LFxuXHRcdFx0e2NsYXNzZXM6ICdsYXlvdXQtc2FtcGxlLXRvb2xiYXInLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICcxJ31cblx0XHRcdF19XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1jb2x1bW4gZml0dGFibGUtc2FtcGxlLXNoYWRvdycsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtmaXQ6IHRydWV9LFxuXHRcdFx0e2NsYXNzZXM6ICdsYXlvdXQtc2FtcGxlLXRvb2xiYXInLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICcyJ31cblx0XHRcdF19XG5cdFx0XX1cblx0XVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnNcIjo4NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODh9XSwxMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdEJ1dHRvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0J1dHRvbicpO1xuXG52YXJcblx0Rml0dGFibGVDb2x1bW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnMnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2VueW8uc2FtcGxlLkZpdHRhYmxlQXBwTGF5b3V0NCcsXG5cdGtpbmQ6IEZpdHRhYmxlQ29sdW1ucyxcblx0Y2xhc3NlczogJ2VueW8tZml0Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBGaXR0YWJsZVJvd3MsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtY29sdW1uIGZpdHRhYmxlLXNhbXBsZS1zaGFkb3c0JywgY29tcG9uZW50czogW1xuXHRcdFx0e2ZpdDogdHJ1ZX0sXG5cdFx0XHR7Y2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2NvbnRlbnQ6ICdUb29sYmFyJ31cblx0XHRcdF19XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgZml0OiB0cnVlLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Zml0OiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWZpdHRpbmctY29sb3InfSxcblx0XHRcdHtjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnMid9XG5cdFx0XHRdfVxuXHRcdF19XG5cdF1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b25cIjoxMCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zXCI6ODUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKTtcblxudmFyXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlSGVhZGVyTGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUhlYWRlckxheW91dCcpLFxuXHRGaXR0YWJsZVJvd3MgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuRml0dGFibGVTYW1wbGUnLFxuXHRraW5kOiBGaXR0YWJsZVJvd3MsXG5cdGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGVueW8tZml0Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtsYXlvdXRLaW5kOiBGaXR0YWJsZUhlYWRlckxheW91dCwgY29tcG9uZW50czpbXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnQmFjayd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGaXR0YWJsZSBTYW1wbGUnLCBmaXQ6IHRydWUsIHN0eWxlOiAndGV4dC1hbGlnbjpjZW50ZXInfSxcblx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdBY3Rpb24gMSd9LFxuXHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ0FjdGlvbiAyJ31cblx0XHRdfSxcblx0XHR7Y29udGVudDogJ0Zvbzxicj5Gb28nLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tdGInfSxcblx0XHR7Y29udGVudDogJ0Zvbzxicj5Gb28nLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tdGInfSxcblx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tdGIgZml0dGFibGUtc2FtcGxlLW8nLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0ZvbycsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdHtjb250ZW50OiAnRm9vJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGaXRzIScsIGZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbyd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGb28nLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ31cblx0XHRdfSxcblx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBjb250ZW50OiAnQmF0JywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW10YiBlbnlvLWNlbnRlcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAnQ2VudGVyZWQnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJzEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJzInLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJzMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJzQnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ31cblx0XHRdfVxuXHRdXG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1uc1wiOjg1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUhlYWRlckxheW91dFwiOjg2LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3NcIjo4OH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uLy4uL2VueW8nKTtcblxuXG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4va2luZCcpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vcGxhdGZvcm0nKTtcblxudmFyXG5cdENvbnRyb2wgPSByZXF1aXJlKCcuLi9Db250cm9sJyksXG5cdFNjcm9sbFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi4vU2Nyb2xsU3RyYXRlZ3knKSxcblx0VG91Y2hTY3JvbGxTdHJhdGVneSA9IHJlcXVpcmUoJy4uL1RvdWNoU2Nyb2xsU3RyYXRlZ3knKSxcblx0VHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3kgPSByZXF1aXJlKCcuLi9UcmFuc2xhdGVTY3JvbGxTdHJhdGVneScpO1xuXG4vKipcbiogQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gcmVwcmVzZW50aW5nIHRoZSBzY3JvbGwgYm91bmRhcmllcy5cbipcbiogQHR5cGVkZWYge09iamVjdH0gZW55by5TY3JvbGxlcn5Cb3VuZGFyeU9iamVjdFxuKiBAcHJvcGVydHkge051bWJlcn0gbGVmdCAtIFRoZSBsZWZ0IHNjcm9sbCBwb3NpdGlvbi5cbiogQHByb3BlcnR5IHtOdW1iZXJ9IHRvcCAtIFRoZSB0b3Agc2Nyb2xsIHBvc2l0aW9uLlxuKiBAcHJvcGVydHkge051bWJlcn0gbWF4TGVmdCAtIE1heGltdW0gdmFsdWUgZm9yIHRoZSBsZWZ0IHNjcm9sbCBwb3NpdGlvbiAobWluaW11bSBpcyBhbHdheXMgMCkuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhUb3AgLSBNYXhpbXVtIHZhbHVlIGZvciB0aGUgdG9wIHNjcm9sbCBwb3NpdGlvbiAobWluaW11bSBpcyBhbHdheXMgMCkuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBjbGllbnRIZWlnaHQgLSBUaGUgdmVydGljYWwgc2l6ZSBvZiB0aGUgW3Njcm9sbGVyXXtAbGluayBlbnlvLlNjcm9sbGVyfSBvblxuKlx0c2NyZWVuLlxuKiBAcHJvcGVydHkge051bWJlcn0gY2xpZW50V2lkdGggLSBUaGUgaG9yaXpvbnRhbCBzaXplIG9mIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IG9uXG4qXHRzY3JlZW4uXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBob3Jpem9udGFsIHNpemUgb2YgdGhlIGZ1bGwgYXJlYSBvZiB0aGUgc2Nyb2xsZWQgcmVnaW9uLlxuKiBAcHJvcGVydHkge051bWJlcn0gaGVpZ2h0IC0gVGhlIHZlcnRpY2FsIHNpemUgb2YgdGhlIGZ1bGwgYXJlYSBvZiB0aGUgc2Nyb2xsZWQgcmVnaW9uLlxuKiBAcHJvcGVydHkge051bWJlcn0geERpciAtIEVpdGhlciBgMWAsIGAtMWAsIG9yIGAwYCwgaW5kaWNhdGluZyBwb3NpdGl2ZSBtb3ZlbWVudCBhbG9uZyB0aGVcbipcdHgtYXhpcywgbmVnYXRpdmUgbW92ZW1lbnQsIG9yIG5vIG1vdmVtZW50LCByZXNwZWN0aXZlbHkuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSB5RGlyIC0gRWl0aGVyIGAxYCwgYC0xYCwgb3IgYDBgLCBpbmRpY2F0aW5nIHBvc2l0aXZlIG1vdmVtZW50IGFsb25nIHRoZVxuKlx0eS1heGlzLCBuZWdhdGl2ZSBtb3ZlbWVudCwgb3Igbm8gbW92ZW1lbnQsIHJlc3BlY3RpdmVseS5cbiovXG5cblxuLyoqXG4qIEFuIFtvYmplY3Rde0BnbG9zc2FyeSBPYmplY3R9IHJlcHJlc2VudGluZyB0aGUgb3ZlcnNjcm9sbCBib3VuZGFyaWVzLlxuKlxuKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnlvLlNjcm9sbGVyfk92ZXJzY3JvbGxCb3VuZGFyeU9iamVjdFxuKiBAcHJvcGVydHkge051bWJlcn0gb3ZlcmxlZnQgLSBUaGUgbGVmdCBvdmVyc2Nyb2xsIHBvc2l0aW9uLlxuKiBAcHJvcGVydHkge051bWJlcn0gb3ZlcnRvcCAtIFRoZSB0b3Agb3ZlcnNjcm9sbCBwb3NpdGlvbi5cbiovXG5cbi8qKlxuKiBUaGUgZXh0ZW5kZWQge0BnbG9zc2FyeSBldmVudH0gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gdGhhdCBpcyBwcm92aWRlZCBcbiogd2hlbiBhIHNjcm9sbCBldmVudCBpcyBmaXJlZC5cbipcbiogQHR5cGVkZWYge09iamVjdH0gZW55by5TY3JvbGxlcn5TY3JvbGxFdmVudFxuKiBAcHJvcGVydHkge2VueW8uU2Nyb2xsZXJ+Qm91bmRhcnlPYmplY3R9IGJvdW5kcyBDdXJyZW50IHZhbHVlcyBvZiBzY3JvbGxlciBib3VuZHMuXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBhIHNjcm9sbGluZyBhY3Rpb24gc3RhcnRzLlxuKlxuKiBAZXZlbnQgZW55by5TY3JvbGxlciNvblNjcm9sbFN0YXJ0XG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZW5kZXIgLSBUaGUgW2NvbXBvbmVudF17QGxpbmsgZW55by5Db21wb25lbnR9IHRoYXQgbW9zdCByZWNlbnRseSBcbipcdHByb3BhZ2F0ZWQgdGhlIHtAZ2xvc3NhcnkgZXZlbnR9LlxuKiBAcHJvcGVydHkge2VueW8uU2Nyb2xsZXJ+U2Nyb2xsRXZlbnR9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBcbipcdGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hpbGUgYSBzY3JvbGxpbmcgYWN0aW9uIGlzIGluIHByb2dyZXNzLlxuKlxuKiBAZXZlbnQgZW55by5TY3JvbGxlciNvblNjcm9sbFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHkgXG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBcbipcdGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBhIHNjcm9sbGluZyBhY3Rpb24gc3RvcHMuXG4qXG4qIEBldmVudCBlbnlvLlNjcm9sbGVyI29uU2Nyb2xsU3RvcFxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge09iamVjdH0gc2VuZGVyIC0gVGhlIFtjb21wb25lbnRde0BsaW5rIGVueW8uQ29tcG9uZW50fSB0aGF0IG1vc3QgcmVjZW50bHkgXG4qXHRwcm9wYWdhdGVkIHRoZSB7QGdsb3NzYXJ5IGV2ZW50fS5cbiogQHByb3BlcnR5IHtPYmplY3R9IGV2ZW50IC0gQW4gW29iamVjdF17QGdsb3NzYXJ5IE9iamVjdH0gY29udGFpbmluZyBcbipcdGV2ZW50IGluZm9ybWF0aW9uLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uU2Nyb2xsZXJ9IGlzIGEgc2Nyb2xsZXIgc3VpdGFibGUgZm9yIHVzZSBpbiBib3RoIGRlc2t0b3AgYW5kIG1vYmlsZVxuKiBhcHBsaWNhdGlvbnMuXG4qIFxuKiBJbiBzb21lIG1vYmlsZSBlbnZpcm9ubWVudHMsIGEgZGVmYXVsdCBzY3JvbGxpbmcgc29sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvclxuKiBET00gZWxlbWVudHMuIEluIHN1Y2ggY2FzZXMsIGBlbnlvLlNjcm9sbGVyYCBpbXBsZW1lbnRzIGEgdG91Y2gtYmFzZWQgc2Nyb2xsaW5nXG4qIHNvbHV0aW9uLCB3aGljaCBtYXkgYmUgb3B0ZWQgaW50byBlaXRoZXIgZ2xvYmFsbHkgKGJ5IHNldHRpbmdcbiogW3RvdWNoU2Nyb2xsaW5nXXtAbGluayBlbnlvLlNjcm9sbGVyI3RvdWNoU2Nyb2xsaW5nfSB0byBgdHJ1ZWApIG9yIG9uIGFcbiogcGVyLWluc3RhbmNlIGJhc2lzIChieSBzcGVjaWZ5aW5nIGEgW3N0cmF0ZWd5S2luZF17QGxpbmsgZW55by5TY3JvbGxlciNzdHJhdGVneUtpbmR9XG4qIG9mIGBcIlRvdWNoU2Nyb2xsU3RyYXRlZ3lcImApLlxuKiBcbiogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvblxuKiBbU2Nyb2xsZXJzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvc2Nyb2xsZXJzLmh0bWx9IGluIHRoZVxuKiBFbnlvIERldmVsb3BlciBHdWlkZS5cbipcbiogQGNsYXNzIGVueW8uU2Nyb2xsZXJcbiogQHB1YmxpY1xuKi9cbnZhciBTY3JvbGxlciA9IG1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLlNjcm9sbGVyLnByb3RvdHlwZSAqLyB7XG5cdFxuXHRuYW1lOiAnZW55by5TY3JvbGxlcicsXG5cdFxuXHRraW5kOiBDb250cm9sLFxuXHRcblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVibGlzaGVkOiBcblx0XHQvKiogQGxlbmRzIGVueW8uU2Nyb2xsZXIucHJvdG90eXBlICovIHtcblxuXHRcdC8qKlxuXHRcdCogU3BlY2lmaWVzIGhvdyB0byBob3Jpem9udGFsbHkgc2Nyb2xsLiAgQWNjZXB0YWJsZSB2YWx1ZXMgYXJlIGAnc2Nyb2xsJ2AsIGAnYXV0bydgLFxuXHRcdCogYCdoaWRkZW4nYCwgYW5kIGAnZGVmYXVsdCdgLiBUaGUgcHJlY2lzZSBlZmZlY3Qgb2YgdGhlIHNldHRpbmcgaXMgZGV0ZXJtaW5lZCBieSB0aGVcblx0XHQqIHNjcm9sbCBzdHJhdGVneS5cblx0XHQqIFxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdkZWZhdWx0J1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0aG9yaXpvbnRhbDogJ2RlZmF1bHQnLFxuXG5cdFx0LyoqXG5cdFx0KiBTcGVjaWZpZXMgaG93IHRvIHZlcnRpY2FsbHkgc2Nyb2xsLiAgQWNjZXB0YWJsZSB2YWx1ZXMgYXJlIGAnc2Nyb2xsJ2AsIGAnYXV0bydgLFxuXHRcdCogYCdoaWRkZW4nYCwgYW5kIGAnZGVmYXVsdCdgLiBUaGUgcHJlY2lzZSBlZmZlY3Qgb2YgdGhlIHNldHRpbmcgaXMgZGV0ZXJtaW5lZCBieSB0aGVcblx0XHQqIHNjcm9sbCBzdHJhdGVneS5cblx0XHQqIFxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdkZWZhdWx0J1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dmVydGljYWw6ICdkZWZhdWx0JyxcblxuXHRcdC8qKlxuXHRcdCogVGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cblx0XHQqIFxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IDBcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHNjcm9sbFRvcDogMCxcblxuXHRcdC8qKlxuXHRcdCogVGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2Nyb2xsTGVmdDogMCxcblxuXHRcdC8qKlxuXHRcdCogTWF4aW11bSBoZWlnaHQgb2YgdGhlIHNjcm9sbCBjb250ZW50LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgbnVsbFxuXHRcdCogQG1lbWJlcm9mIGVueW8uU2Nyb2xsZXIucHJvdG90eXBlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRtYXhIZWlnaHQ6IG51bGwsXG5cblx0XHQvKipcblx0XHQqIFNldCB0byBgdHJ1ZWAgdG8gbWFrZSB0aGlzIFtzY3JvbGxlcl17QGxpbmsgZW55by5TY3JvbGxlcn0gc2VsZWN0IGEgXG5cdFx0KiBwbGF0Zm9ybS1hcHByb3ByaWF0ZSB0b3VjaC1iYXNlZCBzY3JvbGxpbmcgc3RyYXRlZ3kuIE5vdGUgdGhhdCBpZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIFxuXHRcdCogZm9yIFtzdHJhdGVneUtpbmRde0BsaW5rIGVueW8uU2Nyb2xsZXIjc3RyYXRlZ3lLaW5kfSwgdGhhdCB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyXG5cdFx0KiB0aGlzIHNldHRpbmcuXG5cdFx0KiBcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHRvdWNoOiBmYWxzZSxcblx0XHQvKipcblx0XHQqIFNwZWNpZmllcyBhIHR5cGUgb2Ygc2Nyb2xsaW5nLiBUaGUgW3Njcm9sbGVyXXtAbGluayBlbnlvLlNjcm9sbGVyfSB3aWxsIGF0dGVtcHQgdG8gXG5cdFx0KiBhdXRvbWF0aWNhbGx5IHNlbGVjdCBhIHN0cmF0ZWd5IGNvbXBhdGlibGUgd2l0aCB0aGUgcnVudGltZSBlbnZpcm9ubWVudC4gQWx0ZXJuYXRpdmVseSxcblx0XHQqIHlvdSBtYXkgY2hvb3NlIHRvIHVzZSBhIHNwZWNpZmljIHN0cmF0ZWd5OlxuXHRcdCogXG5cdFx0KiAtIFtTY3JvbGxTdHJhdGVneV17QGxpbmsgZW55by5TY3JvbGxTdHJhdGVneX0gaXMgdGhlIGRlZmF1bHQgYW5kIGltcGxlbWVudHMgbm8gXG5cdFx0Klx0c2Nyb2xsaW5nLCByZWx5aW5nIGluc3RlYWQgb24gdGhlIGVudmlyb25tZW50IHRvIHNjcm9sbCBwcm9wZXJseS5cblx0XHQqIC0gW1RvdWNoU2Nyb2xsU3RyYXRlZ3lde0BsaW5rIGVueW8uVG91Y2hTY3JvbGxTdHJhdGVneX0gaW1wbGVtZW50cyBhIHRvdWNoIHNjcm9sbGluZyBcblx0XHQqXHRtZWNoYW5pc20uXG5cdFx0KiAtIFtUcmFuc2xhdGVTY3JvbGxTdHJhdGVneV17QGxpbmsgZW55by5UcmFuc2xhdGVTY3JvbGxTdHJhdGVneX0gaW1wbGVtZW50cyBhIHRvdWNoIFxuXHRcdCpcdHNjcm9sbGluZyBtZWNoYW5pc20gdXNpbmcgdHJhbnNsYXRpb25zOyBpdCBpcyBjdXJyZW50bHkgcmVjb21tZW5kZWQgb25seSBmb3IgQW5kcm9pZFxuXHRcdCpcdDMgYW5kIDQsIGFuZCBXaW5kb3dzIFBob25lIDguXG5cdFx0KiAtIFtUcmFuc2l0aW9uU2Nyb2xsU3RyYXRlZ3lde0BsaW5rIGVueW8uVHJhbnNpdGlvblNjcm9sbFN0cmF0ZWd5fSBpbXBsZW1lbnRzIGEgdG91Y2ggXG5cdFx0Klx0c2Nyb2xsaW5nIG1lY2hhbmlzbSB1c2luZyBDU1MgdHJhbnNpdGlvbnM7IGl0IGlzIGN1cnJlbnRseSByZWNvbW1lbmRlZCBvbmx5IGZvciBpT1MgXG5cdFx0Klx0NSBhbmQgbGF0ZXIuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdTY3JvbGxTdHJhdGVneSdcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHN0cmF0ZWd5S2luZDogU2Nyb2xsU3RyYXRlZ3ksXG5cblx0XHQvKipcblx0XHQqIFNldCB0byBgdHJ1ZWAgdG8gZGlzcGxheSBhIHNjcm9sbCB0aHVtYiBpbiB0b3VjaCBbc2Nyb2xsZXJzXXtAbGluayBlbnlvLlNjcm9sbGVyfS5cblx0XHQqIFxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCB0cnVlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHR0aHVtYjogdHJ1ZSxcblxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgLCBtb3VzZSB3aGVlbCBtYXkgYmUgdXNlZCB0byBtb3ZlIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LlxuXHRcdCogXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IHRydWVcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHVzZU1vdXNlV2hlZWw6IHRydWVcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblNjcm9sbFN0YXJ0OiAnJyxcblx0XHRvblNjcm9sbDogJycsXG5cdFx0b25TY3JvbGxTdG9wOiAnJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIElmIGB0cnVlYCwgZW5hYmxlcyB0b3VjaCBzY3JvbGxpbmcgZ2xvYmFsbHkuXG5cdCpcblx0KiBAbmFtZSB0b3VjaFNjcm9sbGluZ1xuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHQqIEBtZW1iZXJvZiBlbnlvLlNjcm9sbGVyLnByb3RvdHlwZVxuXHQqIEBwdWJsaWNcblx0Ki9cblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAgYW5kIHRoaXMgaXMgYSB0b3VjaCBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LCB0aGUgc2Nyb2xsZXJcblx0KiB3aWxsIG92ZXJzY3JvbGwgYW5kIGJvdW5jZSBiYWNrIGF0IHRoZSBlZGdlcy5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHRydWVcblx0KiBAcHVibGljXG5cdCovXG5cdHRvdWNoT3ZlcnNjcm9sbDogdHJ1ZSxcblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAsIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IHdpbGwgbm90IHByb3BhZ2F0ZSBgZHJhZ3N0YXJ0YCBcblx0KiBbZXZlbnRzXXtAZ2xvc3NhcnkgZXZlbnR9IHRoYXQgY2F1c2UgaXQgdG8gc3RhcnQgc2Nyb2xsaW5nLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0cHJldmVudERyYWdQcm9wYWdhdGlvbjogdHJ1ZSxcblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAsIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IHdpbGwgbm90IHByb3BhZ2F0ZSBzY3JvbGwgXG5cdCogW2V2ZW50c117QGdsb3NzYXJ5IGV2ZW50fS5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHRydWVcblx0KiBAcHVibGljXG5cdCovXG5cdHByZXZlbnRTY3JvbGxQcm9wYWdhdGlvbjogdHJ1ZSxcblxuXHQvKipcblx0KiBOZWVkZWQgdG8gYWxsb3cgZ2xvYmFsIG1vZHMgdG8gYGVueW8uU2Nyb2xsZXIudG91Y2hTY3JvbGxpbmdgLlxuXHQqIFxuXHQqIEBwcml2YXRlXG5cdCovXG5cblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVyczoge1xuXHRcdG9uc2Nyb2xsOiAnZG9tU2Nyb2xsJyxcblx0XHRvblNjcm9sbFN0YXJ0OiAnc2Nyb2xsU3RhcnQnLFxuXHRcdG9uU2Nyb2xsOiAnc2Nyb2xsJyxcblx0XHRvblNjcm9sbFN0b3A6ICdzY3JvbGxTdG9wJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNsYXNzZXM6ICdlbnlvLXNjcm9sbGVyJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdGF0aWNzOiB7XG5cdFx0b3NJbmZvOiBbXG5cdFx0XHR7b3M6ICdhbmRyb2lkJywgdmVyc2lvbjogM30sXG5cdFx0XHR7b3M6ICdhbmRyb2lkQ2hyb21lJywgdmVyc2lvbjogMTh9LFxuXHRcdFx0e29zOiAnYW5kcm9pZEZpcmVmb3gnLCB2ZXJzaW9uOiAxNn0sXG5cdFx0XHR7b3M6ICdmaXJlZm94T1MnLCB2ZXJzaW9uOiAxNn0sXG5cdFx0XHR7b3M6ICdpb3MnLCB2ZXJzaW9uOiA1fSxcblx0XHRcdHtvczogJ3dlYm9zJywgdmVyc2lvbjogMWU5fSxcblx0XHRcdHtvczogJ2JsYWNrYmVycnknLCB2ZXJzaW9uOjFlOX0sXG5cdFx0XHR7b3M6ICd0aXplbicsIHZlcnNpb246IDJ9XG5cdFx0XSxcblx0XHQvLyogUmV0dXJucyB0cnVlIGlmIHBsYXRmb3JtIHNob3VsZCBoYXZlIHRvdWNoIGV2ZW50cy5cblx0XHRoYXNUb3VjaFNjcm9sbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIHQ7ICh0PXRoaXMub3NJbmZvW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGlmIChwbGF0Zm9ybVt0Lm9zXSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBzcGVjaWFsIGRldGVjdGlvbiBmb3IgSUUxMCsgb24gdG91Y2ggZGV2aWNlc1xuXHRcdFx0aWYgKChwbGF0Zm9ybS5pZSA+PSAxMCB8fCBwbGF0Zm9ybS53aW5kb3dzUGhvbmUgPj0gOCkgJiYgcGxhdGZvcm0udG91Y2gpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHRcdFJldHVybnMgdHJ1ZSBpZiB0aGUgcGxhdGZvcm0gaGFzIG5hdGl2ZSBkaXYgc2Nyb2xsZXJzIChkZXNrdG9wXG5cdFx0XHRicm93c2VycyBhbHdheXMgaGF2ZSB0aGVtKS5cblx0XHQqL1xuXHRcdGhhc05hdGl2ZVNjcm9sbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIHQ7ICh0PXRoaXMub3NJbmZvW2ldKTsgaSsrKSB7XG5cdFx0XHRcdGlmIChwbGF0Zm9ybVt0Lm9zXSA8IHQudmVyc2lvbikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRnZXRUb3VjaFN0cmF0ZWd5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAocGxhdGZvcm0uYW5kcm9pZENocm9tZSA+PSAyNykgfHwgKHBsYXRmb3JtLmFuZHJvaWQgPj0gMykgfHwgKHBsYXRmb3JtLndpbmRvd3NQaG9uZSA9PT0gOCkgfHwgKHBsYXRmb3JtLndlYm9zID49IDQpXG5cdFx0XHRcdD8gVHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3lcblx0XHRcdFx0OiBUb3VjaFNjcm9sbFN0cmF0ZWd5O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb250cm9sUGFyZW50TmFtZTogJ3N0cmF0ZWd5JyxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5ob3Jpem9udGFsQ2hhbmdlZCgpO1xuXHRcdFx0dGhpcy52ZXJ0aWNhbENoYW5nZWQoKTtcblx0XHRcdHRoaXMudXNlTW91c2VXaGVlbENoYW5nZWQoKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1wb3J0UHJvcHM6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGluUHJvcHMpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gYWxsb3cgZ2xvYmFsIG92ZXJyaWRpbmcgb2Ygc3RyYXRlZ3kga2luZFxuXHRcdFx0aWYgKGluUHJvcHMgJiYgaW5Qcm9wcy5zdHJhdGVneUtpbmQgPT09IHVuZGVmaW5lZCAmJiAoU2Nyb2xsZXIudG91Y2hTY3JvbGxpbmcgfHwgdGhpcy50b3VjaCkpIHtcblx0XHRcdFx0dGhpcy5zdHJhdGVneUtpbmQgPSBTY3JvbGxlci5nZXRUb3VjaFN0cmF0ZWd5KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluaXRDb21wb25lbnRzOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc3RyYXRlZ3lLaW5kQ2hhbmdlZCgpO1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5zeW5jU3RyYXRlZ3koKTtcblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3luY1N0cmF0ZWd5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLiQuc3RyYXRlZ3kuc2V0U2Nyb2xsTGVmdCh0aGlzLnNjcm9sbExlZnQpO1xuXHRcdHRoaXMuJC5zdHJhdGVneS5zZXRTY3JvbGxUb3AodGhpcy5zY3JvbGxUb3ApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHN0cmF0ZWd5S2luZENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy4kLnN0cmF0ZWd5KSB7XG5cdFx0XHR0aGlzLiQuc3RyYXRlZ3kuZGVzdHJveSgpO1xuXHRcdFx0dGhpcy5jb250cm9sUGFyZW50ID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gbm90ZTogY3JlYXRlQ29tcG9uZW50cyBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgY29udHJvbFBhcmVudC5cblx0XHR0aGlzLmNyZWF0ZVN0cmF0ZWd5KCk7XG5cdFx0aWYgKHRoaXMuaGFzTm9kZSgpKSB7XG5cdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGVTdHJhdGVneTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50cyhbe25hbWU6ICdzdHJhdGVneScsIG1heEhlaWdodDogdGhpcy5tYXhIZWlnaHQsXG5cdFx0XHRraW5kOiB0aGlzLnN0cmF0ZWd5S2luZCwgdGh1bWI6IHRoaXMudGh1bWIsXG5cdFx0XHRwcmV2ZW50RHJhZ1Byb3BhZ2F0aW9uOiB0aGlzLnByZXZlbnREcmFnUHJvcGFnYXRpb24sXG5cdFx0XHRvdmVyc2Nyb2xsOnRoaXMudG91Y2hPdmVyc2Nyb2xsLCBpc0Nocm9tZTogdHJ1ZX1dKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRTdHJhdGVneTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLiQuc3RyYXRlZ3k7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bWF4SGVpZ2h0Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5zdHJhdGVneS5zZXRNYXhIZWlnaHQodGhpcy5tYXhIZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG93aW5nQ2hhbmdlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGlmICh0aGlzLnNob3dpbmcpIHtcblx0XHRcdFx0dGhpcy5zeW5jU3RyYXRlZ3koKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaG93aW5nQ2hhbmdlZEhhbmRsZXI6IGtpbmQuaW5oZXJpdChmdW5jdGlvbihzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oc2VuZGVyLCBldmVudCkge1xuXHRcdFx0aWYgKHRoaXMuc2hvd2luZyAmJiBldmVudC5zaG93aW5nKSB7XG5cdFx0XHRcdHRoaXMuc3luY1N0cmF0ZWd5KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSksXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dGh1bWJDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnN0cmF0ZWd5LnNldFRodW1iKHRoaXMudGh1bWIpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhvcml6b250YWxDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnN0cmF0ZWd5LnNldEhvcml6b250YWwodGhpcy5ob3Jpem9udGFsKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR2ZXJ0aWNhbENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQuc3RyYXRlZ3kuc2V0VmVydGljYWwodGhpcy52ZXJ0aWNhbCk7XG5cdH0sXG5cblx0Ly8gRklYTUU6IHRoZXNlIHByb3BlcnRpZXMgYXJlIHZpcnR1YWw7IHByb3BlcnR5IGNoYW5nZWQgbWV0aG9kcyBhcmUgZmlyZWQgb25seSBpZlxuXHQvLyBwcm9wZXJ0eSB2YWx1ZSBjaGFuZ2VzLCBub3QgaWYgZ2V0dGVyIGNoYW5nZXMuXG5cdFxuXHQvKipcblx0KiBTZXRzIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IC0gVGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAcHVibGljXG5cdCovXG5cdHNldFNjcm9sbExlZnQ6IGZ1bmN0aW9uIChsZWZ0KSB7XG5cdFx0dGhpcy4kLnN0cmF0ZWd5LnNldFNjcm9sbExlZnQobGVmdCk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2V0cyB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHRvcCAtIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2V0U2Nyb2xsVG9wOiBmdW5jdGlvbiAodG9wKSB7XG5cdFx0dGhpcy4kLnN0cmF0ZWd5LnNldFNjcm9sbFRvcCh0b3ApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG5cdCpcblx0KiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gaW4gcGl4ZWxzLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHN5bmMgb3VyIGludGVybmFsIHByb3BlcnR5XG5cdFx0dGhpcy5zY3JvbGxMZWZ0ID0gdGhpcy4kLnN0cmF0ZWd5LmdldFNjcm9sbExlZnQoKTtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxMZWZ0O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuXHQqXG5cdCogQHJldHVybnMge051bWJlcn0gVGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTY3JvbGxUb3A6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBzeW5jIG91ciBpbnRlcm5hbCBwcm9wZXJ0eVxuXHRcdHRoaXMuc2Nyb2xsVG9wID0gdGhpcy4kLnN0cmF0ZWd5LmdldFNjcm9sbFRvcCgpO1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbFRvcDtcblx0fSxcblxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIHNjcm9sbCBib3VuZGFyaWVzIG9mIHRoZSBbc2Nyb2xsZXJde0BsaW5rIGVueW8uU2Nyb2xsZXJ9LlxuXHQqIFxuXHQqIEByZXR1cm5zIHtlbnlvLlNjcm9sbGVyfkJvdW5kYXJ5T2JqZWN0fSBBbiBbb2JqZWN0XXtAZ2xvc3NhcnkgT2JqZWN0fSBkZXNjcmliaW5nIHRoZSBcblx0Klx0c2Nyb2xsIGJvdW5kYXJpZXMuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRnZXRTY3JvbGxCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzICA9IHRoaXMuJC5zdHJhdGVneS5nZXRTY3JvbGxCb3VuZHMoKTtcblx0XHRpZiAoXG5cdFx0XHQoYm91bmRzLnhEaXIgIT09IC0xICYmIGJvdW5kcy54RGlyICE9PSAwICYmIGJvdW5kcy54RGlyICE9PSAxKSB8fFxuXHRcdFx0KGJvdW5kcy55RGlyICE9PSAtMSAmJiBib3VuZHMueURpciAhPT0gMCAmJiBib3VuZHMueURpciAhPT0gMSlcblx0XHQpIHtcblx0XHRcdHRoaXMuZGVjb3JhdGVCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0Ly8ga2VlcCBvdXIgcHJvcGVydGllcyBzeW5jaHJvbml6ZWQgYWx3YXlzIGFuZCB3aXRob3V0IGV4dHJhIGNhbGxzXG5cdFx0dGhpcy5zY3JvbGxUb3AgID0gYm91bmRzLnRvcDtcblx0XHR0aGlzLnNjcm9sbExlZnQgPSBib3VuZHMubGVmdDtcblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBUcmlnZ2VyIGEgcmVtZWFzdXJlbWVudCBvZiB0aGUgc2Nyb2xsZXIncyBtZXRyaWNzIChzcGVjaWZpY2FsbHksIHRoZVxuXHQqIHNpemUgb2YgaXRzIHZpZXdwb3J0LCB0aGUgc2l6ZSBvZiBpdHMgY29udGVudHMgYW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cblx0KiB0aGUgdHdvLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBleHRlbnQgdG8gd2hpY2ggdGhlIHNjcm9sbGVyIG1heSBzY3JvbGwpLlxuXHQqIFxuXHQqIFlvdSBzaG91bGQgZ2VuZXJhbGx5IG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmcm9tIGFwcGxpY2F0aW9uIGNvZGUsIGFzIHRoZVxuXHQqIHNjcm9sbGVyIHVzdWFsbHkgcmVtZWFzdXJlcyBhdXRvbWF0aWNhbGx5IHdoZW5ldmVyIG5lZWRlZC4gVGhpcyBtZXRob2Rcblx0KiBleGlzdHMgcHJpbWFyaWx5IHRvIHN1cHBvcnQgYW4gaW50ZXJuYWwgdXNlIGNhc2UgZm9yXG5cdCogW2VueW8uRGF0YUxpc3Rde0BsaW5rIGVueW8uRGF0YUxpc3R9LlxuXHQqXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRyZW1lYXN1cmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzID0gdGhpcy4kLnN0cmF0ZWd5O1xuXHRcdGlmIChzLnJlbWVhc3VyZSkgcy5yZW1lYXN1cmUoKTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRoZSBnaXZlbiBbY29udHJvbF17QGxpbmsgZW55by5Db250cm9sfSBpbnRvIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29udHJvbH0gY3RsIC0gVGhlIGNvbnRyb2wgdG8gbWFrZSB2aXNpYmxlIGluIHRoZVxuXHQqXHRbc2Nyb2xsZXInc117QGxpbmsgZW55by5TY3JvbGxlcn0gdmlld3BvcnQuXG5cdCogQHBhcmFtIHtCb29sZWFufSBhbGlnbldpdGhUb3AgLSBJZiBgdHJ1ZWAsIHRoZSBub2RlIGlzIGFsaWduZWQgd2l0aCB0aGUgdG9wXG5cdCogb2YgdGhlIHNjcm9sbGVyLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uIChjdGwsIGFsaWduV2l0aFRvcCkge1xuXHRcdHRoaXMuJC5zdHJhdGVneS5zY3JvbGxJbnRvVmlldyhjdGwsIGFsaWduV2l0aFRvcCk7XG5cdH0sXG5cblx0LyoqIFxuXHQqIFNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIGB4YCBwb3NpdGlvbiBpbiBwaXhlbHMuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgYHlgIHBvc2l0aW9uIGluIHBpeGVscy5cblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdHRoaXMuJC5zdHJhdGVneS5zY3JvbGxUbyh4LCB5KTtcblx0fSxcblxuXHQvKipcblx0KiBFbnN1cmVzIHRoYXQgdGhlIGdpdmVuIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IGlzIHZpc2libGUgaW4gdGhlIFxuXHQqIFtzY3JvbGxlcidzXXtAbGluayBlbnlvLlNjcm9sbGVyfSB2aWV3cG9ydC4gVW5saWtlIFxuXHQqIFtzY3JvbGxJbnRvVmlldygpXXtAbGluayBlbnlvLlNjcm9sbGVyI3Njcm9sbEludG9WaWV3fSwgd2hpY2ggdXNlcyBET00ncyBcblx0KiBbc2Nyb2xsSW50b1ZpZXcoKV17QGdsb3NzYXJ5IHNjcm9sbEludG9WaWV3fSwgdGhpcyBvbmx5IGFmZmVjdHMgdGhlIGN1cnJlbnQgXG5cdCogc2Nyb2xsZXIuXG5cdCpcblx0KiBAcGFyYW0ge2VueW8uQ29udHJvbH0gY3RsIC0gVGhlIFtjb250cm9sXXtAbGluayBlbnlvLkNvbnRyb2x9IHRvIG1ha2UgdmlzaWJsZSBpbiB0aGVcblx0Klx0W3Njcm9sbGVyJ3Nde0BsaW5rIGVueW8uU2Nyb2xsZXJ9IHZpZXdwb3J0LlxuXHQqIEBwYXJhbSB7Qm9vbGVhbn0gYWxpZ25XaXRoVG9wIC0gSWYgYHRydWVgLCB0aGUgbm9kZSBpcyBhbGlnbmVkIHdpdGggdGhlIHRvcCBvZiB0aGVcblx0Klx0c2Nyb2xsZXIuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzY3JvbGxUb0NvbnRyb2w6IGZ1bmN0aW9uIChjdGwsIGFsaWduV2l0aFRvcCkge1xuXHRcdHRoaXMuc2Nyb2xsVG9Ob2RlKGN0bC5oYXNOb2RlKCksIGFsaWduV2l0aFRvcCk7XG5cdH0sXG5cblx0LyoqIFxuXHQqIEVuc3VyZXMgdGhhdCB0aGUgZ2l2ZW4gbm9kZSBpcyB2aXNpYmxlIGluIHRoZSBbc2Nyb2xsZXInc117QGxpbmsgZW55by5TY3JvbGxlcn0gdmlld3BvcnQuXG5cdCpcblx0KiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBtYWtlIHZpc2libGUgaW4gdGhlIFtzY3JvbGxlcidzXXtAbGluayBlbnlvLlNjcm9sbGVyfVxuXHQqXHR2aWV3cG9ydC5cblx0KiBAcGFyYW0ge0Jvb2xlYW59IGFsaWduV2l0aFRvcCAtIElmIGB0cnVlYCwgdGhlIG5vZGUgaXMgYWxpZ25lZCB3aXRoIHRoZSB0b3Agb2YgdGhlXG5cdCpcdHNjcm9sbGVyLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsVG9Ob2RlOiBmdW5jdGlvbiAobm9kZSwgYWxpZ25XaXRoVG9wKSB7XG5cdFx0dGhpcy4kLnN0cmF0ZWd5LnNjcm9sbFRvTm9kZShub2RlLCBhbGlnbldpdGhUb3ApO1xuXHR9LFxuXG5cdC8qKiBcblx0KiBTdG9wcyB0aGUgc2Nyb2xsZXIgaWYgaXQgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cblx0KiBcblx0KiBAcHVibGljXG5cdCovXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy4kLnN0cmF0ZWd5LnN0b3AgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy4kLnN0cmF0ZWd5LnN0b3AodHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBcblx0KiBBZGRzIGN1cnJlbnQgdmFsdWVzIG9mIGBnZXRTY3JvbGxCb3VuZHMoKWAgdG8ge0BnbG9zc2FyeSBldmVudH0uXG5cdCogXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVjb3JhdGVTY3JvbGxFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYm91bmRzID0gZS5zY3JvbGxCb3VuZHMgPSBlLnNjcm9sbEJvdW5kcyB8fCB0aGlzLiQuc3RyYXRlZ3kuX2dldFNjcm9sbEJvdW5kcygpO1xuXHRcdC8vIGluIHRoZSBvZmYgY2hhbmNlIHRoYXQgdGhlIGV2ZW50IGFscmVhZHkgaGFkIHNjcm9sbEJvdW5kcyB0aGVuIHdlIG5lZWRcblx0XHQvLyB0byBtYWtlIHN1cmUgdGhleSBhcmUgZGVjb3JhdGVkXG5cdFx0aWYgKFxuXHRcdFx0KGJvdW5kcy54RGlyICE9PSAtMSAmJiBib3VuZHMueERpciAhPT0gMCAmJiBib3VuZHMueERpciAhPT0gMSkgfHxcblx0XHRcdChib3VuZHMueURpciAhPT0gLTEgJiYgYm91bmRzLnlEaXIgIT09IDAgJiYgYm91bmRzLnlEaXIgIT09IDEpXG5cdFx0KSB7XG5cdFx0XHR0aGlzLmRlY29yYXRlQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdC8vIGtlZXAgb3VyIHByb3BlcnRpZXMgc3luY2hyb25pemVkIGFsd2F5cyBhbmQgd2l0aG91dCBleHRyYSBjYWxsc1xuXHRcdHRoaXMuc2Nyb2xsVG9wICA9IGJvdW5kcy50b3A7XG5cdFx0dGhpcy5zY3JvbGxMZWZ0ID0gYm91bmRzLmxlZnQ7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZGVjb3JhdGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgeCAgICAgICA9IHRoaXMuc2Nyb2xsTGVmdCAtIGJvdW5kcy5sZWZ0LFxuXHRcdFx0eSAgICAgICA9IHRoaXMuc2Nyb2xsVG9wICAtIGJvdW5kcy50b3A7XG5cdFx0Ym91bmRzLnhEaXIgPSAoeCA8IDA/IDE6IHggPiAwPyAtMTogMCk7XG5cdFx0Ym91bmRzLnlEaXIgPSAoeSA8IDA/IDE6IHkgPiAwPyAtMTogMCk7XG5cdFx0Ly8gd2UgdXBkYXRlIG91ciBjdXJyZW50IGJvdW5kcyBwcm9wZXJ0aWVzIHNvIHdlIGRvbid0IGhhdmUgdG8gdW5uZWNlc3NhcmlseVxuXHRcdC8vIGNhbGwgZ2V0U2Nyb2xsVG9wL2dldFNjcm9sbExlZnQgYmVjYXVzZSB3ZSBhbHJlYWR5IGhhdmUgdGhlIGN1cnJlbnQgZGF0YVxuXHRcdHRoaXMuc2Nyb2xsTGVmdCA9IGJvdW5kcy5sZWZ0O1xuXHRcdHRoaXMuc2Nyb2xsVG9wICA9IGJvdW5kcy50b3A7XG5cdH0sXG5cblx0LyoqIFxuXHQqIE5vcm1hbGl6ZXMgc2Nyb2xsIHtAZ2xvc3NhcnkgZXZlbnR9IHRvIGBvblNjcm9sbGAuXG5cdCpcblx0KiBAZmlyZXMgZW55by5TY3JvbGxlciNvblNjcm9sbFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvbVNjcm9sbDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIGlmIGEgc2Nyb2xsIGV2ZW50IG9yaWdpbmF0ZWQgaGVyZSwgcGFzcyBpdCB0byBvdXIgc3RyYXRlZ3kgdG8gaGFuZGxlXG5cdFx0aWYgKHRoaXMuJC5zdHJhdGVneS5kb21TY3JvbGwgJiYgZS5vcmlnaW5hdG9yID09IHRoaXMpIHtcblx0XHRcdHRoaXMuJC5zdHJhdGVneS5kb21TY3JvbGwoc2VuZGVyLCBlKTtcblx0XHR9XG5cdFx0dGhpcy5kZWNvcmF0ZVNjcm9sbEV2ZW50KGUpO1xuXHRcdHRoaXMuZG9TY3JvbGwoZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY3VycmVudCBzY3JvbGwge0BnbG9zc2FyeSBldmVudH0gc2hvdWxkXG5cdCogYmUgc3RvcHBlZDsgYGZhbHNlYCBpZiBpdCBzaG91bGQgYmUgYWxsb3dlZCB0byBwcm9wYWdhdGUuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2hvdWxkU3RvcFNjcm9sbEV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHJldHVybiAodGhpcy5wcmV2ZW50U2Nyb2xsUHJvcGFnYXRpb24gJiZcblx0XHRcdGUub3JpZ2luYXRvci5vd25lciAhPSB0aGlzLiQuc3RyYXRlZ3kpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGxzIFtzaG91bGRTdG9wU2Nyb2xsRXZlbnQoKV17QGxpbmsgZW55by5TY3JvbGxlciNzaG91bGRTdG9wU2Nyb2xsRXZlbnR9IHRvXG5cdCogZGV0ZXJtaW5lIHdoZXRoZXIgY3VycmVudCBzY3JvbGwge0BnbG9zc2FyeSBldmVudH0gc2hvdWxkIGJlIHN0b3BwZWQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGxTdGFydDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdGlmICghdGhpcy5zaG91bGRTdG9wU2Nyb2xsRXZlbnQoZSkpIHtcblx0XHRcdHRoaXMuZGVjb3JhdGVTY3JvbGxFdmVudChlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqIFxuXHQqIEVpdGhlciBwcm9wYWdhdGVzIG9yIHN0b3BzIHRoZSBjdXJyZW50IHNjcm9sbCB7QGdsb3NzYXJ5IGV2ZW50fS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbDogZnVuY3Rpb24gKHNlbmRlciwgZSkge1xuXHRcdC8vIG5vdGU6IHNjcm9sbCBldmVudCBjYW4gYmUgbmF0aXZlIGRvbSBvciBnZW5lcmF0ZWQuXG5cdFx0dmFyIHN0b3A7XG5cdFx0aWYgKGUuZGlzcGF0Y2hUYXJnZXQpIHtcblx0XHRcdC8vIGFsbG93IGEgZG9tIGV2ZW50IGlmIGl0IG9yaWduYXRlZCB3aXRoIHRoaXMgc2Nyb2xsZXIgb3IgaXRzIHN0cmF0ZWd5XG5cdFx0XHRzdG9wID0gdGhpcy5wcmV2ZW50U2Nyb2xsUHJvcGFnYXRpb24gJiYgIShlLm9yaWdpbmF0b3IgPT0gdGhpcyB8fFxuXHRcdFx0XHRlLm9yaWdpbmF0b3Iub3duZXIgPT0gdGhpcy4kLnN0cmF0ZWd5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RvcCA9IHRoaXMuc2hvdWxkU3RvcFNjcm9sbEV2ZW50KGUpO1xuXHRcdH1cblx0XHRpZiAoIXN0b3ApIHtcblx0XHRcdHRoaXMuZGVjb3JhdGVTY3JvbGxFdmVudChlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogQ2FsbHMgW3Nob3VsZFN0b3BTY3JvbGxFdmVudCgpXXtAbGluayBlbnlvLlNjcm9sbGVyI3Nob3VsZFN0b3BTY3JvbGxFdmVudH0gdG9cblx0KiBkZXRlcm1pbmUgd2hldGhlciBjdXJyZW50IHNjcm9sbCB7QGdsb3NzYXJ5IGV2ZW50fSBzaG91bGQgYmUgc3RvcHBlZC5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNjcm9sbFN0b3A6IGZ1bmN0aW9uIChzZW5kZXIsIGUpIHtcblx0XHRpZiAoIXRoaXMuc2hvdWxkU3RvcFNjcm9sbEV2ZW50KGUpKSB7XG5cdFx0XHR0aGlzLmRlY29yYXRlU2Nyb2xsRXZlbnQoZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNjcm9sbHMgdG8gdGhlIHRvcCBvZiB0aGUgc2Nyb2xsaW5nIHJlZ2lvbi5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0c2Nyb2xsVG9Ub3A6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFNjcm9sbFRvcCgwKTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbGluZyByZWdpb24uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvQm90dG9tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRTY3JvbGxUb3AodGhpcy5nZXRTY3JvbGxCb3VuZHMoKS5tYXhUb3ApO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNjcm9sbHMgdG8gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHNjcm9sbGluZyByZWdpb24uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFNjcm9sbExlZnQodGhpcy5nZXRTY3JvbGxCb3VuZHMoKS5tYXhMZWZ0KTtcblx0fSxcblxuXHQvKipcblx0KiBTY3JvbGxzIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHNjcm9sbGluZyByZWdpb24uXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvTGVmdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0U2Nyb2xsTGVmdCgwKTtcblx0fSxcblxuXHQvKipcblx0KiBFbnN1cmVzIHNjcm9sbCBwb3NpdGlvbiBpcyBpbiBib3VuZHMuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHN0YWJpbGl6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5nZXRTdHJhdGVneSgpO1xuXHRcdGlmIChzLnN0YWJpbGl6ZSkge1xuXHRcdFx0cy5zdGFiaWxpemUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogU2VuZHMgdGhlIFt1c2VNb3VzZVdoZWVsXXtAbGluayBlbnlvLlNjcm9sbGVyI3VzZU1vdXNlV2hlZWx9IHByb3BlcnR5IHRvIHRoZSBzY3JvbGwgXG5cdCogc3RyYXRlZ3kuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR1c2VNb3VzZVdoZWVsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5zdHJhdGVneS5zZXRVc2VNb3VzZVdoZWVsKHRoaXMudXNlTW91c2VXaGVlbCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVzaXplOiBraW5kLmluaGVyaXQoZnVuY3Rpb24gKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5nZXRBYnNvbHV0ZVNob3dpbmcodHJ1ZSkpIHtcblx0XHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSlcbn0pO1xuXG4vLyBwcm92aWRlIGEgdG91Y2ggc2Nyb2xsaW5nIHNvbHV0aW9uIGJ5IGRlZmF1bHQgd2hlbiB0aGUgZW52aXJvbm1lbnQgaXMgbW9iaWxlXG5pZiAoU2Nyb2xsZXIuaGFzVG91Y2hTY3JvbGxpbmcoKSkge1xuXHRTY3JvbGxlci5wcm90b3R5cGUuc3RyYXRlZ3lLaW5kID0gU2Nyb2xsZXIuZ2V0VG91Y2hTdHJhdGVneSgpO1xufVxufSx7XCIuLi8uLi8uLi9lbnlvXCI6MSxcIi4uL0NvbnRyb2xcIjoxNixcIi4uL1Njcm9sbFN0cmF0ZWd5XCI6NDIsXCIuLi9Ub3VjaFNjcm9sbFN0cmF0ZWd5XCI6NTMsXCIuLi9UcmFuc2xhdGVTY3JvbGxTdHJhdGVneVwiOjU0LFwiLi4va2luZFwiOjY2LFwiLi4vcGxhdGZvcm1cIjo3MSxcIi4uL3V0aWxzXCI6NzV9XSw5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi91dGlscycpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyk7XG5cbnZhclxuXHRGbHl3ZWlnaHRSZXBlYXRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRmx5d2VpZ2h0UmVwZWF0ZXInKTtcblxudmFyXG5cdG1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcblxuLyoqXG4qIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgbWV0cmljcyBhYm91dCBhIHBhZ2UuXG4qXG4qIEB0eXBlZGVmIHtPYmplY3R9IGVueW8uTGlzdH5QYWdlSW5mb1xuKiBAcHJvcGVydHkge051bWJlcn0gbm8gICAgICAgLSBUaGUgcGFnZSBudW1iZXIuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBzaXplICAgICAtIFRoZSBwYWdlIHNpemUuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBwb3MgICAgICAtIFRoZSBwYWdlIHBvc2l0aW9uLlxuKiBAcHJvcGVydHkge051bWJlcn0gc3RhcnRSb3cgLSBUaGUgaW5kZXggb2YgdGhlIHBhZ2UncyBmaXJzdCByb3cuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBlbmRSb3cgICAtIFRoZSBpbmRleCBvZiB0aGUgcGFnZSdzIGxhc3Qgcm93LlxuKi9cblxuLyoqXG4qIEZpcmVzIG9uY2UgcGVyIHJvdyBhdCByZW5kZXIgdGltZS5cbipcbiogQGV2ZW50IGVueW8uTGlzdCNvblNldHVwSXRlbVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHJvcGVydHkge051bWJlcn0gaW5kZXggLSBUaGUgY3VycmVudCByb3cgaW5kZXguXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHJlb3JkZXJpbmcgc3RhcnRzLCB0byBzZXR1cCByZW9yZGVyaW5nIGNvbXBvbmVudHMuIE5vIGFkZGl0aW9uYWxcbiogZGF0YSBpcyBpbmNsdWRlZCB3aXRoIHRoaXMgZXZlbnQuXG4qXG4qIEBldmVudCBlbnlvLkxpc3Qjb25TZXR1cFJlb3JkZXJDb21wb25lbnRzXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBpbmRleCAtIFRoZSBjdXJyZW50IHJvdyBpbmRleC5cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gcmVvcmRlcmluZyBjb21wbGV0ZXMuXG4qXG4qIEBldmVudCBlbnlvLkxpc3Qjb25SZW9yZGVyXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSByZW9yZGVyVG8gICAtIFRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gcm93LlxuKiBAcHJvcGVydHkge051bWJlcn0gcmVvcmRlckZyb20gLSBUaGUgaW5kZXggb2YgdGhlIHNvdXJjZSByb3cuXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyB3aGVuIHBpbm5lZCByZW9yZGVyaW5nIHN0YXJ0cy4gTm8gYWRkaXRpb25hbCBkYXRhIGlzIGluY2x1ZGVkIHdpdGhcbiogdGhpcyBldmVudC5cbipcbiogQGV2ZW50IGVueW8uTGlzdCNvblNldHVwUGlubmVkUmVvcmRlckNvbXBvbmVudHNcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gc3dpcGluZyBzdGFydHMsIHRvIHNldCB1cCBzd2lwZWFibGUgY29tcG9uZW50cy4gTm8gYWRkaXRpb25hbFxuKiBkYXRhIGlzIGluY2x1ZGVkIHdpdGggdGhpcyBldmVudC5cbipcbiogQGV2ZW50IGVueW8uTGlzdCNvblNldHVwU3dpcGVJdGVtXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBAdG9kbyBvblN3aXBlRHJhZyBpcyBuZXZlciBmaXJlZFxuKiBAZXZlbnQgZW55by5MaXN0I29uU3dpcGVEcmFnXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBAdG9kbyBvblN3aXBlIGlzIG5ldmVyIGZpcmVkXG4qIEBldmVudCBlbnlvLkxpc3Qjb25Td2lwZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHVibGljXG4qL1xuXG4vKipcbiogRmlyZXMgd2hlbiBhIHN3aXBlIGNvbXBsZXRlcy5cbipcbiogQGV2ZW50IGVueW8uTGlzdCNvblN3aXBlQ29tcGxldGVcbiogQHR5cGUge09iamVjdH1cbiogQHByb3BlcnR5IHtOdW1iZXJ9IGluZGV4ICAgICAgLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0aGF0IHdhcyBzd2lwZWQuXG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSB4RGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc3dpcGUuXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiB7QGxpbmsgZW55by5MaXN0fSBpcyBhIGNvbnRyb2wgdGhhdCBkaXNwbGF5cyBhIHNjcm9sbGluZyBsaXN0IG9mIHJvd3MsXG4qIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIHZlcnkgbGFyZ2UgbGlzdHMuIEl0IGlzIG9wdGltaXplZCBzdWNoIHRoYXQgb25seSBhXG4qIHNtYWxsIHBvcnRpb24gb2YgdGhlIGxpc3QgaXMgcmVuZGVyZWQgYXQgYSBnaXZlbiB0aW1lLiBBIGZseXdlaWdodCBwYXR0ZXJuXG4qIGlzIGVtcGxveWVkLCBpbiB3aGljaCBjb250cm9scyBwbGFjZWQgaW5zaWRlIHRoZSBsaXN0IGFyZSBjcmVhdGVkIG9uY2UsIGJ1dFxuKiByZW5kZXJlZCBmb3IgZWFjaCBsaXN0IGl0ZW0uIEZvciB0aGlzIHJlYXNvbiwgaXQncyBiZXN0IHRvIHVzZSBvbmx5IHNpbXBsZVxuKiBjb250cm9scyBpblx0YSBMaXN0LCBzdWNoIGFzIHtAbGluayBlbnlvLkNvbnRyb2x9IGFuZCB7QGxpbmsgZW55by5JbWFnZX0uXG4qXG4qIEEgTGlzdCdzIGBjb21wb25lbnRzYCBibG9jayBjb250YWlucyB0aGUgY29udHJvbHMgdG8gYmUgdXNlZCBmb3IgYSBzaW5nbGVcbiogcm93LiBUaGlzIHNldCBvZiBjb250cm9scyB3aWxsIGJlIHJlbmRlcmVkIGZvciBlYWNoIHJvdy4gWW91IG1heSBjdXN0b21pemVcbiogcm93IHJlbmRlcmluZyBieSBoYW5kbGluZyB0aGUgW29uU2V0dXBJdGVtXXtAbGluayBlbnlvLkxpc3Qjb25TZXR1cEl0ZW19XG4qIGV2ZW50LlxuKlxuKiBFdmVudHMgZmlyZWQgZnJvbSB3aXRoaW4gbGlzdCByb3dzIGNvbnRhaW4gdGhlIGBpbmRleGAgcHJvcGVydHksIHdoaWNoIG1heVxuKiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSByb3cgZnJvbSB3aGljaCB0aGUgZXZlbnQgb3JpZ2luYXRlZC5cbipcbiogQmVnaW5uaW5nIHdpdGggRW55byAyLjIsIGxpc3RzIGhhdmUgYnVpbHQtaW4gc3VwcG9ydCBmb3Igc3dpcGVhYmxlIGFuZFxuKiByZW9yZGVyYWJsZSBsaXN0IGl0ZW1zLiAgSW5kaXZpZHVhbCBsaXN0IGl0ZW1zIGFyZSBzd2lwZWFibGUgYnkgZGVmYXVsdDsgdG9cbiogZW5hYmxlIHJlb3JkZXJhYmlsaXR5LCBzZXQgdGhlIFtyZW9yZGVyYWJsZV17QGxpbmsgZW55by5MaXN0I3Jlb3JkZXJhYmxlfVxuKiBwcm9wZXJ0eSB0byBgdHJ1ZWAuXG4qXG4qIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiogW0xpc3RzXXtAbGlua3BsYWluICRkZXYtZ3VpZGUvYnVpbGRpbmctYXBwcy9sYXlvdXQvbGlzdHMuaHRtbH0gaW4gdGhlXG4qIEVueW8gRGV2ZWxvcGVyIEd1aWRlLlxuKlxuKiBAdWlcbiogQGNsYXNzIGVueW8uTGlzdFxuKiBAZXh0ZW5kcyBlbnlvLlNjcm9sbGVyXG4qIEBwdWJsaWNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQodXRpbHMubWl4aW4obWV0aG9kcyxcblx0LyoqIEBsZW5kcyBlbnlvLkxpc3QucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5MaXN0JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBTY3JvbGxlcixcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjbGFzc2VzOiAnZW55by1saXN0JyxcblxuXHQvKipcblx0KiBAbGVuZHMgZW55by5MaXN0LnByb3RvdHlwZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXHRcdC8qKlxuXHRcdCogVGhlIG51bWJlciBvZiByb3dzIGNvbnRhaW5lZCBpbiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFzIHRoZSBhbW91bnQgb2Zcblx0XHQqIGxpc3QgZGF0YSBjaGFuZ2VzLCBgc2V0Um93cygpYCBtYXkgYmUgY2FsbGVkIHRvIGFkanVzdCB0aGUgbnVtYmVyIG9mXG5cdFx0KiByb3dzLiBUbyByZS1yZW5kZXIgdGhlIGxpc3QgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gd2hlbiB0aGUgY291bnQgaGFzXG5cdFx0KiBjaGFuZ2VkLCBjYWxsIHRoZSBbcmVmcmVzaCgpXXtAbGluayBlbnlvLkxpc3QjcmVmcmVzaH0gbWV0aG9kLiAgSWYgdGhlXG5cdFx0KiB3aG9sZSBkYXRhIG1vZGVsIG9mIHRoZSBsaXN0IGhhcyBjaGFuZ2VkIGFuZCB5b3Ugd2FudCB0byByZWRpc3BsYXkgaXRcblx0XHQqIGZyb20gdGhlIHRvcCwgY2FsbCBbcmVzZXQoKV17QGxpbmsgZW55by5MaXN0I3Jlc2V0fS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7TnVtYmVyfVxuXHRcdCogQGRlZmF1bHQgMFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y291bnQ6IDAsXG5cdFx0LyoqXG5cdFx0KiBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gYmUgc2hvd24gaW4gYSBnaXZlbiBsaXN0IHBhZ2Ugc2VnbWVudC4gVGhlcmUgaXNcblx0XHQqIGdlbmVyYWxseSBubyBuZWVkIHRvIGFkanVzdCB0aGlzIHZhbHVlLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0KiBAZGVmYXVsdCA1MFxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0cm93c1BlclBhZ2U6IDUwLFxuXHRcdC8qKlxuXHRcdCogRGlyZWN0aW9uIGluIHdoaWNoIHRoZSBsaXN0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIGluIHdoaWNoIGl0IHdpbGwgYmVcblx0XHQqIHNjcm9sbGFibGUuIFZhbGlkIHZhbHVlcyBhcmUgYCd2J2AgZm9yIHZlcnRpY2FsIG9yIGAnaCdgIGZvciBob3Jpem9udGFsLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtTdHJpbmd9XG5cdFx0KiBAZGVmYXVsdCAndidcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG9yaWVudDogJ3YnLFxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgLCB0aGUgbGlzdCBpcyByZW5kZXJlZCBzdWNoIHRoYXQgcm93IGAwYCBpcyBhdCB0aGUgYm90dG9tIG9mXG5cdFx0KiB0aGUgdmlld3BvcnQgYW5kIHRoZSBiZWdpbm5pbmcgcG9zaXRpb24gb2YgdGhlIGxpc3QgaXMgc2Nyb2xsZWQgdG8gdGhlXG5cdFx0KiBib3R0b20uXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Ym90dG9tVXA6IGZhbHNlLFxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgLCB0aGUgc2VsZWN0aW9uIG1lY2hhbmlzbSBpcyBkaXNhYmxlZC4gVGFwIGV2ZW50cyBhcmUgc3RpbGxcblx0XHQqIHNlbnQsIGJ1dCBpdGVtcyB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IHJlLXJlbmRlcmVkIHdoZW4gdGFwcGVkLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdG5vU2VsZWN0OiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIElmIGB0cnVlYCwgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGFsbG93ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRtdWx0aVNlbGVjdDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQqIElmIGB0cnVlYCwgdGhlIHNlbGVjdGVkIGl0ZW0gd2lsbCB0b2dnbGUuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0dG9nZ2xlU2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IHdpbGwgYXNzdW1lIHRoYXQgYWxsIHJvd3MgaGF2ZSB0aGUgc2FtZSBzaXplIHRvXG5cdFx0KiBvcHRpbWl6ZSBwZXJmb3JtYW5jZS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRmaXhlZFNpemU6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gcmVvcmRlciBsaXN0IGl0ZW1zLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgZmFsc2Vcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHJlb3JkZXJhYmxlOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgIGFuZCBgcmVvcmRlcmFibGVgIGlzIHRydWUsIGEgcmVvcmRlcmFibGUgaXRlbSB3aWxsIGJlIGNlbnRlcmVkXG5cdFx0KiBvbiBmaW5nZXIgd2hlbiBjcmVhdGVkLiBJZiBgZmFsc2VgLCBpdCB3aWxsIGJlIGNyZWF0ZWQgb3ZlciB0aGUgb2xkIGl0ZW1cblx0XHQqIGFuZCB3aWxsIHRoZW4gdHJhY2sgZmluZ2VyLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtCb29sZWFufVxuXHRcdCogQGRlZmF1bHQgdHJ1ZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0Y2VudGVyUmVvcmRlckNvbnRhaW5lcjogdHJ1ZSxcblxuXHRcdC8qKlxuXHRcdCogQW4gYXJyYXkgY29udGFpbmluZyBjb21wb25lbnRzIHRvIGJlIHNob3duIGFzIGEgcGxhY2Vob2xkZXIgd2hlblxuXHRcdCogcmVvcmRlcmluZyBsaXN0IGl0ZW1zLlxuXHRcdCpcblx0XHQqIEB0eXBlIHtlbnlvLkNvbnRyb2xbXX1cblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdHJlb3JkZXJDb21wb25lbnRzOiBbXSxcblxuXHRcdC8qKlxuXHRcdCogQW4gYXJyYXkgY29udGFpbmluZyBjb21wb25lbnRzIGZvciB0aGUgcGlubmVkIHZlcnNpb24gb2YgYSByb3cuIElmIG5vdFxuXHRcdCogc3BlY2lmaWVkLCByZW9yZGVyaW5nIHdpbGwgbm90IHN1cHBvcnQgcGlubmVkIG1vZGUuXG5cdFx0KlxuXHRcdCogQHR5cGUge2VueW8uQ29udHJvbFtdfVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0cGlubmVkUmVvcmRlckNvbXBvbmVudHM6IFtdLFxuXG5cdFx0LyoqXG5cdFx0KiBBbiBhcnJheSBjb250YWluaW5nIGFueSBzd2lwZWFibGUgY29tcG9uZW50cyB0aGF0IHdpbGwgYmUgdXNlZC5cblx0XHQqXG5cdFx0KiBAdHlwZSB7ZW55by5Db250cm9sW119XG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRzd2lwZWFibGVDb21wb25lbnRzOiBbXSxcblxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgLCBzd2lwZSBmdW5jdGlvbmFsaXR5IGlzIGVuYWJsZWQuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0ZW5hYmxlU3dpcGU6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IHdpbGwgcGVyc2lzdCB0aGUgY3VycmVudCBzd2lwZWFibGUgaXRlbS5cblx0XHQqXG5cdFx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQqIEBkZWZhdWx0IGZhbHNlXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRwZXJzaXN0U3dpcGVhYmxlSXRlbTogZmFsc2Vcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblNldHVwSXRlbTogJycsXG5cdFx0b25TZXR1cFJlb3JkZXJDb21wb25lbnRzOiAnJyxcblx0XHRvblNldHVwUGlubmVkUmVvcmRlckNvbXBvbmVudHM6ICcnLFxuXHRcdG9uUmVvcmRlcjogJycsXG5cdFx0b25TZXR1cFN3aXBlSXRlbTogJycsXG5cdFx0b25Td2lwZURyYWc6ICcnLFxuXHRcdG9uU3dpcGU6ICcnLFxuXHRcdG9uU3dpcGVDb21wbGV0ZTogJydcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVyczoge1xuXHRcdG9uQW5pbWF0ZUZpbmlzaDogJ2FuaW1hdGVGaW5pc2gnLFxuXHRcdG9uUmVuZGVyUm93OiAncm93UmVuZGVyZWQnLFxuXHRcdG9uZHJhZ3N0YXJ0OiAnZHJhZ3N0YXJ0Jyxcblx0XHRvbmRyYWc6ICdkcmFnJyxcblx0XHRvbmRyYWdmaW5pc2g6ICdkcmFnZmluaXNoJyxcblx0XHRvbnVwOiAndXAnLFxuXHRcdG9uaG9sZHB1bHNlOiAnaG9sZHB1bHNlJyxcblx0XHRvbmZsaWNrOiAnZmxpY2snXG5cdH0sXG5cblx0LyoqXG5cdCogQXZlcmFnZSByb3cgc2l6ZSAoaW4gcGl4ZWxzKSwgY2FsY3VsYXRlZCBhcyBgKHBhZ2Ugc2l6ZSAvIG51bWJlciBvZiByb3dzIHBlciBwYWdlKWAuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyb3dTaXplOiAwLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGxpc3RUb29sczogW1xuXHRcdHtuYW1lOiAncG9ydCcsIGNsYXNzZXM6ICdlbnlvLWxpc3QtcG9ydCBlbnlvLWJvcmRlci1ib3gnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ2dlbmVyYXRvcicsIGtpbmQ6IEZseXdlaWdodFJlcGVhdGVyLCBjYW5HZW5lcmF0ZTogZmFsc2UsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e3RhZzogbnVsbCwgbmFtZTogJ2NsaWVudCd9XG5cdFx0XHRdfSxcblx0XHRcdHtuYW1lOiAnaG9sZGluZ2FyZWEnLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdlbnlvLWxpc3QtaG9sZGluZ2FyZWEnfSxcblx0XHRcdHtuYW1lOiAncGFnZTAnLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdlbnlvLWxpc3QtcGFnZSd9LFxuXHRcdFx0e25hbWU6ICdwYWdlMScsIGFsbG93SHRtbDogdHJ1ZSwgY2xhc3NlczogJ2VueW8tbGlzdC1wYWdlJ30sXG5cdFx0XHR7bmFtZTogJ3BsYWNlaG9sZGVyJywgY2xhc3NlczogJ2VueW8tbGlzdC1wbGFjZWhvbGRlcid9LFxuXHRcdFx0e25hbWU6ICdzd2lwZWFibGVDb21wb25lbnRzJywgc3R5bGU6ICdwb3NpdGlvbjphYnNvbHV0ZTsgZGlzcGxheTpibG9jazsgdG9wOi0xMDAwcHg7IGxlZnQ6MDsnfVxuXHRcdF19XG5cdF0sXG5cblx0Ly8qIFJlb3JkZXIgdmFyc1xuXG5cdC8qKlxuXHQqIExlbmd0aCBvZiB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRvIHdhaXQgZm9yIHRvIGFjdGl2ZSByZW9yZGVyaW5nLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCA2MDBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZW9yZGVySG9sZFRpbWVNUzogNjAwLFxuXG5cdC8qKlxuXHQqIEluZGV4IG9mIHRoZSByb3cgdGhhdCB3ZSdyZSBtb3ZpbmcuXG5cdCpcblx0KiBAdHlwZSB7TnVtYmVyfVxuXHQqIEBkZWZhdWx0IC0xXG5cdCogQHByaXZhdGVcblx0Ki9cblx0ZHJhZ2dpbmdSb3dJbmRleDogLTEsXG5cblx0LyoqXG5cdCogQHRvZG8gU2VlbXMgdG8gYmUgY3J1ZnQgLi4uIGNhbid0IGZpbmQgYW55IHJlZmVyZW5jZXMgdG8gaXQgaW4gbGF5b3V0LlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGluaXRIb2xkQ291bnRlcjogMyxcblxuXHQvKipcblx0KiBAdG9kbyBTZWVtcyB0byBiZSBjcnVmdCAuLi4gY2FuJ3QgZmluZCBhbnkgcmVmZXJlbmNlcyB0byBpdCBpbiBsYXlvdXQuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aG9sZENvdW50ZXI6IDMsXG5cblx0LyoqXG5cdCogQHRvZG8gU2VlbXMgdG8gYmUgY3J1ZnQgLi4uIGNhbid0IGZpbmQgYW55IHJlZmVyZW5jZXMgdG8gaXQgaW4gbGF5b3V0LlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGhvbGRpbmc6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIEluZGV4IG9mIHRoZSByb3cgYmVmb3JlIHdoaWNoIHRoZSBwbGFjZWhvbGRlciBpdGVtIHdpbGwgYmUgc2hvd24uIElmIHRoZVxuXHQqIHBsYWNlaG9sZGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoaXMgdmFsdWUgd2lsbCBiZSBvbmUgbGFyZ2VyIHRoYW5cblx0KiB0aGUgcm93IGNvdW50LlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwbGFjZWhvbGRlclJvd0luZGV4OiAtMSxcblxuXHQvKipcblx0KiBEZXRlcm1pbmVzIHNjcm9sbCBoZWlnaHQgYXQgdG9wL2JvdHRvbSBvZiBsaXN0IHdoZXJlIGRyYWdnaW5nIHdpbGwgY2F1c2Ugc2Nyb2xsLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCAwLjFcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnVG9TY3JvbGxUaHJlc2hvbGQ6IDAuMSxcblxuXHQvKipcblx0ICogQW1vdW50IHRvIHNjcm9sbCBkdXJpbmcgYXV0b3Njcm9sbC5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2Nyb2xsRGlzdGFuY2U6IDAsXG5cblx0LyoqXG5cdCogVXNlZCB0byBkZXRlcm1pbmUgZGlyZWN0aW9uIG9mIHNjcm9sbGluZyBkdXJpbmcgcmVvcmRlcmluZy5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHByZXZTY3JvbGxUb3A6IDAsXG5cblx0LyoqXG5cdCogTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHNjcm9sbCBldmVudHMgd2hlbiBhdXRvc2Nyb2xsaW5nLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCAyMFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGF1dG9TY3JvbGxUaW1lb3V0TVM6IDIwLFxuXG5cdC8qKlxuXHQqIEhvbGRzIHRpbWVvdXQgSUQgZm9yIGF1dG9zY3JvbGwuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRhdXRvU2Nyb2xsVGltZW91dDogbnVsbCxcblxuXHQvKipcblx0KiBLZWVwIGxhc3QgZXZlbnQgWSBjb29yZGluYXRlIHRvIHVwZGF0ZSBwbGFjZWhvbGRlciBwb3NpdGlvbiBkdXJpbmcgYXV0b3Njcm9sbC5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0YXV0b3Njcm9sbFBhZ2VZOiAwLFxuXG5cdC8qKlxuXHQqIFNldCB0byBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCB3ZSdyZSBpbiBwaW5uZWQgcmVvcmRlcmluZyBtb2RlLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwaW5uZWRSZW9yZGVyTW9kZTogZmFsc2UsXG5cblx0LyoqXG5cdCogeS1jb29yZGluYXRlIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgcGlubmVkIHJvdy5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdGlhbFBpblBvc2l0aW9uOiAtMSxcblxuXHQvKipcblx0KiBTZXQgdG8gYHRydWVgIGFmdGVyIGRyYWctYW5kLWRyb3AgaGFzIG1vdmVkIHRoZSBpdGVtIHRvIHJlb3JkZXIgYXQgbGVhc3Rcblx0KiBvbmUgc3BhY2UuIFVzZWQgdG8gYWN0aXZhdGUgcGluIG1vZGUgaWYgaXRlbSBpcyBkcm9wcGVkIGltbWVkaWF0ZWx5LlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpdGVtTW92ZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIFRyYWNrcyB0aGUgcGFnZSB3aGVyZSB0aGUgaXRlbSBiZWluZyBkcmFnZ2VkIGlzLCBzbyB3ZSBjYW4gZGV0ZWN0IHdoZW4gd2Vcblx0KiBzd2l0Y2ggcGFnZXMgYW5kIG5lZWQgdG8gYWRqdXN0IHJlbmRlcmluZy5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3VycmVudFBhZ2VOdW1iZXI6IC0xLFxuXG5cdC8qKlxuXHQqIFRpbWVvdXQgZm9yIGNvbXBsZXRpbmcgcmVvcmRlciBvcGVyYXRpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZVJlb3JkZXJUaW1lb3V0OiBudWxsLFxuXG5cdC8vKiBTd2lwZWFibGUgdmFyc1xuXG5cdC8qKlxuXHQqIEluZGV4IG9mIHN3aXBlZCBpdGVtLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzd2lwZUluZGV4OiBudWxsLFxuXG5cdC8qKlxuXHQqIERpcmVjdGlvbiBvZiBzd2lwZS5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3dpcGVEaXJlY3Rpb246IG51bGwsXG5cblx0LyoqXG5cdCogYHRydWVgIGlmIGEgcGVyc2lzdGVudCBpdGVtIGlzIGN1cnJlbnRseSBwZXJzaXN0aW5nLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgZmFsc2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwZXJzaXN0ZW50SXRlbVZpc2libGU6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIFNpZGUgZnJvbSB3aGljaCB0aGUgcGVyc2lzdGluZyBpdGVtIGNhbWUuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHBlcnNpc3RlbnRJdGVtT3JpZ2luOiBudWxsLFxuXG5cdC8qKlxuXHQqIGB0cnVlYCBpZiBzd2lwZSB3YXMgY29tcGxldGVkLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQHByaXZhdGVcblx0Ki9cblx0c3dpcGVDb21wbGV0ZTogZmFsc2UsXG5cblx0LyoqXG5cdCogVGltZW91dCB3aGVuIHdhaXRpbmcgZm9yIHN3aXBlIGFjdGlvbiB0byBjb21wbGV0ZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNvbXBsZXRlU3dpcGVUaW1lb3V0OiBudWxsLFxuXG5cdC8qKlxuXHQqIExlbmd0aCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRvIHdhaXQgYmVmb3JlIGNvbXBsZXRpbmcgc3dpcGUgYWN0aW9uLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCA1MDBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wbGV0ZVN3aXBlRGVsYXlNUzogNTAwLFxuXG5cdC8qKlxuXHQqIER1cmF0aW9uIChpbiBtaWxsaXNlY29uZHMpIG9mIG5vcm1hbCBzd2lwZSBhbmltYXRpb24uXG5cdCpcblx0KiBAdHlwZSB7TnVtYmVyfVxuXHQqIEBkZWZhdWx0IDIwMFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdG5vcm1hbFN3aXBlU3BlZWRNUzogMjAwLFxuXG5cdC8qKlxuXHQqIER1cmF0aW9uIChpbiBtaWxsaXNlY29uZHMpIG9mIGZhc3Qgc3dpcGUgYW5pbWF0aW9uLlxuXHQqXG5cdCogQHR5cGUge051bWJlcn1cblx0KiBAZGVmYXVsdCAxMDBcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRmYXN0U3dpcGVTcGVlZE1TOiAxMDAsXG5cblx0LyoqXG5cdCogUGVyY2VudGFnZSBvZiBhIHN3aXBlIG5lZWRlZCB0byBmb3JjZSBjb21wbGV0aW9uIG9mIHRoZSBzd2lwZS5cblx0KlxuXHQqIEB0eXBlIHtOdW1iZXJ9XG5cdCogQGRlZmF1bHQgMC4yXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cGVyY2VudGFnZURyYWdnZWRUaHJlc2hvbGQ6IDAuMlxufSkpO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9TY3JvbGxlclwiOjQ0LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRmx5d2VpZ2h0UmVwZWF0ZXJcIjo4OSxcIi4vbWV0aG9kc1wiOjk2fV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdGRvbSA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL2RvbScpLFxuXHRwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL3BsYXRmb3JtJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIvdXRpbHMnKSxcblx0QW5pbWF0b3IgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9BbmltYXRvcicpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyk7XG5cbi8qKlxuKiBGaXJlcyB3aGVuZXZlciB0aGUgdXNlciBhZGp1c3RzIHRoZSB6b29tIHZpYSBkb3VibGUtdGFwL2RvdWJsZS1jbGljaywgbW91c2V3aGVlbCxcbiogb3IgcGluY2gtem9vbS5cbipcbiogQGV2ZW50IGVueW8uUGFuWm9vbVZpZXcjb25ab29tXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBuZXcgc2NhbGluZyBmYWN0b3IuXG4qIEBwdWJsaWNcbiovXG5cbi8qKlxuKiBGaXJlcyBhZnRlciBhIHpvb20gdG8gbm90aWZ5IGNoaWxkcmVuIHRvIHBvc2l0aW9uIG5vbi16b29taW5nIGNvbnRyb2xzLlxuKlxuKiBAZXZlbnQgZW55by5QYW5ab29tVmlldyNvblBvc2l0aW9uUGluXG4qIEB0eXBlIHtPYmplY3R9XG4qIEBwcm9wZXJ0eSB7TnVtZXJ9IHNjYWxlICAgLSBUaGUgbmV3IHNjYWxpbmcgZmFjdG9yLlxuKiBAcHJvcGVydHkge09iamVjdH0gYm91bmRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgdmlld3BvcnQgYm91bmRzLlxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uUGFuWm9vbVZpZXd9IGlzIGEgY29udHJvbCB0aGF0IGRpc3BsYXlzIGFyYml0cmFyeSBjb250ZW50IGF0IGEgZ2l2ZW5cbiogc2NhbGluZyBmYWN0b3IsIHdpdGggZW5oYW5jZWQgc3VwcG9ydCBmb3IgZG91YmxlLXRhcC9kb3VibGUtY2xpY2sgdG8gem9vbSxcbiogcGFubmluZywgbW91c2V3aGVlbCB6b29taW5nIGFuZCBwaW5jaC16b29tIChvbiB0b3VjaHNjcmVlbiBkZXZpY2VzIHRoYXRcbiogc3VwcG9ydCBpdCkuXG4qXG4qIGBgYFxuKiB7a2luZDogJ1Bhblpvb21WaWV3Jywgc2NhbGU6ICdhdXRvJywgY29udGVudFdpZHRoOiA1MDAsIGNvbnRlbnRIZWlnaHQ6IDUwMCxcbiogXHRzdHlsZTogJ3dpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MDBweDsnLFxuKiBcdGNvbXBvbmVudHM6IFt7Y29udGVudDogJ0hlbGxvIFdvcmxkJ31dXG4qIH1cbiogYGBgXG4qXG4qIEFuIFtvblpvb21de0BsaW5rIGVueW8uUGFuWm9vbVZpZXcjb25ab29tfSBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGVcbiogdXNlciBjaGFuZ2VzIHRoZSB6b29tIGxldmVsLlxuKlxuKiBJZiB5b3Ugd2lzaCwgeW91IG1heSBhZGQge0BsaW5rIGVueW8uU2Nyb2xsVGh1bWJ9IGluZGljYXRvcnMsIGRpc2FibGUgem9vbVxuKiBhbmltYXRpb24sIGFsbG93IHBhbm5pbmcgb3ZlcnNjcm9sbCAod2l0aCBhIGJvdW5jZS1iYWNrIGVmZmVjdCksIGFuZCBjb250cm9sXG4qIHRoZSBwcm9wYWdhdGlvbiBvZiBkcmFnIGV2ZW50cywgYWxsIHZpYSBCb29sZWFuIHByb3BlcnRpZXMuXG4qXG4qIEZvciB0aGUgUGFuWm9vbVZpZXcgdG8gd29yaywgeW91IG11c3QgZWl0aGVyIHNwZWNpZnkgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2ZcbiogdGhlIHNjYWxlZCBjb250ZW50ICh2aWEgdGhlIGBjb250ZW50V2lkdGhgIGFuZCBgY29udGVudEhlaWdodGAgcHJvcGVydGllcykgb3JcbiogYnViYmxlIGFuIGBvblNldERpbWVuc2lvbnNgIGV2ZW50IGZyb20gb25lIG9mIHRoZSB1bmRlcmx5aW5nIGNvbXBvbmVudHMuXG4qXG4qIE5vdGUgdGhhdCBpdCdzIGJlc3QgdG8gc3BlY2lmeSBhIHNpemUgZm9yIHRoZSBQYW5ab29tVmlldyBpbiBvcmRlciB0byBhdm9pZFxuKiBjb21wbGljYXRpb25zLlxuKlxuKiBAdWlcbiogQGNsYXNzIGVueW8uUGFuWm9vbVZpZXdcbiogQGV4dGVuZHMgZW55by5TY3JvbGxlclxuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uUGFuWm9vbVZpZXcucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5QYW5ab29tVmlldycsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0a2luZDogU2Nyb2xsZXIsXG5cblx0LyoqXG5cdCogSWYgYHRydWVgLCBhbGxvd3Mgb3ZlcnNjcm9sbGluZyBkdXJpbmcgcGFubmluZywgd2l0aCBhIGJvdW5jZS1iYWNrIGVmZmVjdC5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IGZhbHNlXG5cdCogQHNlZSB7QGxpbmsgZW55by5TY3JvbGxlci50b3VjaE92ZXJzY3JvbGx9XG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0b3VjaE92ZXJzY3JvbGw6IGZhbHNlLFxuXG5cdC8qKlxuXHQqIElmIGB0cnVlYCwgYSBTY3JvbGxUaHVtYiBpcyB1c2VkIHRvIGluZGljYXRlIHNjcm9sbCBwb3NpdGlvbi9ib3VuZHMuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBzZWUge0BsaW5rIGVueW8uU2Nyb2xsZXIudGh1bWJ9XG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0aHVtYjogZmFsc2UsXG5cblx0LyoqXG5cdCogSWYgYHRydWVgICh0aGUgZGVmYXVsdCksIGFuaW1hdGVzIHRoZSB6b29tIGFjdGlvbiB0cmlnZ2VyZWQgYnkgYSBkb3VibGUtdGFwXG5cdCogKG9yIGRvdWJsZS1jbGljaykuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCB0cnVlXG5cdCogQHNlZSB7QGxpbmsgZW55by5TY3JvbGxlci5hbmltYXRlfVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0YW5pbWF0ZTogdHJ1ZSxcblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAgKHRoZSBkZWZhdWx0KSwgYWxsb3dzIHByb3BhZ2F0aW9uIG9mIHZlcnRpY2FsIGRyYWcgZXZlbnRzIHdoZW5cblx0KiBhbHJlYWR5IGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBwYW5uYWJsZSBhcmVhLlxuXHQqXG5cdCogQHR5cGUge0Jvb2xlYW59XG5cdCogQGRlZmF1bHQgdHJ1ZVxuXHQqIEBzZWUge0BsaW5rIGVueW8uU2Nyb2xsZXIudmVydGljYWxEcmFnUHJvcGFnYXRpb259XG5cdCogQHB1YmxpY1xuXHQqL1xuXHR2ZXJ0aWNhbERyYWdQcm9wYWdhdGlvbjogdHJ1ZSxcblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAgKHRoZSBkZWZhdWx0KSwgYWxsb3dzIHByb3BhZ2F0aW9uIG9mIGhvcml6b250YWwgZHJhZyBldmVudHMgd2hlblxuXHQqIGFscmVhZHkgYXQgdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBvZiB0aGUgcGFubmFibGUgYXJlYS5cblx0KlxuXHQqIEB0eXBlIHtCb29sZWFufVxuXHQqIEBkZWZhdWx0IHRydWVcblx0KiBAc2VlIHtAbGluayBlbnlvLlNjcm9sbGVyLmhvcml6b250YWxEcmFnUHJvcGFnYXRpb259XG5cdCogQHB1YmxpY1xuXHQqL1xuXHRob3Jpem9udGFsRHJhZ1Byb3BhZ2F0aW9uOiB0cnVlLFxuXG5cdC8qKlxuXHQqIEBsZW5kcyBlbnlvLlBhblpvb21WaWV3cy5wcm90b3R5cGVcblx0KiBAcHVibGljXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXHRcdC8qKlxuXHRcdCogVGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjb250ZW50IHNob3VsZCBiZSBkaXNwbGF5ZWQuIFRoaXMgbWF5IGJlIGFueVxuXHRcdCogcG9zaXRpdmUgbnVtZXJpYyB2YWx1ZSBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXkgd29yZHMgKHdoaWNoIHdpbGxcblx0XHQqIGJlIHJlc29sdmVkIHRvIGEgdmFsdWUgZHluYW1pY2FsbHkpOlxuXHRcdCpcblx0XHQqICogYCdhdXRvJ2A6IEZpdHMgdGhlIGNvbnRlbnQgdG8gdGhlIHNpemUgb2YgdGhlIFBhblpvb21WaWV3LlxuXHRcdCogKiBgJ3dpZHRoJ2A6IEZpdHMgdGhlIGNvbnRlbnQgdG8gdGhlIHdpZHRoIG9mIHRoZSBQYW5ab29tVmlldy5cblx0XHQqICogYCdoZWlnaHQnYDogRml0cyB0aGUgY29udGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBQYW5ab29tVmlldy5cblx0XHQqICogYCdmaXQnYDogRml0cyB0aGUgY29udGVudCB0byB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgUGFuWm9vbVZpZXc7IHRoZVxuXHRcdCogXHRvdmVyZmxvdyBvZiB0aGUgbGFyZ2VyIGRpbWVuc2lvbiBpcyBjcm9wcGVkIGFuZCB0aGUgY29udGVudCBpcyBjZW50ZXJlZFxuXHRcdCogXHRhbG9uZyB0aGF0IGF4aXMuXG5cdFx0KlxuXHRcdCogQHR5cGUge1N0cmluZ31cblx0XHQqIEBkZWZhdWx0ICdhdXRvJ1xuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0c2NhbGU6ICdhdXRvJyxcblxuXHRcdC8qKlxuXHRcdCogSWYgYHRydWVgLCB6b29tIGZ1bmN0aW9uYWxpdHkgaXMgZGlzYWJsZWQuXG5cdFx0KlxuXHRcdCogQHR5cGUge0Jvb2xlYW59XG5cdFx0KiBAZGVmYXVsdCBmYWxzZVxuXHRcdCogQHB1YmxpY1xuXHRcdCovXG5cdFx0ZGlzYWJsZVpvb206IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0KiBXaWR0aCBvZiB0aGUgc2NhbGVkIGNvbnRlbnQuXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IG51bGxcblx0XHQqIEBwcml2YXRlXG5cdFx0Ki9cblx0XHRjb250ZW50V2lkdGg6IG51bGwsXG5cblx0XHQvKipcblx0XHQqIEhlaWdodCBvZiB0aGUgc2NhbGVkIGNvbnRlbnQuXG5cdFx0KlxuXHRcdCogQHR5cGUge051bWJlcn1cblx0XHQqIEBkZWZhdWx0IG51bGxcblx0XHQqIEBwdWJsaWNcblx0XHQqL1xuXHRcdGNvbnRlbnRIZWlnaHQ6IG51bGxcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHRvblpvb206ICcnXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0dG91Y2g6IHRydWUsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHJldmVudERyYWdQcm9wYWdhdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvbmRyYWdzdGFydDogJ2RyYWdQcm9wYWdhdGlvbicsXG5cdFx0b25TZXREaW1lbnNpb25zOiAnc2V0RGltZW5zaW9ucydcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICdhbmltYXRvcicsIGtpbmQ6IEFuaW1hdG9yLCBvblN0ZXA6ICd6b29tQW5pbWF0aW9uU3RlcCcsIG9uRW5kOiAnem9vbUFuaW1hdGlvbkVuZCd9LFxuXHRcdHtuYW1lOiAndmlld3BvcnQnLCBzdHlsZTogJ292ZXJmbG93OmhpZGRlbjttaW4taGVpZ2h0OjEwMCU7bWluLXdpZHRoOjEwMCU7JywgY2xhc3NlczogJ2VueW8tZml0Jywgb25nZXN0dXJlY2hhbmdlOiAnZ2VzdHVyZVRyYW5zZm9ybScsIG9uZ2VzdHVyZWVuZDogJ3NhdmVTdGF0ZScsIG9udGFwOiAnc2luZ2xlVGFwJywgb25kYmxjbGljazogJ2RvdWJsZUNsaWNrJywgb25tb3VzZXdoZWVsOiAnbW91c2V3aGVlbCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnY29udGVudCd9XG5cdFx0XX1cblx0XSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcmVtZW1iZXIgc2NhbGUga2V5d29yZFxuXHRcdHRoaXMuc2NhbGVLZXl3b3JkID0gdGhpcy5zY2FsZTtcblxuXHRcdC8vIENhY2hlIGluc3RhbmNlIGNvbXBvbmVudHNcblx0XHR2YXIgaW5zdGFuY2VDb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuXHRcdHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXHRcdFNjcm9sbGVyLnByb3RvdHlwZS5jcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLiQuY29udGVudC5hcHBseVN0eWxlKCd3aWR0aCcsIHRoaXMuY29udGVudFdpZHRoICsgJ3B4Jyk7XG5cdFx0dGhpcy4kLmNvbnRlbnQuYXBwbHlTdHlsZSgnaGVpZ2h0JywgdGhpcy5jb250ZW50SGVpZ2h0ICsgJ3B4Jyk7XG5cblx0XHRpZiAodGhpcy51bnNjYWxlZENvbXBvbmVudHMpe1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5oYXNPd25Qcm9wZXJ0eSgndW5zY2FsZWRDb21wb25lbnRzJykgPyB0aGlzLmdldEluc3RhbmNlT3duZXIoKSA6IHRoaXM7XG5cdFx0XHR0aGlzLmNyZWF0ZUNvbXBvbmVudHModGhpcy51bnNjYWxlZENvbXBvbmVudHMsIHtvd25lcjogb3duZXJ9KTtcblx0XHR9XG5cblx0XHQvLyBDaGFuZ2UgY29udHJvbFBhcmVudE5hbWUgc28gUGFuWm9vbVZpZXcgaW5zdGFuY2UgY29tcG9uZW50cyBhcmUgY3JlYXRlZCBpbnRvIHZpZXdwb3J0XG5cdFx0dGhpcy5jb250cm9sUGFyZW50TmFtZSA9ICdjb250ZW50Jztcblx0XHR0aGlzLmRpc2NvdmVyQ29udHJvbFBhcmVudCgpO1xuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50cyhpbnN0YW5jZUNvbXBvbmVudHMpO1xuXG5cdFx0dGhpcy5jYW5UcmFuc2Zvcm0gPSBkb20uY2FuVHJhbnNmb3JtKCk7XG5cdFx0aWYgKCF0aGlzLmNhblRyYW5zZm9ybSkge1xuXHRcdFx0dGhpcy4kLmNvbnRlbnQuYXBwbHlTdHlsZSgncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcblx0XHR9XG5cdFx0dGhpcy5jYW5BY2NlbGVyYXRlID0gZG9tLmNhbkFjY2VsZXJhdGUoKTtcblxuXHRcdC8vXHRGb3IgcGFuem9vbXZpZXcsIGRpc2FibGUgZHJhZ3MgZHVyaW5nIGdlc3R1cmUgKHRvIGZpeCBmbGlja2VyOiBFTllPLTEyMDgpXG5cdFx0dGhpcy5nZXRTdHJhdGVneSgpLnNldERyYWdEdXJpbmdHZXN0dXJlKGZhbHNlKTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVuZGVyZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRTY3JvbGxlci5wcm90b3R5cGUucmVuZGVyZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLmdldE9yaWdpbmFsU2NhbGUoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnUHJvcGFnYXRpb246IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gUHJvcGFnYXRlIGRyYWcgZXZlbnRzIGF0IHRoZSBlZGdlcyBvZiB0aGUgY29udGVudCBhcyBkZXNpcmVkIGJ5IHRoZVxuXHRcdC8vIHZlcnRpY2FsRHJhZ1Byb3BhZ2F0aW9uIGFuZCBob3Jpem9udGFsRHJhZ1Byb3BhZ2F0aW9uIHByb3BlcnRpZXNcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJhdGVneSgpLmdldFNjcm9sbEJvdW5kcygpO1xuXHRcdHZhciB2ZXJ0aWNhbEVkZ2UgPSAoKGJvdW5kcy50b3A9PT0wICYmIGV2ZW50LmR5PjApIHx8IChib3VuZHMudG9wPj1ib3VuZHMubWF4VG9wLTIgJiYgZXZlbnQuZHk8MCkpO1xuXHRcdHZhciBob3Jpem9udGFsRWRnZSA9ICgoYm91bmRzLmxlZnQ9PT0wICYmIGV2ZW50LmR4PjApIHx8IChib3VuZHMubGVmdD49Ym91bmRzLm1heExlZnQtMiAmJiBldmVudC5keDwwKSk7XG5cdFx0cmV0dXJuICEoKHZlcnRpY2FsRWRnZSAmJiB0aGlzLnZlcnRpY2FsRHJhZ1Byb3BhZ2F0aW9uKSB8fCAoaG9yaXpvbnRhbEVkZ2UgJiYgdGhpcy5ob3Jpem9udGFsRHJhZ1Byb3BhZ2F0aW9uKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bW91c2V3aGVlbDogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRldmVudC5wYWdlWCB8PSAoZXZlbnQuY2xpZW50WCArIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0KTtcblx0XHRldmVudC5wYWdlWSB8PSAoZXZlbnQuY2xpZW50WSArIGV2ZW50LnRhcmdldC5zY3JvbGxUb3ApO1xuXHRcdHZhciB6b29tSW5jID0gKHRoaXMubWF4U2NhbGUgLSB0aGlzLm1pblNjYWxlKS8xMDtcblx0XHR2YXIgb2xkU2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdGlmICgoZXZlbnQud2hlZWxEZWx0YSA+IDApIHx8IChldmVudC5kZXRhaWwgPCAwKSkgeyAvL3pvb20gaW5cblx0XHRcdHRoaXMuc2NhbGUgPSB0aGlzLmxpbWl0U2NhbGUodGhpcy5zY2FsZSArIHpvb21JbmMpO1xuXHRcdH0gZWxzZSBpZiAoKGV2ZW50LndoZWVsRGVsdGEgPCAwKSB8fCAoZXZlbnQuZGV0YWlsID4gMCkpIHsgLy96b29tIG91dFxuXHRcdFx0dGhpcy5zY2FsZSA9IHRoaXMubGltaXRTY2FsZSh0aGlzLnNjYWxlIC0gem9vbUluYyk7XG5cdFx0fVxuXHRcdHRoaXMuZXZlbnRQdCA9IHRoaXMuY2FsY0V2ZW50TG9jYXRpb24oZXZlbnQpO1xuXHRcdHRoaXMudHJhbnNmb3JtKHRoaXMuc2NhbGUpO1xuXHRcdGlmIChvbGRTY2FsZSAhPSB0aGlzLnNjYWxlKSB7XG5cdFx0XHR0aGlzLmRvWm9vbSh7c2NhbGU6dGhpcy5zY2FsZX0pO1xuXHRcdH1cblx0XHR0aGlzLnJhdGlvWCA9IHRoaXMucmF0aW9ZID0gbnVsbDtcblx0XHQvLyBQcmV2ZW50IGRlZmF1bHQgc2Nyb2xsIHdoZWVsIGFjdGlvbiBhbmQgcHJldmVudCBldmVudCBmcm9tIGJ1YmJsaW5nIHVwIHRvIHRvIHRvdWNoIHNjcm9sbGVyXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlUmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0U2Nyb2xsZXIucHJvdG90eXBlLmhhbmRsZVJlc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLiQuY29udGVudC5hcHBseVN0eWxlKCd3aWR0aCcsIGV2ZW50LndpZHRoICsgJ3B4Jyk7XG5cdFx0dGhpcy4kLmNvbnRlbnQuYXBwbHlTdHlsZSgnaGVpZ2h0JywgZXZlbnQuaGVpZ2h0ICsgJ3B4Jyk7XG5cdFx0dGhpcy5vcmlnaW5hbFdpZHRoID0gZXZlbnQud2lkdGg7XG5cdFx0dGhpcy5vcmlnaW5hbEhlaWdodCA9IGV2ZW50LmhlaWdodDtcblx0XHR0aGlzLnNjYWxlID0gdGhpcy5zY2FsZUtleXdvcmQ7XG5cdFx0dGhpcy5zY2FsZUNoYW5nZWQoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0KiBDYWNoZXMgdGhlIGluaXRpYWwgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgY29tcG9uZW50IChpbiBgb3JpZ2luYWxIZWlnaHRgXG5cdCogYW5kIGBvcmlnaW5hbFdpZHRoYCwgcmVzcGVjdGl2ZWx5KSBhdCByZW5kZXIgdGltZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldE9yaWdpbmFsU2NhbGUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuJC5jb250ZW50Lmhhc05vZGUoKSl7XG5cdFx0XHR0aGlzLm9yaWdpbmFsV2lkdGggID0gdGhpcy4kLmNvbnRlbnQubm9kZS5jbGllbnRXaWR0aDtcblx0XHRcdHRoaXMub3JpZ2luYWxIZWlnaHQgPSB0aGlzLiQuY29udGVudC5ub2RlLmNsaWVudEhlaWdodDtcblx0XHRcdHRoaXMuc2NhbGUgPSB0aGlzLnNjYWxlS2V5d29yZDtcblx0XHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIENhbGN1bGF0ZXMgdGhlIGBtaW5TY2FsZWAgYW5kIGBtYXhTY2FsZWAgYW5kIHpvb21zIHRoZSBjb250ZW50IGFjY29yZGluZyB0byB0aGVcblx0KiBjbGFtcGVkIHNjYWxlIHZhbHVlLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2NhbGVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lck5vZGUgPSB0aGlzLmhhc05vZGUoKTtcblx0XHRpZiAoY29udGFpbmVyTm9kZSkge1xuXHRcdFx0dGhpcy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lck5vZGUuY2xpZW50V2lkdGg7XG5cdFx0XHR0aGlzLmNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lck5vZGUuY2xpZW50SGVpZ2h0O1xuXHRcdFx0dmFyIHdpZHRoU2NhbGUgPSB0aGlzLmNvbnRhaW5lcldpZHRoIC8gdGhpcy5vcmlnaW5hbFdpZHRoO1xuXHRcdFx0dmFyIGhlaWdodFNjYWxlID0gdGhpcy5jb250YWluZXJIZWlnaHQgLyB0aGlzLm9yaWdpbmFsSGVpZ2h0O1xuXHRcdFx0dGhpcy5taW5TY2FsZSA9IE1hdGgubWluKHdpZHRoU2NhbGUsIGhlaWdodFNjYWxlKTtcblx0XHRcdHRoaXMubWF4U2NhbGUgPSAodGhpcy5taW5TY2FsZSozIDwgMSkgPyAxIDogdGhpcy5taW5TY2FsZSozO1xuXHRcdFx0Ly9yZXNvbHZlIGFueSBrZXl3b3JkIHNjYWxlIHZhbHVlcyB0byBzb2xpZCBudW1lcmljIHZhbHVlc1xuXHRcdFx0aWYgKHRoaXMuc2NhbGUgPT0gJ2F1dG8nKSB7XG5cdFx0XHRcdHRoaXMuc2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNjYWxlID09ICd3aWR0aCcpIHtcblx0XHRcdFx0dGhpcy5zY2FsZSA9IHdpZHRoU2NhbGU7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2NhbGUgPT0gJ2hlaWdodCcpIHtcblx0XHRcdFx0dGhpcy5zY2FsZSA9IGhlaWdodFNjYWxlO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNjYWxlID09ICdmaXQnKSB7XG5cdFx0XHRcdHRoaXMuZml0QWxpZ25tZW50ID0gJ2NlbnRlcic7XG5cdFx0XHRcdHRoaXMuc2NhbGUgPSBNYXRoLm1heCh3aWR0aFNjYWxlLCBoZWlnaHRTY2FsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1heFNjYWxlID0gTWF0aC5tYXgodGhpcy5tYXhTY2FsZSwgdGhpcy5zY2FsZSk7XG5cdFx0XHRcdHRoaXMuc2NhbGUgPSB0aGlzLmxpbWl0U2NhbGUodGhpcy5zY2FsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZXZlbnRQdCA9IHRoaXMuY2FsY0V2ZW50TG9jYXRpb24oKTtcblx0XHR0aGlzLnRyYW5zZm9ybSh0aGlzLnNjYWxlKTtcblx0XHQvLyBzdGFydCBzY3JvbGxlclxuXHRcdGlmICh0aGlzLmdldFN0cmF0ZWd5KCkuJC5zY3JvbGxNYXRoKSB7XG5cdFx0XHR0aGlzLmdldFN0cmF0ZWd5KCkuJC5zY3JvbGxNYXRoLnN0YXJ0KCk7XG5cdFx0fVxuXHRcdHRoaXMuYWxpZ24oKTtcblx0fSxcblxuXHQvKipcblx0KiBDZW50ZXJzIHRoZSBjb250ZW50IGluIHRoZSBzY3JvbGxlci5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGFsaWduOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZml0QWxpZ25tZW50ICYmIHRoaXMuZml0QWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuXHRcdFx0dmFyIHNiID0gdGhpcy5nZXRTY3JvbGxCb3VuZHMoKTtcblx0XHRcdHRoaXMuc2V0U2Nyb2xsTGVmdChzYi5tYXhMZWZ0IC8gMik7XG5cdFx0XHR0aGlzLnNldFNjcm9sbFRvcChzYi5tYXhUb3AgLyAyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2VzdHVyZVRyYW5zZm9ybTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50UHQgPSB0aGlzLmNhbGNFdmVudExvY2F0aW9uKGV2ZW50KTtcblx0XHR0aGlzLnRyYW5zZm9ybSh0aGlzLmxpbWl0U2NhbGUodGhpcy5zY2FsZSAqIGV2ZW50LnNjYWxlKSk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGV0ZXJtaW5lcyB0aGUgdGFyZ2V0IGNvb3JkaW5hdGVzIG9uIHRoZSBQYW5ab29tVmlldyBmcm9tIGFuIGV2ZW50LlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y2FsY0V2ZW50TG9jYXRpb246IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBldmVudFB0ID0ge3g6IDAsIHk6MH07XG5cdFx0aWYgKGV2ZW50ICYmIHRoaXMuaGFzTm9kZSgpKSB7XG5cdFx0XHR2YXIgcmVjdCA9IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdGV2ZW50UHQueCA9IE1hdGgucm91bmQoKGV2ZW50LnBhZ2VYIC0gcmVjdC5sZWZ0KSAtIHRoaXMuYm91bmRzLngpO1xuXHRcdFx0ZXZlbnRQdC54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5ib3VuZHMud2lkdGgsIGV2ZW50UHQueCkpO1xuXHRcdFx0ZXZlbnRQdC55ID0gTWF0aC5yb3VuZCgoZXZlbnQucGFnZVkgLSByZWN0LnRvcCkgLSB0aGlzLmJvdW5kcy55KTtcblx0XHRcdGV2ZW50UHQueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm91bmRzLmhlaWdodCwgZXZlbnRQdC55KSk7XG5cdFx0fVxuXHRcdHJldHVybiBldmVudFB0O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFNjYWxlcyB0aGUgY29udGVudC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsaW5nIGZhY3Rvci5cblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHRoaXMudGFwcGVkID0gZmFsc2U7XG5cblx0XHR2YXIgcHJldkJvdW5kcyA9IHRoaXMuYm91bmRzIHx8IHRoaXMuaW5uZXJCb3VuZHMoc2NhbGUpO1xuXHRcdHRoaXMuYm91bmRzID0gdGhpcy5pbm5lckJvdW5kcyhzY2FsZSk7XG5cblx0XHQvL3N0eWxlIGN1cnNvciBpZiBuZWVkZWQgdG8gaW5kaWNhdGUgdGhlIGNvbnRlbnQgaXMgbW92YWJsZVxuXHRcdGlmICh0aGlzLnNjYWxlPnRoaXMubWluU2NhbGUpIHtcblx0XHRcdHRoaXMuJC52aWV3cG9ydC5hcHBseVN0eWxlKCdjdXJzb3InLCAnbW92ZScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiQudmlld3BvcnQuYXBwbHlTdHlsZSgnY3Vyc29yJywgbnVsbCk7XG5cdFx0fVxuXHRcdHRoaXMuJC52aWV3cG9ydC5zZXRCb3VuZHMoe3dpZHRoOiB0aGlzLmJvdW5kcy53aWR0aCArICdweCcsIGhlaWdodDogdGhpcy5ib3VuZHMuaGVpZ2h0ICsgJ3B4J30pO1xuXG5cdFx0Ly9kZXRlcm1pbmUgdGhlIGV4YWN0IHJhdGlvIHdoZXJlIG9uIHRoZSBjb250ZW50IHdhcyB0YXBwZWRcblx0XHR0aGlzLnJhdGlvWCA9IHRoaXMucmF0aW9YIHx8ICh0aGlzLmV2ZW50UHQueCArIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpKSAvIHByZXZCb3VuZHMud2lkdGg7XG5cdFx0dGhpcy5yYXRpb1kgPSB0aGlzLnJhdGlvWSB8fCAodGhpcy5ldmVudFB0LnkgKyB0aGlzLmdldFNjcm9sbFRvcCgpKSAvIHByZXZCb3VuZHMuaGVpZ2h0O1xuXHRcdHZhciBzY3JvbGxMZWZ0LCBzY3JvbGxUb3A7XG5cdFx0aWYgKHRoaXMuJC5hbmltYXRvci5yYXRpb0xvY2spIHsgLy9sb2NrZWQgZm9yIHNtYXJ0em9vbVxuXHRcdFx0c2Nyb2xsTGVmdCA9ICh0aGlzLiQuYW5pbWF0b3IucmF0aW9Mb2NrLnggKiB0aGlzLmJvdW5kcy53aWR0aCkgLSAodGhpcy5jb250YWluZXJXaWR0aCAvIDIpO1xuXHRcdFx0c2Nyb2xsVG9wID0gKHRoaXMuJC5hbmltYXRvci5yYXRpb0xvY2sueSAqIHRoaXMuYm91bmRzLmhlaWdodCkgLSAodGhpcy5jb250YWluZXJIZWlnaHQgLyAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsTGVmdCA9ICh0aGlzLnJhdGlvWCAqIHRoaXMuYm91bmRzLndpZHRoKSAtIHRoaXMuZXZlbnRQdC54O1xuXHRcdFx0c2Nyb2xsVG9wID0gKHRoaXMucmF0aW9ZICogdGhpcy5ib3VuZHMuaGVpZ2h0KSAtIHRoaXMuZXZlbnRQdC55O1xuXHRcdH1cblx0XHRzY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oKHRoaXMuYm91bmRzLndpZHRoIC0gdGhpcy5jb250YWluZXJXaWR0aCksIHNjcm9sbExlZnQpKTtcblx0XHRzY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigodGhpcy5ib3VuZHMuaGVpZ2h0IC0gdGhpcy5jb250YWluZXJIZWlnaHQpLCBzY3JvbGxUb3ApKTtcblxuXHRcdGlmICh0aGlzLmNhblRyYW5zZm9ybSkge1xuXHRcdFx0dmFyIHBhcmFtcyA9IHtzY2FsZTogc2NhbGV9O1xuXHRcdFx0Ly8gdHJhbnNsYXRlIG5lZWRzIHRvIGJlIGZpcnN0LCBvciBzY2FsZSBhbmQgcm90YXRpb24gd2lsbCBub3QgYmUgaW4gdGhlIGNvcnJlY3Qgc3BvdFxuXHRcdFx0aWYgKHRoaXMuY2FuQWNjZWxlcmF0ZSkge1xuXHRcdFx0XHQvL3RyYW5zbGF0ZTNkIHJvdW5kZWQgdmFsdWVzIHRvIGF2b2lkIGRpc3RvcnRpb247IHJlZjogaHR0cDovL21hcnRpbmtvb2wuY29tL3Bvc3QvMjc2MTg4MzIyMjUvYmV3YXJlLW9mLWhhbGYtcGl4ZWxzLWluLWNzc1xuXHRcdFx0XHRwYXJhbXMgPSB1dGlscy5taXhpbih7dHJhbnNsYXRlM2Q6IE1hdGgucm91bmQodGhpcy5ib3VuZHMubGVmdCkgKyAncHgsICcgKyBNYXRoLnJvdW5kKHRoaXMuYm91bmRzLnRvcCkgKyAncHgsIDBweCd9LCBwYXJhbXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyYW1zID0gdXRpbHMubWl4aW4oe3RyYW5zbGF0ZTogdGhpcy5ib3VuZHMubGVmdCArICdweCwgJyArIHRoaXMuYm91bmRzLnRvcCArICdweCd9LCBwYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0ZG9tLnRyYW5zZm9ybSh0aGlzLiQuY29udGVudCwgcGFyYW1zKTtcblx0XHR9IGVsc2UgaWYgKHBsYXRmb3JtLmllKSB7XG5cdFx0XHQvLyBJRTggZG9lcyBub3Qgc3VwcG9ydCB0cmFuc2Zvcm1zLCBidXQgZmlsdGVyIHNob3VsZCB3b3JrXG5cdFx0XHQvLyBodHRwOi8vd3d3LnVzZXJhZ2VudG1hbi5jb20vSUVUcmFuc2Zvcm1zVHJhbnNsYXRvci9cblx0XHRcdHZhciBtYXRyaXggPSAnXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0nK3NjYWxlKycsIE0xMj0wLCBNMjE9MCwgTTIyPScrc2NhbGUrJywgU2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnKVwiJztcblx0XHRcdHRoaXMuJC5jb250ZW50LmFwcGx5U3R5bGUoJy1tcy1maWx0ZXInLCBtYXRyaXgpO1xuXHRcdFx0dGhpcy4kLmNvbnRlbnQuc2V0Qm91bmRzKHt3aWR0aDogdGhpcy5ib3VuZHMud2lkdGgqc2NhbGUgKyAncHgnLCBoZWlnaHQ6IHRoaXMuYm91bmRzLmhlaWdodCpzY2FsZSArICdweCcsXG5cdFx0XHRcdFx0bGVmdDp0aGlzLmJvdW5kcy5sZWZ0ICsgJ3B4JywgdG9wOnRoaXMuYm91bmRzLnRvcCArICdweCd9KTtcblx0XHRcdHRoaXMuJC5jb250ZW50LmFwcGx5U3R5bGUoJ3dpZHRoJywgc2NhbGUqdGhpcy5ib3VuZHMud2lkdGgpO1xuXHRcdFx0dGhpcy4kLmNvbnRlbnQuYXBwbHlTdHlsZSgnaGVpZ2h0Jywgc2NhbGUqdGhpcy5ib3VuZHMuaGVpZ2h0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gLi4ubm8gdHJhbnNmb3JtcyBhbmQgbm90IElFLi4uIHRoZXJlJ3Mgbm90aGluJyBJIGNhbiBkby5cblx0XHR9XG5cblx0XHQvL2FkanVzdCBzY3JvbGxlciB0byBuZXcgcG9zaXRpb24gdGhhdCBrZWVwcyByYXRpbyB3aXRoIHRoZSBuZXcgY29udGVudCBzaXplXG5cdFx0dGhpcy5zZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpO1xuXHRcdHRoaXMuc2V0U2Nyb2xsVG9wKHNjcm9sbFRvcCk7XG5cblx0XHR0aGlzLnBvc2l0aW9uQ2xpZW50Q29udHJvbHMoc2NhbGUpO1xuXG5cdFx0Ly90aGlzLnN0YWJpbGl6ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIENsYW1wcyB0aGUgc2NhbGluZyBmYWN0b3IgYmV0d2VlbiBgbWluU2NhbGVgIGFuZCBgbWF4U2NhbGVgLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bGltaXRTY2FsZTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZVpvb20pIHtcblx0XHRcdHNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHR9IGVsc2UgaWYgKHNjYWxlID4gdGhpcy5tYXhTY2FsZSkge1xuXHRcdFx0c2NhbGUgPSB0aGlzLm1heFNjYWxlO1xuXHRcdH0gZWxzZSBpZiAoc2NhbGUgPCB0aGlzLm1pblNjYWxlKSB7XG5cdFx0XHRzY2FsZSA9IHRoaXMubWluU2NhbGU7XG5cdFx0fVxuXHRcdHJldHVybiBzY2FsZTtcblx0fSxcblxuXHQvKipcblx0KiBDYWxjdWxhdGVzIHRoZSBvZmZzZXRzIGZvciB0aGUgY29udGVudCBmb3IgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxpbmcgZmFjdG9yLlxuXHQqIEByZXR1cm4ge09iamVjdH0gICAgICAtIE9iamVjdCBjb250YWluaW5nIG9mZnNldHMgZm9yIGNvbnRlbnQgKGluIGl0cyBgbGVmdGAsIGB0b3BgLFxuXHQqIGB3aWR0aGAsIGBoZWlnaHRgLCBgeGAsIGFuZCBgeWAgcHJvcGVydGllcykuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5uZXJCb3VuZHM6IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHZhciB3aWR0aCA9IHRoaXMub3JpZ2luYWxXaWR0aCAqIHNjYWxlO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLm9yaWdpbmFsSGVpZ2h0ICogc2NhbGU7XG5cdFx0dmFyIG9mZnNldCA9IHt4OjAsIHk6MCwgdHJhbnNYOjAsIHRyYW5zWTowfTtcblx0XHRpZiAod2lkdGggPCB0aGlzLmNvbnRhaW5lcldpZHRoKSB7XG5cdFx0XHRvZmZzZXQueCArPSAodGhpcy5jb250YWluZXJXaWR0aCAtIHdpZHRoKS8yO1xuXHRcdH1cblx0XHRpZiAoaGVpZ2h0IDwgdGhpcy5jb250YWluZXJIZWlnaHQpIHtcblx0XHRcdG9mZnNldC55ICs9ICh0aGlzLmNvbnRhaW5lckhlaWdodCAtIGhlaWdodCkvMjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FuVHJhbnNmb3JtKSB7IC8vYWRqdXN0IGZvciB0aGUgY3NzIHRyYW5zbGF0ZSwgd2hpY2ggZG9lc24ndCBhbHRlciBjb250ZW50IG9mZnNldFdpZHRoIGFuZCBvZmZzZXRIZWlnaHRcblx0XHRcdG9mZnNldC50cmFuc1ggLT0gKHRoaXMub3JpZ2luYWxXaWR0aCAtIHdpZHRoKS8yO1xuXHRcdFx0b2Zmc2V0LnRyYW5zWSAtPSAodGhpcy5vcmlnaW5hbEhlaWdodCAtIGhlaWdodCkvMjtcblx0XHR9XG5cdFx0cmV0dXJuIHtsZWZ0Om9mZnNldC54ICsgb2Zmc2V0LnRyYW5zWCwgdG9wOm9mZnNldC55ICsgb2Zmc2V0LnRyYW5zWSwgd2lkdGg6d2lkdGgsIGhlaWdodDpoZWlnaHQsIHg6b2Zmc2V0LngsIHk6b2Zmc2V0Lnl9O1xuXHR9LFxuXG5cdC8qKlxuXHQqIFBlcnNpc3RzIHRoZSBzY2FsaW5nIGZhY3RvciB3aGVuIGEgZ2VzdHVyZSBmaW5pc2hlcy5cblx0KlxuXHQqIEBmaXJlcyBlbnlvLlBhblpvb21WaWV3I29uWm9vbVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNhdmVTdGF0ZTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR2YXIgb2xkU2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdHRoaXMuc2NhbGUgKj0gZXZlbnQuc2NhbGU7XG5cdFx0dGhpcy5zY2FsZSA9IHRoaXMubGltaXRTY2FsZSh0aGlzLnNjYWxlKTtcblx0XHRpZiAob2xkU2NhbGUgIT0gdGhpcy5zY2FsZSkge1xuXHRcdFx0dGhpcy5kb1pvb20oe3NjYWxlOnRoaXMuc2NhbGV9KTtcblx0XHR9XG5cdFx0dGhpcy5yYXRpb1ggPSB0aGlzLnJhdGlvWSA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCogTm9ybWFsaXplcyB0aGUgZXZlbnQgYW5kIGZvcndhcmRzIGl0IHRvXG5cdCogW3NpbmdsZVRhcCgpXXtAbGluayBlbnlvLlBhblpvb21WaWV3I3NpbmdsZVRhcH0uXG5cdCpcblx0KiBJRSA4IE9ubHlcblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdC8vSUUgOCBmaXg7IGRibGNsaWNrIGZpcmVzIHJhdGhlciB0aGFuIG11bHRpcGxlIHN1Y2Nlc3NpdmUgY2xpY2sgZXZlbnRzXG5cdFx0aWYgKHBsYXRmb3JtLmllPT04KSB7XG5cdFx0XHR0aGlzLnRhcHBlZCA9IHRydWU7XG5cdFx0XHQvL25vcm1hbGl6ZSBldmVudFxuXHRcdFx0ZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQ7XG5cdFx0XHRldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyBldmVudC50YXJnZXQuc2Nyb2xsVG9wO1xuXHRcdFx0dGhpcy5zaW5nbGVUYXAoc2VuZGVyLCBldmVudCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBTaW11bGF0ZXMgZG91YmxlLXRhcCBieSB3YXRjaGluZyBmb3IgdHdvIHRhcHMgd2l0aGluIDMwMG1zIG9mIGVhY2ggb3RoZXIuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzaW5nbGVUYXA6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0c2V0VGltZW91dCh0aGlzLmJpbmRTYWZlbHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy50YXBwZWQgPSBmYWxzZTtcblx0XHR9KSwgMzAwKTtcblx0XHRpZiAodGhpcy50YXBwZWQpIHsgLy9kYmx0YXBcblx0XHRcdHRoaXMudGFwcGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNtYXJ0Wm9vbShzZW5kZXIsIGV2ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50YXBwZWQgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBab29tcyBhdCB0aGUgZXZlbnQgbG9jYXRpb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzbWFydFpvb206IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dmFyIGNvbnRhaW5lck5vZGUgPSB0aGlzLmhhc05vZGUoKTtcblx0XHR2YXIgaW1nTm9kZSA9IHRoaXMuJC5jb250ZW50Lmhhc05vZGUoKTtcblx0XHRpZiAoY29udGFpbmVyTm9kZSAmJiBpbWdOb2RlICYmIHRoaXMuaGFzTm9kZSgpICYmICF0aGlzLmRpc2FibGVab29tKSB7XG5cdFx0XHR2YXIgcHJldlNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdGlmICh0aGlzLnNjYWxlICE9IHRoaXMubWluU2NhbGUpIHsgLy96b29tIG91dFxuXHRcdFx0XHR0aGlzLnNjYWxlID0gdGhpcy5taW5TY2FsZTtcblx0XHRcdH0gZWxzZSB7IC8vem9vbSBpblxuXHRcdFx0XHR0aGlzLnNjYWxlID0gdGhpcy5tYXhTY2FsZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZXZlbnRQdCA9IHRoaXMuY2FsY0V2ZW50TG9jYXRpb24oZXZlbnQpO1xuXHRcdFx0aWYgKHRoaXMuYW5pbWF0ZSkge1xuXHRcdFx0XHQvL2xvY2sgcmF0aW8gcG9zaXRpb24gb2YgZXZlbnQsIGFuZCBhbmltYXRlIHRoZSBzY2FsZSBjaGFuZ2Vcblx0XHRcdFx0dmFyIHJhdGlvTG9jayA9IHtcblx0XHRcdFx0XHR4OiAoKHRoaXMuZXZlbnRQdC54ICsgdGhpcy5nZXRTY3JvbGxMZWZ0KCkpIC8gdGhpcy5ib3VuZHMud2lkdGgpLFxuXHRcdFx0XHRcdHk6ICgodGhpcy5ldmVudFB0LnkgKyB0aGlzLmdldFNjcm9sbFRvcCgpKSAvIHRoaXMuYm91bmRzLmhlaWdodClcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy4kLmFuaW1hdG9yLnBsYXkoe1xuXHRcdFx0XHRcdGR1cmF0aW9uOiAzNTAsXG5cdFx0XHRcdFx0cmF0aW9Mb2NrOiByYXRpb0xvY2ssXG5cdFx0XHRcdFx0YmFzZVNjYWxlOiBwcmV2U2NhbGUsXG5cdFx0XHRcdFx0ZGVsdGFTY2FsZTogdGhpcy5zY2FsZSAtIHByZXZTY2FsZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtKHRoaXMuc2NhbGUpO1xuXHRcdFx0XHR0aGlzLmRvWm9vbSh7c2NhbGU6dGhpcy5zY2FsZX0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR6b29tQW5pbWF0aW9uU3RlcDogZnVuY3Rpb24gKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dmFyIGN1cnJTY2FsZSA9IHRoaXMuJC5hbmltYXRvci5iYXNlU2NhbGUgKyAodGhpcy4kLmFuaW1hdG9yLmRlbHRhU2NhbGUgKiB0aGlzLiQuYW5pbWF0b3IudmFsdWUpO1xuXHRcdHRoaXMudHJhbnNmb3JtKGN1cnJTY2FsZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0em9vbUFuaW1hdGlvbkVuZDogZnVuY3Rpb24gKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dGhpcy5zdGFiaWxpemUoKTtcblx0XHR0aGlzLmRvWm9vbSh7c2NhbGU6dGhpcy5zY2FsZX0pO1xuXHRcdHRoaXMuJC5hbmltYXRvci5yYXRpb0xvY2sgPSB1bmRlZmluZWQ7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCogQGZpcmVzIGVueW8uUGFuWm9vbVZpZXcjb25Qb3NpdGlvblBpblxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHBvc2l0aW9uQ2xpZW50Q29udHJvbHM6IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHRoaXMud2F0ZXJmYWxsRG93bignb25Qb3NpdGlvblBpbicsIHtcblx0XHRcdHNjYWxlOiBzY2FsZSxcblx0XHRcdGJvdW5kczogdGhpcy5ib3VuZHNcblx0XHR9KTtcblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW8vbGliL0FuaW1hdG9yXCI6NSxcIi4uLy4uL2VueW8vbGliL1Njcm9sbGVyXCI6NDQsXCIuLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uL2VueW8vbGliL3BsYXRmb3JtXCI6NzEsXCIuLi8uLi9lbnlvL2xpYi91dGlsc1wiOjc1fV0sMTA2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRDb250cm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ29udHJvbCcpLFxuXHRJbWFnZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0ltYWdlJyksXG5cdFBvcHVwID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvUG9wdXAnKSxcblx0UmVwZWF0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9SZXBlYXRlcicpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyk7XG5cbnZhclxuXHRDb250ZXh0dWFsTGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9Db250ZXh0dWFsTGF5b3V0JyksXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyk7XG5cblxuLyoqXG5cdHNhbXBsZS5Db250ZXh0dWFsUG9wdXBfIGlzIGFuIGV4YW1wbGUgb2YgYSBwb3B1cCB0aGF0IHVzZXMgdGhlIENvbnRleHR1YWxMYXlvdXQgbGF5b3V0IHN0cmF0ZWd5LlxuKi9cbnZhciBDb250ZXh0dWFsUG9wdXAgPSBraW5kKHtcblx0a2luZDogUG9wdXAsXG5cdGxheW91dEtpbmQ6IENvbnRleHR1YWxMYXlvdXQsXG5cdGNsYXNzZXM6ICdzYW1wbGUtY29udGV4dHVhbC1wb3B1cCcsXG5cblx0ZmxvYXRpbmc6IHRydWUsXG5cdGNvdW50OiA1LFxuXG5cdC8vbGF5b3V0IHBhcmFtZXRlcnNcblx0dmVydEZsdXNoTWFyZ2luOiA2MCxcdC8vdmVydGljYWwgZmx1c2ggbGF5b3V0IG1hcmdpblxuXHRob3JpekZsdXNoTWFyZ2luOiA1MCxcdC8vaG9yaXpvbnRhbCBmbHVzaCBsYXlvdXQgbWFyZ2luXG5cdHdpZGVQb3B1cDogMjAwLFx0XHRcdC8vcG9wdXBzIHdpZGVyIHRoYW4gdGhpcyB2YWx1ZSBhcmUgY29uc2lkZXJlZCB3aWRlIChmb3IgbGF5b3V0IHB1cnBvc2VzKVxuXHRsb25nUG9wdXA6IDIwMCxcdFx0XHQvL3BvcHVwcyBsb25nZXIgdGhhbiB0aGlzIHZhbHVlIGFyZSBjb25zaWRlcmVkIGxvbmcgKGZvciBsYXlvdXQgcHVycG9zZXMpXG5cdGhvcml6QnVmZmVyOiAxNixcdFx0Ly9kbyBub3QgYWxsb3cgaG9yaXpvbnRhbCBmbHVzaCBwb3B1cHMgcGFzdCBzcGVjJ2QgYW1vdW50IG9mIGJ1ZmZlciBzcGFjZSBvbiBsZWZ0L3JpZ2h0IHNjcmVlbiBlZGdlXG5cblx0aGFuZGxlcnM6IHtcblx0XHRvblJlcXVlc3RTaG93TWVudTogJ3JlcXVlc3RTaG93J1xuXHR9LFxuXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFBvcHVwLnByb3RvdHlwZS5jcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLmNyZWF0ZUNvbXBvbmVudCh7a2luZDogUmVwZWF0ZXIsIGNvdW50OiB0aGlzLmNvdW50LCBvblNldHVwSXRlbTogJ3NldHVwSXRlbScsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnaXRlbSd9XG5cdFx0XX0pO1xuXHR9LFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0ZXZlbnQuaXRlbS4kLml0ZW0uc2V0KCdjb250ZW50JywgJ0l0ZW0gJyArIGV2ZW50LmluZGV4KTtcblx0fSxcblx0cmVxdWVzdFNob3c6IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dmFyIG4gPSBpbkV2ZW50LmFjdGl2YXRvci5oYXNOb2RlKCk7XG5cdFx0aWYgKG4pIHtcblx0XHRcdHRoaXMuYWN0aXZhdG9yT2Zmc2V0ID0gdGhpcy5nZXRQYWdlT2Zmc2V0KG4pO1xuXHRcdH1cblx0XHR0aGlzLnNob3coKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Z2V0UGFnZU9mZnNldDogZnVuY3Rpb24oaW5Ob2RlKSB7XG5cdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHJldHVybnMgdG9wL2xlZnQgdmFsdWVzIHdoaWNoIGFyZSByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgYW5kIG5vdCBhYnNvbHV0ZVxuXHRcdHZhciByID0gaW5Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0dmFyIHBhZ2VZT2Zmc2V0ID0gKHdpbmRvdy5wYWdlWU9mZnNldCA9PT0gdW5kZWZpbmVkKSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cdFx0dmFyIHBhZ2VYT2Zmc2V0ID0gKHdpbmRvdy5wYWdlWE9mZnNldCA9PT0gdW5kZWZpbmVkKSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuXHRcdHZhciBySGVpZ2h0ID0gKHIuaGVpZ2h0ID09PSB1bmRlZmluZWQpID8gKHIuYm90dG9tIC0gci50b3ApIDogci5oZWlnaHQ7XG5cdFx0dmFyIHJXaWR0aCA9IChyLndpZHRoID09PSB1bmRlZmluZWQpID8gKHIucmlnaHQgLSByLmxlZnQpIDogci53aWR0aDtcblxuXHRcdHJldHVybiB7dG9wOiByLnRvcCArIHBhZ2VZT2Zmc2V0LCBsZWZ0OiByLmxlZnQgKyBwYWdlWE9mZnNldCwgaGVpZ2h0OiBySGVpZ2h0LCB3aWR0aDogcldpZHRofTtcblx0fVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2xheW91dC5zYW1wbGUuQ29udGV4dHVhbExheW91dFNhbXBsZScsXG5cdGtpbmQ6IEZpdHRhYmxlUm93cyxcblx0Y2xhc3NlczogJ2VueW8gZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICd0b3BUb29sYmFyJywgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGdyYXknLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBzdHlsZTogJ3dpZHRoOjEwMCU7JywgY29tcG9uZW50czpbXG5cdFx0XHRcdHtjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e2tpbmQ6IENvbnRyb2wsIGNsYXNzZXM6ICdzYW1wbGUtcG9wdXAtYnV0dG9uIGljb24tYnV0dG9uJywgb250YXA6ICdzaG93UG9wdXAnLCBzdHlsZTogJ2JhY2tncm91bmQtaW1hZ2U6IHVybChhc3NldHMvbWVudS1pY29uLWJvb2ttYXJrLnBuZyknfSxcblx0XHRcdFx0XHR7a2luZDogQ29udGV4dHVhbFBvcHVwLCBjb3VudDogMn1cblx0XHRcdFx0XX0sXG5cdFx0XHRcdHtmaXQ6dHJ1ZSwgc3R5bGU6ICdwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7a2luZDogQ29udHJvbCwgY2xhc3NlczogJ3NhbXBsZS1wb3B1cC1idXR0b24gaWNvbi1idXR0b24nLCBvbnRhcDogJ3Nob3dQb3B1cCcsIHN0eWxlOiAnYmFja2dyb3VuZC1pbWFnZTogdXJsKGFzc2V0cy9tZW51LWljb24tYm9va21hcmsucG5nKSd9LFxuXHRcdFx0XHRcdHtraW5kOiBDb250ZXh0dWFsUG9wdXAsIGNvdW50OiA2fVxuXHRcdFx0XHRdfVxuXHRcdFx0XX1cblx0XHRdfSxcblx0XHR7a2luZDogU2Nyb2xsZXIsIGZpdDogdHJ1ZSwgdGh1bWI6IGZhbHNlLCBjb21wb25lbnRzOltcblx0XHRcdHtuYW1lOiAnYnV0dG9uQ29udGFpbmVyJywga2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnb255eC1jb250ZXh0dWFscG9wdXAtYnV0dG9uLWNvbnRhaW5lciBlbnlvLWZpdCcsIGNvbXBvbmVudHM6W1xuXHRcdFx0XHQvL1RvcCByb3cgb2YgYnV0dG9uc1xuXHRcdFx0XHR7Y29tcG9uZW50czpbXG5cdFx0XHRcdFx0e3N0eWxlOiAnZGlzcGxheTppbmxpbmUtYmxvY2snLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udHJvbCwgY29udGVudDogJ0F2ZXJhZ2UnLCBjbGFzc2VzOiAnc2FtcGxlLXBvcHVwLWJ1dHRvbicsIG9udGFwOiAnc2hvd1BvcHVwJ30sXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udGV4dHVhbFBvcHVwLCBjb3VudDogNX1cblx0XHRcdFx0XHRdfSxcblxuXHRcdFx0XHRcdHtzdHlsZTogJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO2Zsb2F0OnJpZ2h0JywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdFx0e2tpbmQ6IENvbnRyb2wsIGNvbnRlbnQ6ICdTbWFsbCcsIGNsYXNzZXM6ICdzYW1wbGUtcG9wdXAtYnV0dG9uJywgb250YXA6ICdzaG93UG9wdXAnfSxcblx0XHRcdFx0XHRcdHtraW5kOiBDb250ZXh0dWFsUG9wdXAsIGNvdW50OiAxfVxuXHRcdFx0XHRcdF19XG5cdFx0XHRcdF19LFxuXHRcdFx0XHQvL0NlbnRlciByb3cgb2YgYnV0dG9uc1xuXHRcdFx0XHR7Zml0OnRydWUsIHN0eWxlOiAncGFkZGluZy10b3A6MTUlO3BhZGRpbmctYm90dG9tOjE1JTsnLCBjb21wb25lbnRzOltcblx0XHRcdFx0XHR7c3R5bGU6ICdkaXNwbGF5OmlubGluZS1ibG9jazsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udHJvbCwgY29udGVudDogJ1dpZGUnLCBjbGFzc2VzOiAnc2FtcGxlLXBvcHVwLWJ1dHRvbicsIG9udGFwOiAnc2hvd1BvcHVwJ30sXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udGV4dHVhbFBvcHVwLCBzdHlsZTogJ3dpZHRoOjMwMHB4JywgY291bnQ6IDAsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHRcdFx0e2tpbmQ6IFNjcm9sbGVyLCBzdHlsZTogJ21pbi13aWR0aDoxNTBweDsnLCBob3Jpem9udGFsOiAnYXV0bycsICB0b3VjaDp0cnVlLCB0aHVtYjpmYWxzZSwgIGNvbXBvbmVudHM6W1xuXHRcdFx0XHRcdFx0XHRcdHtjb250ZW50OiAndGVzdGluZyAxJ30sXG5cdFx0XHRcdFx0XHRcdFx0e2NvbnRlbnQ6ICd0ZXN0aW5nIDInfVxuXHRcdFx0XHRcdFx0XHRdfVxuXHRcdFx0XHRcdFx0XX1cblx0XHRcdFx0XHRdfSxcblx0XHRcdFx0XHR7c3R5bGU6ICdkaXNwbGF5OmlubGluZS1ibG9jaztmbG9hdDpyaWdodCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHRcdHtraW5kOiBDb250cm9sLCBjb250ZW50OiAnTG9uZycsIGNsYXNzZXM6ICdzYW1wbGUtcG9wdXAtYnV0dG9uJywgb250YXA6ICdzaG93UG9wdXAnfSxcblx0XHRcdFx0XHRcdHtraW5kOiBDb250ZXh0dWFsUG9wdXAsIGNvdW50OiAzMH1cblx0XHRcdFx0XHRdfVxuXHRcdFx0XHRdfSxcblx0XHRcdFx0Ly9Cb3R0b20gcm93IG9mIGJ1dHRvbnNcblx0XHRcdFx0e2NvbXBvbmVudHM6W1xuXHRcdFx0XHRcdHtzdHlsZTogJ2Rpc3BsYXk6aW5saW5lLWJsb2NrOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHRcdHtraW5kOiBDb250cm9sLCBjb250ZW50OiAnUHJlc3MgTWUnLCBjbGFzc2VzOiAnc2FtcGxlLXBvcHVwLWJ1dHRvbicsIG9udGFwOiAnc2hvd1BvcHVwJ30sXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udGV4dHVhbFBvcHVwLCBzdHlsZTogJ3dpZHRoOjIwMHB4JywgY291bnQ6IDEwfVxuXHRcdFx0XHRcdF19LFxuXHRcdFx0XHRcdHtzdHlsZTogJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO2Zsb2F0OnJpZ2h0JywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdFx0e2tpbmQ6IENvbnRyb2wsIGNvbnRlbnQ6ICdUcnkgTWUnLCBjbGFzc2VzOiAnc2FtcGxlLXBvcHVwLWJ1dHRvbicsIG9udGFwOiAnc2hvd1BvcHVwJ30sXG5cdFx0XHRcdFx0XHR7a2luZDogQ29udGV4dHVhbFBvcHVwLCBzdHlsZTogJ3dpZHRoOjI1MHB4JywgY291bnQ6IDV9XG5cdFx0XHRcdFx0XX1cblx0XHRcdFx0XX1cblx0XHRcdF19XG5cdFx0XX0sXG5cdFx0e25hbWU6ICdib3R0b21Ub29sYmFyJywgY2xhc3NlczogJ29ueXgtbWVudS10b29sYmFyJywgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOmxpZ2h0Z3JheScsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIHN0eWxlOiAnd2lkdGg6MTAwJTsnLCBjb21wb25lbnRzOltcblx0XHRcdFx0e2NvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7a2luZDogQ29udHJvbCwgY2xhc3NlczogJ3NhbXBsZS1wb3B1cC1idXR0b24gaWNvbi1idXR0b24nLCBvbnRhcDogJ3Nob3dQb3B1cCcsIHN0eWxlOiAnYmFja2dyb3VuZC1pbWFnZTogdXJsKGFzc2V0cy9tZW51LWljb24tYm9va21hcmsucG5nKSd9LFxuXHRcdFx0XHRcdHtraW5kOiBDb250ZXh0dWFsUG9wdXAsIGNvdW50OiA2fVxuXHRcdFx0XHRdfSxcblx0XHRcdFx0e2ZpdDogdHJ1ZSwgc3R5bGU6ICdwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7a2luZDogQ29udHJvbCwgY2xhc3NlczogJ3NhbXBsZS1wb3B1cC1idXR0b24gaWNvbi1idXR0b24nLCBvbnRhcDogJ3Nob3dQb3B1cCcsIHN0eWxlOiAnYmFja2dyb3VuZC1pbWFnZTogdXJsKGFzc2V0cy9tZW51LWljb24tYm9va21hcmsucG5nKSd9LFxuXHRcdFx0XHRcdHtraW5kOiBDb250ZXh0dWFsUG9wdXAsIG5hbWU6ICdmYWNlYm9vaycsIGNvdW50OiA2fVxuXHRcdFx0XHRdfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdLFxuXHRzaG93UG9wdXA6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gXG5cdFx0c2VuZGVyLnBhcmVudC53YXRlcmZhbGwoJ29uUmVxdWVzdFNob3dNZW51Jywge1xuXHRcdFx0YWN0aXZhdG9yOiBzZW5kZXJcblx0XHR9KTtcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0NvbnRyb2xcIjoxNixcIi4uLy4uLy4uL2VueW8vbGliL0ltYWdlXCI6MjMsXCIuLi8uLi8uLi9lbnlvL2xpYi9Qb3B1cFwiOjM3LFwiLi4vLi4vLi4vZW55by9saWIvUmVwZWF0ZXJcIjozOCxcIi4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyXCI6NDQsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0NvbnRleHR1YWxMYXlvdXRcIjo4MyxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zXCI6ODUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4fV0sMTEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyk7XG5cbnZhclxuXHRGaXR0YWJsZUNvbHVtbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1ucycpLFxuXHRGaXR0YWJsZVJvd3MgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuRml0dGFibGVEZXNjcmlwdGlvbicsXG5cdGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGVueW8tZml0Jyxcblx0c3R5bGU6ICdwYWRkaW5nOjEwcHg7Jyxcblx0a2luZDogU2Nyb2xsZXIsXG5cdGNvbXBvbmVudHM6IFtcblx0XHR7dGFnOiAncCcsIGFsbG93SHRtbDogdHJ1ZSwgY29udGVudDogJ0ZpdHRhYmxlQ29sdW1ucywgbm8gbWFyZ2luIG9uIGJveGVzIChhbGwgZGl2cyBoYXZlIHNvbWUgcGFkZGluZykuIEJ5IGRlZmF1bHQsIGJveGVzIFwic3RyZXRjaFwiIHRvIGZpdCB0aGUgY29udGFpbmVyICh3aGljaCBtdXN0IGhhdmUgYSBoZWlnaHQpLid9LFxuXHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtaGVpZ2h0IGZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW8gZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdCb3hBJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3gnfSxcblx0XHRcdHtjb250ZW50OiAnRml0dGluZyBCb3hCJywgZml0OiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdCb3hDJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3gnfVxuXHRcdF19LFxuXHRcdHt0YWc6ICdwJywgYWxsb3dIdG1sOiB0cnVlLCBjb250ZW50OiAnQm94ZXMgd2l0aCBsZWZ0L3JpZ2h0IG1hcmdpbnMuIE5vdGU6IHRvcC9ib3R0b20gbWFyZ2luIG9uIGNvbHVtbiBib3hlcyBpcyBOT1Qgc3VwcG9ydGVkLid9LFxuXHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtaGVpZ2h0IGZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW8gZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdCb3hBJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGaXR0aW5nIEJveEInLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdHtjb250ZW50OiAnQm94QycsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfVxuXHRcdF19LFxuXHRcdHt0YWc6ICdwJywgYWxsb3dIdG1sOiB0cnVlLCBjb250ZW50OiAnV2l0aCA8Y29kZT5ub1N0cmV0Y2g6IHRydWU8L2NvZGU+LCBib3hlcyBoYXZlIG5hdHVyYWwgaGVpZ2h0Lid9LFxuXHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIG5vU3RyZXRjaDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1oZWlnaHQgZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbyBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0JveEEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJ0ZpdHRpbmcgQm94Qjxicj48YnI+d2l0aCBuYXR1cmFsIGhlaWdodCcsIGZpdDogdHJ1ZSwgYWxsb3dIdG1sOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHR7Y29udGVudDogJ0JveEMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ31cblx0XHRdfSxcblx0XHR7dGFnOiAncCcsIGFsbG93SHRtbDogdHJ1ZSwgY29udGVudDogJ0ZpdHRhYmxlUm93cywgbm8gbWFyZ2luIG9uIGJveGVzIChhbGwgZGl2cyBoYXZlIHNvbWUgcGFkZGluZykuJ30sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1oZWlnaHQgZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbyBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0JveEEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGaXR0aW5nIEJveEInLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94J30sXG5cdFx0XHR7Y29udGVudDogJ0JveEMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCd9XG5cdFx0XX0sXG5cdFx0e3RhZzogJ3AnLCBhbGxvd0h0bWw6IHRydWUsIGNvbnRlbnQ6ICdSb3cgYm94ZXMgbWF5IGhhdmUgbWFyZ2luIGluIGFueSBkaW1lbnNpb24uPGJyPjxicj4gTk9URTogUm93IGJveGVzIHdpbGwgY29sbGFwc2UgdmVydGljYWwgbWFyZ2lucyBhY2NvcmRpbmcgdG8gY3NzIHJ1bGVzLiBJZiBtYXJnaW4gY29sbGFwc2UgaXMgbm90IGRlc2lyZWQsIHRoZW4gXCJlbnlvLW1hcmdpbi1leHBhbmRcIiBtYXkgYmUgYXBwbGllZC4gT25seSBpbiB0aGlzIGNhc2UsIGxlZnQvcmlnaHQgbWFyZ2luIG9uIHJvdyBib3hlcyBpcyBOT1Qgc3VwcG9ydGVkLid9LFxuXHRcdHtraW5kOiBGaXR0YWJsZVJvd3MsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtaGVpZ2h0IGZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW8gZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdCb3hBJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJ30sXG5cdFx0XHR7Y29udGVudDogJ0ZpdHRpbmcgQm94QicsIGZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJ30sXG5cdFx0XHR7Y29udGVudDogJ0JveEMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInfVxuXHRcdF19LFxuXHRcdHt0YWc6ICdwJywgYWxsb3dIdG1sOiB0cnVlLCBjb250ZW50OiAnV2l0aCA8Y29kZT5ub1N0cmV0Y2g6IHRydWU8L2NvZGU+LCBib3hlcyBoYXZlIG5hdHVyYWwgd2lkdGguPGJyPjxicj4gTk9URTogbWFyZ2lucyB3aWxsIG5vdCBjb2xsYXBzZSBpbiB0aGlzIGNhc2UuJ30sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgbm9TdHJldGNoOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWhlaWdodCBmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1vIGZpdHRhYmxlLXNhbXBsZS1tdGInLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0JveEEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInfSxcblx0XHRcdHtjb250ZW50OiAnRml0dGluZyBCb3hCJywgZml0OiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInfSxcblx0XHRcdHtjb250ZW50OiAnQm94QycsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHIgZml0dGFibGUtc2FtcGxlLW10Yid9XG5cdFx0XX1cblx0XVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyXCI6NDQsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1uc1wiOjg1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3NcIjo4OH1dLDExNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0U2Nyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9TY3JvbGxlcicpO1xuXG52YXJcblx0Rml0dGFibGVDb2x1bW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnMnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2VueW8uc2FtcGxlLkZpdHRhYmxlVGVzdHMnLFxuXHRjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBlbnlvLWZpdCcsXG5cdGtpbmQ6IFNjcm9sbGVyLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2NsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtc2VjdGlvbicsIGNvbnRlbnQ6ICdSb3dzL0NvbHVtbnMgdXNpbmcgYSBjb21iaW5hdGlvbiBvZiBjc3MgdW5pdHMgYW5kIGhpZ2hsaWdodGluZyBtYXJnaW4gY29sbGFwc2UnfSxcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtdGVzdCcsIHN0eWxlOiAnaGVpZ2h0OiA0MDBweDsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0ZPTzxicj5tYXJnaW4tYm90dG9tOiAxZW0nLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHIgZml0dGFibGUtc2FtcGxlLW10YicsIHN0eWxlOiAnbWFyZ2luLWJvdHRvbTogMWVtOyd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdtYXJnaW4tdG9wOiAxZW0gKGNvbGxhcHNlZCBzaW5jZSBzaWJsaW5nIHNob3dzIGdyZWF0ZXIgb2YgcHJldmlvdXMgYm90dG9tIGFuZCB0aGlzIHRvcCk8YnI+Rk9PJywgYWxsb3dIdG1sOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInLCBzdHlsZTogJ21hcmdpbi10b3A6IDFlbTsnfSxcblx0XHRcdHtjb250ZW50OiAnRk9PPGJyPkZPTycsIGFsbG93SHRtbDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJ30sXG5cdFx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tdGIgZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2NvbnRlbnQ6ICcxMTExMTExMTExMTExMTEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHRcdHtjb250ZW50OiAnMTExMTExMTExMTExMTExJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0XHR7Y29udGVudDogJzInLCBmaXQ6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHIgZml0dGFibGUtc2FtcGxlLW8nfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICczMzMzMzMzJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9XG5cdFx0XHRdfSxcblx0XHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGNvbnRlbnQ6ICdCYXQnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbXRiIGVueW8tY2VudGVyJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7Y29udGVudDogJ2FkZCBlbnlvLWNlbnRlciB0byBGaXR0YWJsZUNvbHVtbnMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHRcdHtjb250ZW50OiAnMScsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICcyJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0XHR7Y29udGVudDogJzMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHRcdHtjb250ZW50OiAnNCcsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICc1JywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9XG5cdFx0XHRdfVxuXHRcdF19LFxuXHRcdHtjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLXNlY3Rpb24nLCBjb250ZW50OiAnUm93cyB3aXRoIGVueW8tbWFyZ2luLWV4cGFuZCB0byBhdm9pZCBtYXJnaW4tY29sbGFwc2UnfSxcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtdGVzdCBlbnlvLW1hcmdpbi1leHBhbmQnLCBzdHlsZTogJ2hlaWdodDogMjUwcHg7JywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdGT088YnI+bWFyZ2luLWJvdHRvbTogMWVtJywgYWxsb3dIdG1sOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbXRiJywgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAxZW07J30sXG5cdFx0XHR7Y29udGVudDogJ21hcmdpbi10b3A6IDNlbSAobm90IGNvbGxhcHNlZCBkdWUgdG8gZW55by1tYXJnaW4tZXhwYW5kIG9uIGJveCk8YnI+Rk9PJywgYWxsb3dIdG1sOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbXRiJywgc3R5bGU6ICdtYXJnaW4tdG9wOiAzZW07J30sXG5cdFx0XHR7Y29udGVudDogJ0ZPTzxicj5GT08nLCBhbGxvd0h0bWw6IHRydWUsIGZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW10Yid9XG5cdFx0XX0sXG5cdFx0e2NsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtc2VjdGlvbicsIGNvbnRlbnQ6ICdUZXN0cyB0byBlbnN1cmUgZml0IHJlZ2lvbiBjYW4gYmUgZmlyc3QsIG1pZGRsZSwgb3IgbGFzdCd9LFxuXHRcdHtraW5kOiBGaXR0YWJsZVJvd3MsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94YWJsZSBmaXR0YWJsZS1zYW1wbGUtc21hbGwtdGVzdCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAnQScsIGZpdDogdHJ1ZX0sXG5cdFx0XHR7Y29udGVudDogJ0InfSxcblx0XHRcdHtjb250ZW50OiAnQyd9XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3hhYmxlIGZpdHRhYmxlLXNhbXBsZS1zbWFsbC10ZXN0JywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdBJ30sXG5cdFx0XHR7Y29udGVudDogJ0InLCBmaXQ6IHRydWV9LFxuXHRcdFx0e2NvbnRlbnQ6ICdDJ31cblx0XHRdfSxcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveGFibGUgZml0dGFibGUtc2FtcGxlLXNtYWxsLXRlc3QnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y29udGVudDogJ0EnfSxcblx0XHRcdHtjb250ZW50OiAnQid9LFxuXHRcdFx0e2NvbnRlbnQ6ICdDJywgZml0OiB0cnVlfVxuXHRcdF19LFxuXHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94YWJsZSBmaXR0YWJsZS1zYW1wbGUtc21hbGwtdGVzdCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAnQScsIGZpdDogdHJ1ZX0sXG5cdFx0XHR7Y29udGVudDogJ0InfSxcblx0XHRcdHtjb250ZW50OiAnQyd9XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IEZpdHRhYmxlQ29sdW1ucywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3hhYmxlIGZpdHRhYmxlLXNhbXBsZS1zbWFsbC10ZXN0JywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdBJ30sXG5cdFx0XHR7Y29udGVudDogJ0InLCBmaXQ6IHRydWV9LFxuXHRcdFx0e2NvbnRlbnQ6ICdDJ31cblx0XHRdfSxcblx0XHR7c3R5bGU6ICdoZWlnaHQ6IDIwMHB4OycsIGtpbmQ6IEZpdHRhYmxlQ29sdW1ucywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3hhYmxlIGZpdHRhYmxlLXNhbXBsZS1zbWFsbC10ZXN0JywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdBJ30sXG5cdFx0XHR7Y29udGVudDogJ0InfSxcblx0XHRcdHtjb250ZW50OiAnQycsIGZpdDogdHJ1ZX1cblx0XHRdfSxcblx0XHR7Y2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1zZWN0aW9uJywgY29udGVudDogJ1Rlc3RzIGZvciBub1N0cmV0Y2g6IHRydWUnfSxcblx0XHR7a2luZDogRml0dGFibGVSb3dzLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtdGVzdCcsIHN0eWxlOiAnaGVpZ2h0OiA0MDBweDsnLCBub1N0cmV0Y2g6IHRydWUsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAnRk9PPGJyPm1hcmdpbi1ib3R0b206IDFlbScsIGFsbG93SHRtbDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbXRiJywgc3R5bGU6ICdtYXJnaW4tYm90dG9tOiAxZW07J30sXG5cdFx0XHR7Y29udGVudDogJ21hcmdpbi10b3A6IDJlbSAobm90IGNvbGxhcHNlZDsgc3RyZXRjaCBmYWxzZSBkb2VzIG5vdCBjb2xsYXBzZSBkdWUgdG8gdXNlIG9mIGZsb2F0KTxicj5GT08nLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHIgZml0dGFibGUtc2FtcGxlLW10YicsIHN0eWxlOiAnbWFyZ2luLXRvcDogMWVtOyd9LFxuXHRcdFx0e2NvbnRlbnQ6ICdGT088YnI+Rk9PJywgYWxsb3dIdG1sOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyIGZpdHRhYmxlLXNhbXBsZS1tdGInfSxcblx0XHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIGZpdDogdHJ1ZSwgbm9TdHJldGNoOiB0cnVlLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbXRiIGZpdHRhYmxlLXNhbXBsZS1tbHIgZml0dGFibGUtc2FtcGxlLW8nLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAnMTExMTExMTExMTExMTExJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0XHR7Y29udGVudDogJzExMTExMTExMTExMTExMScsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICcyPGJyPjInLCBhbGxvd0h0bWw6IHRydWUsIGZpdDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1sciBmaXR0YWJsZS1zYW1wbGUtbyd9LFxuXHRcdFx0XHR7Y29udGVudDogJzMzMzMzMzMnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ31cblx0XHRcdF19LFxuXHRcdFx0e2tpbmQ6IEZpdHRhYmxlQ29sdW1ucywgY29udGVudDogJ0JhdCcsIG5vU3RyZXRjaDogdHJ1ZSwgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW10YiBlbnlvLWNlbnRlcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2NvbnRlbnQ6ICdhZGQgZW55by1jZW50ZXIgdG8gRml0dGFibGVDb2x1bW5zJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0XHR7Y29udGVudDogJzEnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHRcdHtjb250ZW50OiAnMicsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICczJywgY2xhc3NlczogJ2ZpdHRhYmxlLXNhbXBsZS1ib3ggZml0dGFibGUtc2FtcGxlLW1scid9LFxuXHRcdFx0XHR7Y29udGVudDogJzQnLCBjbGFzc2VzOiAnZml0dGFibGUtc2FtcGxlLWJveCBmaXR0YWJsZS1zYW1wbGUtbWxyJ30sXG5cdFx0XHRcdHtjb250ZW50OiAnNScsIGNsYXNzZXM6ICdmaXR0YWJsZS1zYW1wbGUtYm94IGZpdHRhYmxlLXNhbXBsZS1tbHInfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdXG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvU2Nyb2xsZXJcIjo0NCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zXCI6ODUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4fV0sMTE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyk7XG5cbnZhclxuXHRGaXR0YWJsZVJvd3MgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93cycpLFxuXHRGbHl3ZWlnaHRSZXBlYXRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRmx5d2VpZ2h0UmVwZWF0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2VueW8uc2FtcGxlLkZseXdlaWdodFJlcGVhdGVyU2FtcGxlJyxcblx0a2luZDogRml0dGFibGVSb3dzLFxuXHRjbGFzc2VzOiAnZmx5d2VpZ2h0LXJlcGVhdGVyLXNhbXBsZSBlbnlvLWZpdCBvbnl4Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdGbHl3ZWlnaHRSZXBlYXRlciBSZXN1bHQnfVxuXHRcdF19LFxuXHRcdHtuYW1lOidyZXN1bHQnLCBzdHlsZToncGFkZGluZzoxMnB4OyBmb250LXNpemU6IDIwcHg7JywgY29udGVudDogJ05vdGhpbmcgc2VsZWN0ZWQgeWV0Lid9LFxuXHRcdHtraW5kOiBTY3JvbGxlciwgZml0OiB0cnVlLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZToncmVwZWF0ZXInLCBraW5kOiBGbHl3ZWlnaHRSZXBlYXRlciwgY2xhc3NlczonZmx5d2VpZ2h0LXJlcGVhdGVyLXNhbXBsZS1saXN0JywgY291bnQ6IDI2LCBvblNldHVwSXRlbTogJ3NldHVwSXRlbScsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdpdGVtJywgY2xhc3NlczonZmx5d2VpZ2h0LXJlcGVhdGVyLXNhbXBsZS1pdGVtJ31cblx0XHRcdF19XG5cdFx0XX1cblx0XSxcblx0aGFuZGxlcnM6IHtcblx0XHRvblNlbGVjdDogJ2l0ZW1TZWxlY3RlZCdcblx0fSxcblx0cGVvcGxlOiBbXG5cdFx0e25hbWU6ICdBbmRyZXcnfSxcblx0XHR7bmFtZTogJ0JldHR5J30sXG5cdFx0e25hbWU6ICdDaHJpc3RvcGhlcid9LFxuXHRcdHtuYW1lOiAnRG9ubmEnfSxcblx0XHR7bmFtZTogJ0VwaHJhaW0nfSxcblx0XHR7bmFtZTogJ0ZyYW5raWUnfSxcblx0XHR7bmFtZTogJ0dlcmFsZCd9LFxuXHRcdHtuYW1lOiAnSGVhdGhlcid9LFxuXHRcdHtuYW1lOiAnSW5ncmVkJ30sXG5cdFx0e25hbWU6ICdKYWNrJ30sXG5cdFx0e25hbWU6ICdLZXZpbid9LFxuXHRcdHtuYW1lOiAnTHVjeSd9LFxuXHRcdHtuYW1lOiAnTWF0dGhldyd9LFxuXHRcdHtuYW1lOiAnTm9yZWVuJ30sXG5cdFx0e25hbWU6ICdPc2Nhcid9LFxuXHRcdHtuYW1lOiAnUGVkcm8nfSxcblx0XHR7bmFtZTogJ1F1ZW50aW4nfSxcblx0XHR7bmFtZTogJ1JhbHBoJ30sXG5cdFx0e25hbWU6ICdTdGV2ZW4nfSxcblx0XHR7bmFtZTogJ1RyYWN5J30sXG5cdFx0e25hbWU6ICdVbWEnfSxcblx0XHR7bmFtZTogJ1ZpY3Rvcid9LFxuXHRcdHtuYW1lOiAnV2VuZHknfSxcblx0XHR7bmFtZTogJ1hpbid9LFxuXHRcdHtuYW1lOiAnWXVsaWEnfSxcblx0XHR7bmFtZTogJ1pvbHRhbid9XG5cdF0sXG5cdHNldHVwSXRlbTogZnVuY3Rpb24oc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBpbmRleCA9IGV2ZW50LmluZGV4O1xuXHRcdHRoaXMuJC5pdGVtLnNldENvbnRlbnQoKGluZGV4KzEpICsgJy4gJyArIHRoaXMucGVvcGxlW2luZGV4XS5uYW1lKTtcblx0XHR0aGlzLiQuaXRlbS5hcHBseVN0eWxlKCdiYWNrZ3JvdW5kJywgKGV2ZW50LnNlbGVjdGVkPyAnZG9kZ2VyYmx1ZSc6J2xpZ2h0Z3JheScpKTtcblx0XHQvKiBzdG9wIHByb3BvZ2F0aW9uICovXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGl0ZW1TZWxlY3RlZDogZnVuY3Rpb24oc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBpbmRleCA9IGV2ZW50LmluZGV4O1xuXHRcdHZhciBjb3VudCA9IGV2ZW50LmZseXdlaWdodC5jb3VudDtcblx0XHRpZihpbmRleD49MCAmJiBpbmRleDxjb3VudCl7XG5cdFx0XHR0aGlzLiQucmVzdWx0LnNldENvbnRlbnQoJyBbJyArIChpbmRleCsxKSArICcuICcgKyB0aGlzLnBlb3BsZVtpbmRleF0ubmFtZSArICddIGlzIHNlbGVjdGVkJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9TY3JvbGxlclwiOjQ0LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3NcIjo4OCxcIi4uLy4uLy4uL2xheW91dC9saWIvRmx5d2VpZ2h0UmVwZWF0ZXJcIjo4OX1dLDEzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRyZWFkeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL3JlYWR5JyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvdXRpbHMnKSxcblx0ZHJhZyA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2RyYWcnKSxcblx0U2Nyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9TY3JvbGxlcicpLFxuXHRTZWxlY3QgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9TZWxlY3QnKSxcblx0QnV0dG9uID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQnV0dG9uJyksXG5cdFRvb2xEZWNvcmF0b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9Ub29sRGVjb3JhdG9yJyksXG5cdElucHV0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW5wdXQnKTtcblxudmFyXG5cdENhcmRBcnJhbmdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvQ2FyZEFycmFuZ2VyJyksXG5cdENhcmRTbGlkZUluQXJyYW5nZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0NhcmRTbGlkZUluQXJyYW5nZXInKSxcblx0Q2Fyb3VzZWxBcnJhbmdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvQ2Fyb3VzZWxBcnJhbmdlcicpLFxuXHRDb2xsYXBzaW5nQXJyYW5nZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0NvbGxhcHNpbmdBcnJhbmdlcicpLFxuXHREb2NrUmlnaHRBcnJhbmdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRG9ja1JpZ2h0QXJyYW5nZXInKSxcblx0Rml0dGFibGVDb2x1bW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnMnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0R3JpZEFycmFuZ2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9HcmlkQXJyYW5nZXInKSxcblx0TGVmdFJpZ2h0QXJyYW5nZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0xlZnRSaWdodEFycmFuZ2VyJyksXG5cdFBhbmVscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvUGFuZWxzJyksXG5cdFNwaXJhbEFycmFuZ2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9TcGlyYWxBcnJhbmdlcicpLFxuXHRUb3BCb3R0b21BcnJhbmdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvVG9wQm90dG9tQXJyYW5nZXInKTtcblxudmFyIE15R3JpZEFycmFuZ2VyID0ga2luZCh7XG5cdGtpbmQ6IEdyaWRBcnJhbmdlcixcblx0Y29sSGVpZ2h0OiAnMTUwJyxcblx0Y29sV2lkdGg6ICcxNTAnXG59KTtcblxudmFyIFBhbmVsc1NhbXBsZSA9IG1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5QYW5lbHNTYW1wbGUnLFxuXHRraW5kOiBGaXR0YWJsZVJvd3MsXG5cdGNsYXNzZXM6ICdlbnlvLXNhbXBsZS1wYW5lbHNzYW1wbGUgZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2NsYXNzZXM6ICd0b29sYmFyJywgY29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICdhcnJhbmdlclBpY2tlcicsIGtpbmQ6IFNlbGVjdCwgbWF4SGVpZ2h0OiAzNjAsIGZsb2F0aW5nOiB0cnVlLCBvbmNoYW5nZTogJ2FycmFuZ2VyU2VsZWN0ZWQnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAnQXJyYW5nZXInfVxuXHRcdFx0XX0sXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnUHJldmlvdXMnLCBvbnRhcDogJ3ByZXZQYW5lbCd9LFxuXHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ05leHQnLCBvbnRhcDogJ25leHRQYW5lbCd9LFxuXHRcdFx0e2tpbmQ6IFRvb2xEZWNvcmF0b3IsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IElucHV0LCB2YWx1ZTogMCwgb25jaGFuZ2U6ICdnb3RvUGFuZWwnfVxuXHRcdFx0XX0sXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnR28nLCBvbnRhcDogJ2dvdG9QYW5lbCd9LFxuXHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ0FkZCcsIG9udGFwOiAnYWRkUGFuZWwnfSxcblx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdEZWxldGUnLCBvbnRhcDogJ2RlbGV0ZVBhbmVsJ31cblx0XHRdfSxcblx0XHR7a2luZDogUGFuZWxzLCBuYW1lOiAnc2FtcGxlUGFuZWxzJywgZml0OiB0cnVlLCByZWFsdGltZUZpdDogdHJ1ZSwgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtcGFuZWxzIGVueW8tYm9yZGVyLWJveCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAwLCBzdHlsZTogJ2JhY2tncm91bmQ6cmVkOyd9LFxuXHRcdFx0e2NvbnRlbnQ6IDEsIHN0eWxlOiAnYmFja2dyb3VuZDpvcmFuZ2U7J30sXG5cdFx0XHR7Y29udGVudDogMiwgc3R5bGU6ICdiYWNrZ3JvdW5kOnllbGxvdzsnfSxcblx0XHRcdHtjb250ZW50OiAzLCBzdHlsZTogJ2JhY2tncm91bmQ6Z3JlZW47J30sXG5cdFx0XHR7Y29udGVudDogNCwgc3R5bGU6ICdiYWNrZ3JvdW5kOmJsdWU7J30sXG5cdFx0XHR7Y29udGVudDogNSwgc3R5bGU6ICdiYWNrZ3JvdW5kOmluZGlnbzsnfSxcblx0XHRcdHtjb250ZW50OiA2LCBzdHlsZTogJ2JhY2tncm91bmQ6dmlvbGV0Oyd9XG5cdFx0XX1cblx0XSxcblx0cGFuZWxBcnJhbmdlcnM6IFtcblx0XHR7bmFtZTogJ0NhcmRBcnJhbmdlcicsIGFycmFuZ2VyS2luZDogQ2FyZEFycmFuZ2VyfSxcblx0XHR7bmFtZTogJ0NhcmRTbGlkZUluQXJyYW5nZXInLCBhcnJhbmdlcktpbmQ6IENhcmRTbGlkZUluQXJyYW5nZXJ9LFxuXHRcdHtuYW1lOiAnQ2Fyb3VzZWxBcnJhbmdlcicsIGFycmFuZ2VyS2luZDogQ2Fyb3VzZWxBcnJhbmdlciwgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtd2lkZSd9LFxuXHRcdHtuYW1lOiAnQ29sbGFwc2luZ0FycmFuZ2VyJywgYXJyYW5nZXJLaW5kOiBDb2xsYXBzaW5nQXJyYW5nZXIsIGNsYXNzZXM6ICdwYW5lbHMtc2FtcGxlLWNvbGxhcHNpYmxlJ30sXG5cdFx0e25hbWU6ICdMZWZ0UmlnaHRBcnJhbmdlcicsIGFycmFuZ2VyS2luZDogTGVmdFJpZ2h0QXJyYW5nZXJ9LFxuXHRcdHtuYW1lOiAnVG9wQm90dG9tQXJyYW5nZXInLCBhcnJhbmdlcktpbmQ6IFRvcEJvdHRvbUFycmFuZ2VyLCBjbGFzc2VzOiAncGFuZWxzLXNhbXBsZS10b3Bib3R0b20nfSxcblx0XHR7bmFtZTogJ1NwaXJhbEFycmFuZ2VyJywgYXJyYW5nZXJLaW5kOiBTcGlyYWxBcnJhbmdlciwgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtc3BpcmFsJ30sXG5cdFx0e25hbWU6ICdHcmlkQXJyYW5nZXInLCBhcnJhbmdlcktpbmQ6IE15R3JpZEFycmFuZ2VyLCBjbGFzc2VzOiAncGFuZWxzLXNhbXBsZS1ncmlkJ30sXG5cdFx0e25hbWU6ICdEb2NrUmlnaHRBcnJhbmdlcicsIGFycmFuZ2VyS2luZDogRG9ja1JpZ2h0QXJyYW5nZXIsIGNsYXNzZXM6ICdwYW5lbHMtc2FtcGxlLWNvbGxhcHNpYmxlJ31cblx0XSxcblx0Ymdjb2xvcnM6IFsncmVkJywgJ29yYW5nZScsICd5ZWxsb3cnLCAnZ3JlZW4nLCAnYmx1ZScsICdpbmRpZ28nLCAndmlvbGV0J10sXG5cdGNyZWF0ZToga2luZC5pbmhlcml0KGZ1bmN0aW9uKHN1cCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMucGFuZWxBcnJhbmdlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy4kLmFycmFuZ2VyUGlja2VyLmNyZWF0ZUNvbXBvbmVudCh7Y29udGVudDp0aGlzLnBhbmVsQXJyYW5nZXJzW2ldLm5hbWV9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMucGFuZWxDb3VudD10aGlzLiQuc2FtcGxlUGFuZWxzLmdldFBhbmVscygpLmxlbmd0aDtcblx0XHR9O1xuXHR9KSxcblx0YXJyYW5nZXJTZWxlY3RlZDogZnVuY3Rpb24oc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBzcCA9IHRoaXMuJC5zYW1wbGVQYW5lbHM7XG5cdFx0dmFyIHAgPSB0aGlzLnBhbmVsQXJyYW5nZXJzW3NlbmRlci5zZWxlY3RlZCAtIDFdO1xuXHRcdGlmICh0aGlzLmN1cnJlbnRDbGFzcykge1xuXHRcdFx0c3AucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50Q2xhc3MpO1xuXHRcdH1cblx0XHRpZiAocCkge1xuXHRcdFx0aWYgKHAuY2xhc3Nlcykge1xuXHRcdFx0XHRzcC5hZGRDbGFzcyhwLmNsYXNzZXMpO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRDbGFzcyA9IHAuY2xhc3Nlcztcblx0XHRcdH1cblx0XHRcdHNwLnNldEFycmFuZ2VyS2luZChwLmFycmFuZ2VyS2luZCk7XG5cdFx0XHRpZiAoUGFuZWxzLmlzU2NyZWVuTmFycm93KCkpIHtcblx0XHRcdFx0dGhpcy5zZXRJbmRleCgxKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdC8vIHBhbmVsc1xuXHRwcmV2UGFuZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuJC5zYW1wbGVQYW5lbHMucHJldmlvdXMoKTtcblx0XHR0aGlzLiQuaW5wdXQuc2V0VmFsdWUodGhpcy4kLnNhbXBsZVBhbmVscy5pbmRleCk7XG5cdH0sXG5cdG5leHRQYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy4kLnNhbXBsZVBhbmVscy5uZXh0KCk7XG5cdFx0dGhpcy4kLmlucHV0LnNldFZhbHVlKHRoaXMuJC5zYW1wbGVQYW5lbHMuaW5kZXgpO1xuXHR9LFxuXHRnb3RvUGFuZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuJC5zYW1wbGVQYW5lbHMuc2V0SW5kZXgodGhpcy4kLmlucHV0LmdldFZhbHVlKCkpO1xuXHR9LFxuXHRwYW5lbENvdW50OiAwLFxuXHRhZGRQYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNwID0gdGhpcy4kLnNhbXBsZVBhbmVscztcblx0XHR2YXIgaSA9IHRoaXMucGFuZWxDb3VudCsrO1xuXHRcdHZhciBwID0gc3AuY3JlYXRlQ29tcG9uZW50KHtcblx0XHRcdHN0eWxlOiAnYmFja2dyb3VuZDogJyArIHRoaXMuYmdjb2xvcnNbaSAlIHRoaXMuYmdjb2xvcnMubGVuZ3RoXSxcblx0XHRcdGNvbnRlbnQ6aVxuXHRcdH0pO1xuXHRcdHAucmVuZGVyKCk7XG5cdFx0c3AucmVmbG93KCk7XG5cdFx0c3Auc2V0SW5kZXgoaSk7XG5cdH0sXG5cdGRlbGV0ZVBhbmVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcCA9IHRoaXMuJC5zYW1wbGVQYW5lbHMuZ2V0QWN0aXZlKCk7XG5cdFx0aWYgKHApIHtcblx0XHRcdHAuZGVzdHJveSgpO1xuXHRcdH1cblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyXCI6NDQsXCIuLi8uLi8uLi9lbnlvL2xpYi9TZWxlY3RcIjo0NSxcIi4uLy4uLy4uL2VueW8vbGliL1Rvb2xEZWNvcmF0b3JcIjo1MixcIi4uLy4uLy4uL2VueW8vbGliL2RyYWdcIjo1OSxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2VueW8vbGliL3JlYWR5XCI6NzIsXCIuLi8uLi8uLi9lbnlvL2xpYi91dGlsc1wiOjc1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9DYXJkQXJyYW5nZXJcIjo3OSxcIi4uLy4uLy4uL2xheW91dC9saWIvQ2FyZFNsaWRlSW5BcnJhbmdlclwiOjgwLFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9DYXJvdXNlbEFycmFuZ2VyXCI6ODEsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0NvbGxhcHNpbmdBcnJhbmdlclwiOjgyLFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9Eb2NrUmlnaHRBcnJhbmdlclwiOjg0LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnNcIjo4NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0dyaWRBcnJhbmdlclwiOjkwLFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9MZWZ0UmlnaHRBcnJhbmdlclwiOjk0LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9QYW5lbHNcIjo5OSxcIi4uLy4uLy4uL2xheW91dC9saWIvU3BpcmFsQXJyYW5nZXJcIjoxMDMsXCIuLi8uLi8uLi9sYXlvdXQvbGliL1RvcEJvdHRvbUFycmFuZ2VyXCI6MTA0fV0sMTM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRTY3JvbGxlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyJyksXG5cdFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1NlbGVjdGlvbicpO1xuXG52YXJcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0VHJlZU5vZGUgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL05vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2VueW8uc2FtcGxlLlRyZWVTYW1wbGUnLFxuXHRjbGFzc2VzOiAnZW55by11bnNlbGVjdGFibGUgZW55by1maXQnLFxuXHRraW5kOiBGaXR0YWJsZVJvd3MsXG5cdGZpdDogdHJ1ZSxcblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBTZWxlY3Rpb24sIG9uU2VsZWN0OiAnc2VsZWN0Jywgb25EZXNlbGVjdDogJ2Rlc2VsZWN0J30sXG5cdFx0e2tpbmQ6IFNjcm9sbGVyLCBmaXQ6IHRydWUsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtraW5kOiBUcmVlTm9kZSwgaWNvbjogJ2Fzc2V0cy9mb2xkZXItb3Blbi5wbmcnLCBjb250ZW50OiAnVHJlZScsIGV4cGFuZGFibGU6IHRydWUsIGV4cGFuZGVkOiB0cnVlLCBvbkV4cGFuZDogJ25vZGVFeHBhbmQnLCBvbk5vZGVUYXA6ICdub2RlVGFwJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9maWxlLnBuZycsIGNvbnRlbnQ6ICdBbHBoYSd9LFxuXHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9mb2xkZXItb3Blbi5wbmcnLCBjb250ZW50OiAnQnJhdm8nLCBleHBhbmRhYmxlOiB0cnVlLCBleHBhbmRlZDogdHJ1ZSwgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtpY29uOiAnYXNzZXRzL2ZpbGUucG5nJywgY29udGVudDogJ0JyYXZvLUFscGhhJ30sXG5cdFx0XHRcdFx0e2ljb246ICdhc3NldHMvZmlsZS5wbmcnLCBjb250ZW50OiAnQnJhdm8tQnJhdm8nfSxcblx0XHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9maWxlLnBuZycsIGNvbnRlbnQ6ICdCcmF2by1DaGFybGllJ31cblx0XHRcdFx0XX0sXG5cdFx0XHRcdHtpY29uOiAnYXNzZXRzL2ZvbGRlci5wbmcnLCBjb250ZW50OiAnQ2hhcmxpZScsIGV4cGFuZGFibGU6IHRydWUsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9maWxlLnBuZycsIGNvbnRlbnQ6ICdDaGFybGllLUFscGhhJ30sXG5cdFx0XHRcdFx0e2ljb246ICdhc3NldHMvZmlsZS5wbmcnLCBjb250ZW50OiAnQ2hhcmxpZS1CcmF2byd9LFxuXHRcdFx0XHRcdHtpY29uOiAnYXNzZXRzL2ZpbGUucG5nJywgY29udGVudDogJ0NoYXJsaWUtQ2hhcmxpZSd9XG5cdFx0XHRcdF19LFxuXHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9mb2xkZXItb3Blbi5wbmcnLCBjb250ZW50OiAnRGVsdGEnLCBleHBhbmRhYmxlOiB0cnVlLCBleHBhbmRlZDogdHJ1ZSwgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtpY29uOiAnYXNzZXRzL2ZpbGUucG5nJywgY29udGVudDogJ0RlbHRhLUFscGhhJ30sXG5cdFx0XHRcdFx0e2ljb246ICdhc3NldHMvZmlsZS5wbmcnLCBjb250ZW50OiAnRGVsdGEtQnJhdm8nfSxcblx0XHRcdFx0XHR7aWNvbjogJ2Fzc2V0cy9maWxlLnBuZycsIGNvbnRlbnQ6ICdEZWx0YS1DaGFybGllJ31cblx0XHRcdFx0XX0sXG5cdFx0XHRcdHtpY29uOiAnYXNzZXRzL2ZpbGUucG5nJywgY29udGVudDogJ0Vwc2lsb24nfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdLFxuXHRub2RlRXhwYW5kOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHNlbmRlci5zZXRJY29uKCdhc3NldHMvJyArIChzZW5kZXIuZXhwYW5kZWQgPyAnZm9sZGVyLW9wZW4ucG5nJyA6ICdmb2xkZXIucG5nJykpO1xuXHR9LFxuXHRub2RlVGFwOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBub2RlID0gZXZlbnQub3JpZ2luYXRvcjtcblx0XHR0aGlzLiQuc2VsZWN0aW9uLnNlbGVjdChub2RlLmlkLCBub2RlKTtcblx0fSxcblx0c2VsZWN0OiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdGV2ZW50LmRhdGEuJC5jYXB0aW9uLmFwcGx5U3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAnbGlnaHRibHVlJyk7XG5cdH0sXG5cdGRlc2VsZWN0OiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdGV2ZW50LmRhdGEuJC5jYXB0aW9uLmFwcGx5U3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBudWxsKTtcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL1Njcm9sbGVyXCI6NDQsXCIuLi8uLi8uLi9lbnlvL2xpYi9TZWxlY3Rpb25cIjo0NixcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL05vZGVcIjo5N31dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0TGlzdCA9IHJlcXVpcmUoJy4vTGlzdCcpLFxuXHRGbHl3ZWlnaHRSZXBlYXRlciA9IHJlcXVpcmUoJy4vRmx5d2VpZ2h0UmVwZWF0ZXInKTtcblxuLyoqXG4qIHtAbGluayBlbnlvLkFyb3VuZExpc3R9IGlzIGFuIHtAbGluayBlbnlvLkxpc3R9IHRoYXQgYWxsb3dzIGNvbnRlbnQgdG8gYmVcbiogZGlzcGxheWVkIGFyb3VuZCBpdHMgcm93cy5cbipcbiogYGBgXG4qIHtraW5kOiAnZW55by5Bcm91bmRMaXN0Jywgb25TZXR1cEl0ZW06ICdzZXR1cEl0ZW0nLFxuKiAgICAgYWJvdmVDb21wb25lbnRzOiBbXG4qICAgICAgICAge2NvbnRlbnQ6ICdDb250ZW50IGFib3ZlIHRoZSBsaXN0J31cbiogICAgIF0sXG4qICAgICBjb21wb25lbnRzOiBbXG4qICAgICAgICAge2NvbnRlbnQ6ICdMaXN0IGl0ZW0nfVxuKiAgICAgXVxuKiB9XG4qIGBgYFxuKlxuKiBAdWlcbiogQGNsYXNzIGVueW8uQXJvdW5kTGlzdFxuKiBAZXh0ZW5kcyBlbnlvLkxpc3RcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkFyb3VuZExpc3QucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5Bcm91bmRMaXN0JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBMaXN0LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGxpc3RUb29sczogW1xuXHRcdHtuYW1lOiAncG9ydCcsIGNsYXNzZXM6ICdlbnlvLWxpc3QtcG9ydCBlbnlvLWJvcmRlci1ib3gnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ2Fib3ZlQ2xpZW50J30sXG5cdFx0XHR7bmFtZTogJ2dlbmVyYXRvcicsIGtpbmQ6IEZseXdlaWdodFJlcGVhdGVyLCBjYW5HZW5lcmF0ZTogZmFsc2UsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e3RhZzogbnVsbCwgbmFtZTogJ2NsaWVudCd9XG5cdFx0XHRdfSxcblx0XHRcdHtuYW1lOiAnaG9sZGluZ2FyZWEnLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdlbnlvLWxpc3QtaG9sZGluZ2FyZWEnfSxcblx0XHRcdHtuYW1lOiAncGFnZTAnLCBhbGxvd0h0bWw6IHRydWUsIGNsYXNzZXM6ICdlbnlvLWxpc3QtcGFnZSd9LFxuXHRcdFx0e25hbWU6ICdwYWdlMScsIGFsbG93SHRtbDogdHJ1ZSwgY2xhc3NlczogJ2VueW8tbGlzdC1wYWdlJ30sXG5cdFx0XHR7bmFtZTogJ2JlbG93Q2xpZW50J30sXG5cdFx0XHR7bmFtZTogJ3BsYWNlaG9sZGVyJ30sXG5cdFx0XHR7bmFtZTogJ3N3aXBlYWJsZUNvbXBvbmVudHMnLCBzdHlsZTogJ3Bvc2l0aW9uOmFic29sdXRlOyBkaXNwbGF5OmJsb2NrOyB0b3A6LTEwMDBweDsgbGVmdDowcHg7J31cblx0XHRdfVxuXHRdLFxuXG5cdC8qKlxuXHQqIEEgYmxvY2sgb2YgY29tcG9uZW50cyB0byBiZSByZW5kZXJlZCBhYm92ZSB0aGUgbGlzdC5cblx0KlxuXHQqIEB0eXBlIHtPYmplY3RbXX1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRhYm92ZUNvbXBvbmVudHM6IG51bGwsXG5cblx0LyoqXG5cdCogQSBibG9jayBvZiBjb21wb25lbnRzIHRvIGJlIHJlbmRlcmVkIGJlbG93IHRoZSBsaXN0LlxuXHQqXG5cdCogQHR5cGUge09iamVjdFtdfVxuXHQqIEBkZWZhdWx0IG51bGxcblx0KiBAcHVibGljXG5cdCovXG5cdGJlbG93Q29tcG9uZW50czogbnVsbCxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRMaXN0LnByb3RvdHlwZS5pbml0Q29tcG9uZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLmFib3ZlQ29tcG9uZW50cykge1xuXHRcdFx0dGhpcy4kLmFib3ZlQ2xpZW50LmNyZWF0ZUNvbXBvbmVudHModGhpcy5hYm92ZUNvbXBvbmVudHMsIHtvd25lcjogdGhpcy5vd25lcn0pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5iZWxvd0NvbXBvbmVudHMpIHtcblx0XHRcdHRoaXMuJC5iZWxvd0NsaWVudC5jcmVhdGVDb21wb25lbnRzKHRoaXMuYmVsb3dDb21wb25lbnRzLCB7b3duZXI6IHRoaXMub3duZXJ9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogQHNlZSBlbnlvLkxpc3QudXBkYXRlTWV0cmljc1xuXHQqIEBwcml2YXRlXG5cdCovXG5cdHVwZGF0ZU1ldHJpY3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmRlZmF1bHRQYWdlU2l6ZSA9IHRoaXMucm93c1BlclBhZ2UgKiAodGhpcy5yb3dTaXplIHx8IDEwMCk7XG5cdFx0dGhpcy5wYWdlQ291bnQgPSBNYXRoLmNlaWwodGhpcy5jb3VudCAvIHRoaXMucm93c1BlclBhZ2UpO1xuXHRcdHRoaXMuYWJvdmVIZWlnaHQgPSB0aGlzLiQuYWJvdmVDbGllbnQuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuXHRcdHRoaXMuYmVsb3dIZWlnaHQgPSB0aGlzLiQuYmVsb3dDbGllbnQuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuXHRcdHRoaXMucG9ydFNpemUgPSB0aGlzLmFib3ZlSGVpZ2h0ICsgdGhpcy5iZWxvd0hlaWdodDtcblx0XHRmb3IgKHZhciBpPTA7IGkgPCB0aGlzLnBhZ2VDb3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLnBvcnRTaXplICs9IHRoaXMuZ2V0UGFnZVNpemUoaSk7XG5cdFx0fVxuXHRcdHRoaXMuYWRqdXN0UG9ydFNpemUoKTtcblx0fSxcblxuXHQvKipcblx0KiBAc2VlIGVueW8uTGlzdC5wb3NpdGlvblBhZ2Vcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwb3NpdGlvblBhZ2U6IGZ1bmN0aW9uIChwYWdlTnVtYmVyLCB0YXJnZXQpIHtcblx0XHR0YXJnZXQucGFnZU5vID0gcGFnZU51bWJlcjtcblx0XHR2YXIgeSA9IHRoaXMucGFnZVRvUG9zaXRpb24ocGFnZU51bWJlcik7XG5cdFx0dmFyIG8gPSB0aGlzLmJvdHRvbVVwID8gdGhpcy5iZWxvd0hlaWdodCA6IHRoaXMuYWJvdmVIZWlnaHQ7XG5cdFx0eSArPSBvO1xuXHRcdHRhcmdldC5hcHBseVN0eWxlKHRoaXMucGFnZUJvdW5kLCB5ICsgJ3B4Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCogU2Nyb2xscyBwYXN0IHRoZSBbYWJvdmVDb21wb25lbnRzXXtAbGluayBlbnlvLkFyb3VuZExpc3QjYWJvdmVDb21wb25lbnRzfVxuXHQqIG9yIFtiZWxvd0NvbXBvbmVudHNde0BsaW5rIGVueW8uQXJvdW5kTGlzdCNiZWxvd0NvbXBvbmVudHN9IGNvbXBvbmVudHMgdG9cblx0KiByZXZlYWwgdGhlIGxpc3QuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdHNjcm9sbFRvQ29udGVudFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHkgPSB0aGlzLmJvdHRvbVVwID8gdGhpcy5iZWxvd0hlaWdodCA6IHRoaXMuYWJvdmVIZWlnaHQ7XG5cdFx0dGhpcy5zZXRTY3JvbGxQb3NpdGlvbih5KTtcblx0fVxufSk7XG59LHtcIi4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4vRmx5d2VpZ2h0UmVwZWF0ZXJcIjo4OSxcIi4vTGlzdFwiOjk1fV0sMTAwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9kb20nKSxcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0cGxhdGZvcm0gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9wbGF0Zm9ybScpLFxuXHRUb3VjaFNjcm9sbFN0cmF0ZWd5ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvVG91Y2hTY3JvbGxTdHJhdGVneScpLFxuXHRUcmFuc2xhdGVTY3JvbGxTdHJhdGVneSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1RyYW5zbGF0ZVNjcm9sbFN0cmF0ZWd5Jyk7XG5cbnZhclxuXHRMaXN0ID0gcmVxdWlyZSgnLi4vTGlzdCcpLFxuXHRQdWxsZXIgPSByZXF1aXJlKCcuL1B1bGxlcicpO1xuXG4vKipcbiogRmlyZXMgd2hlbiB1c2VyIGluaXRpYXRlcyBhIHB1bGwgYWN0aW9uLiBObyBhZGRpdGlvbmFsIGRhdGEgaXMgaW5jbHVkZWQgd2l0aFxuKiB0aGlzIGV2ZW50LlxuKlxuKiBAZXZlbnQgZW55by5QdWxsZG93bkxpc3Qjb25QdWxsU3RhcnRcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdXNlciBjYW5jZWxzIGEgcHVsbCBhY3Rpb24uIE5vIGFkZGl0aW9uYWwgZGF0YSBpcyBpbmNsdWRlZCB3aXRoXG4qIHRoaXMgZXZlbnQuXG4qXG4qIEBldmVudCBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxDYW5jZWxcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoaWxlIGEgcHVsbCBhY3Rpb24gaXMgaW4gcHJvZ3Jlc3MuIE5vIGFkZGl0aW9uYWwgZGF0YSBpcyBpbmNsdWRlZCB3aXRoXG4qIHRoaXMgZXZlbnQuXG4qXG4qIEBldmVudCBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gdGhlIGxpc3QgaXMgcmVsZWFzZWQgZm9sbG93aW5nIGEgcHVsbCBhY3Rpb24sIGluZGljYXRpbmdcbiogdGhhdCB3ZSBhcmUgcmVhZHkgdG8gcmV0cmlldmUgZGF0YS4gTm8gYWRkaXRpb25hbCBkYXRhIGlzIGluY2x1ZGVkIHdpdGhcbiogdGhpcyBldmVudC5cbipcbiogQGV2ZW50IGVueW8uUHVsbGRvd25MaXN0I29uUHVsbFJlbGVhc2VcbiogQHR5cGUge09iamVjdH1cbiogQHB1YmxpY1xuKi9cblxuLyoqXG4qIEZpcmVzIHdoZW4gZGF0YSByZXRyaWV2YWwgaXMgY29tcGxldGUsIGluZGljYXRpbmcgdGhhdCB0aGUgZGF0YSBpc1xuKiBpcyByZWFkeSB0byBiZSBkaXNwbGF5ZWQuIE5vIGFkZGl0aW9uYWwgZGF0YSBpcyBpbmNsdWRlZCB3aXRoXG4qIHRoaXMgZXZlbnQuXG4qXG4qIEBldmVudCBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxDb21wbGV0ZVxuKiBAdHlwZSB7T2JqZWN0fVxuKiBAcHVibGljXG4qL1xuXG4vKipcbioge0BsaW5rIGVueW8uUHVsbGRvd25MaXN0fSBpcyBhIGxpc3QgdGhhdCBwcm92aWRlcyBhIHB1bGwtdG8tcmVmcmVzaCBmZWF0dXJlLCB3aGljaFxuKiBhbGxvd3MgbmV3IGRhdGEgdG8gYmUgcmV0cmlldmVkIGFuZCB1cGRhdGVkIGluIHRoZSBsaXN0LlxuKlxuKiBQdWxsZG93bkxpc3QgcHJvdmlkZXMgdGhlIFtvblB1bGxSZWxlYXNlXXtAbGluayBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxSZWxlYXNlfVxuKiBldmVudCB0byBhbGxvdyBhbiBhcHBsaWNhdGlvbiB0byBzdGFydCByZXRyaWV2aW5nIG5ldyBkYXRhLiAgVGhlXG4qIFtvblB1bGxDb21wbGV0ZV17QGxpbmsgZW55by5QdWxsZG93bkxpc3Qjb25QdWxsQ29tcGxldGV9IGV2ZW50IGluZGljYXRlcyB0aGF0XG4qIHRoZSBwdWxsIGlzIGNvbXBsZXRlIGFuZCBpdCdzIHRpbWUgdG8gdXBkYXRlIHRoZSBsaXN0IHdpdGggdGhlIG5ldyBkYXRhLlxuKlxuKiBgYGBcbioge25hbWU6ICdsaXN0Jywga2luZDogJ1B1bGxkb3duTGlzdCcsIG9uU2V0dXBJdGVtOiAnc2V0dXBJdGVtJyxcbiogXHRvblB1bGxSZWxlYXNlOiAncHVsbFJlbGVhc2UnLCBvblB1bGxDb21wbGV0ZTogJ3B1bGxDb21wbGV0ZScsXG4qIFx0Y29tcG9uZW50czogW1xuKiBcdFx0e25hbWU6ICdpdGVtJ31cbiogXHRdXG4qIH1cbipcbiogcHVsbFJlbGVhc2U6IGZ1bmN0aW9uICgpIHtcbiogXHR0aGlzLnNlYXJjaCgpO1xuKiB9LFxuKiBwcm9jZXNzU2VhcmNoUmVzdWx0czogZnVuY3Rpb24gKGluUmVxdWVzdCwgaW5SZXNwb25zZSkge1xuKiBcdHRoaXMucmVzdWx0cyA9IGluUmVzcG9uc2UucmVzdWx0cztcbiogXHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLnJlc3VsdHMubGVuZ3RoKTtcbiogXHR0aGlzLiQubGlzdC5jb21wbGV0ZVB1bGwoKTtcbiogfSxcbiogcHVsbENvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4qIFx0dGhpcy4kLmxpc3QucmVzZXQoKTtcbiogfVxuKiBgYGBcbipcbiogQHVpXG4qIEBjbGFzcyBlbnlvLlB1bGxkb3duTGlzdFxuKiBAZXh0ZW5kcyBlbnlvLkxpc3RcbiogQHB1YmxpY1xuKi9cbnZhciBQdWxsZG93bkxpc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGtpbmQoXG5cdC8qKiBAbGVuZHMgZW55by5QdWxsZG93bkxpc3QucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5QdWxsZG93bkxpc3QnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGtpbmQ6IExpc3QsXG5cblx0LyoqXG5cdCogU2V0cyBgdG91Y2hgIHRvIGB0cnVlYCBpbiBpbmhlcml0ZWQgU2Nyb2xsZXIga2luZCBmb3IgdG91Y2gtYmFzZWQgc2Nyb2xsaW5nIHN0cmF0ZWd5LlxuXHQqXG5cdCogQHNlZSB7QGxpbmsgZW55by5TY3JvbGxlci50b3VjaH1cblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCB0cnVlXG5cdCogQHB1YmxpY1xuXHQqL1xuXHR0b3VjaDogdHJ1ZSxcblxuXHQvKipcblx0KiBUaGUgcHVsbCBub3RpZmljYXRpb24gYXJlYSBhdCB0aGUgdG9wIG9mIHRoZSBsaXN0LlxuXHQqXG5cdCogQHR5cGUge2VueW8uQ29udHJvbH1cblx0KiBAZGVmYXVsdCBudWxsXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVsbHk6IG51bGwsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVsbGRvd25Ub29sczogW1xuXHRcdHtuYW1lOiAncHVsbGRvd24nLCBjbGFzc2VzOiAnZW55by1saXN0LXB1bGxkb3duJywgY29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICdwdWxsZXInLCBraW5kOiBQdWxsZXJ9XG5cdFx0XX1cblx0XSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRldmVudHM6IHtcblx0XHQvLyogRmlyZXMgd2hlbiB1c2VyIGluaXRpYXRlcyBhIHB1bGwgYWN0aW9uLlxuXHRcdG9uUHVsbFN0YXJ0OiAnJyxcblx0XHQvLyogRmlyZXMgd2hlbiB1c2VyIGNhbmNlbHMgYSBwdWxsIGFjdGlvbi5cblx0XHRvblB1bGxDYW5jZWw6ICcnLFxuXHRcdC8vKiBGaXJlcyB3aGlsZSBhIHB1bGwgYWN0aW9uIGlzIGluIHByb2dyZXNzLlxuXHRcdG9uUHVsbDogJycsXG5cdFx0Ly8qIEZpcmVzIHdoZW4gdGhlIGxpc3QgaXMgcmVsZWFzZWQgZm9sbG93aW5nIGEgcHVsbCBhY3Rpb24sIGluZGljYXRpbmdcblx0XHQvLyogdGhhdCB3ZSBhcmUgcmVhZHkgdG8gcmV0cmlldmUgZGF0YS5cblx0XHRvblB1bGxSZWxlYXNlOiAnJyxcblx0XHQvLyogRmlyZXMgd2hlbiBkYXRhIHJldHJpZXZhbCBpcyBjb21wbGV0ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBkYXRhIGlzXG5cdFx0Ly8qIGlzIHJlYWR5IHRvIGJlIGRpc3BsYXllZC5cblx0XHRvblB1bGxDb21wbGV0ZTogJydcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRoYW5kbGVyczoge1xuXHRcdG9uU2Nyb2xsU3RhcnQ6ICdzY3JvbGxTdGFydEhhbmRsZXInLFxuXHRcdG9uU2Nyb2xsU3RvcDogJ3Njcm9sbFN0b3BIYW5kbGVyJyxcblx0XHRvbmRyYWdmaW5pc2g6ICdkcmFnZmluaXNoJ1xuXHR9LFxuXG5cdC8qKlxuXHQqIE1lc3NhZ2UgZGlzcGxheWVkIHdoZW4gbGlzdCBpcyBub3QgYmVpbmcgcHVsbGVkLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnUHVsbCBkb3duIHRvIHJlZnJlc2guLi4nXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRwdWxsaW5nTWVzc2FnZTogJ1B1bGwgZG93biB0byByZWZyZXNoLi4uJyxcblxuXHQvKipcblx0KiBNZXNzYWdlIGRpc3BsYXllZCB3aGlsZSBhIHB1bGwgYWN0aW9uIGlzIGluIHByb2dyZXNzLlxuXHQqXG5cdCogQHR5cGUge1N0cmluZ31cblx0KiBAZGVmYXVsdCAnUmVsZWFzZSB0byByZWZyZXNoLi4uJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0cHVsbGVkTWVzc2FnZTogJ1JlbGVhc2UgdG8gcmVmcmVzaC4uLicsXG5cblx0LyoqXG5cdCogTWVzc2FnZSBkaXNwbGF5ZWQgd2hpbGUgZGF0YSBpcyBiZWluZyByZXRyaWV2ZWQuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfVxuXHQqIEBkZWZhdWx0ICdMb2FkaW5nLi4uJ1xuXHQqIEBwdWJsaWNcblx0Ki9cblx0bG9hZGluZ01lc3NhZ2U6ICdMb2FkaW5nLi4uJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWxsaW5nSWNvbkNsYXNzOiAnZW55by1wdWxsZXItYXJyb3cgZW55by1wdWxsZXItYXJyb3ctZG93bicsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVsbGVkSWNvbkNsYXNzOiAnZW55by1wdWxsZXItYXJyb3cgZW55by1wdWxsZXItYXJyb3ctdXAnLFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGxvYWRpbmdJY29uQ2xhc3M6ICcnLFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcCA9IHtraW5kOiBQdWxsZXIsIHNob3dpbmc6IGZhbHNlLCB0ZXh0OiB0aGlzLmxvYWRpbmdNZXNzYWdlLCBpY29uQ2xhc3M6IHRoaXMubG9hZGluZ0ljb25DbGFzcywgb25DcmVhdGU6ICdzZXRQdWxseSd9O1xuXHRcdHRoaXMubGlzdFRvb2xzLnNwbGljZSgwLCAwLCBwKTtcblx0XHRMaXN0LnByb3RvdHlwZS5jcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLnNldFB1bGxpbmcoKTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5pdENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNyZWF0ZUNocm9tZSh0aGlzLnB1bGxkb3duVG9vbHMpO1xuXHRcdHRoaXMuYWNjZWwgPSBkb20uY2FuQWNjZWxlcmF0ZSgpO1xuXHRcdHRoaXMudHJhbnNsYXRpb24gPSB0aGlzLmFjY2VsID8gJ3RyYW5zbGF0ZTNkJyA6ICd0cmFuc2xhdGUnO1xuXHRcdHRoaXMuc3RyYXRlZ3lLaW5kID0gdGhpcy5yZXNldFN0cmF0ZWd5S2luZCgpO1xuXHRcdExpc3QucHJvdG90eXBlLmluaXRDb21wb25lbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCogVGVtcG9yYXJpbHkgdXNlIFRvdWNoU2Nyb2xsU3RyYXRlZ3kgb24gaU9TIGRldmljZXMgKHNlZSBFTllPLTE3MTQpLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0cmVzZXRTdHJhdGVneUtpbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHBsYXRmb3JtLmFuZHJvaWQgPj0gMylcblx0XHRcdD8gVHJhbnNsYXRlU2Nyb2xsU3RyYXRlZ3lcblx0XHRcdDogVG91Y2hTY3JvbGxTdHJhdGVneTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzZXRQdWxseTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLnB1bGx5ID0gZXZlbnQub3JpZ2luYXRvcjtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGxTdGFydEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmZpcmVkUHVsbFN0YXJ0ID0gZmFsc2U7XG5cdFx0dGhpcy5maXJlZFB1bGwgPSBmYWxzZTtcblx0XHR0aGlzLmZpcmVkUHVsbENhbmNlbCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIE1vbml0b3JzIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gZGlzcGxheSBhbmQgcG9zaXRpb24gdGhlXG5cdCogW3B1bGx5XXtAbGluayBlbnlvLlB1bGxkb3duTGlzdCNwdWxseX0uXG5cdCpcblx0KiBAc2VlIHtAbGluayBlbnlvLlNjcm9sbGVyLnNjcm9sbH1cblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2Nyb2xsOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciByID0gTGlzdC5wcm90b3R5cGUuc2Nyb2xsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuY29tcGxldGluZ1B1bGwpIHtcblx0XHRcdHRoaXMucHVsbHkuc2V0U2hvd2luZyhmYWxzZSk7XG5cdFx0fVxuXHRcdHZhciBzID0gdGhpcy5nZXRTdHJhdGVneSgpLiQuc2Nyb2xsTWF0aCB8fCB0aGlzLmdldFN0cmF0ZWd5KCk7XG5cdFx0dmFyIG92ZXIgPSAtMSp0aGlzLmdldFNjcm9sbFRvcCgpO1xuXHRcdGlmIChzLmlzSW5PdmVyU2Nyb2xsKCkgJiYgb3ZlciA+IDApIHtcblx0XHRcdGRvbS50cmFuc2Zvcm1WYWx1ZSh0aGlzLiQucHVsbGRvd24sIHRoaXMudHJhbnNsYXRpb24sICcwLCcgKyBvdmVyICsgJ3B4JyArICh0aGlzLmFjY2VsID8gJywwJyA6ICcnKSk7XG5cdFx0XHRpZiAoIXRoaXMuZmlyZWRQdWxsU3RhcnQpIHtcblx0XHRcdFx0dGhpcy5maXJlZFB1bGxTdGFydCA9IHRydWU7XG5cdFx0XHRcdHRoaXMucHVsbFN0YXJ0KCk7XG5cdFx0XHRcdHRoaXMucHVsbEhlaWdodCA9IHRoaXMuJC5wdWxsZG93bi5nZXRCb3VuZHMoKS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3ZlciA+IHRoaXMucHVsbEhlaWdodCAmJiAhdGhpcy5maXJlZFB1bGwpIHtcblx0XHRcdFx0dGhpcy5maXJlZFB1bGwgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmZpcmVkUHVsbENhbmNlbCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLnB1bGwoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmZpcmVkUHVsbCAmJiAhdGhpcy5maXJlZFB1bGxDYW5jZWwgJiYgb3ZlciA8IHRoaXMucHVsbEhlaWdodCkge1xuXHRcdFx0XHR0aGlzLmZpcmVkUHVsbENhbmNlbCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZmlyZWRQdWxsID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMucHVsbENhbmNlbCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcjtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzY3JvbGxTdG9wSGFuZGxlcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmNvbXBsZXRpbmdQdWxsKSB7XG5cdFx0XHR0aGlzLmNvbXBsZXRpbmdQdWxsID0gZmFsc2U7XG5cdFx0XHR0aGlzLmRvUHVsbENvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIElmIHRoZSBwdWxsIGhhcyBiZWVuIGZpcmVkLCBvZmZzZXQgdGhlIHNjcm9sbCB0b3AgYnkgdGhlIGhlaWdodCBvZiB0aGVcblx0KiBbcHVsbHlde0BsaW5rIGVueW8uUHVsbGRvd25MaXN0I3B1bGx5fSB1bnRpbFxuXHQqIFtjb21wbGV0ZVB1bGwoKV17QGxpbmsgZW55by5QdWxsZG93bkxpc3QjY29tcGxldGVQdWxsfSBpcyBjYWxsZWQuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkcmFnZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZmlyZWRQdWxsKSB7XG5cdFx0XHR2YXIgcyA9IHRoaXMuZ2V0U3RyYXRlZ3koKS4kLnNjcm9sbE1hdGggfHwgdGhpcy5nZXRTdHJhdGVneSgpO1xuXHRcdFx0cy5zZXRTY3JvbGxZKC0xKnRoaXMuZ2V0U2Nyb2xsVG9wKCkgLSB0aGlzLnB1bGxIZWlnaHQpO1xuXHRcdFx0dGhpcy5wdWxsUmVsZWFzZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBTaWduYWxzIHRoYXQgdGhlIGxpc3Qgc2hvdWxkIGV4ZWN1dGUgcHVsbCBjb21wbGV0aW9uLiBUaGlzIGlzIHVzdWFsbHlcblx0KiBjYWxsZWQgYWZ0ZXIgdGhlIGFwcGxpY2F0aW9uIGhhcyByZWNlaXZlZCBuZXcgZGF0YS5cblx0KlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Y29tcGxldGVQdWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jb21wbGV0aW5nUHVsbCA9IHRydWU7XG5cdFx0dmFyIHMgPSB0aGlzLmdldFN0cmF0ZWd5KCkuJC5zY3JvbGxNYXRoIHx8IHRoaXMuZ2V0U3RyYXRlZ3koKTtcblx0XHRzLnNldFNjcm9sbFkodGhpcy5wdWxsSGVpZ2h0KTtcblx0XHRzLnN0YXJ0KCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQGZpcmVzIGVueW8uUHVsbGRvd25MaXN0I29uUHVsbFN0YXJ0XG5cdCogQHByaXZhdGVcblx0Ki9cblx0cHVsbFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRQdWxsaW5nKCk7XG5cdFx0dGhpcy5wdWxseS5zZXRTaG93aW5nKGZhbHNlKTtcblx0XHR0aGlzLiQucHVsbGVyLnNldFNob3dpbmcodHJ1ZSk7XG5cdFx0dGhpcy5kb1B1bGxTdGFydCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBmaXJlcyBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRQdWxsZWQoKTtcblx0XHR0aGlzLmRvUHVsbCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBmaXJlcyBlbnlvLlB1bGxkb3duTGlzdCNvblB1bGxDYW5jZWxcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRwdWxsQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5zZXRQdWxsaW5nKCk7XG5cdFx0dGhpcy5kb1B1bGxDYW5jZWwoKTtcblx0fSxcblxuXHQvKipcblx0KiBAZmlyZXMgZW55by5QdWxsZG93bkxpc3Qjb25QdWxsUmVsZWFzZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1bGxSZWxlYXNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy4kLnB1bGxlci5zZXRTaG93aW5nKGZhbHNlKTtcblx0XHR0aGlzLnB1bGx5LnNldFNob3dpbmcodHJ1ZSk7XG5cdFx0dGhpcy5kb1B1bGxSZWxlYXNlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0c2V0UHVsbGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5wdWxsZXIuc2V0VGV4dCh0aGlzLnB1bGxpbmdNZXNzYWdlKTtcblx0XHR0aGlzLiQucHVsbGVyLnNldEljb25DbGFzcyh0aGlzLnB1bGxpbmdJY29uQ2xhc3MpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHNldFB1bGxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5wdWxsZXIuc2V0VGV4dCh0aGlzLnB1bGxlZE1lc3NhZ2UpO1xuXHRcdHRoaXMuJC5wdWxsZXIuc2V0SWNvbkNsYXNzKHRoaXMucHVsbGVkSWNvbkNsYXNzKTtcblx0fVxufSk7XG5cblB1bGxkb3duTGlzdC5QdWxsZXIgPSBQdWxsZXI7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL1RvdWNoU2Nyb2xsU3RyYXRlZ3lcIjo1MyxcIi4uLy4uLy4uL2VueW8vbGliL1RyYW5zbGF0ZVNjcm9sbFN0cmF0ZWd5XCI6NTQsXCIuLi8uLi8uLi9lbnlvL2xpYi9kb21cIjo1OCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2VueW8vbGliL3BsYXRmb3JtXCI6NzEsXCIuLi9MaXN0XCI6OTUsXCIuL1B1bGxlclwiOjEwMX1dLDExOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKTtcblxudmFyXG5cdExpc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3QnKTtcblxudmFyXG5cdG5hbWVzID0gcmVxdWlyZSgnLi9OYW1lR2VuZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5MaXN0QmFzaWNTYW1wbGUnLFxuXHRjbGFzc2VzOiAnbGlzdC1zYW1wbGUgZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICdsaXN0Jywga2luZDogTGlzdCwgY291bnQ6IDIwMDAwLCBtdWx0aVNlbGVjdDogZmFsc2UsIGNsYXNzZXM6ICdlbnlvLWZpdCBsaXN0LXNhbXBsZS1saXN0Jywgb25TZXR1cEl0ZW06ICdzZXR1cEl0ZW0nLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ2l0ZW0nLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtaXRlbSBlbnlvLWJvcmRlci1ib3gnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAnaW5kZXgnLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtaW5kZXgnfSxcblx0XHRcdFx0e25hbWU6ICduYW1lJ31cblx0XHRcdF19XG5cdFx0XX1cblx0XSxcblx0bmFtZXM6IFtdLFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uKHNlbmRlciwgZXZlbnQpIHtcblx0XHQvLyB0aGlzIGlzIHRoZSByb3cgd2UncmUgc2V0dGluZyB1cFxuXHRcdHZhciBpID0gZXZlbnQuaW5kZXg7XG5cdFx0Ly8gbWFrZSBzb21lIG1vY2sgZGF0YSBpZiB3ZSBoYXZlIG5vbmUgZm9yIHRoaXMgcm93XG5cdFx0aWYgKCF0aGlzLm5hbWVzW2ldKSB7XG5cdFx0XHR0aGlzLm5hbWVzW2ldID0gbmFtZXMubWFrZU5hbWUoNSwgMTAsICcnLCAnJyk7XG5cdFx0fVxuXHRcdHZhciBuID0gdGhpcy5uYW1lc1tpXTtcblx0XHR2YXIgbmkgPSAoJzAwMDAwMDAwJyArIGkpLnNsaWNlKC03KTtcblx0XHQvLyBhcHBseSBzZWxlY3Rpb24gc3R5bGUgaWYgc2VuZGVyICh0aGUgbGlzdCkgaW5kaWNhdGVzIHRoYXQgdGhpcyByb3cgaXMgc2VsZWN0ZWQuXG5cdFx0dGhpcy4kLml0ZW0uYWRkUmVtb3ZlQ2xhc3MoJ2xpc3Qtc2FtcGxlLXNlbGVjdGVkJywgc2VuZGVyLmlzU2VsZWN0ZWQoaSkpO1xuXHRcdHRoaXMuJC5uYW1lLnNldENvbnRlbnQobik7XG5cdFx0dGhpcy4kLmluZGV4LnNldENvbnRlbnQobmkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9MaXN0XCI6OTUsXCIuL05hbWVHZW5lcmF0b3JcIjoxMjV9XSwxMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdGpvYiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2pvYicpLFxuXHR1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL3V0aWxzJyksXG5cdEJ1dHRvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0J1dHRvbicpLFxuXHRDaGVja2JveCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0NoZWNrYm94JyksXG5cdEltYWdlID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW1hZ2UnKSxcblx0SW5wdXQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dCcpLFxuXHRQb3B1cCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL1BvcHVwJyk7XG5cbnZhclxuXHRGaXR0YWJsZUNvbHVtbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1ucycpLFxuXHRGaXR0YWJsZVJvd3MgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93cycpLFxuXHRMaXN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9MaXN0Jyk7XG5cbnZhclxuXHRuYW1lcyA9IHJlcXVpcmUoJy4vTmFtZUdlbmVyYXRvcicpO1xuXG5cbi8vIEl0J3MgY29udmVuaWVudCB0byBjcmVhdGUgYSBraW5kIGZvciB0aGUgaXRlbSB3ZSdsbCByZW5kZXIgaW4gdGhlIGNvbnRhY3RzIGxpc3QuXG52YXIgQ29udGFjdEl0ZW0gPSBraW5kKHtcblx0ZXZlbnRzOiB7XG5cdFx0b25SZW1vdmU6ICcnXG5cdH0sXG5cdHB1Ymxpc2hlZDoge1xuXHRcdGltcG9ydGFuY2U6IDBcblx0fSxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnYXZhdGFyJywga2luZDogSW1hZ2UsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1hdmF0YXInfSxcblx0XHR7Y29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICduYW1lJ30sXG5cdFx0XHR7bmFtZTogJ3RpdGxlJywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWNvbnRhY3RzLWRlc2NyaXB0aW9uJ30sXG5cdFx0XHR7Y29udGVudDogJyg0MTUpIDcxMS0xMjM0JywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWNvbnRhY3RzLWRlc2NyaXB0aW9uJ31cblx0XHRdfSxcblx0XHR7bmFtZTogJ3JlbW92ZScsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1yZW1vdmUtYnV0dG9uJywgb250YXA6ICdyZW1vdmVUYXAnfVxuXHRdLFxuXHRzZXRDb250YWN0OiBmdW5jdGlvbiAoY29udGFjdCkge1xuXHRcdHRoaXMuJC5uYW1lLnNldENvbnRlbnQoY29udGFjdC5uYW1lKTtcblx0XHR0aGlzLiQuYXZhdGFyLnNldFNyYyhjb250YWN0LmF2YXRhcik7XG5cdFx0dGhpcy4kLnRpdGxlLnNldENvbnRlbnQoY29udGFjdC50aXRsZSk7XG5cdH0sXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmFkZFJlbW92ZUNsYXNzKCdsaXN0LXNhbXBsZS1jb250YWN0cy1pdGVtLXNlbGVjdGVkJywgc2VsZWN0ZWQpO1xuXHRcdHRoaXMuJC5yZW1vdmUuYXBwbHlTdHlsZSgnZGlzcGxheScsIHNlbGVjdGVkID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZScpO1xuXHR9LFxuXHRyZW5kZXJJbXBvcnRhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0c3dpdGNoKHRoaXMuaW1wb3J0YW5jZSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHRoaXMuJC5pbXBvcnRhbmNlLnNldENvbnRlbnQoJ25vdCBpbXBvcnRhbnQnKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgLTE6XG5cdFx0XHR0aGlzLiQuaW1wb3J0YW5jZS5zZXRDb250ZW50KCdpbXBvcnRhbnQnKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgLTI6XG5cdFx0XHR0aGlzLiQuaW1wb3J0YW5jZS5zZXRDb250ZW50KCd2ZXJ5IGltcG9ydGFudCcpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHdpbmRvdy5hbGVydCh0aGlzLmltcG9ydGFuY2UrJyAtIHdvd3plcicpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXHRyZW1vdmVUYXA6IGZ1bmN0aW9uIChpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHRoaXMuZG9SZW1vdmUoe2luZGV4OiBpbkV2ZW50LmluZGV4fSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuTGlzdENvbnRhY3RzU2FtcGxlJyxcblx0a2luZDogRml0dGFibGVSb3dzLFxuXHRjbGFzc2VzOiAnbGlzdC1zYW1wbGUtY29udGFjdHMgZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e1xuXHRcdFx0a2luZDogRml0dGFibGVDb2x1bW5zLFxuXHRcdFx0Y2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsXG5cdFx0XHRzdHlsZTogJ2hlaWdodDogNTVweDsnLFxuXHRcdFx0Y29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnc2V0dXAnLCBvbnRhcDogJ3Nob3dTZXR1cFBvcHVwJ30sXG5cdFx0XHRcdHt0YWc6ICdsYWJlbCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ25ld0NvbnRhY3RJbnB1dCcsIGtpbmQ6IElucHV0LCB2YWx1ZTogJ0ZyYW5raWUgRnUnfVxuXHRcdFx0XHRdfSxcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ25ldyBjb250YWN0Jywgb250YXA6ICdhZGRJdGVtJ30sXG5cdFx0XHRcdHtmaXQ6IHRydWV9LFxuXHRcdFx0XHR7dGFnOiAnbGFiZWwnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e2tpbmQ6IElucHV0LCBwbGFjZWhvbGRlcjogJ1NlYXJjaC4uLicsIHN0eWxlOiAnd2lkdGg6IDE0MHB4OycsIG9uaW5wdXQ6ICdzZWFyY2hJbnB1dENoYW5nZSd9LFxuXHRcdFx0XHRcdHtraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NlYXJjaC1pbnB1dC1zZWFyY2gucG5nJywgc3R5bGU6ICd3aWR0aDogMjBweDsnfVxuXHRcdFx0XHRdfSxcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ3JlbW92ZSBzZWxlY3RlZCcsIG9udGFwOiAncmVtb3ZlU2VsZWN0ZWQnfVxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0a2luZDogTGlzdCxcblx0XHRcdGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1saXN0IGVueW8tdW5zZWxlY3RhYmxlJyxcblx0XHRcdGZpdDogdHJ1ZSxcblx0XHRcdG11bHRpU2VsZWN0OiB0cnVlLFxuXHRcdFx0b25TZXR1cEl0ZW06ICdzZXR1cEl0ZW0nLFxuXHRcdFx0Y29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ2RpdmlkZXInLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtY29udGFjdHMtZGl2aWRlcid9LFxuXHRcdFx0XHR7bmFtZTogJ2l0ZW0nLCBraW5kOiBDb250YWN0SXRlbSwgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWNvbnRhY3RzLWl0ZW0gZW55by1ib3JkZXItYm94Jywgb25SZW1vdmU6ICdyZW1vdmVUYXAnfVxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogJ3BvcHVwJyxcblx0XHRcdGtpbmQ6IFBvcHVwLFxuXHRcdFx0bW9kYWw6IHRydWUsXG5cdFx0XHRjZW50ZXJlZDogdHJ1ZSxcblx0XHRcdGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1wb3B1cCcsXG5cdFx0XHRjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0XHR7c3R5bGU6ICdkaXNwbGF5OmlubGluZS1ibG9jaycsIGNvbXBvbmVudHM6W1xuXHRcdFx0XHRcdFx0XHR7Y29udGVudDogJ2NvdW50OicsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1sYWJlbCd9LFxuXHRcdFx0XHRcdFx0XHR7bmFtZTogJ2NvdW50T3V0cHV0Jywga2luZDogSW5wdXQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMjAwLCBvbmNoYW5nZTogJ2NvdW50Q2hhbmdpbmcnfVxuXHRcdFx0XHRcdFx0XX1cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0XHR7Y29udGVudDogJ3Jvd3NQZXJQYWdlOicsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1sYWJlbCd9LFxuXHRcdFx0XHRcdFx0e25hbWU6ICdyb3dzUGVyUGFnZU91dHB1dCcsIGtpbmQ6IElucHV0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDUwLCBvbmNoYW5nZTogJ3Jvd3NDaGFuZ2luZyd9XG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tcG9uZW50czogW1xuXHRcdFx0XHRcdFx0e2NvbnRlbnQ6ICdoaWRlIGRpdmlkZXI6JywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWNvbnRhY3RzLWxhYmVsJ30sXG5cdFx0XHRcdFx0XHR7bmFtZTogJ2hpZGVEaXZpZGVyQ2hlY2tib3gnLCBraW5kOiBDaGVja2JveH1cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAncG9wdWxhdGUgbGlzdCcsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1jb250YWN0cy1wb3B1bGF0ZS1idXR0b24nLCBvbnRhcDogJ3BvcHVsYXRlTGlzdCd9XG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fVxuXHRdLFxuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnBvcHVsYXRlTGlzdCgpO1xuXHRcdH07XG5cdH0pLFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uIChpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZmlsdGVyID8gdGhpcy5maWx0ZXJlZCA6IHRoaXMuZGI7XG5cdFx0dmFyIGl0ZW0gPSBkYXRhW2ldO1xuXHRcdC8vIGNvbnRlbnRcblx0XHR0aGlzLiQuaXRlbS5zZXRDb250YWN0KGl0ZW0pO1xuXHRcdC8vIHNlbGVjdGlvblxuXHRcdHRoaXMuJC5pdGVtLnNldFNlbGVjdGVkKGluU2VuZGVyLmlzU2VsZWN0ZWQoaSkpO1xuXHRcdC8vIGRpdmlkZXJcblx0XHRpZiAoIXRoaXMuaGlkZURpdmlkZXIpIHtcblx0XHRcdHZhciBkID0gaXRlbS5uYW1lWzBdO1xuXHRcdFx0dmFyIHByZXYgPSBkYXRhW2ktMV07XG5cdFx0XHR2YXIgc2hvd2QgPSBkICE9IChwcmV2ICYmIHByZXYubmFtZVswXSk7XG5cdFx0XHR0aGlzLiQuZGl2aWRlci5zZXRDb250ZW50KGQpO1xuXHRcdFx0dGhpcy4kLmRpdmlkZXIuY2FuR2VuZXJhdGUgPSBzaG93ZDtcblx0XHRcdHRoaXMuJC5pdGVtLmFwcGx5U3R5bGUoJ2JvcmRlci10b3AnLCBzaG93ZCA/ICdub25lJyA6IG51bGwpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0cmVmcmVzaExpc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5maWx0ZXIpIHtcblx0XHRcdHRoaXMuZmlsdGVyZWQgPSB0aGlzLmdlbmVyYXRlRmlsdGVyZWREYXRhKHRoaXMuZmlsdGVyKTtcblx0XHRcdHRoaXMuJC5saXN0LnNldENvdW50KHRoaXMuZmlsdGVyZWQubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kLmxpc3Quc2V0Q291bnQodGhpcy5kYi5sZW5ndGgpO1xuXHRcdH1cblx0XHR0aGlzLiQubGlzdC5yZWZyZXNoKCk7XG5cdH0sXG5cdGFkZEl0ZW06IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuZ2VuZXJhdGVJdGVtKHV0aWxzLmNhcCh0aGlzLiQubmV3Q29udGFjdElucHV0LmdldFZhbHVlKCkpKTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICh2YXIgZGk7IChkaT10aGlzLmRiW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAoZGkubmFtZSA+IGl0ZW0ubmFtZSkge1xuXHRcdFx0XHR0aGlzLmRiLnNwbGljZShpLCAwLCBpdGVtKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlmIHdlIGhpdCBlbmQgb2YgZm9yLWxvb3AsIGFkZCB0byBlbmQgb2YgbGlzdFxuXHRcdGlmICghZGkpIHtcblx0XHRcdHRoaXMuZGIucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0dGhpcy5yZWZyZXNoTGlzdCgpO1xuXHRcdHRoaXMuJC5saXN0LnNjcm9sbFRvUm93KGkpO1xuXHR9LFxuXHRyZW1vdmVJdGVtOiBmdW5jdGlvbiAoaW5JbmRleCkge1xuXHRcdHRoaXMuX3JlbW92ZUl0ZW0oaW5JbmRleCk7XG5cdFx0dGhpcy4kLmxpc3QuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlKGluSW5kZXgpO1xuXHRcdHRoaXMucmVmcmVzaExpc3QoKTtcblx0fSxcblx0X3JlbW92ZUl0ZW06IGZ1bmN0aW9uIChpbkluZGV4KSB7XG5cdFx0dmFyIGkgPSB0aGlzLmZpbHRlciA/IHRoaXMuZmlsdGVyZWRbaW5JbmRleF0uZGJJbmRleCA6IGluSW5kZXg7XG5cdFx0dGhpcy5kYi5zcGxpY2UoaSwgMSk7XG5cdH0sXG5cdHJlbW92ZVRhcDogZnVuY3Rpb24gKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dGhpcy5yZW1vdmVJdGVtKGluRXZlbnQuaW5kZXgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRyZW1vdmVTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGdldCBzZWxlY3RlZCBpdGVtcywgc29ydCBudW1lcmljYWxseSBpbiBkZWNlbmRpbmcgb3JkZXJcblx0XHR2YXIgc2VsZWN0ZWQgPSB1dGlscy5rZXlzKHRoaXMuJC5saXN0LmdldFNlbGVjdGlvbigpLmdldFNlbGVjdGVkKCkpO1xuXHRcdHNlbGVjdGVkLnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYi1hOyB9KTtcblx0XHQvLyByZW1vdmUgaXRlbXMgb25lLWJ5LW9uZSwgc3RhcnRpbmcgd2l0aCBsYXN0IGluIHRoZSBsaXN0XG5cdFx0Zm9yICh2YXIgaT0wOyBpIDwgc2VsZWN0ZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuX3JlbW92ZUl0ZW0oc2VsZWN0ZWRbaV0pO1xuXHRcdH1cblx0XHQvLyBjbGVhciBzZWxlY3Rpb24sIHNpbmNlIGFsbCBzZWxlY3RlZCBpdGVtcyBhcmUgbm93IGdvbmVcblx0XHR0aGlzLiQubGlzdC5nZXRTZWxlY3Rpb24oKS5jbGVhcigpO1xuXHRcdC8vIHJlLXJlbmRlciBsaXN0IGluIGN1cnJlbnQgcG9zaXRpb25cblx0XHR0aGlzLnJlZnJlc2hMaXN0KCk7XG5cdH0sXG5cdHBvcHVsYXRlTGlzdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5wb3B1cC5oaWRlKCk7XG5cdFx0dGhpcy5jcmVhdGVEYih0aGlzLiQuY291bnRPdXRwdXQuZ2V0VmFsdWUoKSk7XG5cdFx0dGhpcy4kLmxpc3Quc2V0Q291bnQodGhpcy5kYi5sZW5ndGgpO1xuXHRcdHRoaXMuJC5saXN0LnNldFJvd3NQZXJQYWdlKHRoaXMuJC5yb3dzUGVyUGFnZU91dHB1dC5nZXRWYWx1ZSgpKTtcblx0XHQvL1xuXHRcdHRoaXMuaGlkZURpdmlkZXIgPSB0aGlzLiQuaGlkZURpdmlkZXJDaGVja2JveC5nZXRWYWx1ZSgpO1xuXHRcdC8vdGhpcy4kLmRpdmlkZXIuY2FuR2VuZXJhdGUgPSAhdGhpcy5oaWRlRGl2aWRlcjtcblx0XHQvL1xuXHRcdHRoaXMuJC5saXN0LnJlc2V0KCk7XG5cdH0sXG5cdGNyZWF0ZURiOiBmdW5jdGlvbiAoaW5Db3VudCkge1xuXHRcdHRoaXMuZGIgPSBbXTtcblx0XHRmb3IgKHZhciBpPTA7IGk8aW5Db3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLmRiLnB1c2godGhpcy5nZW5lcmF0ZUl0ZW0obmFtZXMubWFrZU5hbWUoNCwgNikgKyAnICcgKyBuYW1lcy5tYWtlTmFtZSg1LCAxMCkpKTtcblx0XHR9XG5cdFx0dGhpcy5zb3J0RGIoKTtcblx0fSxcblx0Z2VuZXJhdGVJdGVtOiBmdW5jdGlvbiAoaW5OYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IGluTmFtZSxcblx0XHRcdGF2YXRhcjogJ2Fzc2V0cy9hdmF0YXJzLycgKyBhdmF0YXJzW3V0aWxzLmlyYW5kKGF2YXRhcnMubGVuZ3RoKV0sXG5cdFx0XHR0aXRsZTogdGl0bGVzW3V0aWxzLmlyYW5kKHRpdGxlcy5sZW5ndGgpXSxcblx0XHRcdGltcG9ydGFuY2U6IDBcblx0XHR9O1xuXHR9LFxuXHRzb3J0RGI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmRiLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdGlmIChhLm5hbWUgPCBiLm5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoYS5uYW1lID4gYi5uYW1lKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRzaG93U2V0dXBQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuJC5wb3B1cC5zaG93KCk7XG5cdH0sXG5cdHNlYXJjaElucHV0Q2hhbmdlOiBmdW5jdGlvbiAoaW5TZW5kZXIpIHtcblx0XHRqb2IodGhpcy5pZCArICc6c2VhcmNoJywgdGhpcy5iaW5kU2FmZWx5KCdmaWx0ZXJMaXN0JywgaW5TZW5kZXIuZ2V0VmFsdWUoKSksIDIwMCk7XG5cdH0sXG5cdGZpbHRlckxpc3Q6IGZ1bmN0aW9uIChpbkZpbHRlcikge1xuXHRcdGlmIChpbkZpbHRlciAhPSB0aGlzLmZpbHRlcikge1xuXHRcdFx0dGhpcy5maWx0ZXIgPSBpbkZpbHRlcjtcblx0XHRcdHRoaXMuZmlsdGVyZWQgPSB0aGlzLmdlbmVyYXRlRmlsdGVyZWREYXRhKGluRmlsdGVyKTtcblx0XHRcdHRoaXMuJC5saXN0LnNldENvdW50KHRoaXMuZmlsdGVyZWQubGVuZ3RoKTtcblx0XHRcdHRoaXMuJC5saXN0LnJlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXHRnZW5lcmF0ZUZpbHRlcmVkRGF0YTogZnVuY3Rpb24gKGluRmlsdGVyKSB7XG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cCgnXicgKyBpbkZpbHRlciwgJ2knKTtcblx0XHR2YXIgciA9IFtdO1xuXHRcdGZvciAodmFyIGk9MCwgZDsgKGQ9dGhpcy5kYltpXSk7IGkrKykge1xuXHRcdFx0aWYgKGQubmFtZS5tYXRjaChyZSkpIHtcblx0XHRcdFx0ZC5kYkluZGV4ID0gaTtcblx0XHRcdFx0ci5wdXNoKGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcjtcblx0fSxcblx0Y291bnRDaGFuZ2luZzogZnVuY3Rpb24gKGluU2VuZGVyLCBpbkV2ZW50KXtcblx0XHR0aGlzLiQuY291bnRPdXRwdXQuc2V0Q29udGVudChNYXRoLnJvdW5kKGluU2VuZGVyLmdldFZhbHVlKCkpICogNTApO1xuXHR9LFxuXHRyb3dzQ2hhbmdpbmc6IGZ1bmN0aW9uIChpblNlbmRlciwgaW5FdmVudCl7XG5cdFx0dGhpcy4kLnJvd3NQZXJQYWdlT3V0cHV0LnNldENvbnRlbnQoTWF0aC5yb3VuZChpblNlbmRlci5nZXRWYWx1ZSgpKSAqIDUpO1xuXHR9XG59KTtcblxudmFyIGF2YXRhcnMgPSBbXG5cdCdhbmdlbC5wbmcnLFxuXHQnYXN0cm9sb2dlci5wbmcnLFxuXHQnYXRobGV0ZS5wbmcnLFxuXHQnYmFieS5wbmcnLFxuXHQnY2xvd24ucG5nJyxcblx0J2RldmlsLnBuZycsXG5cdCdkb2N0b3IucG5nJyxcblx0J2R1ZGUucG5nJyxcblx0J2R1ZGUyLnBuZycsXG5cdCdkdWRlMy5wbmcnLFxuXHQnZHVkZTQucG5nJyxcblx0J2R1ZGU1LnBuZycsXG5cdCdkdWRlNi5wbmcnXG5dO1xudmFyIHRpdGxlcyA9IFtcblx0J1JlZ2lvbmFsIERhdGEgUHJvZHVjZXInLFxuXHQnSW50ZXJuYWwgTWFya2V0cyBBZG1pbmlzdHJhdG9yJyxcblx0J0NlbnRyYWwgU29sdXRpb25zIFByb2R1Y2VyJyxcblx0J0R5bmFtaWMgUHJvZ3JhbSBFeGVjdXRpdmUnLFxuXHQnRGlyZWN0IENvbmZpZ3VyYXRpb24gRXhlY3V0aXZlJyxcblx0J0ludGVybmF0aW9uYWwgTWFya2V0aW5nIEFzc2lzdGFudCcsXG5cdCdEaXN0cmljdCBSZXNlYXJjaCBDb25zdWx0YW50Jyxcblx0J0xlYWQgSW50cmFuZXQgQ29vcmRpbmF0b3InLFxuXHQnQ2VudHJhbCBBY2NvdW50YWJpbGl0eSBEaXJlY3RvcicsXG5cdCdQcm9kdWN0IFdlYiBBc3Npc3RhbnQnXG5dO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b25cIjoxMCxcIi4uLy4uLy4uL2VueW8vbGliL0NoZWNrYm94XCI6MTEsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZVwiOjIzLFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL1BvcHVwXCI6MzcsXCIuLi8uLi8uLi9lbnlvL2xpYi9qb2JcIjo2MyxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2VueW8vbGliL3V0aWxzXCI6NzUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1uc1wiOjg1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3NcIjo4OCxcIi4uLy4uLy4uL2xheW91dC9saWIvTGlzdFwiOjk1LFwiLi9OYW1lR2VuZXJhdG9yXCI6MTI1fV0sMTIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKSxcblx0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ29tcG9uZW50JyksXG5cdEltYWdlID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW1hZ2UnKSxcblx0SW5wdXQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dCcpLFxuXHRKc29ucFJlcXVlc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9Kc29ucCcpO1xuXG52YXJcblx0Rml0dGFibGVDb2x1bW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnMnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0TGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvTGlzdCcpO1xuXG4vLyBBIHNpbXBsZSBjb21wb25lbnQgdG8gZG8gYSBGbGlja3Igc2VhcmNoLlxudmFyIExpc3RIb3Jpem9udGFsRmxpY2tyU2VhcmNoID0ga2luZCh7XG5cdGtpbmQ6IENvbXBvbmVudCxcblx0cHVibGlzaGVkOiB7XG5cdFx0c2VhcmNoVGV4dDogJydcblx0fSxcblx0ZXZlbnRzOiB7XG5cdFx0b25SZXN1bHRzOiAnJ1xuXHR9LFxuXHR1cmw6ICdodHRwczovL2FwaS5mbGlja3IuY29tL3NlcnZpY2VzL3Jlc3QvJyxcblx0cGFnZVNpemU6IDIwMCxcblx0YXBpX2tleTogJzJhMjFiNDZlNThkMjA3ZTQ4ODhlMWVjZTBjYjE0OWE1Jyxcblx0c2VhcmNoOiBmdW5jdGlvbihpblNlYXJjaFRleHQsIGluUGFnZSkge1xuXHRcdHRoaXMuc2VhcmNoVGV4dCA9IGluU2VhcmNoVGV4dCB8fCB0aGlzLnNlYXJjaFRleHQ7XG5cdFx0dmFyIGkgPSAoaW5QYWdlIHx8IDApICogdGhpcy5wYWdlU2l6ZTtcblx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0bWV0aG9kOiAnZmxpY2tyLnBob3Rvcy5zZWFyY2gnLFxuXHRcdFx0Zm9ybWF0OiAnanNvbicsXG5cdFx0XHRhcGlfa2V5OiB0aGlzLmFwaV9rZXksXG5cdFx0XHRwZXJfcGFnZTogdGhpcy5wYWdlU2l6ZSxcblx0XHRcdHBhZ2U6IGksXG5cdFx0XHR0ZXh0OiB0aGlzLnNlYXJjaFRleHRcblx0XHR9O1xuXHRcdHJldHVybiBuZXcgSnNvbnBSZXF1ZXN0KHt1cmw6IHRoaXMudXJsLCBjYWxsYmFja05hbWU6ICdqc29uY2FsbGJhY2snfSlcblx0XHRcdC5yZXNwb25zZSh0aGlzLCAncHJvY2Vzc1Jlc3BvbnNlJylcblx0XHRcdC5nbyhwYXJhbXMpO1xuXHR9LFxuXHRwcm9jZXNzUmVzcG9uc2U6IGZ1bmN0aW9uKGluU2VuZGVyLCBpblJlc3BvbnNlKSB7XG5cdFx0dmFyIHBob3RvcyA9IGluUmVzcG9uc2UucGhvdG9zID8gaW5SZXNwb25zZS5waG90b3MucGhvdG8gfHwgW10gOiBbXTtcblx0XHRmb3IgKHZhciBpPTAsIHA7IChwPXBob3Rvc1tpXSk7IGkrKykge1xuXHRcdFx0dmFyIHVybHByZWZpeCA9ICdodHRwOi8vZmFybScgKyBwLmZhcm0gKyAnLnN0YXRpYy5mbGlja3IuY29tLycgKyBwLnNlcnZlciArICcvJyArIHAuaWQgKyAnXycgKyBwLnNlY3JldDtcblx0XHRcdHAudGh1bWJuYWlsID0gdXJscHJlZml4ICsgJ19zLmpwZyc7XG5cdFx0XHRwLm9yaWdpbmFsID0gdXJscHJlZml4ICsgJy5qcGcnO1xuXHRcdH1cblx0XHR0aGlzLmRvUmVzdWx0cyhwaG90b3MpO1xuXHRcdHJldHVybiBwaG90b3M7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuTGlzdEhvcml6b250YWxGbGlja3JTYW1wbGUnLFxuXHRjbGFzc2VzOiAnZW55by11bnNlbGVjdGFibGUgZW55by1maXQgbGlzdC1zYW1wbGUtZmxpY2tyJyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBGaXR0YWJsZVJvd3MsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCB0YWc6ICdsYWJlbCcsIHN0eWxlOiAnd2lkdGg6IDkwJTsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e25hbWU6ICdzZWFyY2hJbnB1dCcsIGZpdDogdHJ1ZSwga2luZDogSW5wdXQsIHZhbHVlOiAnSmFwYW4nLCBvbmNoYW5nZTogJ3NlYXJjaCd9LFxuXHRcdFx0XHRcdHtraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NlYXJjaC1pbnB1dC1zZWFyY2gucG5nJywgc3R5bGU6ICd3aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4Oyd9XG5cdFx0XHRcdF19LFxuXHRcdFx0XHR7bmFtZTogJ3NlYXJjaFNwaW5uZXInLCBraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NwaW5uZXIuZ2lmJywgc2hvd2luZzogZmFsc2V9XG5cdFx0XHRdfSxcblx0XHRcdHtraW5kOiBMaXN0LCBvcmllbnQ6ICdoJywgZml0OiB0cnVlLCBvblNldHVwSXRlbTogJ3NldHVwSXRlbScsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdpdGVtJywgc3R5bGU6ICdwYWRkaW5nOiAxMHB4OycsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1mbGlja3ItaXRlbSBlbnlvLWJvcmRlci1ib3gnLCBvbnRhcDogJ2l0ZW1UYXAnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e25hbWU6ICd0aHVtYm5haWwnLCBraW5kOiBJbWFnZSwgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWZsaWNrci10aHVtYm5haWwnfVxuXHRcdFx0XHRdfSxcblx0XHRcdFx0e25hbWU6ICdtb3JlJywgc3R5bGU6ICdwYWRkaW5nOiAxMHB4O3Bvc2l0aW9uOmFic29sdXRlJywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWZsaWNrci1tb3JlIGVueW8tYm9yZGVyLWJveCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnbW9yZScsICBvbnRhcDogJ21vcmUnfSxcblx0XHRcdFx0XHR7bmFtZTogJ21vcmVTcGlubmVyJywga2luZDogSW1hZ2UsIHNyYzogJ2Fzc2V0cy9zcGlubmVyLmdpZicsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1mbGlja3ItbW9yZS1zcGlubmVyJ31cblx0XHRcdFx0XX1cblx0XHRcdF19XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IExpc3RIb3Jpem9udGFsRmxpY2tyU2VhcmNoLCBuYW1lOiAnZmxpY2tyU2VhcmNoJywgb25SZXN1bHRzOiAnc2VhcmNoUmVzdWx0cyd9XG5cdF0sXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnNlYXJjaCgpO1xuXHRcdH07XG5cdH0pLFxuXHRzZWFyY2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2VhcmNoVGV4dCA9IHRoaXMuJC5zZWFyY2hJbnB1dC5nZXRWYWx1ZSgpO1xuXHRcdHRoaXMucGFnZSA9IDA7XG5cdFx0dGhpcy5yZXN1bHRzID0gW107XG5cdFx0dGhpcy4kLnNlYXJjaFNwaW5uZXIuc2hvdygpO1xuXHRcdHRoaXMuJC5mbGlja3JTZWFyY2guc2VhcmNoKHRoaXMuc2VhcmNoVGV4dCk7XG5cdH0sXG5cdHNlYXJjaFJlc3VsdHM6IGZ1bmN0aW9uKGluU2VuZGVyLCBpblJlc3VsdHMpIHtcblx0XHR0aGlzLiQuc2VhcmNoU3Bpbm5lci5oaWRlKCk7XG5cdFx0dGhpcy4kLm1vcmVTcGlubmVyLmhpZGUoKTtcblx0XHR0aGlzLnJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuY29uY2F0KGluUmVzdWx0cyk7XG5cdFx0dGhpcy4kLmxpc3Quc2V0Q291bnQodGhpcy5yZXN1bHRzLmxlbmd0aCk7XG5cdFx0aWYgKHRoaXMucGFnZSA9PT0gMCkge1xuXHRcdFx0dGhpcy4kLmxpc3QucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4kLmxpc3QucmVmcmVzaCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0c2V0dXBJdGVtOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHR2YXIgaXRlbSA9IHRoaXMucmVzdWx0c1tpXTtcblx0XHR0aGlzLiQuaXRlbS5hZGRSZW1vdmVDbGFzcygnb255eC1zZWxlY3RlZCcsIGluU2VuZGVyLmlzU2VsZWN0ZWQoaW5FdmVudC5pbmRleCkpO1xuXHRcdHRoaXMuJC50aHVtYm5haWwuc2V0U3JjKGl0ZW0udGh1bWJuYWlsKTtcblx0XHR0aGlzLiQubW9yZS5jYW5HZW5lcmF0ZSA9ICF0aGlzLnJlc3VsdHNbaSsxXTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0bW9yZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGFnZSsrO1xuXHRcdHRoaXMuJC5tb3JlU3Bpbm5lci5zaG93KCk7XG4gICAgICAgIHRoaXMuJC5mbGlja3JTZWFyY2guc2VhcmNoKHRoaXMuc2VhcmNoVGV4dCwgdGhpcy5wYWdlKTtcblx0fSxcblx0c2hvd0xpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0SW5kZXgoMCk7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b25cIjoxMCxcIi4uLy4uLy4uL2VueW8vbGliL0NvbXBvbmVudFwiOjEzLFwiLi4vLi4vLi4vZW55by9saWIvSW1hZ2VcIjoyMyxcIi4uLy4uLy4uL2VueW8vbGliL0lucHV0XCI6MjQsXCIuLi8uLi8uLi9lbnlvL2xpYi9Kc29ucFwiOjI1LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnNcIjo4NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3RcIjo5NX1dLDEyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi91dGlscycpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKSxcblx0SW5wdXQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dCcpO1xuXG52YXJcblx0Rml0dGFibGVDb2x1bW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnMnKSxcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0TGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvTGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuTGlzdExhbmd1YWdlc1NhbXBsZScsXG5cdGtpbmQ6IEZpdHRhYmxlUm93cyxcblx0Y2xhc3NlczogJ2xpc3Qtc2FtcGxlLWxhbmd1YWdlIGVueW8tZml0Jyxcblx0ZGF0YTogW10sXG5cdGxhbmd1YWdlczoge1xuXHRcdEVuZ2xpc2g6IFsnT25lJywgICdUd28nLCAgJ1RocmVlJywgJ0ZvdXInLCAgICAnRml2ZScsICAgICdTaXgnLCAgICdTZXZlbicsICAnRWlnaHQnLCAnTmluZScsICAnVGVuJ10sXG5cdFx0SXRhbGlhbjogWydVbm8nLCAgJ0R1ZScsICAnVHJlJywgICAnUXVhdHRybycsICdDaW5xdWUnLCAgJ1NlaScsICAgJ1NldHRlJywgICdPdHRvJywgICdOb3ZlJywgICdEaWVjaSddLFxuXHRcdFNwYW5pc2g6IFsnVW5vJywgICdEb3MnLCAgJ1RyZXMnLCAgJ0N1YXRybycsICAnQ2luY28nLCAgICdTZWlzJywgICdTaWV0ZScsICAnT2NobycsICAnTnVldmUnLCAnRGlleiddLFxuXHRcdEdlcm1hbjogIFsnRWlucycsICdad2VpJywgJ0RyZWknLCAgJ1ZpZXInLCAgICAnRlxceEZDbmYnLCAnU2VjaHMnLCAnU2llYmVuJywgJ0FjaHQnLCAgJ05ldW4nLCAgJ1plaG4nXSxcblx0XHRGcmVuY2g6ICBbJ1VuJywgICAnRGV1eCcsICdUcm9pcycsICdRdWF0cmUnLCAgJ0NpbnEnLCAgICAnU2l4JywgICAnU2VwdCcsICAgJ0h1aXQnLCAgJ05ldWYnLCAgJ0RpeCddXG5cdH0sXG5cdGNvbXBvbmVudHM6IFtcblx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgc3R5bGU6ICdoZWlnaHQ6IDU1cHg7JywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbnRlbnQ6ICdSb3dzOid9LFxuXHRcdFx0e3RhZzogJ2xhYmVsJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogSW5wdXQsIHZhbHVlOiAnMTAnLCBuYW1lOiAnbnVtUm93cycgfVxuXHRcdFx0XX0sXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnUmVwb3B1bGF0ZScsIG9udGFwOiAncG9wdWxhdGVMaXN0J31cblx0XHRdfSxcblx0XHR7XG5cdFx0XHRraW5kOiBMaXN0LFxuXHRcdFx0Y2xhc3NlczogJ2xpc3Qtc2FtcGxlLWxhbmd1YWdlLWxpc3QgZW55by11bnNlbGVjdGFibGUnLFxuXHRcdFx0Zml0OiB0cnVlLFxuXHRcdFx0bXVsdGlTZWxlY3Q6IHRydWUsXG5cdFx0XHRyZW9yZGVyYWJsZTogdHJ1ZSxcblx0XHRcdGNlbnRlclJlb3JkZXJDb250YWluZXI6IGZhbHNlLFxuXHRcdFx0ZW5hYmxlU3dpcGU6IHRydWUsXG5cdFx0XHRvblNldHVwSXRlbTogJ3NldHVwSXRlbScsXG5cdFx0XHRvblJlb3JkZXI6ICdsaXN0UmVvcmRlcicsXG5cdFx0XHRvblNldHVwUmVvcmRlckNvbXBvbmVudHM6ICdzZXR1cFJlb3JkZXJDb21wb25lbnRzJyxcblx0XHRcdC8vIG9uU2V0dXBQaW5uZWRSZW9yZGVyQ29tcG9uZW50czogJ3NldHVwUGlubmVkUmVvcmRlckNvbXBvbmVudHMnLFxuXHRcdFx0b25TZXR1cFN3aXBlSXRlbTogJ3NldHVwU3dpcGVJdGVtJyxcblx0XHRcdG9uU3dpcGVDb21wbGV0ZTogJ3N3aXBlQ29tcGxldGUnLFxuXHRcdFx0Y29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ2l0ZW0nLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtbGFuZ3VhZ2UtaXRlbScsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3RleHQnLCBjbGFzc2VzOiAnaXRlbUxhYmVsJ30sXG5cdFx0XHRcdFx0e25hbWU6ICdyb3dOdW1iZXInLCBjbGFzc2VzOiAncm93TnVtYmVyTGFiZWwnfSxcblx0XHRcdFx0XHR7bmFtZTogJ3NlcmlhbCcsIGNsYXNzZXM6ICdzZXJpYWxMYWJlbCd9XG5cdFx0XHRcdF19XG5cdFx0XHRdLFxuXHRcdFx0cmVvcmRlckNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdyZW9yZGVyQ29udGVudCcsIGNsYXNzZXM6ICdlbnlvLWZpdCByZW9yZGVyRHJhZ2dlcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3Jlb3JkZXJUaXRsZScsIHRhZzogJ2gyJywgYWxsb3dIdG1sOiB0cnVlfVxuXHRcdFx0XHRdfVxuXHRcdFx0XSxcblx0XHRcdC8vIEZvciBFbnlvIDIuMiwgd2UgY29tbWVudCBvdXQgdGhlc2UgY29tcG9uZW50cyB0byBkaXNhYmxlIHBpbm5lZCBtb2RlIHdoaWNoIGlzIHN0aWxsXG5cdFx0XHQvLyBjb25zaWRlcmVkIGEgd29yayBpbiBwcm9ncmVzcy5cblx0XHRcdC8qIHBpbm5lZFJlb3JkZXJDb21wb25lbnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAncGlubmVkUmVvcmRlckl0ZW0nLCBjbGFzc2VzOiAnZW55by1maXQgc3dpcGVHcmVlbicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3Bpbm5lZFJlb3JkZXJUaXRsZScsIHRhZzogJ2gyJywgYWxsb3dIdG1sOiB0cnVlfSxcblx0XHRcdFx0XHR7bmFtZTogJ2Ryb3BCdXR0b24nLCBraW5kOiAnb255eC5CdXR0b24nLCBvbnRhcDogJ2Ryb3BQaW5uZWRSb3cnLCBjb250ZW50OiAnRHJvcCcsIGNsYXNzZXM6ICdkcm9wQnV0dG9uJ30sXG5cdFx0XHRcdFx0e25hbWU6ICdjYW5jZWxCdXR0b24nLCBraW5kOiAnb255eC5CdXR0b24nLCBvbnRhcDogJ2NhbmNlbFBpbm5lZE1vZGUnLCBjb250ZW50OiAnQ2FuY2VsJywgY2xhc3NlczogJ2NhbmNlbEJ1dHRvbid9XG5cdFx0XHRcdF19XG5cdFx0XHRdLCAqL1xuXHRcdFx0c3dpcGVhYmxlQ29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ3N3aXBlSXRlbScsIGNsYXNzZXM6ICdlbnlvLWZpdCBzd2lwZUdyZWVuJywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtuYW1lOiAnc3dpcGVUaXRsZScsIGNsYXNzZXM6ICdzd2lwZVRpdGxlJ31cblx0XHRcdFx0XX1cblx0XHRcdF1cblx0XHR9XG5cdF0sXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnBvcHVsYXRlTGlzdCgpO1xuXHRcdH07XG5cdH0pLFxuXHRsaXN0UmVvcmRlcjogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcblx0XHR2YXIgbW92ZWRJdGVtID0gdXRpbHMuY2xvbmUodGhpcy5kYXRhW2luRXZlbnQucmVvcmRlckZyb21dKTtcblx0XHR0aGlzLmRhdGEuc3BsaWNlKGluRXZlbnQucmVvcmRlckZyb20sMSk7XG5cdFx0dGhpcy5kYXRhLnNwbGljZSgoaW5FdmVudC5yZW9yZGVyVG8pLDAsbW92ZWRJdGVtKTtcblx0fSxcblx0c2V0dXBJdGVtOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHRpZighdGhpcy5kYXRhW2ldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50TGFuZ3VhZ2UgPSB0aGlzLmRhdGFbaV0ubGFuZ3NbdGhpcy5kYXRhW2ldLmN1cnJlbnRJbmRleF07XG5cdFx0dmFyIHZhbCA9IHRoaXMuZGF0YVtpXS52YWw7XG5cdFx0dmFyIG51bWJlciA9IHRoaXMubGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV1bdmFsXTtcblx0XHR2YXIgc2VyaWFsID0gdGhpcy5kYXRhW2ldLnNlcmlhbDtcblx0XHR0aGlzLiQucm93TnVtYmVyLnNldENvbnRlbnQoJ1JPVyAnICsgaSk7XG5cdFx0dGhpcy4kLnRleHQuc2V0Q29udGVudChudW1iZXIpO1xuXHRcdHRoaXMuJC5zZXJpYWwuc2V0Q29udGVudCgnIycgKyBzZXJpYWwpO1xuXHR9LFxuXHRzZXR1cFJlb3JkZXJDb21wb25lbnRzOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHRpZighdGhpcy5kYXRhW2ldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50TGFuZ3VhZ2UgPSB0aGlzLmRhdGFbaV0ubGFuZ3NbdGhpcy5kYXRhW2ldLmN1cnJlbnRJbmRleF07XG5cdFx0dmFyIHZhbCA9IHRoaXMuZGF0YVtpXS52YWw7XG5cdFx0dmFyIG51bWJlciA9IHRoaXMubGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV1bdmFsXTtcblx0XHR0aGlzLiQucmVvcmRlclRpdGxlLnNldENvbnRlbnQobnVtYmVyKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Lyogc2V0dXBQaW5uZWRSZW9yZGVyQ29tcG9uZW50czogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcblx0XHR2YXIgaSA9IGluRXZlbnQuaW5kZXg7XG5cdFx0aWYoIXRoaXMuZGF0YVtpXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgY3VycmVudExhbmd1YWdlID0gdGhpcy5kYXRhW2ldLmxhbmdzW3RoaXMuZGF0YVtpXS5jdXJyZW50SW5kZXhdO1xuXHRcdHZhciB2YWwgPSB0aGlzLmRhdGFbaV0udmFsO1xuXHRcdHZhciBudW1iZXIgPSB0aGlzLmxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdW3ZhbF07XG5cdFx0dGhpcy4kLnBpbm5lZFJlb3JkZXJUaXRsZS5zZXRDb250ZW50KG51bWJlcik7XG5cdH0sICovXG5cdC8vKiBDYWxsZWQgd2hlbiB0aGUgJ0Ryb3AnIGJ1dHRvbiBpcyBwcmVzc2VkIG9uIHRoZSBwaW5uZWQgcGxhY2Vob2xkZXIgcm93XG5cdC8qIGRyb3BQaW5uZWRSb3c6IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dGhpcy4kLmxpc3QuZHJvcFBpbm5lZFJvdyhpbkV2ZW50KTtcblx0fSwgKi9cblx0Ly8qIENhbGxlZCB3aGVuIHRoZSAnQ2FuY2VsJyBidXR0b24gaXMgcHJlc3NlZCBvbiB0aGUgcGlubmVkIHBsYWNlaG9sZGVyIHJvd1xuXHQvKiBjYW5jZWxQaW5uZWRNb2RlOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHRoaXMuJC5saXN0LmNhbmNlbFBpbm5lZE1vZGUoaW5FdmVudCk7XG5cdH0sICovXG5cdHNldHVwU3dpcGVJdGVtOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHRpZighdGhpcy5kYXRhW2ldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBuZXdMYW5nID0gKGluRXZlbnQueERpcmVjdGlvbiA9PSAxKVxuXHRcdFx0PyB0aGlzLmdldE5leHRMYW5nKGkpXG5cdFx0XHQ6IHRoaXMuZ2V0UHJldkxhbmcoaSk7XG5cdFx0dGhpcy4kLnN3aXBlVGl0bGUuc2V0Q29udGVudCh0aGlzLmRhdGFbaV0ubGFuZ3NbbmV3TGFuZ10pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRzd2lwZUNvbXBsZXRlOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHR0aGlzLmRhdGFbaV0uY3VycmVudEluZGV4ID0gKGluRXZlbnQueERpcmVjdGlvbiA9PSAxKVxuXHRcdFx0PyB0aGlzLmdldE5leHRMYW5nKGkpXG5cdFx0XHQ6IHRoaXMuZ2V0UHJldkxhbmcoaSk7XG5cdFx0dGhpcy4kLmxpc3QucmVuZGVyUm93KGkpO1xuXHR9LFxuXHRnZXROZXh0TGFuZzogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgY3VycmVudExhbmcgPSB0aGlzLmRhdGFbaW5kZXhdLmN1cnJlbnRJbmRleDtcblx0XHRyZXR1cm4gKGN1cnJlbnRMYW5nICsgMSkgJSB0aGlzLmRhdGFbaW5kZXhdLmxhbmdzLmxlbmd0aDtcblx0fSxcblx0Z2V0UHJldkxhbmc6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGN1cnJlbnRMYW5nID0gdGhpcy5kYXRhW2luZGV4XS5jdXJyZW50SW5kZXg7XG5cdFx0cmV0dXJuIChjdXJyZW50TGFuZyAtIDEgKyB0aGlzLmRhdGFbaW5kZXhdLmxhbmdzLmxlbmd0aCkgJSB0aGlzLmRhdGFbaW5kZXhdLmxhbmdzLmxlbmd0aDtcblx0fSxcblx0cG9wdWxhdGVMaXN0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNyZWF0ZVJhbmRvbURhdGEoKTtcblx0XHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLmRhdGEubGVuZ3RoKTtcblx0XHR0aGlzLiQubGlzdC5yZXNldCgpO1xuXHR9LFxuXHRjcmVhdGVSYW5kb21EYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFuZ3VhZ2VzID0gdGhpcy5nZXRMYW5ndWFnZXMoKTtcblx0XHR2YXIgbGFuZ3M7XG5cdFx0dmFyIGRhdGFDb3VudCA9IHBhcnNlSW50KHRoaXMuJC5udW1Sb3dzLmdldFZhbHVlKCksIDEwKTtcblx0XHR0aGlzLmRhdGEgPSBbXTtcblx0XHR2YXIgc29ydEZ1bmMgPSBmdW5jdGlvbigpIHtyZXR1cm4gMC41IC0gTWF0aC5yYW5kb20oKTt9O1xuXHRcdGZvcih2YXIgaT0wO2k8ZGF0YUNvdW50O2krKykge1xuXHRcdFx0bGFuZ3MgPSB1dGlscy5jbG9uZShsYW5ndWFnZXMpO1xuXHRcdFx0bGFuZ3Muc29ydChzb3J0RnVuYyk7XG5cdFx0XHR0aGlzLmRhdGEucHVzaCh7XG5cdFx0XHRcdGxhbmdzOiBsYW5ncyxcblx0XHRcdFx0dmFsOiBpICUgMTAsXG5cdFx0XHRcdGN1cnJlbnRJbmRleDogMCxcblx0XHRcdFx0c2VyaWFsOiBpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5kYXRhLnNvcnQoZnVuY3Rpb24oKSB7cmV0dXJuIDAuNSAtIE1hdGgucmFuZG9tKCk7fSk7XG5cdH0sXG5cdGdldExhbmd1YWdlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHV0aWxzLmtleXModGhpcy5sYW5ndWFnZXMpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dFwiOjI0LFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zXCI6ODUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9MaXN0XCI6OTV9XSwxMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyk7XG5cbnZhclxuXHRMaXN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9MaXN0Jyk7XG5cbnZhclxuXHRuYW1lcyA9IHJlcXVpcmUoJy4vTmFtZUdlbmVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuTGlzdE5vU2VsZWN0U2FtcGxlJyxcblx0Y2xhc3NlczogJ2xpc3Qtc2FtcGxlIGVueW8tZml0Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnbGlzdCcsIGtpbmQ6IExpc3QsIGNvdW50OiAyMDAwMCwgbm9TZWxlY3Q6IHRydWUsIG11bHRpU2VsZWN0OiBmYWxzZSwgY2xhc3NlczogJ2VueW8tZml0IGxpc3Qtc2FtcGxlLWxpc3QnLFxuXHRcdFx0b25TZXR1cEl0ZW06ICdzZXR1cEl0ZW0nLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ2l0ZW0nLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtaXRlbSBlbnlvLWJvcmRlci1ib3gnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAnaW5kZXgnLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtaW5kZXgnfSxcblx0XHRcdFx0e25hbWU6ICduYW1lJ31cblx0XHRcdF19XG5cdFx0XX1cblx0XSxcblx0bmFtZXM6IFtdLFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gdGhpcyBpcyB0aGUgcm93IHdlJ3JlIHNldHRpbmcgdXBcblx0XHR2YXIgaSA9IGV2ZW50LmluZGV4O1xuXHRcdC8vIG1ha2Ugc29tZSBtb2NrIGRhdGEgaWYgd2UgaGF2ZSBub25lIGZvciB0aGlzIHJvd1xuXHRcdGlmICghdGhpcy5uYW1lc1tpXSkge1xuXHRcdFx0dGhpcy5uYW1lc1tpXSA9IG5hbWVzLm1ha2VOYW1lKDUsIDEwLCAnJywgJycpO1xuXHRcdH1cblx0XHR2YXIgbiA9IHRoaXMubmFtZXNbaV07XG5cdFx0dmFyIG5pID0gKCcwMDAwMDAwMCcgKyBpKS5zbGljZSgtNyk7XG5cdFx0dGhpcy4kLm5hbWUuc2V0Q29udGVudChuKTtcblx0XHR0aGlzLiQuaW5kZXguc2V0Q29udGVudChuaSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3RcIjo5NSxcIi4vTmFtZUdlbmVyYXRvclwiOjEyNX1dLDEyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0anNvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2pzb24nKSxcblx0QnV0dG9uID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQnV0dG9uJyksXG5cdENvbXBvbmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0NvbXBvbmVudCcpLFxuXHRJbWFnZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0ltYWdlJyksXG5cdElucHV0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW5wdXQnKSxcblx0SnNvbnBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSnNvbnAnKTtcblxudmFyXG5cdENvbGxhcHNpbmdBcnJhbmdlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvQ29sbGFwc2luZ0FycmFuZ2VyJyksXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyksXG5cdExpc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3QnKVxuXHRQYW5lbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL1BhbmVscycpO1xuXG4vLyBBIHNpbXBsZSBjb21wb25lbnQgdG8gZG8gYSBGbGlja3Igc2VhcmNoLlxudmFyIFBhbmVsc0ZsaWNrclNlYXJjaCA9IGtpbmQoe1xuXHRraW5kOiBDb21wb25lbnQsXG5cdHB1Ymxpc2hlZDoge1xuXHRcdHNlYXJjaFRleHQ6ICcnXG5cdH0sXG5cdGV2ZW50czoge1xuXHRcdG9uUmVzdWx0czogJydcblx0fSxcblx0dXJsOiAnaHR0cHM6Ly9hcGkuZmxpY2tyLmNvbS9zZXJ2aWNlcy9yZXN0LycsXG5cdHBhZ2VTaXplOiAyMDAsXG5cdGFwaV9rZXk6ICcyYTIxYjQ2ZTU4ZDIwN2U0ODg4ZTFlY2UwY2IxNDlhNScsXG5cdHNlYXJjaDogZnVuY3Rpb24oaW5TZWFyY2hUZXh0LCBpblBhZ2UpIHtcblx0XHR0aGlzLnNlYXJjaFRleHQgPSBpblNlYXJjaFRleHQgfHwgdGhpcy5zZWFyY2hUZXh0O1xuXHRcdHZhciBpID0gKGluUGFnZSB8fCAwKSAqIHRoaXMucGFnZVNpemU7XG5cdFx0dmFyIHBhcmFtcyA9IHtcblx0XHRcdG1ldGhvZDogJ2ZsaWNrci5waG90b3Muc2VhcmNoJyxcblx0XHRcdGZvcm1hdDogJ2pzb24nLFxuXHRcdFx0YXBpX2tleTogdGhpcy5hcGlfa2V5LFxuXHRcdFx0cGVyX3BhZ2U6IHRoaXMucGFnZVNpemUsXG5cdFx0XHRwYWdlOiBpLFxuXHRcdFx0dGV4dDogdGhpcy5zZWFyY2hUZXh0XG5cdFx0fTtcblx0XHR2YXIgcmVxO1xuXHRcdGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdtcy1hcHB4OicpIHtcblx0XHRcdHBhcmFtcy5ub2pzb25jYWxsYmFjayA9IDE7XG5cdFx0XHQvLyBVc2UgYWpheCBmb3IgcGxhdGZvcm1zIHdpdGggbm8ganNvbnAgc3VwcG9ydCAoV2luZG93cyA4KVxuXHRcdFx0cmVxID0gbmV3IGVueW8uQWpheCh7dXJsOiB0aGlzLnVybCwgaGFuZGxlQXM6ICd0ZXh0J30pXG5cdFx0XHRcdC5yZXNwb25zZSh0aGlzLCAncHJvY2Vzc0FqYXhSZXNwb25zZScpXG5cdFx0XHRcdC5nbyhwYXJhbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXEgPSBuZXcgSnNvbnBSZXF1ZXN0KHt1cmw6IHRoaXMudXJsLCBjYWxsYmFja05hbWU6ICdqc29uY2FsbGJhY2snfSlcblx0XHRcdFx0LnJlc3BvbnNlKHRoaXMsICdwcm9jZXNzUmVzcG9uc2UnKVxuXHRcdFx0XHQuZ28ocGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcTtcblx0fSxcblx0cHJvY2Vzc0FqYXhSZXNwb25zZTogZnVuY3Rpb24oaW5TZW5kZXIsIGluUmVzcG9uc2UpIHtcblx0XHRpblJlc3BvbnNlID0ganNvbi5wYXJzZShpblJlc3BvbnNlKTtcblx0XHR0aGlzLnByb2Nlc3NSZXNwb25zZShpblNlbmRlciwgaW5SZXNwb25zZSk7XG5cdH0sXG5cdHByb2Nlc3NSZXNwb25zZTogZnVuY3Rpb24oaW5TZW5kZXIsIGluUmVzcG9uc2UpIHtcblx0XHR2YXIgcGhvdG9zID0gaW5SZXNwb25zZS5waG90b3MgPyBpblJlc3BvbnNlLnBob3Rvcy5waG90byB8fCBbXSA6IFtdO1xuXHRcdGZvciAodmFyIGk9MCwgcDsgKHA9cGhvdG9zW2ldKTsgaSsrKSB7XG5cdFx0XHR2YXIgdXJscHJlZml4ID0gJ2h0dHA6Ly9mYXJtJyArIHAuZmFybSArICcuc3RhdGljLmZsaWNrci5jb20vJyArIHAuc2VydmVyICsgJy8nICsgcC5pZCArICdfJyArIHAuc2VjcmV0O1xuXHRcdFx0cC50aHVtYm5haWwgPSB1cmxwcmVmaXggKyAnX3MuanBnJztcblx0XHRcdHAub3JpZ2luYWwgPSB1cmxwcmVmaXggKyAnLmpwZyc7XG5cdFx0fVxuXHRcdHRoaXMuZG9SZXN1bHRzKHBob3Rvcyk7XG5cdFx0cmV0dXJuIHBob3Rvcztcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5QYW5lbHNGbGlja3JTYW1wbGUnLFxuXHRraW5kOiBQYW5lbHMsXG5cdGNsYXNzZXM6ICdwYW5lbHMtc2FtcGxlLWZsaWNrci1wYW5lbHMgZW55by11bnNlbGVjdGFibGUgZW55by1maXQnLFxuXHRhcnJhbmdlcktpbmQ6IENvbGxhcHNpbmdBcnJhbmdlcixcblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBGaXR0YWJsZVJvd3MsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBGaXR0YWJsZUNvbHVtbnMsIHRhZzogJ2xhYmVsJywgc3R5bGU6ICd3aWR0aDogOTAlOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3NlYXJjaElucHV0JywgZml0OiB0cnVlLCBraW5kOiBJbnB1dCwgdmFsdWU6ICdKYXBhbicsIG9uY2hhbmdlOiAnc2VhcmNoJ30sXG5cdFx0XHRcdFx0e2tpbmQ6IEltYWdlLCBzcmM6ICdhc3NldHMvc2VhcmNoLWlucHV0LXNlYXJjaC5wbmcnLCBzdHlsZTogJ3dpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHg7J31cblx0XHRcdFx0XX0sXG5cdFx0XHRcdHtuYW1lOiAnc2VhcmNoU3Bpbm5lcicsIGtpbmQ6IEltYWdlLCBzcmM6ICdhc3NldHMvc3Bpbm5lci5naWYnLCBzaG93aW5nOiBmYWxzZX1cblx0XHRcdF19LFxuXHRcdFx0e2tpbmQ6IExpc3QsIGZpdDogdHJ1ZSwgdG91Y2g6IHRydWUsIG9uU2V0dXBJdGVtOiAnc2V0dXBJdGVtJywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ2l0ZW0nLCBzdHlsZTogJ3BhZGRpbmc6IDEwcHg7JywgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtZmxpY2tyLWl0ZW0gZW55by1ib3JkZXItYm94Jywgb250YXA6ICdpdGVtVGFwJywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtuYW1lOiAndGh1bWJuYWlsJywga2luZDogSW1hZ2UsIGNsYXNzZXM6ICdwYW5lbHMtc2FtcGxlLWZsaWNrci10aHVtYm5haWwnfSxcblx0XHRcdFx0XHR7bmFtZTogJ3RpdGxlJywgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtZmxpY2tyLXRpdGxlJ31cblx0XHRcdFx0XX0sXG5cdFx0XHRcdHtuYW1lOiAnbW9yZScsIHN0eWxlOiAnYmFja2dyb3VuZC1jb2xvcjogIzMyMzIzMjsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ21vcmUgcGhvdG9zJywgY2xhc3NlczogJ29ueXgtZGFyayBwYW5lbHMtc2FtcGxlLWZsaWNrci1tb3JlLWJ1dHRvbicsIG9udGFwOiAnbW9yZSd9LFxuXHRcdFx0XHRcdHtuYW1lOiAnbW9yZVNwaW5uZXInLCBraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NwaW5uZXIuZ2lmJywgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtZmxpY2tyLW1vcmUtc3Bpbm5lcid9XG5cdFx0XHRcdF19XG5cdFx0XHRdfVxuXHRcdF19LFxuXHRcdHtuYW1lOiAncGljdHVyZVZpZXcnLCBmaXQ6IHRydWUsIGtpbmQ6IEZpdHRhYmxlUm93cywgY2xhc3NlczogJ2VueW8tZml0IHBhbmVscy1zYW1wbGUtZmxpY2tyLW1haW4nLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7bmFtZTogJ2JhY2tUb29sYmFyJywgc2hvd2luZzogZmFsc2UsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ0JhY2snLCBvbnRhcDogJ3Nob3dMaXN0J31cblx0XHRcdF19LFxuXHRcdFx0e2ZpdDogdHJ1ZSwgc3R5bGU6ICdwb3NpdGlvbjogcmVsYXRpdmU7JywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ2ZsaWNrckltYWdlJywga2luZDogSW1hZ2UsIGNsYXNzZXM6ICdlbnlvLWZpdCBwYW5lbHMtc2FtcGxlLWZsaWNrci1jZW50ZXIgcGFuZWxzLXNhbXBsZS1mbGlja3ItaW1hZ2UnLCBzaG93aW5nOiBmYWxzZSwgb25sb2FkOiAnaW1hZ2VMb2FkZWQnLCBvbmVycm9yOiAnaW1hZ2VMb2FkZWQnfSxcblx0XHRcdFx0e25hbWU6ICdpbWFnZVNwaW5uZXInLCBraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NwaW5uZXItbGFyZ2UuZ2lmJywgY2xhc3NlczogJ2VueW8tZml0IHBhbmVscy1zYW1wbGUtZmxpY2tyLWNlbnRlcicsIHNob3dpbmc6IGZhbHNlfVxuXHRcdFx0XX1cblx0XHRdfSxcblx0XHR7bmFtZTogJ2ZsaWNrclNlYXJjaCcsIGtpbmQ6IFBhbmVsc0ZsaWNrclNlYXJjaCwgb25SZXN1bHRzOiAnc2VhcmNoUmVzdWx0cyd9XG5cdF0sXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnNlYXJjaCgpO1xuXHRcdH07XG5cdH0pLFxuXHRyZWZsb3c6IGtpbmQuaW5oZXJpdChmdW5jdGlvbihzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHZhciBiYWNrU2hvd2luZyA9IHRoaXMuJC5iYWNrVG9vbGJhci5zaG93aW5nO1xuXHRcdFx0dGhpcy4kLmJhY2tUb29sYmFyLnNldFNob3dpbmcoUGFuZWxzLmlzU2NyZWVuTmFycm93KCkpO1xuXHRcdFx0aWYgKHRoaXMuJC5iYWNrVG9vbGJhci5zaG93aW5nICE9IGJhY2tTaG93aW5nKSB7XG5cdFx0XHRcdHRoaXMuJC5waWN0dXJlVmlldy5yZXNpemUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSxcblx0c2VhcmNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNlYXJjaFRleHQgPSB0aGlzLiQuc2VhcmNoSW5wdXQuZ2V0VmFsdWUoKTtcblx0XHR0aGlzLnBhZ2UgPSAwO1xuXHRcdHRoaXMucmVzdWx0cyA9IFtdO1xuXHRcdHRoaXMuJC5zZWFyY2hTcGlubmVyLnNob3coKTtcblx0XHR0aGlzLiQuZmxpY2tyU2VhcmNoLnNlYXJjaCh0aGlzLnNlYXJjaFRleHQpO1xuXHR9LFxuXHRzZWFyY2hSZXN1bHRzOiBmdW5jdGlvbihpblNlbmRlciwgaW5SZXN1bHRzKSB7XG5cdFx0dGhpcy4kLnNlYXJjaFNwaW5uZXIuaGlkZSgpO1xuXHRcdHRoaXMuJC5tb3JlU3Bpbm5lci5oaWRlKCk7XG5cdFx0dGhpcy5yZXN1bHRzID0gdGhpcy5yZXN1bHRzLmNvbmNhdChpblJlc3VsdHMpO1xuXHRcdHRoaXMuJC5saXN0LnNldENvdW50KHRoaXMucmVzdWx0cy5sZW5ndGgpO1xuXHRcdGlmICh0aGlzLnBhZ2UgPT09IDApIHtcblx0XHRcdHRoaXMuJC5saXN0LnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJC5saXN0LnJlZnJlc2goKTtcblx0XHR9XG5cdH0sXG5cdHNldHVwSXRlbTogZnVuY3Rpb24oaW5TZW5kZXIsIGluRXZlbnQpIHtcblx0XHR2YXIgaSA9IGluRXZlbnQuaW5kZXg7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLnJlc3VsdHNbaV07XG5cdFx0dGhpcy4kLml0ZW0uYWRkUmVtb3ZlQ2xhc3MoJ29ueXgtc2VsZWN0ZWQnLCBpblNlbmRlci5pc1NlbGVjdGVkKGluRXZlbnQuaW5kZXgpKTtcblx0XHR0aGlzLiQudGh1bWJuYWlsLnNldFNyYyhpdGVtLnRodW1ibmFpbCk7XG5cdFx0dGhpcy4kLnRpdGxlLnNldENvbnRlbnQoaXRlbS50aXRsZSB8fCAnVW50aXRsZWQnKTtcblx0XHR0aGlzLiQubW9yZS5jYW5HZW5lcmF0ZSA9ICF0aGlzLnJlc3VsdHNbaSsxXTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0bW9yZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYWdlKys7XG5cdFx0dGhpcy4kLm1vcmVTcGlubmVyLnNob3coKTtcblx0XHR0aGlzLiQuZmxpY2tyU2VhcmNoLnNlYXJjaCh0aGlzLnNlYXJjaFRleHQsIHRoaXMucGFnZSk7XG5cdH0sXG5cdGl0ZW1UYXA6IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0aWYgKFBhbmVscy5pc1NjcmVlbk5hcnJvdygpKSB7XG5cdFx0XHR0aGlzLnNldEluZGV4KDEpO1xuXHRcdH1cblx0XHR0aGlzLiQuaW1hZ2VTcGlubmVyLnNob3coKTtcblx0XHR2YXIgaXRlbSA9IHRoaXMucmVzdWx0c1tpbkV2ZW50LmluZGV4XTtcblxuXHRcdGlmIChpdGVtLm9yaWdpbmFsID09IHRoaXMuJC5mbGlja3JJbWFnZS5nZXRTcmMoKSkge1xuXHRcdFx0dGhpcy5pbWFnZUxvYWRlZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiQuZmxpY2tySW1hZ2UuaGlkZSgpO1xuXHRcdFx0dGhpcy4kLmZsaWNrckltYWdlLnNldFNyYyhpdGVtLm9yaWdpbmFsKTtcblx0XHR9XG5cdH0sXG5cdGltYWdlTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1nID0gdGhpcy4kLmZsaWNrckltYWdlO1xuXHRcdGltZy5yZW1vdmVDbGFzcygndGFsbCcpO1xuXHRcdGltZy5yZW1vdmVDbGFzcygnd2lkZScpO1xuXHRcdGltZy5zaG93KCk7XG5cdFx0dmFyIGIgPSBpbWcuZ2V0Qm91bmRzKCk7XG5cdFx0dmFyIHIgPSBiLmhlaWdodCAvIGIud2lkdGg7XG5cdFx0aWYgKHIgPj0gMS4yNSkge1xuXHRcdFx0aW1nLmFkZENsYXNzKCd0YWxsJyk7XG5cdFx0fSBlbHNlIGlmIChyIDw9IDAuOCApIHtcblx0XHRcdGltZy5hZGRDbGFzcygnd2lkZScpO1xuXHRcdH1cblx0XHR0aGlzLiQuaW1hZ2VTcGlubmVyLmhpZGUoKTtcblx0fSxcblx0c2hvd0xpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0SW5kZXgoMCk7XG5cdH1cbn0pO1xuXG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvQ29tcG9uZW50XCI6MTMsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZVwiOjIzLFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL0pzb25wXCI6MjUsXCIuLi8uLi8uLi9lbnlvL2xpYi9qc29uXCI6NjUsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0NvbGxhcHNpbmdBcnJhbmdlclwiOjgyLFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnNcIjo4NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3RcIjo5NSxcIi4uLy4uLy4uL2xheW91dC9saWIvUGFuZWxzXCI6OTl9XSwxMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdENoZWNrYm94ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ2hlY2tib3gnKSxcblx0U2Nyb2xsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9TY3JvbGxlcicpO1xuXG52YXJcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0Q29sbGFwc2luZ0FycmFuZ2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9Db2xsYXBzaW5nQXJyYW5nZXInKSxcblx0UGFuZWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9QYW5lbHMnKSxcblx0TGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvTGlzdCcpO1xuXG52YXIgUGFuZWxzU2xpZGluZ1NhbXBsZSA9IG1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5QYW5lbHNTbGlkaW5nU2FtcGxlJyxcblx0a2luZDogRml0dGFibGVSb3dzLFxuXHRjbGFzc2VzOiAnZW55by1maXQnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e3RhZzogJ2xhYmVsJywgY29tcG9uZW50czogW1xuXHRcdFx0e3RhZzogJ3NwYW4nLCBjb250ZW50OiAnUmVhbHRpbWUnfSxcblx0XHRcdHtraW5kOiBDaGVja2JveCwgb25jaGFuZ2U6ICdjaGVja2JveENoYW5nZSd9XG5cdFx0XX0sXG5cdFx0e2tpbmQ6IFBhbmVscywgZml0OiB0cnVlLCBjbGFzc2VzOiAncGFuZWxzLXNhbXBsZS1zbGlkaW5nLXBhbmVscycsIGFycmFuZ2VyS2luZDogQ29sbGFwc2luZ0FycmFuZ2VyLCB3cmFwOiBmYWxzZSwgY29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICdsZWZ0JywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7a2luZDogTGlzdCwgY2xhc3NlczogJ2VueW8tZml0JywgdG91Y2g6IHRydWUsIGNvdW50OiAxMDAwLCBvblNldHVwSXRlbTogJ3NldHVwSXRlbScsIGl0ZW06ICdpdGVtMScsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ2l0ZW0xJywgY2xhc3NlczogJ3BhbmVscy1zYW1wbGUtc2xpZGluZy1pdGVtJ31cblx0XHRcdFx0XX1cblx0XHRcdF19LFxuXHRcdFx0e25hbWU6ICdtaWRkbGUnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBMaXN0LCBjbGFzc2VzOiAnZW55by1maXQnLCB0b3VjaDogdHJ1ZSwgY291bnQ6IDEwMDAsIG9uU2V0dXBJdGVtOiAnc2V0dXBJdGVtJywgaXRlbTogJ2l0ZW0yJywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtuYW1lOiAnaXRlbTInLCBjbGFzc2VzOiAncGFuZWxzLXNhbXBsZS1zbGlkaW5nLWl0ZW0nfVxuXHRcdFx0XHRdfVxuXHRcdFx0XX0sXG5cdFx0XHR7bmFtZTogJ2JvZHknLCBmaXQ6IHRydWUsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IFNjcm9sbGVyLCBjbGFzc2VzOiAnZW55by1maXQnLCB0b3VjaDogdHJ1ZSwgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtjbGFzc2VzOiAncGFuZWxzLXNhbXBsZS1zbGlkaW5nLWNvbnRlbnQnLCBjb250ZW50OiAnQnJva2UsIGRvd24gZHVtYiBob3NwaXRhbGl0eSBmaXJld29vZCBjaGl0bGlucy4gSGFzIG11ZCB0aXJlZCB1bmNsZSBldmVybGFzdGluXFwnIGNvbGQsIG91dC4gSGF1bGVkIHRoYXIsIHVwIHRoYXIgdGFyIGhlZmZlciBxdWFycmVsIGZhcm1lciBmaXNoIHdhdGVyIGlzLiBTaW1wbGUgZ3JpdHRzIGRvZ3Mgc29hcCBnaXZlIGtpY2tpblxcJy4gQWluXFwndCBzaGluZXkgd2F0ZXIgcmFuZ2UsIHByZWFjaGVyIGphdmEgcmVudCB0aGFyIGdvLiBTa2lubmVkIHdpcmV5IHRpbiBmYXJtLCB0cmVzcGFzc2luXFwnIGl0LCByb2Rlby4gU2FpZCByb3BlZCBjYXVnaHQgY3Jlb3NvdGUgZ28gc2ltcGxlLiBCdWZmYWxvIGJ1dHQsIGppZyBmcmllZCBjb21tZW5jaW5cXCcgY2lwaGVyaW5cXCcgbWF3LCB3YXNoLiBSb3VuZC11cCBiYXJlZm9vdCBqZXN0IGJpYmxlIHJvdHRndXQgc2l0dGluXFwnIHRyYWlsZXIgc2hlZCBqZXplYmVsLiBDcm9wIG9sZCBvdmVyIHBva2VyIGRyaW5raW5cXCcgZGlydCB3aGVyZSB0b29scyBza2lubmVkLCBjaXR5LXNsaWNrZXJzIHRvb2xzIGxpbmltZW50IG11c2ggdGFybmF0aW9uLiBUcnVjayBseWluXFwnIHNuYWtlb2lsIGNyZW9zb3RlLCBvbGQgYSBpbmJyZWQgcHVkbmVlciwgc2xhcCBkaXJ0eSBjYWluXFwndC4gSGFpcnksIHNtb2tpblxcJywgbm90aGluXFwnIGhpZ2h3YXkgaG9vdGNoIHBpZ3MgZHJpbmtpblxcJywgYmFyZWZvb3QgYm9vdGxlZyBob29zZWdvdyBtdWxlLiBUYXgtY29sbGVjdG9ycyB1bmNsZSB3dXosIG1hdyB3YXRjaGluXFwnIGhhZCBqdW1waW5cXCcgZ290IHJlZGJsb29kZWQgZ2ltbWllIHRydWNrIHNob290aW5cXCcgYXNraW5cXCcgaG9vdGNoLiBObyBmYXQgYWlscyBmaXJlIHNvYXAgY2FiaW4gamFpbCwgcmVja29uIGlmIHRyZXNwYXNzaW5cXCcgZml4aW5cXCcgcnVzdGxlIGplc3QgbGluaW1lbnQuIFlhIGh1bnRpblxcJyBjYXRmaXNoIHNob3QgZ29vZCBiYW5rcnVwdC4gRmlzaGluXFwnIHNoZXJyaWYgaGFzLCBmYXQgY29va2VkIHNoZWQgb2xkLiBCcm9rZSwgZG93biBkdW1iIGhvc3BpdGFsaXR5IGZpcmV3b29kIGNoaXRsaW5zLiBIYXMgbXVkIHRpcmVkIHVuY2xlIGV2ZXJsYXN0aW5cXCcgY29sZCwgb3V0LiBIYXVsZWQgdGhhciwgdXAgdGhhciB0YXIgaGVmZmVyIHF1YXJyZWwgZmFybWVyIGZpc2ggd2F0ZXIgaXMuIFNpbXBsZSBncml0dHMgZG9ncyBzb2FwIGdpdmUga2lja2luXFwnLiBBaW5cXCd0IHNoaW5leSB3YXRlciByYW5nZSwgcHJlYWNoZXIgamF2YSByZW50IHRoYXIgZ28uIFNraW5uZWQgd2lyZXkgdGluIGZhcm0sIHRyZXNwYXNzaW5cXCcgaXQsIHJvZGVvLiBTYWlkIHJvcGVkIGNhdWdodCBjcmVvc290ZSBnbyBzaW1wbGUuIEJ1ZmZhbG8gYnV0dCwgamlnIGZyaWVkIGNvbW1lbmNpblxcJyBjaXBoZXJpblxcJyBtYXcsIHdhc2guIFJvdW5kLXVwIGJhcmVmb290IGplc3QgYmlibGUgcm90dGd1dCBzaXR0aW5cXCcgdHJhaWxlciBzaGVkIGplemViZWwuIENyb3Agb2xkIG92ZXIgcG9rZXIgZHJpbmtpblxcJyBkaXJ0IHdoZXJlIHRvb2xzIHNraW5uZWQsIGNpdHktc2xpY2tlcnMgdG9vbHMgbGluaW1lbnQgbXVzaCB0YXJuYXRpb24uIFRydWNrIGx5aW5cXCcgc25ha2VvaWwgY3Jlb3NvdGUsIG9sZCBhIGluYnJlZCBwdWRuZWVyLCBzbGFwIGRpcnR5IGNhaW5cXCd0LiBIYWlyeSwgc21va2luXFwnLCBub3RoaW5cXCcgaGlnaHdheSBob290Y2ggcGlncyBkcmlua2luXFwnLCBiYXJlZm9vdCBib290bGVnIGhvb3NlZ293IG11bGUuIFRheC1jb2xsZWN0b3JzIHVuY2xlIHd1eiwgbWF3IHdhdGNoaW5cXCcgaGFkIGp1bXBpblxcJyBnb3QgcmVkYmxvb2RlZCBnaW1taWUgdHJ1Y2sgc2hvb3RpblxcJyBhc2tpblxcJyBob290Y2guIE5vIGZhdCBhaWxzIGZpcmUgc29hcCBjYWJpbiBqYWlsLCByZWNrb24gaWYgdHJlc3Bhc3NpblxcJyBmaXhpblxcJyBydXN0bGUgamVzdCBsaW5pbWVudC4gWWEgaHVudGluXFwnIGNhdGZpc2ggc2hvdCBnb29kIGJhbmtydXB0LiBGaXNoaW5cXCcgc2hlcnJpZiBoYXMsIGZhdCBjb29rZWQgc2hlZCBvbGQuIEJyb2tlLCBkb3duIGR1bWIgaG9zcGl0YWxpdHkgZmlyZXdvb2QgY2hpdGxpbnMuIEhhcyBtdWQgdGlyZWQgdW5jbGUgZXZlcmxhc3RpblxcJyBjb2xkLCBvdXQuIEhhdWxlZCB0aGFyLCB1cCB0aGFyIHRhciBoZWZmZXIgcXVhcnJlbCBmYXJtZXIgZmlzaCB3YXRlciBpcy4gU2ltcGxlIGdyaXR0cyBkb2dzIHNvYXAgZ2l2ZSBraWNraW5cXCcuIEFpblxcJ3Qgc2hpbmV5IHdhdGVyIHJhbmdlLCBwcmVhY2hlciBqYXZhIHJlbnQgdGhhciBnby4gU2tpbm5lZCB3aXJleSB0aW4gZmFybSwgdHJlc3Bhc3NpblxcJyBpdCwgcm9kZW8uIFNhaWQgcm9wZWQgY2F1Z2h0IGNyZW9zb3RlIGdvIHNpbXBsZS4gQnVmZmFsbyBidXR0LCBqaWcgZnJpZWQgY29tbWVuY2luXFwnIGNpcGhlcmluXFwnIG1hdywgd2FzaC4gUm91bmQtdXAgYmFyZWZvb3QgamVzdCBiaWJsZSByb3R0Z3V0IHNpdHRpblxcJyB0cmFpbGVyIHNoZWQgamV6ZWJlbC4gQ3JvcCBvbGQgb3ZlciBwb2tlciBkcmlua2luXFwnIGRpcnQgd2hlcmUgdG9vbHMgc2tpbm5lZCwgY2l0eS1zbGlja2VycyB0b29scyBsaW5pbWVudCBtdXNoIHRhcm5hdGlvbi4gVHJ1Y2sgbHlpblxcJyBzbmFrZW9pbCBjcmVvc290ZSwgb2xkIGEgaW5icmVkIHB1ZG5lZXIsIHNsYXAgZGlydHkgY2FpblxcJ3QuIEhhaXJ5LCBzbW9raW5cXCcsIG5vdGhpblxcJyBoaWdod2F5IGhvb3RjaCBwaWdzIGRyaW5raW5cXCcsIGJhcmVmb290IGJvb3RsZWcgaG9vc2Vnb3cgbXVsZS4gVGF4LWNvbGxlY3RvcnMgdW5jbGUgd3V6LCBtYXcgd2F0Y2hpblxcJyBoYWQganVtcGluXFwnIGdvdCByZWRibG9vZGVkIGdpbW1pZSB0cnVjayBzaG9vdGluXFwnIGFza2luXFwnIGhvb3RjaC4gTm8gZmF0IGFpbHMgZmlyZSBzb2FwIGNhYmluIGphaWwsIHJlY2tvbiBpZiB0cmVzcGFzc2luXFwnIGZpeGluXFwnIHJ1c3RsZSBqZXN0IGxpbmltZW50LiBZYSBodW50aW5cXCcgY2F0ZmlzaCBzaG90IGdvb2QgYmFua3J1cHQuIEZpc2hpblxcJyBzaGVycmlmIGhhcywgZmF0IGNvb2tlZCBzaGVkIG9sZC4gQnJva2UsIGRvd24gZHVtYiBob3NwaXRhbGl0eSBmaXJld29vZCBjaGl0bGlucy4gSGFzIG11ZCB0aXJlZCB1bmNsZSBldmVybGFzdGluXFwnIGNvbGQsIG91dC4gSGF1bGVkIHRoYXIsIHVwIHRoYXIgdGFyIGhlZmZlciBxdWFycmVsIGZhcm1lciBmaXNoIHdhdGVyIGlzLiBTaW1wbGUgZ3JpdHRzIGRvZ3Mgc29hcCBnaXZlIGtpY2tpblxcJy4gQWluXFwndCBzaGluZXkgd2F0ZXIgcmFuZ2UsIHByZWFjaGVyIGphdmEgcmVudCB0aGFyIGdvLiBTa2lubmVkIHdpcmV5IHRpbiBmYXJtLCB0cmVzcGFzc2luXFwnIGl0LCByb2Rlby4gU2FpZCByb3BlZCBjYXVnaHQgY3Jlb3NvdGUgZ28gc2ltcGxlLiBCdWZmYWxvIGJ1dHQsIGppZyBmcmllZCBjb21tZW5jaW5cXCcgY2lwaGVyaW5cXCcgbWF3LCB3YXNoLiBSb3VuZC11cCBiYXJlZm9vdCBqZXN0IGJpYmxlIHJvdHRndXQgc2l0dGluXFwnIHRyYWlsZXIgc2hlZCBqZXplYmVsLiBDcm9wIG9sZCBvdmVyIHBva2VyIGRyaW5raW5cXCcgZGlydCB3aGVyZSB0b29scyBza2lubmVkLCBjaXR5LXNsaWNrZXJzIHRvb2xzIGxpbmltZW50IG11c2ggdGFybmF0aW9uLiBUcnVjayBseWluXFwnIHNuYWtlb2lsIGNyZW9zb3RlLCBvbGQgYSBpbmJyZWQgcHVkbmVlciwgc2xhcCBkaXJ0eSBjYWluXFwndC4gSGFpcnksIHNtb2tpblxcJywgbm90aGluXFwnIGhpZ2h3YXkgaG9vdGNoIHBpZ3MgZHJpbmtpblxcJywgYmFyZWZvb3QgYm9vdGxlZyBob29zZWdvdyBtdWxlLiBUYXgtY29sbGVjdG9ycyB1bmNsZSB3dXosIG1hdyB3YXRjaGluXFwnIGhhZCBqdW1waW5cXCcgZ290IHJlZGJsb29kZWQgZ2ltbWllIHRydWNrIHNob290aW5cXCcgYXNraW5cXCcgaG9vdGNoLiBObyBmYXQgYWlscyBmaXJlIHNvYXAgY2FiaW4gamFpbCwgcmVja29uIGlmIHRyZXNwYXNzaW5cXCcgZml4aW5cXCcgcnVzdGxlIGplc3QgbGluaW1lbnQuIFlhIGh1bnRpblxcJyBjYXRmaXNoIHNob3QgZ29vZCBiYW5rcnVwdC4gRmlzaGluXFwnIHNoZXJyaWYgaGFzLCBmYXQgY29va2VkIHNoZWQgb2xkLid9XG5cdFx0XHRcdF19XG5cdFx0XHRdfVxuXHRcdF19XG5cdF0sXG5cdHNldHVwSXRlbTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLiRbc2VuZGVyLml0ZW1dLnNldENvbnRlbnQoJ1RoaXMgaXMgcm93IG51bWJlcjogJyArIGV2ZW50LmluZGV4KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Y2hlY2tib3hDaGFuZ2U6IGZ1bmN0aW9uIChzZW5kZXIpIHtcblx0XHR0aGlzLiQucGFuZWxzLnJlYWx0aW1lRml0ID0gc2VuZGVyLmdldFZhbHVlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9DaGVja2JveFwiOjExLFwiLi4vLi4vLi4vZW55by9saWIvU2Nyb2xsZXJcIjo0NCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvQ29sbGFwc2luZ0FycmFuZ2VyXCI6ODIsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9MaXN0XCI6OTUsXCIuLi8uLi8uLi9sYXlvdXQvbGliL1BhbmVsc1wiOjk5fV0sMTMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0TGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvTGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuUGVyc2lzdGVudFN3aXBlYWJsZUl0ZW1TYW1wbGUnLFxuXHRraW5kOiBGaXR0YWJsZVJvd3MsXG5cdGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1wZXJzaXN0ZW50LXN3aXBlYWJsZS1pdGVtIGVueW8tZml0Jyxcblx0ZGF0YTogWydDYXQnLCdEb2cnLCdIaXBwb3BvdGFtdXMnXSxcblx0Y29tcG9uZW50czogW1xuXHRcdHtcblx0XHRcdGtpbmQ6IExpc3QsXG5cdFx0XHRjbGFzc2VzOiAnbGlzdC1zYW1wbGUtcGVyc2lzdGVudC1zd2lwZWFibGUtaXRlbS1saXN0IGVueW8tdW5zZWxlY3RhYmxlJyxcblx0XHRcdGZpdDogdHJ1ZSxcblx0XHRcdG11bHRpU2VsZWN0OiB0cnVlLFxuXHRcdFx0cmVvcmRlcmFibGU6IGZhbHNlLFxuXHRcdFx0ZW5hYmxlU3dpcGU6IHRydWUsXG5cdFx0XHRjZW50ZXJSZW9yZGVyQ29udGFpbmVyOiBmYWxzZSxcblx0XHRcdG9uU2V0dXBJdGVtOiAnc2V0dXBJdGVtJyxcblx0XHRcdG9uU2V0dXBTd2lwZUl0ZW06ICdzZXR1cFN3aXBlSXRlbScsXG5cdFx0XHRvblN3aXBlQ29tcGxldGU6ICdzd2lwZUNvbXBsZXRlJyxcblx0XHRcdGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdpdGVtJywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLXBlcnNpc3RlbnQtc3dpcGVhYmxlLWl0ZW0taXRlbScsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3RleHQnLCBjbGFzc2VzOiAnaXRlbUxhYmVsJywgYWxsb3dIdG1sOiB0cnVlfVxuXHRcdFx0XHRdfVxuXHRcdFx0XSxcblx0XHRcdHN3aXBlYWJsZUNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdzd2lwZUl0ZW0nLCBjbGFzc2VzOiAnZW55by1maXQgc3dpcGVHcmVlbicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ3N3aXBlVGl0bGUnLCBjbGFzc2VzOiAnc3dpcGVUaXRsZScsIGNvbnRlbnQ6ICdUaGlzIGlzIGEgdGVzdCd9XG5cdFx0XHRcdF19XG5cdFx0XHRdXG5cdFx0fVxuXHRdLFxuXHRyZW5kZXJlZDoga2luZC5pbmhlcml0KGZ1bmN0aW9uIChzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnBvcHVsYXRlTGlzdCgpO1xuXHRcdH07XG5cdH0pLFxuXHRwb3B1bGF0ZUxpc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLmRhdGEubGVuZ3RoKTtcblx0XHR0aGlzLiQubGlzdC5yZXNldCgpO1xuXHR9LFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYoIXRoaXMuZGF0YVtldmVudC5pbmRleF0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLiQudGV4dC5zZXRDb250ZW50KHRoaXMuZGF0YVtldmVudC5pbmRleF0pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRzZXR1cFN3aXBlSXRlbTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHRpZighdGhpcy5kYXRhW2V2ZW50LmluZGV4XSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYoZXZlbnQueERpcmVjdGlvbiA9PT0gLTEpIHtcblx0XHRcdC8vIFBlcnNpc3Qgc3dpcGVhYmxlIGl0ZW0gaWYgc3dpcGVkIGZyb20gcmlnaHQgdG8gbGVmdFxuXHRcdFx0dGhpcy4kLmxpc3Quc2V0UGVyc2lzdFN3aXBlYWJsZUl0ZW0odHJ1ZSk7XG5cdFx0XHR0aGlzLiQuc3dpcGVUaXRsZS5zZXRDb250ZW50KCdUaGlzIGlzIGEgcGVyc2lzdGVudCBpdGVtJyk7XG5cdFx0XHR0aGlzLiQuc3dpcGVJdGVtLnJlbW92ZUNsYXNzKCdzd2lwZUdyZWVuJyk7XG5cdFx0XHR0aGlzLiQuc3dpcGVJdGVtLmFkZENsYXNzKCdzd2lwZVJlZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEb24ndCBwZXJzaXN0IHN3aXBlYWJsZSBpdGVtIGlmIHN3aXBlZCBmcm9tIGxlZnQgdG8gcmlnaHRcblx0XHRcdHRoaXMuJC5saXN0LnNldFBlcnNpc3RTd2lwZWFibGVJdGVtKGZhbHNlKTtcblx0XHRcdHRoaXMuJC5zd2lwZVRpdGxlLnNldENvbnRlbnQoJ1RoaXMgaXMgbm90IGEgcGVyc2lzdGVudCBpdGVtJyk7XG5cdFx0XHR0aGlzLiQuc3dpcGVJdGVtLnJlbW92ZUNsYXNzKCdzd2lwZVJlZCcpO1xuXHRcdFx0dGhpcy4kLnN3aXBlSXRlbS5hZGRDbGFzcygnc3dpcGVHcmVlbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0c3dpcGVDb21wbGV0ZTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0xpc3RcIjo5NX1dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRkb20gPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9kb20nKSxcblx0bG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIvbG9nZ2VyJyksXG5cdHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vLi4vZW55by9saWIvcGxhdGZvcm0nKSxcblx0SW1hZ2UgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi9JbWFnZScpO1xuXG52YXJcblx0UGFuWm9vbVZpZXcgPSByZXF1aXJlKCcuL1Bhblpvb21WaWV3Jyk7XG5cbi8qKlxuKiB7QGxpbmsgZW55by5JbWFnZVZpZXd9IGlzIGEgY29udHJvbCB0aGF0IGRpc3BsYXlzIGFuIGltYWdlIGF0IGEgZ2l2ZW4gc2NhbGluZ1xuKiBmYWN0b3IsIHdpdGggZW5oYW5jZWQgc3VwcG9ydCBmb3IgZG91YmxlLXRhcC9kb3VibGUtY2xpY2sgdG8gem9vbSwgcGFubmluZyxcbiogbW91c2V3aGVlbCB6b29taW5nIGFuZCBwaW5jaC16b29tIChvbiB0b3VjaHNjcmVlbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCBpdCkuXG4qXG4qIGBgYFxuKiB7a2luZDogJ0ltYWdlVmlldycsIHNyYzogJ2Fzc2V0cy9nbG9iZS5qcGcnLCBzY2FsZTogJ2F1dG8nLCBzdHlsZTogJ3dpZHRoOjUwMHB4OyBoZWlnaHQ6NDAwcHg7J31cbiogYGBgXG4qXG4qIFRoZSBgb25sb2FkYCBhbmQgYG9uZXJyb3JgIGV2ZW50cyBidWJibGUgdXAgZnJvbSB0aGUgdW5kZXJseWluZyBpbWFnZVxuKiBlbGVtZW50IGFuZCBhbiBbb25ab29tXXtAbGluayBlbnlvLlBhblpvb21WaWV3I29uWm9vbX0gZXZlbnQgaXMgdHJpZ2dlcmVkXG4qIHdoZW4gdGhlIHVzZXIgY2hhbmdlcyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgaW1hZ2UuXG4qXG4qIElmIHlvdSB3aXNoLCB5b3UgbWF5IGFkZCB7QGxpbmsgZW55by5TY3JvbGxUaHVtYn0gaW5kaWNhdG9ycywgZGlzYWJsZSB6b29tXG4qIGFuaW1hdGlvbiwgYWxsb3cgcGFubmluZyBvdmVyc2Nyb2xsICh3aXRoIGEgYm91bmNlLWJhY2sgZWZmZWN0KSwgYW5kIGNvbnRyb2xcbiogdGhlIHByb3BhZ2F0aW9uIG9mIGRyYWcgZXZlbnRzLCBhbGwgdXNpbmcgdGhpcyBraW5kJ3MgQm9vbGVhbiBwcm9wZXJ0aWVzLlxuKlxuKiBOb3RlIHRoYXQgaXQncyBiZXN0IHRvIHNwZWNpZnkgYSBzaXplIGZvciB0aGUgSW1hZ2VWaWV3IGluIG9yZGVyIHRvIGF2b2lkXG4qIGNvbXBsaWNhdGlvbnMuXG4qXG4qIEB1aVxuKiBAY2xhc3MgZW55by5JbWFnZVZpZXdcbiogQGV4dGVuZHMgZW55by5QYW5ab29tVmlld1xuKiBAcHVibGljXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBraW5kKFxuXHQvKiogQGxlbmRzIGVueW8uSW1hZ2VWaWV3LnByb3RvdHlwZSAqLyB7XG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bmFtZTogJ2VueW8uSW1hZ2VWaWV3JyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBQYW5ab29tVmlldyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzdWJLaW5kQ29tcG9uZW50czogW1xuXHRcdHtraW5kOiBJbWFnZSwgb25kb3duOiAnZG93bicsIHN0eWxlOiAndmVydGljYWwtYWxpZ246IHRleHQtdG9wOyd9XG5cdF0sXG5cblx0LyoqXG5cdCogQG1ldGhvZFxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIG1vdmUgY29tcG9uZW50cyAobW9zdCBsaWtlbHkgaW1hZ2VWaWV3UGlucykgdG8gdW5zY2FsZWRDb21wb25lbnRzXG5cdFx0dGhpcy51bnNjYWxlZENvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG5cdFx0dGhpcy5jb21wb25lbnRzID0gW107XG5cblx0XHQvL2FtZW5kIGtpbmRDb21wb25lbnRzXG5cdFx0dGhpcy5raW5kQ29tcG9uZW50c1sxXS5jb21wb25lbnRzWzBdLmNvbXBvbmVudHMgPSB0aGlzLnN1YktpbmRDb21wb25lbnRzO1xuXG5cdFx0UGFuWm9vbVZpZXcucHJvdG90eXBlLmNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gc2V0IGNvbnRlbnQgYXMgaW5saW5lLWJsb2NrIHRvIG1pbWljIGJlaGF2aW91ciBvZiBhbiBpbWFnZVxuXHRcdHRoaXMuJC5jb250ZW50LmFwcGx5U3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lLWJsb2NrJyk7XG5cblx0XHQvL29mZnNjcmVlbiBidWZmZXIgaW1hZ2UgdG8gZ2V0IGluaXRpYWwgaW1hZ2UgZGltZW5zaW9uc1xuXHRcdC8vYmVmb3JlIGRpc3BsYXlpbmcgYSBzY2FsZWQgZG93biBpbWFnZSB0aGF0IGNhbiBmaXQgaW4gdGhlIGNvbnRhaW5lclxuXHRcdHRoaXMuYnVmZmVySW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblx0XHR0aGlzLmJ1ZmZlckltYWdlLm9ubG9hZCA9IHRoaXMuYmluZFNhZmVseSgnaW1hZ2VMb2FkZWQnKTtcblx0XHR0aGlzLmJ1ZmZlckltYWdlLm9uZXJyb3IgPSB0aGlzLmJpbmRTYWZlbHkoJ2ltYWdlRXJyb3InKTtcblx0XHR0aGlzLnNyY0NoYW5nZWQoKTtcblx0XHQvL1x0TmVlZGVkIHRvIGtpY2tvZmYgcGluIHJlZHJhd2luZyAob3RoZXJ3aXNlIHRoZXkgd29uJ3QgcmVkcmF3IG9uIGludGl0aWFsIHNjcm9sbClcblx0XHRpZih0aGlzLmdldFN0cmF0ZWd5KCkuJC5zY3JvbGxNYXRoKSB7XG5cdFx0XHR0aGlzLmdldFN0cmF0ZWd5KCkuJC5zY3JvbGxNYXRoLnN0YXJ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuYnVmZmVySW1hZ2UpIHtcblx0XHRcdHRoaXMuYnVmZmVySW1hZ2Uub25lcnJvciA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuYnVmZmVySW1hZ2Uub25lcnJvciA9IHVuZGVmaW5lZDtcblx0XHRcdGRlbGV0ZSB0aGlzLmJ1ZmZlckltYWdlO1xuXHRcdH1cblx0XHRQYW5ab29tVmlldy5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGRvd246IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly8gRml4IHRvIHByZXZlbnQgaW1hZ2UgZHJhZyBpbiBGaXJlZm94XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRzcmNDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYodGhpcy5zcmMgJiYgdGhpcy5zcmMubGVuZ3RoPjAgJiYgdGhpcy5idWZmZXJJbWFnZSAmJiB0aGlzLnNyYyE9dGhpcy5idWZmZXJJbWFnZS5zcmMpIHtcblx0XHRcdHRoaXMuYnVmZmVySW1hZ2Uuc3JjID0gdGhpcy5zcmM7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEhhbmRsZXMgYG9ubG9hZGAgZXZlbnRzIGJ1YmJsZWQgdXAgZnJvbSBjaGlsZHJlbiB0byByZXNldCB0aGUgc2NhbGUgd2hlblxuXHQqIHRoZSBpbWFnZSBjaGFuZ2VzLlxuXHQqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1hZ2VMb2FkZWQ6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuc2NhbGUgPSB0aGlzLnNjYWxlS2V5d29yZDtcblx0XHR0aGlzLm9yaWdpbmFsV2lkdGggPSB0aGlzLmNvbnRlbnRXaWR0aCA9IHRoaXMuYnVmZmVySW1hZ2Uud2lkdGg7XG5cdFx0dGhpcy5vcmlnaW5hbEhlaWdodCA9IHRoaXMuY29udGVudEhlaWdodCA9IHRoaXMuYnVmZmVySW1hZ2UuaGVpZ2h0O1xuXG5cdFx0Ly9zY2FsZSB0byBmaXQgYmVmb3JlIHNldHRpbmcgc3JjLCBzbyB1bnNjYWxlZCBpbWFnZSBpc24ndCB2aXNpYmxlXG5cdFx0dGhpcy5zY2FsZUNoYW5nZWQoKTtcblx0XHR0aGlzLiQuaW1hZ2Uuc2V0U3JjKHRoaXMuYnVmZmVySW1hZ2Uuc3JjKTtcblxuXHRcdC8vIFRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gU2FmYXJpIHdoZXJlIGR1ZSB0byB0aGUgdHJhbnNsYXRpb24gb2YgdGhlc2UgZWxlbWVudHMgaXRcblx0XHQvLyBkb2Vzbid0IGNvcnJlY3RseSByZW5kZXIgdW5sZXNzIHByb2RkZWRcblx0XHRpZiAocGxhdGZvcm0uc2FmYXJpKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMuJC5pbWFnZS5oYXNOb2RlKCksXG5cdFx0XHRcdHNyYyA9IHRoaXMuYnVmZmVySW1hZ2Uuc3JjO1xuXG5cdFx0XHRpZiAobikge1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgbi5zcmMgPSBzcmM7IH0sIDEwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIHRvIGVuc3VyZSBzY3JvbGxlciBjb250ZW50cyBoZWlnaHQvd2lkdGggaXMgY2FsY3VsYXRlZCBjb3JyZWN0bHkgd2hlbiBjb250ZW50cyB1c2UgZW55by1maXRcblx0XHRkb20udHJhbnNmb3JtVmFsdWUodGhpcy5nZXRTdHJhdGVneSgpLiQuY2xpZW50LCAndHJhbnNsYXRlM2QnLCAnMHB4LCAwcHgsIDAnKTtcblxuXHRcdHRoaXMucG9zaXRpb25DbGllbnRDb250cm9scyh0aGlzLnNjYWxlKTtcblx0XHR0aGlzLmFsaWduKCk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1hZ2VFcnJvcjogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0bG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIGltYWdlOiAnICsgdGhpcy5zcmMpO1xuXHRcdC8vYnViYmxlIHVwIHRoZSBlcnJvciBldmVudFxuXHRcdHRoaXMuYnViYmxlKCdvbmVycm9yJywgZXZlbnQpO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55by9saWIvSW1hZ2VcIjoyMyxcIi4uLy4uL2VueW8vbGliL2RvbVwiOjU4LFwiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vZW55by9saWIvbG9nZ2VyXCI6NjcsXCIuLi8uLi9lbnlvL2xpYi9wbGF0Zm9ybVwiOjcxLFwiLi9QYW5ab29tVmlld1wiOjk4fV0sMTI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKTtcblxudmFyXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdFBhblpvb21WaWV3ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9QYW5ab29tVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuUGFuWm9vbVZpZXdTYW1wbGUnLFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e2tpbmQ6IFBhblpvb21WaWV3LCBjb250ZW50V2lkdGg6IDYwMCwgY29udGVudEhlaWdodDogNjAwLCBjbGFzc2VzOiAncGFuem9vbXZpZXctZGVtbycsIG9uWm9vbTogJ3pvb20nLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAnSGVsbG8gV29ybGQnLCBzdHlsZTogJ2JhY2tncm91bmQ6IG9yYW5nZTsgd2lkdGg6IDIwMHB4OyBoZWlnaHQ6IDIwMHB4Oyd9LFxuXHRcdFx0XHR7Y29udGVudDogJ0hlbGxvIFdvcmxkJywgc3R5bGU6ICdiYWNrZ3JvdW5kOiBibHVlOyB3aWR0aDogMjAwcHg7IGhlaWdodDogMjAwcHg7J30sXG5cdFx0XHRcdHtjb250ZW50OiAnSGVsbG8gV29ybGQnLCBzdHlsZTogJ2JhY2tncm91bmQ6IGN5YW47IHdpZHRoOiAyMDBweDsgaGVpZ2h0OiAyMDBweDsnfVxuXHRcdFx0XX0sXG5cdFx0XHR7a2luZDogRml0dGFibGVDb2x1bW5zLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAnSGVsbG8gV29ybGQnLCBzdHlsZTogJ2JhY2tncm91bmQ6IGxpZ2h0Ymx1ZTsgd2lkdGg6IDIwMHB4OyBoZWlnaHQ6IDIwMHB4Oyd9LFxuXHRcdFx0XHR7Y29udGVudDogJ0hlbGxvIFdvcmxkJywgc3R5bGU6ICdiYWNrZ3JvdW5kOiB5ZWxsb3c7IHdpZHRoOiAyMDBweDsgaGVpZ2h0OiAyMDBweDsnfSxcblx0XHRcdFx0e2NvbnRlbnQ6ICdIZWxsbyBXb3JsZCcsIHN0eWxlOiAnYmFja2dyb3VuZDogcmVkOyB3aWR0aDogMjAwcHg7IGhlaWdodDogMjAwcHg7J31cblx0XHRcdF19LFxuXHRcdFx0e2tpbmQ6IEZpdHRhYmxlQ29sdW1ucywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7Y29udGVudDogJ0hlbGxvIFdvcmxkJywgc3R5bGU6ICdiYWNrZ3JvdW5kOiBicm93bjsgd2lkdGg6IDIwMHB4OyBoZWlnaHQ6IDIwMHB4Oyd9LFxuXHRcdFx0XHR7Y29udGVudDogJ0hlbGxvIFdvcmxkJywgc3R5bGU6ICdiYWNrZ3JvdW5kOiBncmVlbjsgd2lkdGg6IDIwMHB4OyBoZWlnaHQ6IDIwMHB4Oyd9LFxuXHRcdFx0XHR7Y29udGVudDogJ0hlbGxvIFdvcmxkJywgc3R5bGU6ICdiYWNrZ3JvdW5kOiBwaW5rOyB3aWR0aDogMjAwcHg7IGhlaWdodDogMjAwcHg7J31cblx0XHRcdF19XG5cdFx0XX0sXG5cblx0XHR7c3R5bGU6ICdwYWRkaW5nLXRvcDoxMHB4OyB3aWR0aDo2MCU7IG1hcmdpbjphdXRvOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtjb250ZW50OiAncGFuWm9vbVZpZXcgU2NhbGUnfSxcblx0XHRcdHtzdHlsZTogJ3RleHQtYWxpZ246Y2VudGVyOycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ2F1dG8nLCAgIG9udGFwOiAnYXV0b1NjYWxlJywgICBjbGFzc2VzOiAncGFuem9vbXZpZXctZGVtb0J1dHRvbid9LFxuXHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnd2lkdGgnLCAgb250YXA6ICd3aWR0aFNjYWxlJywgIGNsYXNzZXM6ICdwYW56b29tdmlldy1kZW1vQnV0dG9uJ30sXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdoZWlnaHQnLCBvbnRhcDogJ2hlaWdodFNjYWxlJywgY2xhc3NlczogJ3Bhbnpvb212aWV3LWRlbW9CdXR0b24nfSxcblx0XHRcdFx0e2tpbmQ6IEJ1dHRvbiwgY29udGVudDogJ2ZpdCcsICAgIG9udGFwOiAnZml0U2NhbGUnLCAgICBjbGFzc2VzOiAncGFuem9vbXZpZXctZGVtb0J1dHRvbid9LFxuXHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnMC41Jywgb250YXA6ICdoYWxmU2NhbGUnLCBjbGFzc2VzOiAncGFuem9vbXZpZXctZGVtb0J1dHRvbid9LFxuXHRcdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnMS4wJywgb250YXA6ICdub3JtYWxTY2FsZScsIGNsYXNzZXM6ICdwYW56b29tdmlldy1kZW1vQnV0dG9uJ30sXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICcyLjAnLCBvbnRhcDogJ2RvdWJsZVNjYWxlJywgY2xhc3NlczogJ3Bhbnpvb212aWV3LWRlbW9CdXR0b24nfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdLFxuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5zY2FsZSA9ICdhdXRvJztcblx0XHR9O1xuXHR9KSxcblx0aGFuZGxlUmVzaXplOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy4kLnBhblpvb21WaWV3LnNldFNjYWxlKHRoaXMuc2NhbGUpO1xuXHR9LFxuXHRhdXRvU2NhbGU6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dGhpcy5zY2FsZSA9ICdhdXRvJztcblx0XHR0aGlzLiQucGFuWm9vbVZpZXcuc2V0U2NhbGUodGhpcy5zY2FsZSk7XG5cdH0sXG5cdHdpZHRoU2NhbGU6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dGhpcy5zY2FsZSA9ICd3aWR0aCc7XG5cdFx0dGhpcy4kLnBhblpvb21WaWV3LnNldFNjYWxlKHRoaXMuc2NhbGUpO1xuXHR9LFxuXHRoZWlnaHRTY2FsZTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLnNjYWxlID0gJ2hlaWdodCc7XG5cdFx0dGhpcy4kLnBhblpvb21WaWV3LnNldFNjYWxlKHRoaXMuc2NhbGUpO1xuXHR9LFxuXHRmaXRTY2FsZTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLnNjYWxlID0gJ2ZpdCc7XG5cdFx0dGhpcy4kLnBhblpvb21WaWV3LnNldFNjYWxlKHRoaXMuc2NhbGUpO1xuXHR9LFxuXHRoYWxmU2NhbGU6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dGhpcy5zY2FsZSA9IDAuNTtcblx0XHR0aGlzLiQucGFuWm9vbVZpZXcuc2V0U2NhbGUodGhpcy5zY2FsZSk7XG5cdH0sXG5cdG5vcm1hbFNjYWxlOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMuc2NhbGUgPSAxLjA7XG5cdFx0dGhpcy4kLnBhblpvb21WaWV3LnNldFNjYWxlKHRoaXMuc2NhbGUpO1xuXHR9LFxuXHRkb3VibGVTY2FsZTogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHR0aGlzLnNjYWxlID0gMi4wO1xuXHRcdHRoaXMuJC5wYW5ab29tVmlldy5zZXRTY2FsZSh0aGlzLnNjYWxlKTtcblx0fVxufSk7XG5cbn0se1wiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlQ29sdW1uc1wiOjg1LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9QYW5ab29tVmlld1wiOjk4fV0sMTI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpO1xuXG52YXJcblx0UGFuWm9vbVZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL1Bhblpvb21WaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5QYW5ab29tVmlld1NhbXBsZTInLFxuXHRjbGFzc2VzOiAnZW55by11bnNlbGVjdGFibGUnLFxuXHRzdHlsZTogJ3dpZHRoOiA2MDBweDsgcGFkZGluZzogMjBweDsgYm9yZGVyOiAxcHggc29saWQgI2NjYzsgbWFyZ2luOiBhdXRvOycsXG5cdGNvbXBvbmVudHM6IFtcblxuXHQvLyBhZGQgem9vbSBpbiBhbmQgem9vbSBvdXQgY29udHJvbHNcblx0Ly8gYWRkIGRvd24gYW5kIHVwIGNvbnRyb2xzXG5cdFx0e2NvbnRlbnQ6ICdQbGVhc2UgcmV2aWV3IHRoaXMgZmluZSBwcmludDonLCB0YWc6ICdoMSd9LFxuXHRcdHtraW5kOiBQYW5ab29tVmlldywgc3R5bGU6ICd3aWR0aDogNjAwcHg7IGhlaWdodDogNDAwcHg7IGZvbnQtc2l6ZTogLjVlbTsnLCB0b3VjaE92ZXJzY3JvbGw6IHRydWUsIHRodW1iOiB0cnVlLCBzY2FsZTogJ3dpZHRoJywgY29udGVudFdpZHRoOiAxMjAwLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7Y2xhc3NlczogJ2VueW8tdW5zZWxlY3RhYmxlJywgY29udGVudDogJ1RydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLlRydWx5IGNyb3NzLXBsYXRmb3JtIFVzZSB0aGUgc2FtZSBmcmFtZXdvcmsgdG8gZGV2ZWxvcCBhcHBzIGZvciB0aGUgd2ViIGFuZCBmb3IgYWxsIG1ham9yIHBsYXRmb3JtcywgZGVza3RvcCBhbmQgbW9iaWxlLiAgRnJlZSBhbmQgb3Blbi1zb3VyY2UgMTAwJSBmcmVlIHRvIHVzZSwgRW55byBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gIEV4dGVuc2libGUgV2l0aCBhIHNtYWxsLCByb2NrLXNvbGlkIGNvcmUsIEVueW8gaXMgbW9kdWxhciBhbmQgZGVzaWduZWQgdG8gYmUgZXh0ZW5kZWQgYnkgdGhlIGRldmVsb3BlciBjb21tdW5pdHkuIEJ1aWx0IHRvIG1hbmFnZSBjb21wbGV4aXR5IEVueW9cXCdzIGVsZWdhbnQgY29tcG9uZW50IG1vZGVsIG1ha2VzIGl0IHNpbXBsZSB0byBidWlsZCBhbmQgbWFpbnRhaW4gZXZlbiB0aGUgbW9zdCBjb21wbGV4IGFwcHMuICBPcHRpbWl6ZWQgZm9yIG1vYmlsZSBFbnlvIGhhcyByb290cyBpbiBtb2JpbGUgYW5kIHdhcyBidWlsdCBmcm9tIHRoZSBncm91bmQgdXAgdG8gc2hpbmUgb24gdGFibGV0cyBhbmQgcGhvbmVzLiAgTGlnaHR3ZWlnaHQgJiBGYXN0IEVueW8gaXMgc21hbGwgKGNvcmUgaXMgPDI1ayBnemlwcGVkKSBhbmQgdHVuZWQgZm9yIHNwZWVkIGFuZCByZXNwb25zaXZlbmVzcyBvbiBhbGwgc3VwcG9ydGVkIHBsYXRmb3Jtcy5UcnVseSBjcm9zcy1wbGF0Zm9ybSBVc2UgdGhlIHNhbWUgZnJhbWV3b3JrIHRvIGRldmVsb3AgYXBwcyBmb3IgdGhlIHdlYiBhbmQgZm9yIGFsbCBtYWpvciBwbGF0Zm9ybXMsIGRlc2t0b3AgYW5kIG1vYmlsZS4gIEZyZWUgYW5kIG9wZW4tc291cmNlIDEwMCUgZnJlZSB0byB1c2UsIEVueW8gaXMgYXZhaWxhYmxlIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBFeHRlbnNpYmxlIFdpdGggYSBzbWFsbCwgcm9jay1zb2xpZCBjb3JlLCBFbnlvIGlzIG1vZHVsYXIgYW5kIGRlc2lnbmVkIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSBkZXZlbG9wZXIgY29tbXVuaXR5LiBCdWlsdCB0byBtYW5hZ2UgY29tcGxleGl0eSBFbnlvXFwncyBlbGVnYW50IGNvbXBvbmVudCBtb2RlbCBtYWtlcyBpdCBzaW1wbGUgdG8gYnVpbGQgYW5kIG1haW50YWluIGV2ZW4gdGhlIG1vc3QgY29tcGxleCBhcHBzLiAgT3B0aW1pemVkIGZvciBtb2JpbGUgRW55byBoYXMgcm9vdHMgaW4gbW9iaWxlIGFuZCB3YXMgYnVpbHQgZnJvbSB0aGUgZ3JvdW5kIHVwIHRvIHNoaW5lIG9uIHRhYmxldHMgYW5kIHBob25lcy4gIExpZ2h0d2VpZ2h0ICYgRmFzdCBFbnlvIGlzIHNtYWxsIChjb3JlIGlzIDwyNWsgZ3ppcHBlZCkgYW5kIHR1bmVkIGZvciBzcGVlZCBhbmQgcmVzcG9uc2l2ZW5lc3Mgb24gYWxsIHN1cHBvcnRlZCBwbGF0Zm9ybXMuVHJ1bHkgY3Jvc3MtcGxhdGZvcm0gVXNlIHRoZSBzYW1lIGZyYW1ld29yayB0byBkZXZlbG9wIGFwcHMgZm9yIHRoZSB3ZWIgYW5kIGZvciBhbGwgbWFqb3IgcGxhdGZvcm1zLCBkZXNrdG9wIGFuZCBtb2JpbGUuICBGcmVlIGFuZCBvcGVuLXNvdXJjZSAxMDAlIGZyZWUgdG8gdXNlLCBFbnlvIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgRXh0ZW5zaWJsZSBXaXRoIGEgc21hbGwsIHJvY2stc29saWQgY29yZSwgRW55byBpcyBtb2R1bGFyIGFuZCBkZXNpZ25lZCB0byBiZSBleHRlbmRlZCBieSB0aGUgZGV2ZWxvcGVyIGNvbW11bml0eS4gQnVpbHQgdG8gbWFuYWdlIGNvbXBsZXhpdHkgRW55b1xcJ3MgZWxlZ2FudCBjb21wb25lbnQgbW9kZWwgbWFrZXMgaXQgc2ltcGxlIHRvIGJ1aWxkIGFuZCBtYWludGFpbiBldmVuIHRoZSBtb3N0IGNvbXBsZXggYXBwcy4gIE9wdGltaXplZCBmb3IgbW9iaWxlIEVueW8gaGFzIHJvb3RzIGluIG1vYmlsZSBhbmQgd2FzIGJ1aWx0IGZyb20gdGhlIGdyb3VuZCB1cCB0byBzaGluZSBvbiB0YWJsZXRzIGFuZCBwaG9uZXMuICBMaWdodHdlaWdodCAmIEZhc3QgRW55byBpcyBzbWFsbCAoY29yZSBpcyA8MjVrIGd6aXBwZWQpIGFuZCB0dW5lZCBmb3Igc3BlZWQgYW5kIHJlc3BvbnNpdmVuZXNzIG9uIGFsbCBzdXBwb3J0ZWQgcGxhdGZvcm1zLid9XG5cdFx0XX1cblx0XVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvUGFuWm9vbVZpZXdcIjo5OH1dLDEyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi91dGlscycpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKSxcblx0SW1hZ2UgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZScpO1xuXG52YXJcblx0UGFuWm9vbVZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL1Bhblpvb21WaWV3Jyk7XG5cbnZhciBJbWFnZXNWaWV3ID0ga2luZCh7XG5cdHdpZHRoOiAwLFxuXHRoZWlnaHQ6IDAsXG5cdHB1Ymxpc2hlZDoge1xuXHRcdHNyYyA6ICcnXG5cdH0sXG5cdGNvbXBvbmVudHM6W1xuXHRcdHtraW5kOiBJbWFnZSwgb25sb2FkOiAnbG9hZCcsIG9uZG93bjogJ2Rvd24nfSxcblx0XHR7a2luZDogSW1hZ2UsIG9ubG9hZDogJ2xvYWQnLCBvbmRvd246ICdkb3duJ31cblx0XSxcblx0Y3JlYXRlOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuc3JjQ2hhbmdlZCgpO1xuXHRcdH07XG5cdH0pLFxuXHRzcmNDaGFuZ2VkOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy53aWR0aCA9IDA7XG5cdFx0dGhpcy4kLmltYWdlLnNldFNyYyh0aGlzLnNyYyk7XG5cdFx0dGhpcy4kLmltYWdlMi5zZXRTcmModGhpcy5zcmMpO1xuXHR9LFxuXHRsb2FkOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCl7XG5cdFx0dGhpcy53aWR0aCArPSBpbkV2ZW50Lm9yaWdpbmF0b3Iubm9kZS5jbGllbnRXaWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBpbkV2ZW50Lm9yaWdpbmF0b3Iubm9kZS5jbGllbnRIZWlnaHQpO1xuXHRcdHRoaXMuYnViYmxlKCdvblNldERpbWVuc2lvbnMnLCB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pO1xuXHR9LFxuXHRkb3duOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdC8vIEZpeCB0byBwcmV2ZW50IGltYWdlIGRyYWcgaW4gRmlyZWZveFxuXHRcdGluRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBraW5kKHtcblx0bmFtZTogJ2VueW8uc2FtcGxlLlBhblpvb21WaWV3U2FtcGxlMycsXG5cdGNsYXNzZXM6ICdlbnlvLXVuc2VsZWN0YWJsZScsXG5cdHN0eWxlOiAnd2lkdGg6IDYwMHB4OyBib3JkZXI6IDFweCBzb2xpZCAjY2NjOyBtYXJnaW46IGF1dG87Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtraW5kOiBQYW5ab29tVmlldywgc3R5bGU6ICd3aWR0aDogMTAwJTsgaGVpZ2h0OiA0MDBweDsnLCBzY2FsZTogJ2ZpdCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnaW1hZ2VzVmlldycsIGtpbmQ6IEltYWdlc1ZpZXcsIHNyYzogJ2Fzc2V0cy9nbG9iZS5qcGcnfVxuXHRcdF19LFxuXHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdjaGFuZ2UgaW1hZ2UnLCBvbnRhcDogJ2NoYW5nZUltYWdlJ31cblx0XSxcblx0cGxhbmV0czogWydhc3NldHMvZ2xvYmUuanBnJywgJ2Fzc2V0cy9lYXJ0aC5qcGcnLCAnYXNzZXRzL2p1cGl0ZXIuanBnJywgJ2Fzc2V0cy9tYXJzLmpwZycsICdhc3NldHMvbWVyY3VyeS5qcGcnLCAnYXNzZXRzL25lcHR1bmUuanBnJywgJ2Fzc2V0cy9zYXR1cm4uanBnJywgJ2Fzc2V0cy91cmFudXMuanBnJywgJ2Fzc2V0cy92ZW51cy5qcGcnXSxcblx0Y2hhbmdlSW1hZ2U6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGltYWdldmlldyA9IHRoaXMuJC5wYW5ab29tVmlldy4kLmltYWdlc1ZpZXc7XG5cdFx0aW1hZ2V2aWV3LnNldFNyYyggdGhpcy5wbGFuZXRzWyAodXRpbHMuaW5kZXhPZihpbWFnZXZpZXcuc3JjLCB0aGlzLnBsYW5ldHMpKzEpJXRoaXMucGxhbmV0cy5sZW5ndGggXSApO1xuXHR9XG59KTtcbn0se1wiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZVwiOjIzLFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4uLy4uLy4uL2xheW91dC9saWIvUGFuWm9vbVZpZXdcIjo5OH1dLDExODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0am9iID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvam9iJyksXG5cdHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvdXRpbHMnKSxcblx0QnV0dG9uID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQnV0dG9uJyksXG5cdENoZWNrYm94ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvQ2hlY2tib3gnKSxcblx0SW1hZ2UgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZScpLFxuXHRJbnB1dCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0lucHV0JyksXG5cdFBvcHVwID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvUG9wdXAnKTtcblxudmFyXG5cdEZpdHRhYmxlQ29sdW1ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVDb2x1bW5zJyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyksXG5cdEFyb3VuZExpc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0Fyb3VuZExpc3QnKTtcblxudmFyXG5cdG5hbWVzID0gcmVxdWlyZSgnLi9OYW1lR2VuZXJhdG9yJyk7XG5cbi8vIEl0J3MgY29udmVuaWVudCB0byBjcmVhdGUgYSBraW5kIGZvciB0aGUgaXRlbSB3ZSdsbCByZW5kZXIgaW4gdGhlIGNvbnRhY3RzIGxpc3QuXG52YXIgQXJvdW5kTGlzdENvbnRhY3RJdGVtID0ga2luZCh7XG5cdGV2ZW50czoge1xuXHRcdG9uUmVtb3ZlOiAnJ1xuXHR9LFxuXHRjb21wb25lbnRzOiBbXG5cdFx0e25hbWU6ICdhdmF0YXInLCBraW5kOiBJbWFnZSwgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWFyb3VuZC1hdmF0YXInfSxcblx0XHR7Y29tcG9uZW50czogW1xuXHRcdFx0e25hbWU6ICduYW1lJywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWFyb3VuZC1uYW1lJ30sXG5cdFx0XHR7bmFtZTogJ3RpdGxlJywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWFyb3VuZC1kZXNjcmlwdGlvbid9LFxuXHRcdFx0e2NvbnRlbnQ6ICcoNDE1KSA3MTEtMTIzNCcsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1hcm91bmQtZGVzY3JpcHRpb24nfVxuXHRcdF19LFxuXHRcdHtuYW1lOiAncmVtb3ZlJywga2luZDogSW1hZ2UsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1hcm91bmQtcmVtb3ZlLWJ1dHRvbicsIHNyYzogJ2Fzc2V0cy9yZW1vdmUtaWNvbi5wbmcnLCBvbnRhcDogJ3JlbW92ZVRhcCd9XG5cdF0sXG5cdHNldENvbnRhY3Q6IGZ1bmN0aW9uIChjb250YWN0KSB7XG5cdFx0dGhpcy4kLm5hbWUuc2V0Q29udGVudChjb250YWN0Lm5hbWUpO1xuXHRcdHRoaXMuJC5hdmF0YXIuc2V0U3JjKGNvbnRhY3QuYXZhdGFyKTtcblx0XHR0aGlzLiQudGl0bGUuc2V0Q29udGVudChjb250YWN0LnRpdGxlKTtcblx0fSxcblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuXHRcdHRoaXMuYWRkUmVtb3ZlQ2xhc3MoJ2xpc3Qtc2FtcGxlLWFyb3VuZC1pdGVtLXNlbGVjdGVkJywgc2VsZWN0ZWQpO1xuXHRcdHRoaXMuJC5yZW1vdmUuYXBwbHlTdHlsZSgnZGlzcGxheScsIHNlbGVjdGVkID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZScpO1xuXHR9LFxuXHRyZW1vdmVUYXA6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dGhpcy5kb1JlbW92ZSh7aW5kZXg6IGV2ZW50LmluZGV4fSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuTGlzdEFyb3VuZFNhbXBsZScsXG5cdGtpbmQ6IEZpdHRhYmxlUm93cyxcblx0Y2xhc3NlczogJ2VueW8tZml0IGVueW8tdW5zZWxlY3RhYmxlJyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnbGlzdCcsIGtpbmQ6IEFyb3VuZExpc3QsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1hcm91bmQnLCBmaXQ6IHRydWUsIG11bHRpU2VsZWN0OiB0cnVlLCBvblNldHVwSXRlbTogJ3NldHVwSXRlbScsIGFib3ZlQ29tcG9uZW50czogW1xuXHRcdFx0e2tpbmQ6IEZpdHRhYmxlQ29sdW1ucywgY2xhc3NlczogJ2xheW91dC1zYW1wbGUtdG9vbGJhcicsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6IEZpdHRhYmxlQ29sdW1ucywgdGFnOiAnbGFiZWwnLCBmaXQ6IHRydWUsIG5vU3RyZXRjaDogdHJ1ZSwgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHtraW5kOiBJbnB1dCwgcGxhY2Vob2xkZXI6ICdTZWFyY2guLi4nLCBmaXQ6IHRydWUsIG9uaW5wdXQ6ICdzZWFyY2hJbnB1dENoYW5nZSd9LFxuXHRcdFx0XHRcdHtraW5kOiBJbWFnZSwgc3JjOiAnYXNzZXRzL3NlYXJjaC1pbnB1dC1zZWFyY2gucG5nJywgc3R5bGU6ICdoZWlnaHQ6IDIwcHg7IHdpZHRoOiAyMHB4Oyd9XG5cdFx0XHRcdF19XG5cdFx0XHRdfVxuXHRcdF0sIGNvbXBvbmVudHM6IFtcblx0XHRcdHtuYW1lOiAnZGl2aWRlcicsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1hcm91bmQtZGl2aWRlcid9LFxuXHRcdFx0e25hbWU6ICdpdGVtJywga2luZDogQXJvdW5kTGlzdENvbnRhY3RJdGVtLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtYXJvdW5kLWl0ZW0gZW55by1ib3JkZXItYm94Jywgb25SZW1vdmU6ICdyZW1vdmVUYXAnfVxuXHRcdF19LFxuXHRcdHtuYW1lOiAncG9wdXAnLCBraW5kOiBQb3B1cCwgbW9kYWw6IHRydWUsIGNlbnRlcmVkOiB0cnVlLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtYXJvdW5kLXBvcHVwJywgY29tcG9uZW50czogW1xuXHRcdFx0e2NvbXBvbmVudHM6IFtcblx0XHRcdFx0e2NvbnRlbnQ6ICdjb3VudDonLCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtYXJvdW5kLWxhYmVsJ30sXG5cdFx0XHRcdHt0YWc6ICdsYWJlbCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0XHR7bmFtZTogJ2NvdW50SW5wdXQnLCBraW5kOiBJbnB1dCwgc3R5bGU6ICd3aWR0aDogODBweCcsIHZhbHVlOiAxMDB9XG5cdFx0XHRcdF19XG5cdFx0XHRdfSxcblx0XHRcdHtjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAncm93c1BlclBhZ2U6JywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWFyb3VuZC1sYWJlbCd9LFxuXHRcdFx0XHR7dGFnOiAnbGFiZWwnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdFx0e25hbWU6ICdyb3dzUGVyUGFnZUlucHV0Jywga2luZDogSW5wdXQsIHN0eWxlOiAnd2lkdGg6IDgwcHgnLCB2YWx1ZTogNTB9XG5cdFx0XHRcdF19XG5cdFx0XHRdfSxcblx0XHRcdHtjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtjb250ZW50OiAnaGlkZSBkaXZpZGVyOicsIGNsYXNzZXM6ICdsaXN0LXNhbXBsZS1hcm91bmQtbGFiZWwnfSxcblx0XHRcdFx0e25hbWU6ICdoaWRlRGl2aWRlckNoZWNrYm94Jywga2luZDogQ2hlY2tib3h9XG5cdFx0XHRdfSxcblx0XHRcdHtjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdwb3B1bGF0ZSBsaXN0JywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLWFyb3VuZC1wb3B1bGF0ZS1idXR0b24nLCBvbnRhcDogJ3BvcHVsYXRlTGlzdCd9XG5cdFx0XHRdfVxuXHRcdF19XG5cdF0sXG5cdHJlbmRlcmVkOiBraW5kLmluaGVyaXQoZnVuY3Rpb24oc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnBvcHVsYXRlTGlzdCgpO1xuXHRcdH07XG5cdH0pLFxuXHRzZXR1cEl0ZW06IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dmFyIGkgPSBpbkV2ZW50LmluZGV4O1xuXHRcdHZhciBkYXRhID0gdGhpcy5maWx0ZXIgPyB0aGlzLmZpbHRlcmVkIDogdGhpcy5kYjtcblx0XHR2YXIgaXRlbSA9IGRhdGFbaV07XG5cdFx0Ly8gY29udGVudFxuXHRcdHRoaXMuJC5pdGVtLnNldENvbnRhY3QoaXRlbSk7XG5cdFx0Ly8gc2VsZWN0aW9uXG5cdFx0dGhpcy4kLml0ZW0uc2V0U2VsZWN0ZWQoaW5TZW5kZXIuaXNTZWxlY3RlZChpKSk7XG5cdFx0Ly8gZGl2aWRlclxuXHRcdGlmICghdGhpcy5oaWRlRGl2aWRlcikge1xuXHRcdFx0dmFyIGQgPSBpdGVtLm5hbWVbMF07XG5cdFx0XHR2YXIgcHJldiA9IGRhdGFbaS0xXTtcblx0XHRcdHZhciBzaG93ZCA9IGQgIT0gKHByZXYgJiYgcHJldi5uYW1lWzBdKTtcblx0XHRcdHRoaXMuJC5kaXZpZGVyLnNldENvbnRlbnQoZCk7XG5cdFx0XHR0aGlzLiQuZGl2aWRlci5jYW5HZW5lcmF0ZSA9IHNob3dkO1xuXHRcdFx0dGhpcy4kLml0ZW0uYXBwbHlTdHlsZSgnYm9yZGVyLXRvcCcsIHNob3dkID8gJ25vbmUnIDogbnVsbCk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRyZWZyZXNoTGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZmlsdGVyKSB7XG5cdFx0XHR0aGlzLmZpbHRlcmVkID0gdGhpcy5nZW5lcmF0ZUZpbHRlcmVkRGF0YSh0aGlzLmZpbHRlcik7XG5cdFx0XHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLmZpbHRlcmVkLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJC5saXN0LnNldENvdW50KHRoaXMuZGIubGVuZ3RoKTtcblx0XHR9XG5cdFx0dGhpcy4kLmxpc3QucmVmcmVzaCgpO1xuXHR9LFxuXHRhZGRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuZ2VuZXJhdGVJdGVtKHV0aWxzLmNhcCh0aGlzLiQubmV3Q29udGFjdElucHV0LmdldFZhbHVlKCkpKTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICh2YXIgZGk7IChkaT10aGlzLmRiW2ldKTsgaSsrKSB7XG5cdFx0XHRpZiAoZGkubmFtZSA+IGl0ZW0ubmFtZSkge1xuXHRcdFx0XHR0aGlzLmRiLnNwbGljZShpLCAwLCBpdGVtKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMucmVmcmVzaExpc3QoKTtcblx0XHR0aGlzLiQubGlzdC5zY3JvbGxUb1JvdyhpKTtcblx0fSxcblx0cmVtb3ZlSXRlbTogZnVuY3Rpb24oaW5JbmRleCkge1xuXHRcdHRoaXMuX3JlbW92ZUl0ZW0oaW5JbmRleCk7XG5cdFx0dGhpcy5yZWZyZXNoTGlzdCgpO1xuXHRcdHRoaXMuJC5saXN0LmdldFNlbGVjdGlvbigpLmRlc2VsZWN0KGluSW5kZXgpO1xuXHR9LFxuXHRfcmVtb3ZlSXRlbTogZnVuY3Rpb24oaW5JbmRleCkge1xuXHRcdHZhciBpID0gdGhpcy5maWx0ZXIgPyB0aGlzLmZpbHRlcmVkW2luSW5kZXhdLmRiSW5kZXggOiBpbkluZGV4O1xuXHRcdHRoaXMuZGIuc3BsaWNlKGksIDEpO1xuXHR9LFxuXHRyZW1vdmVUYXA6IGZ1bmN0aW9uKGluU2VuZGVyLCBpbkV2ZW50KSB7XG5cdFx0dGhpcy5yZW1vdmVJdGVtKGluRXZlbnQuaW5kZXgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRwb3B1bGF0ZUxpc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuJC5wb3B1cC5oaWRlKCk7XG5cdFx0dGhpcy5jcmVhdGVEYih0aGlzLiQuY291bnRJbnB1dC5nZXRWYWx1ZSgpKTtcblx0XHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLmRiLmxlbmd0aCk7XG5cdFx0dGhpcy4kLmxpc3Quc2V0Um93c1BlclBhZ2UodGhpcy4kLnJvd3NQZXJQYWdlSW5wdXQuZ2V0VmFsdWUoKSk7XG5cdFx0Ly9cblx0XHR0aGlzLmhpZGVEaXZpZGVyID0gdGhpcy4kLmhpZGVEaXZpZGVyQ2hlY2tib3guZ2V0VmFsdWUoKTtcblx0XHR0aGlzLiQuZGl2aWRlci5jYW5HZW5lcmF0ZSA9ICF0aGlzLmhpZGVEaXZpZGVyO1xuXHRcdC8vXG5cdFx0dGhpcy4kLmxpc3QucmVzZXQoKTtcblx0XHR0aGlzLiQubGlzdC5zY3JvbGxUb0NvbnRlbnRTdGFydCgpO1xuXHR9LFxuXHRjcmVhdGVEYjogZnVuY3Rpb24oaW5Db3VudCkge1xuXHRcdC8qIGdsb2JhbCBtYWtlTmFtZSAqL1xuXHRcdHRoaXMuZGIgPSBbXTtcblx0XHRmb3IgKHZhciBpPTA7IGk8aW5Db3VudDsgaSsrKSB7XG5cdFx0XHR0aGlzLmRiLnB1c2godGhpcy5nZW5lcmF0ZUl0ZW0obmFtZXMubWFrZU5hbWUoNCwgNikgKyAnICcgKyBuYW1lcy5tYWtlTmFtZSg1LCAxMCkpKTtcblx0XHR9XG5cdFx0dGhpcy5zb3J0RGIoKTtcblx0fSxcblx0Z2VuZXJhdGVJdGVtOiBmdW5jdGlvbihpbk5hbWUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogaW5OYW1lLFxuXHRcdFx0YXZhdGFyOiAnYXNzZXRzL2F2YXRhcnMvJyArIGF2YXRhcnNbdXRpbHMuaXJhbmQoYXZhdGFycy5sZW5ndGgpXSxcblx0XHRcdHRpdGxlOiB0aXRsZXNbdXRpbHMuaXJhbmQodGl0bGVzLmxlbmd0aCldXG5cdFx0fTtcblx0fSxcblx0c29ydERiOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRiLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0aWYgKGEubmFtZSA8IGIubmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChhLm5hbWUgPiBiLm5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdHNob3dTZXR1cFBvcHVwOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLiQucG9wdXAuc2hvdygpO1xuXHR9LFxuXHRzZWFyY2hJbnB1dENoYW5nZTogZnVuY3Rpb24oaW5TZW5kZXIpIHtcblx0XHRqb2IodGhpcy5pZCArICc6c2VhcmNoJywgdGhpcy5iaW5kU2FmZWx5KCdmaWx0ZXJMaXN0JywgaW5TZW5kZXIuZ2V0VmFsdWUoKSksIDIwMCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGZpbHRlckxpc3Q6IGZ1bmN0aW9uKGluRmlsdGVyKSB7XG5cdFx0aWYgKGluRmlsdGVyICE9IHRoaXMuZmlsdGVyKSB7XG5cdFx0XHR0aGlzLmZpbHRlciA9IGluRmlsdGVyO1xuXHRcdFx0dGhpcy5maWx0ZXJlZCA9IHRoaXMuZ2VuZXJhdGVGaWx0ZXJlZERhdGEoaW5GaWx0ZXIpO1xuXHRcdFx0dGhpcy4kLmxpc3Quc2V0Q291bnQodGhpcy5maWx0ZXJlZC5sZW5ndGgpO1xuXHRcdFx0dGhpcy4kLmxpc3QucmVzZXQoKTtcblx0XHR9XG5cdH0sXG5cdGdlbmVyYXRlRmlsdGVyZWREYXRhOiBmdW5jdGlvbihpbkZpbHRlcikge1xuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsgaW5GaWx0ZXIsICdpJyk7XG5cdFx0dmFyIHIgPSBbXTtcblx0XHRmb3IgKHZhciBpPTAsIGQ7IChkPXRoaXMuZGJbaV0pOyBpKyspIHtcblx0XHRcdGlmIChkLm5hbWUubWF0Y2gocmUpKSB7XG5cdFx0XHRcdGQuZGJJbmRleCA9IGk7XG5cdFx0XHRcdHIucHVzaChkKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHI7XG5cdH1cbn0pO1xuXG52YXIgYXZhdGFycyA9IFtcblx0J2FuZ2VsLnBuZycsXG5cdCdhc3Ryb2xvZ2VyLnBuZycsXG5cdCdhdGhsZXRlLnBuZycsXG5cdCdiYWJ5LnBuZycsXG5cdCdjbG93bi5wbmcnLFxuXHQnZGV2aWwucG5nJyxcblx0J2RvY3Rvci5wbmcnLFxuXHQnZHVkZS5wbmcnLFxuXHQnZHVkZTIucG5nJyxcblx0J2R1ZGUzLnBuZycsXG5cdCdkdWRlNC5wbmcnLFxuXHQnZHVkZTUucG5nJyxcblx0J2R1ZGU2LnBuZydcbl07XG52YXIgdGl0bGVzID0gW1xuXHQnUmVnaW9uYWwgRGF0YSBQcm9kdWNlcicsXG5cdCdJbnRlcm5hbCBNYXJrZXRzIEFkbWluaXN0cmF0b3InLFxuXHQnQ2VudHJhbCBTb2x1dGlvbnMgUHJvZHVjZXInLFxuXHQnRHluYW1pYyBQcm9ncmFtIEV4ZWN1dGl2ZScsXG5cdCdEaXJlY3QgQ29uZmlndXJhdGlvbiBFeGVjdXRpdmUnLFxuXHQnSW50ZXJuYXRpb25hbCBNYXJrZXRpbmcgQXNzaXN0YW50Jyxcblx0J0Rpc3RyaWN0IFJlc2VhcmNoIENvbnN1bHRhbnQnLFxuXHQnTGVhZCBJbnRyYW5ldCBDb29yZGluYXRvcicsXG5cdCdDZW50cmFsIEFjY291bnRhYmlsaXR5IERpcmVjdG9yJyxcblx0J1Byb2R1Y3QgV2ViIEFzc2lzdGFudCdcbl07XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvQ2hlY2tib3hcIjoxMSxcIi4uLy4uLy4uL2VueW8vbGliL0ltYWdlXCI6MjMsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dFwiOjI0LFwiLi4vLi4vLi4vZW55by9saWIvUG9wdXBcIjozNyxcIi4uLy4uLy4uL2VueW8vbGliL2pvYlwiOjYzLFwiLi4vLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4uLy4uLy4uL2xheW91dC9saWIvQXJvdW5kTGlzdFwiOjc3LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZUNvbHVtbnNcIjo4NSxcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuL05hbWVHZW5lcmF0b3JcIjoxMjV9XSwxMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyksXG5cdGpzb24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9qc29uJyksXG5cdEFqYXggPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9BamF4JyksXG5cdEJ1dHRvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0J1dHRvbicpLFxuXHRJbWFnZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0ltYWdlJyksXG5cdElucHV0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSW5wdXQnKSxcblx0SnNvbnBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvSnNvbnAnKTtcblxudmFyXG5cdFB1bGxkb3duTGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvUHVsbGRvd25MaXN0JyksXG5cdEZpdHRhYmxlUm93cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2luZCh7XG5cdG5hbWU6ICdlbnlvLnNhbXBsZS5MaXN0UHVsbGRvd25TYW1wbGUnLFxuXHRjbGFzc2VzOiAnZW55by11bnNlbGVjdGFibGUgZW55by1maXQgb255eCcsXG5cdGtpbmQ6IEZpdHRhYmxlUm93cyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgY29tcG9uZW50czogW1xuXHRcdFx0e2xhYmVsOiAnbGFiZWwnLCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAnc2VhcmNoSW5wdXQnLCBraW5kOiBJbnB1dCwgdmFsdWU6ICduYXR1cmUnLCBwbGFjZWhvbGRlcjogJ0VudGVyIHNlYWNoIHRlcm0nfSxcblx0XHRcdFx0e2tpbmQ6IEltYWdlLCBzcmM6ICdhc3NldHMvc2VhcmNoLWlucHV0LXNlYXJjaC5wbmcnLCBzdHlsZTogJ3dpZHRoOiAyMHB4Oyd9XG5cdFx0XHRdfSxcblx0XHRcdHtraW5kOiBCdXR0b24sIGNvbnRlbnQ6ICdzZWFyY2gnLCBvbnRhcDogJ3NlYXJjaCd9XG5cdFx0XX0sXG5cdFx0e25hbWU6ICdsaXN0Jywga2luZDogUHVsbGRvd25MaXN0LCBjbGFzc2VzOiAnbGlzdC1zYW1wbGUtcHVsbGRvd24tbGlzdCcsIGZpdDogdHJ1ZSwgb25TZXR1cEl0ZW06ICdzZXR1cEl0ZW0nLCBvblB1bGxSZWxlYXNlOiAncHVsbFJlbGVhc2UnLCBvblB1bGxDb21wbGV0ZTogJ3B1bGxDb21wbGV0ZScsIGNvbXBvbmVudHM6IFtcblx0XHRcdHtzdHlsZTogJ3BhZGRpbmc6IDEwcHg7IGhlaWdodDo3MHB4JywgY2xhc3NlczogJ2xpc3Qtc2FtcGxlLXB1bGxkb3duLWl0ZW0gZW55by1ib3JkZXItYm94JywgY29tcG9uZW50czogW1xuXHRcdFx0XHR7bmFtZTogJ2ljb24nLCBraW5kOiBJbWFnZSwgc3R5bGU6ICdmbG9hdDogbGVmdDsgd2lkdGg6IDQ4cHg7IGhlaWdodDogNDhweDsgcGFkZGluZzogMCAxMHB4IDEwcHggMDsnfSxcblx0XHRcdFx0e25hbWU6ICduYW1lJywgdGFnOiAnc3BhbicsIHN0eWxlOiAnZm9udC13ZWlnaHQ6IGJvbGQ7J31cblx0XHRcdF19XG5cdFx0XX1cblx0XSxcblx0cmVuZGVyZWQ6IGtpbmQuaW5oZXJpdChmdW5jdGlvbihzdXApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRzdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuc2VhcmNoKCk7XG5cdFx0fTtcblx0fSksXG5cdHB1bGxSZWxlYXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnB1bGxlZCA9IHRydWU7XG5cdFx0Ly8gYWRkIDEgc2Vjb25kIGRlbGF5IHNvIHdlIGNhbiBzZWUgdGhlIGxvYWRpbmcgbWVzc2FnZVxuXHRcdHNldFRpbWVvdXQodGhpcy5iaW5kU2FmZWx5KGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zZWFyY2goKTtcblx0XHR9KSwgMTAwMCk7XG5cdH0sXG5cdHB1bGxDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wdWxsZWQgPSBmYWxzZTtcblx0XHR0aGlzLiQubGlzdC5yZXNldCgpO1xuXHR9LFxuXHRzZWFyY2g6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIENhcHR1cmUgc2VhcmNoVGV4dCBhbmQgc3RyaXAgYW55IHdoaXRlc3BhY2Vcblx0XHR2YXIgc2VhcmNoVGV4dCA9IHRoaXMuJC5zZWFyY2hJbnB1dC5nZXRWYWx1ZSgpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcblx0XHRpZiAoc2VhcmNoVGV4dCA9PT0gJycpIHtcblx0XHRcdC8vIEZvciB3aGl0ZXNwYWNlIHNlYXJjaGVzLCBzZXQgbmV3IGNvbnRlbnQgdmFsdWUgaW4gb3JkZXIgdG8gZGlzcGxheSBwbGFjZWhvbGRlclxuXHRcdFx0dGhpcy4kLnNlYXJjaElucHV0LnNldFZhbHVlKHNlYXJjaFRleHQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnNlYXJjaEZsaWNrcihzZWFyY2hUZXh0KTtcblx0fSxcblx0c2VhcmNoRmxpY2tyOiBmdW5jdGlvbihpblNlYXJjaFRleHQpIHtcblx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0bWV0aG9kOiAnZmxpY2tyLnBob3Rvcy5zZWFyY2gnLFxuXHRcdFx0Zm9ybWF0OiAnanNvbicsXG5cdFx0XHRhcGlfa2V5OiAnMmEyMWI0NmU1OGQyMDdlNDg4OGUxZWNlMGNiMTQ5YTUnLFxuXHRcdFx0cGVyX3BhZ2U6IDUwLFxuXHRcdFx0cGFnZTogMCxcblx0XHRcdHRleHQ6IGluU2VhcmNoVGV4dCxcblx0XHRcdHNvcnQ6ICdkYXRlLXBvc3RlZC1kZXNjJyxcblx0XHRcdGV4dHJhczogJ3VybF9tJ1xuXHRcdH0sIHVybCA9ICdodHRwczovL2FwaS5mbGlja3IuY29tL3NlcnZpY2VzL3Jlc3QvJztcblx0XHRpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnbXMtYXBweDonKSB7XG5cdFx0XHRwYXJhbXMubm9qc29uY2FsbGJhY2sgPSAxO1xuXHRcdFx0Ly8gVXNlIGFqYXggZm9yIHBsYXRmb3JtcyB3aXRoIG5vIGpzb25wIHN1cHBvcnQgKFdpbmRvd3MgOClcblx0XHRcdG5ldyBBamF4KHt1cmw6IHVybCwgaGFuZGxlQXM6ICd0ZXh0J30pXG5cdFx0XHRcdC5yZXNwb25zZSh0aGlzLCAncHJvY2Vzc0FqYXhTZWFyY2hSZXN1bHRzJylcblx0XHRcdFx0LmdvKHBhcmFtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ldyBKc29ucFJlcXVlc3Qoe3VybDogdXJsLCBjYWxsYmFja05hbWU6ICdqc29uY2FsbGJhY2snfSlcblx0XHRcdFx0LnJlc3BvbnNlKHRoaXMsICdwcm9jZXNzU2VhcmNoUmVzdWx0cycpXG5cdFx0XHRcdC5nbyhwYXJhbXMpO1xuXHRcdH1cblx0fSxcblx0cHJvY2Vzc0FqYXhTZWFyY2hSZXN1bHRzOiBmdW5jdGlvbihpblJlcXVlc3QsIGluUmVzcG9uc2UpIHtcblx0XHRpblJlc3BvbnNlID0ganNvbi5wYXJzZShpblJlc3BvbnNlKTtcblx0XHR0aGlzLnByb2Nlc3NTZWFyY2hSZXN1bHRzKGluUmVxdWVzdCwgaW5SZXNwb25zZSk7XG5cdH0sXG5cdHByb2Nlc3NTZWFyY2hSZXN1bHRzOiBmdW5jdGlvbihpblJlcXVlc3QsIGluUmVzcG9uc2UpIHtcblx0XHR0aGlzLnJlc3VsdHMgPSBpblJlc3BvbnNlLnBob3Rvcy5waG90bztcblx0XHR0aGlzLiQubGlzdC5zZXRDb3VudCh0aGlzLnJlc3VsdHMubGVuZ3RoKTtcblx0XHRpZiAodGhpcy5wdWxsZWQpIHtcblx0XHRcdHRoaXMuJC5saXN0LmNvbXBsZXRlUHVsbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiQubGlzdC5yZXNldCgpO1xuXHRcdH1cblx0fSxcblx0c2V0dXBJdGVtOiBmdW5jdGlvbihpblNlbmRlciwgaW5FdmVudCkge1xuXHRcdHZhciBpID0gaW5FdmVudC5pbmRleDtcblx0XHR2YXIgaXRlbSA9IHRoaXMucmVzdWx0c1tpXTtcblx0XHRpZiAoIWl0ZW0udXJsX20pIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLiQuaWNvbi5zZXRTcmMoaXRlbS51cmxfbSk7XG5cdFx0dGhpcy4kLm5hbWUuc2V0Q29udGVudChpdGVtLnRpdGxlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0FqYXhcIjoyLFwiLi4vLi4vLi4vZW55by9saWIvQnV0dG9uXCI6MTAsXCIuLi8uLi8uLi9lbnlvL2xpYi9JbWFnZVwiOjIzLFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL0pzb25wXCI6MjUsXCIuLi8uLi8uLi9lbnlvL2xpYi9qc29uXCI6NjUsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ZpdHRhYmxlUm93c1wiOjg4LFwiLi4vLi4vLi4vbGF5b3V0L2xpYi9QdWxsZG93bkxpc3RcIjoxMDB9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuLi8uLi9lbnlvL2xpYi91dGlscycpO1xuXG52YXJcblx0SW1hZ2VWaWV3ID0gcmVxdWlyZSgnLi9JbWFnZVZpZXcnKSxcblx0UGFuZWxzID0gcmVxdWlyZSgnLi9QYW5lbHMnKSxcblx0Q2Fyb3VzZWxBcnJhbmdlciA9IHJlcXVpcmUoJy4vQ2Fyb3VzZWxBcnJhbmdlcicpO1xuXG4vKipcbioge0BsaW5rIGVueW8uSW1hZ2VDYXJvdXNlbH0gaXMgYW4ge0BsaW5rIGVueW8uUGFuZWxzfSB0aGF0IHVzZXMge0BsaW5rIGVueW8uQ2Fyb3VzZWxBcnJhbmdlcn1cbiogYXMgaXRzIGFycmFuZ2VyS2luZC4gQW4gSW1hZ2VDYXJvdXNlbCBkeW5hbWljYWxseSBjcmVhdGVzIGFuZCBsb2FkcyBpbnN0YW5jZXMgb2Zcbioge0BsaW5rIGVueW8uSW1hZ2VWaWV3fSBhcyBuZWVkZWQsIGNyZWF0aW5nIGEgZ2FsbGVyeSBvZiBpbWFnZXMuXG4qXG4qIGBgYFxuKiB7a2luZDogJ0ltYWdlQ2Fyb3VzZWwnLCBpbWFnZXM6IFtcbiogXHQnYXNzZXRzL21lcmN1cnkuanBnJyxcbiogXHQnYXNzZXRzL3ZlbnVzLmpwZycsXG4qIFx0J2Fzc2V0cy9lYXJ0aC5qcGcnLFxuKiBcdCdhc3NldHMvbWFycy5qcGcnLFxuKiBcdCdhc3NldHMvanVwaXRlci5qcGcnLFxuKiBcdCdhc3NldHMvc2F0dXJuLmpwZycsXG4qIFx0J2Fzc2V0cy91cmFudXMuanBnJyxcbiogXHQnYXNzZXRzL25lcHR1bmUuanBnJ1xuKiBdLCBkZWZhdWx0U2NhbGU6ICdhdXRvJ30sXG4qIGBgYFxuKlxuKiBBbGwgb2YgdGhlIGV2ZW50cyAoYG9ubG9hZGAsIGBvbmVycm9yYCwgYW5kIGBvblpvb21gKSBmcm9tIHRoZSBjb250YWluZWRcbiogSW1hZ2VWaWV3IG9iamVjdHMgYXJlIGJ1YmJsZWQgdXAgdG8gdGhlIEltYWdlQ2Fyb3VzZWwsIHdoaWNoIGFsc28gaW5oZXJpdHNcbiogdGhlIFtvblRyYW5zaXRpb25TdGFydF17QGxpbmsgZW55by5QYW5lbHMjb25UcmFuc2l0aW9uU3RhcnR9IGFuZFxuKiBbb25UcmFuc2l0aW9uRmluaXNoXXtAbGluayBlbnlvLlBhbmVscyNvblRyYW5zaXRpb25GaW5pc2h9IGV2ZW50cyBmcm9tXG4qIHtAbGluayBlbnlvLlBhbmVsc30uXG4qXG4qIFRoZSBbaW1hZ2VzXXtAbGluayBlbnlvLkltYWdlQ2Fyb3VzZWwjaW1hZ2VzfSBwcm9wZXJ0eSBpcyBhbiBhcnJheSBjb250YWluaW5nIHRoZVxuKiBmaWxlIHBhdGhzIG9mIHRoZSBpbWFnZXMgaW4gdGhlIGdhbGxlcnkuICBUaGUgYGltYWdlc2AgYXJyYXkgbWF5IGJlIGFsdGVyZWQgYW5kXG4qIHVwZGF0ZWQgYXQgYW55IHRpbWUsIGFuZCB0aGUgY3VycmVudCBpbmRleCBtYXkgYmUgbWFuaXB1bGF0ZWQgYXQgcnVudGltZSB2aWEgdGhlXG4qIGluaGVyaXRlZCBmdW5jdGlvbnMgW2dldEluZGV4KClde0BsaW5rIGVueW8uUGFuZWxzI2dldEluZGV4fSBhbmRcbiogW3NldEluZGV4KClde0BsaW5rIGVueW8uUGFuZWxzI3NldEluZGV4fS5cbipcbiogTm90ZSB0aGF0IGl0J3MgYmVzdCB0byBzcGVjaWZ5IGEgc2l6ZSBmb3IgdGhlIEltYWdlQ2Fyb3VzZWwgaW4gb3JkZXIgdG9cbiogYXZvaWQgY29tcGxpY2F0aW9ucy5cbipcbiogQHVpXG4qIEBjbGFzcyBlbnlvLkltYWdlQ2Fyb3VzZWxcbiogQGV4dGVuZHMgZW55by5QYW5lbHNcbiogQHB1YmxpY1xuKi9cbm1vZHVsZS5leHBvcnRzID0ga2luZChcblx0LyoqIEBsZW5kcyBlbnlvLkltYWdlQ2Fyb3VzZWwucHJvdG90eXBlICovIHtcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRuYW1lOiAnZW55by5JbWFnZUNhcm91c2VsJyxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRraW5kOiBQYW5lbHMsXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0YXJyYW5nZXJLaW5kOiBDYXJvdXNlbEFycmFuZ2VyLFxuXG5cdC8qKlxuXHQqIFRoZSBkZWZhdWx0IHNjYWxpbmcgdG8gYmUgYXBwbGllZCB0byBlYWNoIEltYWdlVmlldy4gQ2FuIGJlIGAnYXV0bydgLFxuXHQqIGAnd2lkdGgnYCwgYCdoZWlnaHQnYCwgb3IgYW55IHBvc2l0aXZlIG51bWVyaWMgdmFsdWUuXG5cdCpcblx0KiBAdHlwZSB7U3RyaW5nfE51bWJlcn1cblx0KiBAZGVmYXVsdCAnYXV0bydcblx0KiBAcHVibGljXG5cdCovXG5cdGRlZmF1bHRTY2FsZTogJ2F1dG8nLFxuXG5cdC8qKlxuXHQqIElmIGB0cnVlYCwgSW1hZ2VWaWV3IGluc3RhbmNlcyBhcmUgY3JlYXRlZCB3aXRoIHpvb21pbmcgZGlzYWJsZWQuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0ZGlzYWJsZVpvb206ICBmYWxzZSxcblxuXHQvKipcblx0KiBJZiBgdHJ1ZWAsIGFueSBJbWFnZVZpZXdzIHRoYXQgYXJlIG5vdCBpbiB0aGUgaW1tZWRpYXRlIHZpZXdpbmcgYXJlYVxuXHQqIChpLmUuLCBhbnkgaW1hZ2VzIG90aGVyIHRoYW4gdGhlIGN1cnJlbnRseSBhY3RpdmUgaW1hZ2UgYW5kIHRoZSBmaXJzdCBpbWFnZVxuXHQqIG9uIGVpdGhlciBzaWRlIG9mIGl0KSB3aWxsIGJlIGRlc3Ryb3llZCB0byBmcmVlIHVwIG1lbW9yeS4gVGhpcyBoYXMgdGhlXG5cdCogYmVuZWZpdCBvZiBtaW5pbWl6aW5nIG1lbW9yeSB1c2FnZSAod2hpY2ggaXMgZ29vZCBmb3IgbW9iaWxlIGRldmljZXMpLCBidXRcblx0KiBhbHNvIGhhcyB0aGUgZG93bnNpZGUgdGhhdCwgaWYgeW91IHdhbnQgdG8gdmlldyB0aGUgaW1hZ2VzIGFnYWluLCB5b3UnbGwgbmVlZFxuXHQqIHRvIHJlY3JlYXRlIHRoZSBJbWFnZVZpZXdzIHJlZmV0Y2ggdGhlIGltYWdlcyAodGh1cyBpbmNyZWFzaW5nIHRoZSBudW1iZXIgb2Zcblx0KiBpbWFnZS1yZWxhdGVkIEdFVCBjYWxscykuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG5cdCpcblx0KiBAdHlwZSB7Qm9vbGVhbn1cblx0KiBAZGVmYXVsdCBmYWxzZVxuXHQqIEBwdWJsaWNcblx0Ki9cblx0bG93TWVtb3J5OiBmYWxzZSxcblxuXHQvKipcblx0KiBAbGVuZHMgZW55by5JbWFnZUNhcm91c2VsLnByb3RvdHlwZVxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHB1Ymxpc2hlZDoge1xuXG5cdFx0LyoqXG5cdFx0KiBBcnJheSBvZiBwYXRocyB0byBpbWFnZSBmaWxlcy5cblx0XHQqXG5cdFx0KiBAdHlwZSB7U3RyaW5nW119XG5cdFx0KiBAZGVmYXVsdCBgW11gXG5cdFx0KiBAcHVibGljXG5cdFx0Ki9cblx0XHRpbWFnZXM6IFtdXG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aGFuZGxlcnM6IHtcblx0XHRvblRyYW5zaXRpb25TdGFydDogJ3RyYW5zaXRpb25TdGFydCcsXG5cdFx0b25UcmFuc2l0aW9uRmluaXNoOiAndHJhbnNpdGlvbkZpbmlzaCdcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0UGFuZWxzLnByb3RvdHlwZS5jcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLmltYWdlQ291bnQgPSB0aGlzLmltYWdlcy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMuaW1hZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuaW5pdENvbnRhaW5lcnMoKTtcblx0XHRcdHRoaXMubG9hZE5lYXJieSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0KiBCdWlsZHMgYSBjb250YWluZXIgZm9yIGVhY2ggaW1hZ2UgYW5kIGRlc3Ryb3lzIGFueSBleHRyYSBjb250YWluZXJzIGFuZCBpbWFnZXMuXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRpbml0Q29udGFpbmVyczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmltYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLiRbJ2NvbnRhaW5lcicgKyBpXSkge1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUNvbXBvbmVudCh7XG5cdFx0XHRcdFx0bmFtZTogJ2NvbnRhaW5lcicgKyBpLFxuXHRcdFx0XHRcdHN0eWxlOiAnaGVpZ2h0OjEwMCU7IHdpZHRoOjEwMCU7J1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy4kWydjb250YWluZXInICsgaV0ucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoaT10aGlzLmltYWdlcy5sZW5ndGg7IGk8dGhpcy5pbWFnZUNvdW50OyBpKyspIHtcblx0XHRcdGlmICh0aGlzLiRbJ2ltYWdlJyArIGldKSB7XG5cdFx0XHRcdHRoaXMuJFsnaW1hZ2UnICsgaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy4kWydjb250YWluZXInICsgaV0uZGVzdHJveSgpO1xuXHRcdH1cblx0XHR0aGlzLmltYWdlQ291bnQgPSB0aGlzLmltYWdlcy5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCogTG9hZHMgaW1hZ2VzIHRoYXQgYXJlIGluIHZpZXcgb3IgbWF5IGNvbWUgaW50byB2aWV3IHNvb24uXG5cdCpcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRsb2FkTmVhcmJ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJhbmdlID0gdGhpcy5nZXRCdWZmZXJSYW5nZSgpO1xuXHRcdGZvciAodmFyIGkgaW4gcmFuZ2UpIHtcblx0XHRcdHRoaXMubG9hZEltYWdlVmlldyhyYW5nZVtpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIERldGVybWluZXMgd2hpY2ggaW1hZ2UgaW5kaWNlcyBhcmUgYCduZWFyJ2AgdGhlIGFjdGl2ZSBpbWFnZS5cblx0KlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldEJ1ZmZlclJhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJhbmdlID0gW107XG5cdFx0aWYgKHRoaXMubGF5b3V0LmNvbnRhaW5lckJvdW5kcykge1xuXHRcdFx0dmFyIHByZWZldGNoUmFuZ2UgPSAxO1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMubGF5b3V0LmNvbnRhaW5lckJvdW5kcztcblx0XHRcdHZhciBjLCBpLCB4LCB4RW5kO1xuXHRcdFx0Ly8gZ2V0IHRoZSBsb3dlciByYW5nZVxuXHRcdFx0aT10aGlzLmluZGV4LTE7XG5cdFx0XHR4PTA7XG5cdFx0XHR4RW5kID0gYm91bmRzLndpZHRoICogcHJlZmV0Y2hSYW5nZTtcblx0XHRcdHdoaWxlIChpPj0wICYmIHg8PXhFbmQpIHtcblx0XHRcdFx0YyA9IHRoaXMuJFsnY29udGFpbmVyJyArIGldO1xuXHRcdFx0XHR4Kz0gYy53aWR0aCArIGMubWFyZ2luV2lkdGg7XG5cdFx0XHRcdHJhbmdlLnVuc2hpZnQoaSk7XG5cdFx0XHRcdGktLTtcblx0XHRcdH1cblx0XHRcdC8vIGdldCB0aGUgdXBwZXIgcmFuZ2Vcblx0XHRcdGk9dGhpcy5pbmRleDtcblx0XHRcdHg9MDtcblx0XHRcdHhFbmQgPSBib3VuZHMud2lkdGggKiAocHJlZmV0Y2hSYW5nZSArIDEpO1xuXHRcdFx0d2hpbGUgKGk8dGhpcy5pbWFnZXMubGVuZ3RoICYmIHg8PXhFbmQpIHtcblx0XHRcdFx0YyA9IHRoaXMuJFsnY29udGFpbmVyJyArIGldO1xuXHRcdFx0XHR4Kz0gYy53aWR0aCArIGMubWFyZ2luV2lkdGg7XG5cdFx0XHRcdHJhbmdlLnB1c2goaSk7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJhbmdlO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEBtZXRob2Rcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRyZWZsb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRQYW5lbHMucHJvdG90eXBlLnJlZmxvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMubG9hZE5lYXJieSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIExvYWRzIHRoZSBpbWFnZSB3aG9zZSBwYXRoIGlzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gdGhlXG5cdCogW2ltYWdlc117QGxpbmsgZW55by5JbWFnZUNhcm91c2VsI2ltYWdlc30gYXJyYXkuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGltYWdlIHRvIGxvYWQuXG5cdCogQHByaXZhdGVcblx0Ki9cblx0bG9hZEltYWdlVmlldzogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0Ly8gTk9URTogd3JhcCBidWdnZWQgaW4gZW55by5DYXJvdXNlbEFycmFuZ2VyLCBidXQgb25jZSBmaXhlZCwgd3JhcCBzaG91bGQgd29yayBpbiB0aGlzXG5cdFx0aWYgKHRoaXMud3JhcCkge1xuXHRcdFx0Ly8gVXNlZCB0aGlzIG1vZHVsbyB0ZWNobmlxdWUgdG8gZ2V0IGFyb3VuZCBqYXZhc2NyaXB0IGlzc3VlIHdpdGggbmVnYXRpdmUgdmFsdWVzXG5cdFx0XHQvLyByZWY6IGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9vZC9wcm9ibGVtc29sdmluZy9hL21vZHVsb2J1Zy5odG1cblx0XHRcdGluZGV4ID0gKChpbmRleCAlIHRoaXMuaW1hZ2VzLmxlbmd0aCkrdGhpcy5pbWFnZXMubGVuZ3RoKSV0aGlzLmltYWdlcy5sZW5ndGg7XG5cdFx0fVxuXHRcdGlmIChpbmRleD49MCAmJiBpbmRleDw9dGhpcy5pbWFnZXMubGVuZ3RoLTEpIHtcblx0XHRcdGlmICghdGhpcy4kWydpbWFnZScgKyBpbmRleF0pIHtcblx0XHRcdFx0dGhpcy4kWydjb250YWluZXInICsgaW5kZXhdLmNyZWF0ZUNvbXBvbmVudCh7XG5cdFx0XHRcdFx0bmFtZTogJ2ltYWdlJyArIGluZGV4LFxuXHRcdFx0XHRcdGtpbmQ6IEltYWdlVmlldyxcblx0XHRcdFx0XHRzY2FsZTogdGhpcy5kZWZhdWx0U2NhbGUsXG5cdFx0XHRcdFx0ZGlzYWJsZVpvb206IHRoaXMuZGlzYWJsZVpvb20sXG5cdFx0XHRcdFx0c3JjOiB0aGlzLmltYWdlc1tpbmRleF0sXG5cdFx0XHRcdFx0dmVydGljYWxEcmFnUHJvcGFnYXRpb246IGZhbHNlLFxuXHRcdFx0XHRcdHN0eWxlOiAnaGVpZ2h0OjEwMCU7IHdpZHRoOjEwMCU7J1xuXHRcdFx0XHR9LCB7b3duZXI6IHRoaXN9KTtcblx0XHRcdFx0dGhpcy4kWydpbWFnZScgKyBpbmRleF0ucmVuZGVyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy4kWydpbWFnZScgKyBpbmRleF0uc3JjICE9IHRoaXMuaW1hZ2VzW2luZGV4XSkge1xuXHRcdFx0XHRcdHRoaXMuJFsnaW1hZ2UnICsgaW5kZXhdLnNldFNyYyh0aGlzLmltYWdlc1tpbmRleF0pO1xuXHRcdFx0XHRcdHRoaXMuJFsnaW1hZ2UnICsgaW5kZXhdLnNldFNjYWxlKHRoaXMuZGVmYXVsdFNjYWxlKTtcblx0XHRcdFx0XHR0aGlzLiRbJ2ltYWdlJyArIGluZGV4XS5zZXREaXNhYmxlWm9vbSh0aGlzLmRpc2FibGVab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy4kWydpbWFnZScgKyBpbmRleF07XG5cdH0sXG5cblx0LyoqXG5cdCogVXBkYXRlcyB0aGUgYXJyYXkgb2YgaW1hZ2VzLlxuXHQqXG5cdCogQHRvZG8gUHJvYmFibHkgYSBkZWZlY3QgaGVyZS4gU2ltcGx5IGNhbGxpbmcgYHNldCgpYCB3b24ndCBmb3JjZSB0aGUgb2JzZXJ2ZXIgdG8gZmlyZVxuXHQqIGlmIGBpbWFnZXNgIGlzIGEgcmVmIHRvIHRoZSBzYW1lIGFycmF5LiBOZWVkIHRvIGFkZCB0aGUgYGZvcmNlYCBwYXJhbWV0ZXIuXG5cdCogQHB1YmxpY1xuXHQqL1xuXHRzZXRJbWFnZXM6IGZ1bmN0aW9uIChpbWFnZXMpIHtcblx0XHQvLyBhbHdheXMgaW52b2tlIGltYWdlc0NoYW5nZWQgYmVjYXVzZSB0aGlzIGlzIGFuIGFycmF5IHByb3BlcnR5XG5cdFx0Ly8gd2hpY2ggbWlnaHQgb3RoZXJ3aXNlIHNlZW0gdG8gYmUgdGhlIHNhbWUgb2JqZWN0XG5cdFx0dGhpcy5zZXQoJ2ltYWdlcycsIGltYWdlcyk7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW1hZ2VzQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdENvbnRhaW5lcnMoKTtcblx0XHR0aGlzLmxvYWROZWFyYnkoKTtcblx0fSxcblxuXHQvKipcblx0KiBAbWV0aG9kXG5cdCogQHByaXZhdGVcblx0Ki9cblx0aW5kZXhDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5sb2FkTmVhcmJ5KCk7XG5cdFx0aWYgKHRoaXMubG93TWVtb3J5KSB7XG5cdFx0XHR0aGlzLmNsZWFudXBNZW1vcnkoKTtcblx0XHR9XG5cdFx0UGFuZWxzLnByb3RvdHlwZS5pbmRleENoYW5nZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKipcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHR0cmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LmZyb21JbmRleD09ZXZlbnQudG9JbmRleCkge1xuXHRcdFx0cmV0dXJuIHRydWU7IC8vcHJldmVudCBmcm9tIGJ1YmJsaW5nIGlmIHRoZXJlJ3Mgbm8gY2hhbmdlXG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQqIEBwcml2YXRlXG5cdCovXG5cdHRyYW5zaXRpb25GaW5pc2g6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0dGhpcy5sb2FkTmVhcmJ5KCk7XG5cdFx0aWYgKHRoaXMubG93TWVtb3J5KSB7XG5cdFx0XHR0aGlzLmNsZWFudXBNZW1vcnkoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBJbWFnZVZpZXcuXG5cdCpcblx0KiBAcmV0dXJuIHtlbnlvLkNvbnRyb2x9IC0gVGhlIGFjdGl2ZSBpbWFnZSBjb250cm9sLlxuXHQqIEBwdWJsaWNcblx0Ki9cblx0Z2V0QWN0aXZlSW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRJbWFnZUJ5SW5kZXgodGhpcy5pbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmV0dXJucyB0aGUgSW1hZ2VWaWV3IHdpdGggdGhlIHNwZWNpZmllZCBpbmRleC5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgLSBUaGUgaW5kZXggb2YgdGhlIGltYWdlIHRvIGJlIHJldHJpZXZlZC5cblx0KiBAcmV0dXJuIHtlbnlvLkNvbnRyb2x9IC0gVGhlIGltYWdlIGNvbnRyb2wgYXQgYGluZGV4YC5cblx0KiBAcHVibGljXG5cdCovXG5cdGdldEltYWdlQnlJbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuJFsnaW1hZ2UnICsgaW5kZXhdIHx8IHRoaXMubG9hZEltYWdlVmlldyhpbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRGVzdHJveXMgYW55IEltYWdlVmlldyBvYmplY3RzIHRoYXQgYXJlIG5vdCBpbiB0aGUgaW1tZWRpYXRlIHZpZXdpbmcgYXJlYVxuXHQqIChpLmUuLCBhbnkgaW1hZ2VzIG90aGVyIHRoYW4gdGhlIGN1cnJlbnRseSBhY3RpdmUgaW1hZ2UgYW5kIHRoZSBmaXJzdFxuXHQqIGltYWdlIG9uIGVpdGhlciBzaWRlIG9mIGl0KSB0byBmcmVlIHVwIG1lbW9yeS4gSWYgeW91IHNldCB0aGUgSW1hZ2VDYXJvdXNlbCdzXG5cdCogW2xvd01lbW9yeV17QGxpbmsgZW55by5JbWFnZUNhcm91c2VsI2xvd01lbW9yeX0gcHJvcGVydHkgdG8gYHRydWVgLCB0aGlzXG5cdCogZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBhcyBuZWVkZWQuXG5cdCpcblx0KiBAcHVibGljXG5cdCovXG5cdGNsZWFudXBNZW1vcnk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5nZXRCdWZmZXJSYW5nZSgpO1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmltYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHV0aWxzLmluZGV4T2YoaSwgYnVmZmVyKSA9PT0tMSkge1xuXHRcdFx0XHRpZiAodGhpcy4kWydpbWFnZScgKyBpXSkge1xuXHRcdFx0XHRcdHRoaXMuJFsnaW1hZ2UnICsgaV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcbn0se1wiLi4vLi4vZW55by9saWIva2luZFwiOjY2LFwiLi4vLi4vZW55by9saWIvdXRpbHNcIjo3NSxcIi4vQ2Fyb3VzZWxBcnJhbmdlclwiOjgxLFwiLi9JbWFnZVZpZXdcIjo5MixcIi4vUGFuZWxzXCI6OTl9XSwxMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyXG5cdGtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9raW5kJyk7XG5cbnZhclxuXHRJbWFnZVZpZXcgPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ltYWdlVmlldycpLFxuXHRJbWFnZVZpZXdQaW4gPSByZXF1aXJlKCcuLi8uLi8uLi9sYXlvdXQvbGliL0ltYWdlVmlld1BpbicpO1xuXG4vKipcblx0T3VyIG1hcCBwaW4gaWNvbiBpcyBiYXNlZCBpbiB3aG9sZSBvciBpbiBwYXJ0IG9uIHRoZSBPcGVuU3RydWN0cyBvcGVuIHNvdXJjZSBpbmZvcm1hdGlvbiBhbmQgZG9jdW1lbnRhdGlvbixcblx0bGFyZ2VseSBkZXZlbG9wZWQgYnkgU3RydWN0dXJlZCBEeW5hbWljcyBMTEMuIFlvdSBhcmUgZnJlZSB0byB1c2UgdGhpcyBjb250ZW50IGFuZCBzeXN0ZW0gYXMgeW91IHdpc2gsIHNvIGxvbmdcblx0YXMgYW55IGRlcml2YXRpdmUgd29ya3MgYWNrbm93bGVkZ2UgdGhlc2UgY29udHJpYnV0aW9ucy4gVGVjaFdpa2kgaXMgcHJvdmlkZWQgdW5kZXIgdGhlIENyZWF0aXZlIENvbW1vbnNcblx0QXR0cmlidXRpb24gTGljZW5zZSwgdmVyc2lvbiAzLjAuIC0gaHR0cDovL3RlY2h3aWtpLm9wZW5zdHJ1Y3RzLm9yZy9pbmRleC5waHAvT3Blbl9Tb3VyY2VfSWNvbnNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuSW1hZ2VWaWV3U2FtcGxlJyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnc2FtcGxlSW1hZ2VWaWV3Jywga2luZDogSW1hZ2VWaWV3LCBzcmM6ICdhc3NldHMvZ2xvYmUuanBnJywgc2NhbGU6ICdhdXRvJywgY2xhc3NlczogJ2VueW8tZml0JywgY29tcG9uZW50czogW1xuXHRcdFx0e2tpbmQ6IEltYWdlVmlld1BpbiwgaGlnaGxpZ2h0QW5jaG9yUG9pbnQ6dHJ1ZSwgYW5jaG9yOiB7dG9wOjc5LCByaWdodDoyMjR9LCBwb3NpdGlvbjoge2JvdHRvbTowLCBsZWZ0Oi0xNn0sIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e2tpbmQ6ICdJbWFnZScsIHNyYzogJ2Fzc2V0cy9waW4ucG5nJ31cblx0XHRcdF19LFxuXHRcdFx0e2tpbmQ6IEltYWdlVmlld1BpbiwgYW5jaG9yOiB7dG9wOjI4MCwgbGVmdDo0MTV9LCBwb3NpdGlvbjoge2JvdHRvbTowLCByaWdodDotMTZ9LCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtraW5kOiAnSW1hZ2UnLCBzcmM6ICdhc3NldHMvcGluLnBuZyd9XG5cdFx0XHRdfSxcblx0XHRcdHtraW5kOiBJbWFnZVZpZXdQaW4sIGhpZ2hsaWdodEFuY2hvclBvaW50OnRydWUsIGFuY2hvcjoge2JvdHRvbTogJzIwJScsIGxlZnQ6ICc0MDBweCd9LCBwb3NpdGlvbjoge2JvdHRvbTowLCBsZWZ0OjB9LCBjb21wb25lbnRzOiBbXG5cdFx0XHRcdHtzdHlsZTogJ2JhY2tncm91bmQ6cmdiYSgyNTUsMjU1LDI1NSwwLjgpO2JvcmRlcjoxcHggc29saWQgIzg4ODttYXJnaW46MHB4O3BhZGRpbmc6MHB4O3dpZHRoOjMwMHB4JywgY29tcG9uZW50czogW1xuXHRcdFx0XHRcdHt0YWc6ICdoMycsIGNvbnRlbnQ6ICdUaGlzIGlzIGEgdGV4dCBib3gnfVxuXHRcdFx0XHRdfVxuXHRcdFx0XX0sXG5cdFx0XHR7bmFtZTogJ3Rlc3RQaW4nLCBraW5kOiBJbWFnZVZpZXdQaW4sIGFuY2hvcjoge3RvcDogJzEwJScsIHJpZ2h0OiAnMTAlJ30sIHBvc2l0aW9uOiB7dG9wOjAsIGxlZnQ6MH0sIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e3N0eWxlOiAnYm9yZGVyOjFweCBzb2xpZCB5ZWxsb3c7d2lkdGg6MTBweDtiYWNrZ3JvdW5kOnJlZDtoZWlnaHQ6MTBweDsnfVxuXHRcdFx0XX1cblx0XHRdfVxuXHRdXG59KTtcblxuXG59LHtcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvSW1hZ2VWaWV3XCI6OTIsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ltYWdlVmlld1BpblwiOjkzfV0sMTE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhclxuXHRraW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIva2luZCcpLFxuXHRCdXR0b24gPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9CdXR0b24nKSxcblx0SW5wdXQgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9JbnB1dCcpO1xuXG52YXJcblx0Rml0dGFibGVSb3dzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGF5b3V0L2xpYi9GaXR0YWJsZVJvd3MnKSxcblx0SW1hZ2VDYXJvdXNlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xheW91dC9saWIvSW1hZ2VDYXJvdXNlbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtpbmQoe1xuXHRuYW1lOiAnZW55by5zYW1wbGUuSW1hZ2VDYXJvdXNlbFNhbXBsZScsXG5cdGtpbmQ6IEZpdHRhYmxlUm93cyxcblx0Y2xhc3NlczogJ2VueW8tZml0Jyxcblx0Y29tcG9uZW50czogW1xuXHRcdHtjbGFzc2VzOiAnbGF5b3V0LXNhbXBsZS10b29sYmFyJywgc3R5bGU6ICd0ZXh0LWFsaWduOmNlbnRlcjsnLCBjb21wb25lbnRzOiBbXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnJmxhcnI7JywgYWxsb3dIdG1sOiB0cnVlLCBvbnRhcDogJ3ByZXZpb3VzJ30sXG5cdFx0XHR7a2luZDogQnV0dG9uLCBjb250ZW50OiAnJnJhcnI7JywgYWxsb3dIdG1sOiB0cnVlLCBvbnRhcDogJ25leHQnfSxcblx0XHRcdHt0YWc6ICdsYWJlbCcsIGNsYXNzZXM6ICdpbWFnZWNhcm91c2VsLXNhbXBsZS1pbnB1dCcsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdjYXJvdXNlbEluZGV4SW5wdXQnLCBraW5kOiBJbnB1dCwgdmFsdWU6ICcwJywgb25jaGFuZ2U6ICd1cGRhdGVJbmRleCd9XG5cdFx0XHRdfVxuXHRcdF19LFxuXHRcdHtuYW1lOiAnY2Fyb3VzZWwnLCBraW5kOiBJbWFnZUNhcm91c2VsLCBmaXQ6dHJ1ZSwgb25sb2FkOiAnbG9hZCcsIG9uWm9vbTogJ3pvb20nLCBvbmVycm9yOiAnZXJyb3InLCBvblRyYW5zaXRpb25TdGFydDogJ3RyYW5zaXRpb25TdGFydCcsIG9uVHJhbnNpdGlvbkZpbmlzaDogJ3RyYW5zaXRpb25GaW5pc2gnfVxuXHRdLFxuXHRjcmVhdGU6IGtpbmQuaW5oZXJpdChmdW5jdGlvbiAoc3VwKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHN1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy51cmxzID0gW1xuXHRcdFx0XHQnYXNzZXRzL21lcmN1cnkuanBnJyxcblx0XHRcdFx0J2Fzc2V0cy92ZW51cy5qcGcnLFxuXHRcdFx0XHQnYXNzZXRzL2VhcnRoLmpwZycsXG5cdFx0XHRcdCdhc3NldHMvbWFycy5qcGcnLFxuXHRcdFx0XHQnYXNzZXRzL2p1cGl0ZXIuanBnJyxcblx0XHRcdFx0J2Fzc2V0cy9zYXR1cm4uanBnJyxcblx0XHRcdFx0J2Fzc2V0cy91cmFudXMuanBnJyxcblx0XHRcdFx0J2Fzc2V0cy9uZXB0dW5lLmpwZydcblx0XHRcdF07XG5cdFx0XHQvLyBhbHRob3VnaCB3ZSdyZSBzcGVjaWZ5aW5nIGFsbCB0aGUgaW1hZ2UgdXJscyBub3csIHRoZSBpbWFnZXMgdGhlbXNlbHZlc1xuXHRcdFx0Ly8gb25seSBnZXQgY3JlYXRlZC9sb2FkZWQgYXMgbmVlZGVkXG5cdFx0XHR0aGlzLiQuY2Fyb3VzZWwuc2V0SW1hZ2VzKHRoaXMudXJscyk7XG5cdFx0fTtcblx0fSksXG5cdGxvYWQ6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly9lbnlvLmxvZygnaW1hZ2UgbG9hZGVkOiAnICsgZXZlbnQub3JpZ2luYXRvci5zcmMpO1xuXHR9LFxuXHR6b29tOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdC8vZW55by5sb2coJ2ltYWdlIHpvb21lZDogJyArIGV2ZW50LnNjYWxlICsgJyBzY2FsZSBvbiAnICsgZXZlbnQub3JpZ2luYXRvci5zcmMpO1xuXHR9LFxuXHRlcnJvcjogZnVuY3Rpb24gKHNlbmRlciwgZXZlbnQpIHtcblx0XHQvL2VueW8ubG9nKCdpbWFnZSBlcnJvcjogJyArIGV2ZW50Lm9yaWdpbmF0b3Iuc3JjKTtcblx0fSxcblx0dHJhbnNpdGlvblN0YXJ0OiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdC8vZW55by5sb2coJ2ltYWdlIG5vdyB0cmFuc2l0aW9uaW5nIGZyb206ICcgKyB0aGlzLiQuY2Fyb3VzZWwuZ2V0SW1hZ2VCeUluZGV4KGV2ZW50LmZyb21JbmRleCkuc3JjXG5cdFx0Ly9cdFx0KyAnIHRvICcgKyB0aGlzLiQuY2Fyb3VzZWwuZ2V0SW1hZ2VCeUluZGV4KGV2ZW50LnRvSW5kZXgpLnNyYyk7XG5cdH0sXG5cdHRyYW5zaXRpb25GaW5pc2g6IGZ1bmN0aW9uIChzZW5kZXIsIGV2ZW50KSB7XG5cdFx0Ly9lbnlvLmxvZygnaW1hZ2UgdHJhbnNpdGlvbmVkIHRvOiAnICsgdGhpcy4kLmNhcm91c2VsLmdldEFjdGl2ZUltYWdlKCkuc3JjKTtcblx0XHRpZiAodGhpcy4kLmNhcm91c2VsSW5kZXhJbnB1dCkge1xuXHRcdFx0dGhpcy4kLmNhcm91c2VsSW5kZXhJbnB1dC5zZXRWYWx1ZShldmVudC50b0luZGV4KTtcblx0XHR9XG5cdH0sXG5cdHByZXZpb3VzOiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMuJC5jYXJvdXNlbC5wcmV2aW91cygpO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHRoaXMuJC5jYXJvdXNlbC5uZXh0KCk7XG5cdH0sXG5cdGdldFJhbmRvbUluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdGhpcy4kLmNhcm91c2VsLmltYWdlcy5sZW5ndGgpO1xuXHRcdHdoaWxlKGk9PXRoaXMuJC5jYXJvdXNlbC5pbmRleCkgeyAvL21ha2Ugc3VyZSBpdCBpc24ndCB0aGUgYWN0aXZlIGluZGV4XG5cdFx0XHRpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnRoaXMuJC5jYXJvdXNlbC5pbWFnZXMubGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGk7XG5cdH0sXG5cdHVwZGF0ZUluZGV4OiBmdW5jdGlvbiAoc2VuZGVyLCBldmVudCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMudHJpbVdoaXRlc3BhY2UodGhpcy4kLmNhcm91c2VsSW5kZXhJbnB1dC5nZXRWYWx1ZSgpKTtcblx0XHRpZiAoaW5kZXggPT09ICcnIHx8IGlzTmFOKGluZGV4KSkge1xuXHRcdFx0Ly9lbnlvLmxvZygnTnVtYmVycyBvbmx5IHBsZWFzZS4nKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLiQuY2Fyb3VzZWwuc2V0SW5kZXgocGFyc2VJbnQoaW5kZXgsIDEwKSk7XG5cdH0sXG5cdHRyaW1XaGl0ZXNwYWNlOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKTtcblx0fVxufSk7XG59LHtcIi4uLy4uLy4uL2VueW8vbGliL0J1dHRvblwiOjEwLFwiLi4vLi4vLi4vZW55by9saWIvSW5wdXRcIjoyNCxcIi4uLy4uLy4uL2VueW8vbGliL2tpbmRcIjo2NixcIi4uLy4uLy4uL2xheW91dC9saWIvRml0dGFibGVSb3dzXCI6ODgsXCIuLi8uLi8uLi9sYXlvdXQvbGliL0ltYWdlQ2Fyb3VzZWxcIjo5MX1dLDEzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcblx0a2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL2tpbmQnKSxcblx0cmVhZHkgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9yZWFkeScpLFxuXHRBbmNob3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lbnlvL2xpYi9BbmNob3InKSxcblx0Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0NvbGxlY3Rpb24nKSxcblx0Q29udHJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2VueW8vbGliL0NvbnRyb2wnKSxcblx0RGF0YVJlcGVhdGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZW55by9saWIvRGF0YVJlcGVhdGVyJyk7XG5cbnZhclxuXHRzYW1wbGVzID0ge1xuXHRcdENvbnRleHR1YWxMYXlvdXRcdFx0XHQ6IHJlcXVpcmUoJy4vQ29udGV4dHVhbExheW91dFNhbXBsZScpLFxuXHRcdEVhc2luZ1x0XHRcdFx0XHRcdDogcmVxdWlyZSgnLi9FYXNpbmdTYW1wbGUnKSxcblx0XHRGaXR0YWJsZUFwcExheW91dDFcdFx0XHQ6IHJlcXVpcmUoJy4vRml0dGFibGVBcHBMYXlvdXQxJyksXG5cdFx0Rml0dGFibGVBcHBMYXlvdXQyXHRcdFx0OiByZXF1aXJlKCcuL0ZpdHRhYmxlQXBwTGF5b3V0MicpLFxuXHRcdEZpdHRhYmxlQXBwTGF5b3V0M1x0XHRcdDogcmVxdWlyZSgnLi9GaXR0YWJsZUFwcExheW91dDMnKSxcblx0XHRGaXR0YWJsZUFwcExheW91dDRcdFx0XHQ6IHJlcXVpcmUoJy4vRml0dGFibGVBcHBMYXlvdXQ0JyksXG5cdFx0Rml0dGFibGVEZXNjcmlwdGlvblx0XHRcdDogcmVxdWlyZSgnLi9GaXR0YWJsZURlc2NyaXB0aW9uJyksXG5cdFx0Rml0dGFibGVUZXN0c1x0XHRcdFx0OiByZXF1aXJlKCcuL0ZpdHRhYmxlVGVzdHMnKSxcblx0XHRGaXR0YWJsZVx0XHRcdFx0XHQ6IHJlcXVpcmUoJy4vRml0dGFibGVTYW1wbGUnKSxcblx0XHRGbHl3ZWlnaHRSZXBlYXRlclx0XHRcdDogcmVxdWlyZSgnLi9GbHl3ZWlnaHRSZXBlYXRlclNhbXBsZScpLFxuXHRcdEltYWdlQ2Fyb3VzZWxcdFx0XHRcdDogcmVxdWlyZSgnLi9JbWFnZUNhcm91c2VsU2FtcGxlJyksXG5cdFx0SW1hZ2VWaWV3XHRcdFx0XHRcdDogcmVxdWlyZSgnLi9JbWFnZVZpZXdTYW1wbGUnKSxcblx0XHRMaXN0QXJvdW5kXHRcdFx0XHRcdDogcmVxdWlyZSgnLi9MaXN0QXJvdW5kU2FtcGxlJyksXG5cdFx0TGlzdEJhc2ljXHRcdFx0XHRcdDogcmVxdWlyZSgnLi9MaXN0QmFzaWNTYW1wbGUnKSxcblx0XHRMaXN0Q29udGFjdHNcdFx0XHRcdDogcmVxdWlyZSgnLi9MaXN0Q29udGFjdHNTYW1wbGUnKSxcblx0XHRMaXN0SG9yaXpvbnRhbEZsaWNrclx0XHQ6IHJlcXVpcmUoJy4vTGlzdEhvcml6b250YWxGbGlja3JTYW1wbGUnKSxcblx0XHRMaXN0TGFuZ3VhZ2VzXHRcdFx0XHQ6IHJlcXVpcmUoJy4vTGlzdExhbmd1YWdlc1NhbXBsZScpLFxuXHRcdExpc3ROb1NlbGVjdFx0XHRcdFx0OiByZXF1aXJlKCcuL0xpc3ROb1NlbGVjdFNhbXBsZScpLFxuXHRcdExpc3RQdWxsZG93blx0XHRcdFx0OiByZXF1aXJlKCcuL0xpc3RQdWxsZG93blNhbXBsZScpLFxuXHRcdFBlcnNpc3RlbnRTd2lwZWFibGVJdGVtXHRcdDogcmVxdWlyZSgnLi9QZXJzaXN0ZW50U3dpcGVhYmxlSXRlbVNhbXBsZScpLFxuXHRcdFBhbmVsc1x0XHRcdFx0XHRcdDogcmVxdWlyZSgnLi9QYW5lbHNTYW1wbGUnKSxcblx0XHRQYW5lbHNGbGlja3JcdFx0XHRcdDogcmVxdWlyZSgnLi9QYW5lbHNGbGlja3JTYW1wbGUnKSxcdFx0XG5cdFx0UGFuZWxzU2xpZGluZ1x0XHRcdFx0OiByZXF1aXJlKCcuL1BhbmVsc1NsaWRpbmdTYW1wbGUnKSxcblx0XHRQYW5ab29tVmlldzFcdFx0XHRcdDogcmVxdWlyZSgnLi9QYW5ab29tVmlld1NhbXBsZScpLFxuXHRcdFBhblpvb21WaWV3Mlx0XHRcdFx0OiByZXF1aXJlKCcuL1Bhblpvb21WaWV3U2FtcGxlMicpLFxuXHRcdFBhblpvb21WaWV3M1x0XHRcdFx0OiByZXF1aXJlKCcuL1Bhblpvb21WaWV3U2FtcGxlMycpLFxuXHRcdFNsaWRlYWJsZVx0XHRcdFx0XHQ6IHJlcXVpcmUoJy4vU2xpZGVhYmxlU2FtcGxlJyksXG5cdFx0VHJlZVx0XHRcdFx0XHRcdDogcmVxdWlyZSgnLi9UcmVlU2FtcGxlJylcblx0fTtcblxudmFyIExpc3QgPSBraW5kKHtcblx0a2luZDogQ29udHJvbCxcblx0Y29tcG9uZW50czogW1xuXHRcdHtuYW1lOiAnbGlzdCcsIGtpbmQ6IERhdGFSZXBlYXRlciwgY29tcG9uZW50czogW1xuXHRcdFx0e3N0eWxlOiAnbWFyZ2luOiAxMHB4OycsIGNvbXBvbmVudHM6IFtcblx0XHRcdFx0e25hbWU6ICdhJywga2luZDogQW5jaG9yfVxuXHRcdFx0XSwgYmluZGluZ3M6IFtcblx0XHRcdFx0e2Zyb206ICdtb2RlbC5uYW1lJywgdG86ICckLmEuaHJlZicsIHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuICc/JyArIHY7IH19LFxuXHRcdFx0XHR7ZnJvbTogJ21vZGVsLm5hbWUnLCB0bzogJyQuYS5jb250ZW50JywgdHJhbnNmb3JtOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdiArICcgU2FtcGxlJzsgfX1cblx0XHRcdF19XG5cdFx0XX1cblx0XSxcblx0Y3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Q29udHJvbC5wcm90b3R5cGUuY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy4kLmxpc3Quc2V0KCdjb2xsZWN0aW9uJywgbmV3IENvbGxlY3Rpb24oT2JqZWN0LmtleXMoc2FtcGxlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiB7bmFtZToga2V5fTtcblx0XHR9KSkpO1xuXHR9XG59KTtcblxucmVhZHkoZnVuY3Rpb24gKCkge1xuXHR2YXIgbmFtZSA9IHdpbmRvdy5kb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpLFxuXHRcdHNhbXBsZSA9IHNhbXBsZXNbbmFtZV0gfHwgTGlzdDtcblxuXHRuZXcgc2FtcGxlKHtzYW1wbGVzOiBzYW1wbGVzfSkucmVuZGVySW50byhkb2N1bWVudC5ib2R5KTtcbn0pO1xufSx7XCIuLi8uLi8uLi9lbnlvL2xpYi9BbmNob3JcIjo0LFwiLi4vLi4vLi4vZW55by9saWIvQ29sbGVjdGlvblwiOjEyLFwiLi4vLi4vLi4vZW55by9saWIvQ29udHJvbFwiOjE2LFwiLi4vLi4vLi4vZW55by9saWIvRGF0YVJlcGVhdGVyXCI6MTgsXCIuLi8uLi8uLi9lbnlvL2xpYi9raW5kXCI6NjYsXCIuLi8uLi8uLi9lbnlvL2xpYi9yZWFkeVwiOjcyLFwiLi9Db250ZXh0dWFsTGF5b3V0U2FtcGxlXCI6MTA2LFwiLi9FYXNpbmdTYW1wbGVcIjoxMDcsXCIuL0ZpdHRhYmxlQXBwTGF5b3V0MVwiOjEwOCxcIi4vRml0dGFibGVBcHBMYXlvdXQyXCI6MTA5LFwiLi9GaXR0YWJsZUFwcExheW91dDNcIjoxMTAsXCIuL0ZpdHRhYmxlQXBwTGF5b3V0NFwiOjExMSxcIi4vRml0dGFibGVEZXNjcmlwdGlvblwiOjExMixcIi4vRml0dGFibGVTYW1wbGVcIjoxMTMsXCIuL0ZpdHRhYmxlVGVzdHNcIjoxMTQsXCIuL0ZseXdlaWdodFJlcGVhdGVyU2FtcGxlXCI6MTE1LFwiLi9JbWFnZUNhcm91c2VsU2FtcGxlXCI6MTE2LFwiLi9JbWFnZVZpZXdTYW1wbGVcIjoxMTcsXCIuL0xpc3RBcm91bmRTYW1wbGVcIjoxMTgsXCIuL0xpc3RCYXNpY1NhbXBsZVwiOjExOSxcIi4vTGlzdENvbnRhY3RzU2FtcGxlXCI6MTIwLFwiLi9MaXN0SG9yaXpvbnRhbEZsaWNrclNhbXBsZVwiOjEyMSxcIi4vTGlzdExhbmd1YWdlc1NhbXBsZVwiOjEyMixcIi4vTGlzdE5vU2VsZWN0U2FtcGxlXCI6MTIzLFwiLi9MaXN0UHVsbGRvd25TYW1wbGVcIjoxMjQsXCIuL1Bhblpvb21WaWV3U2FtcGxlXCI6MTI2LFwiLi9QYW5ab29tVmlld1NhbXBsZTJcIjoxMjcsXCIuL1Bhblpvb21WaWV3U2FtcGxlM1wiOjEyOCxcIi4vUGFuZWxzRmxpY2tyU2FtcGxlXCI6MTI5LFwiLi9QYW5lbHNTYW1wbGVcIjoxMzAsXCIuL1BhbmVsc1NsaWRpbmdTYW1wbGVcIjoxMzEsXCIuL1BlcnNpc3RlbnRTd2lwZWFibGVJdGVtU2FtcGxlXCI6MTMyLFwiLi9TbGlkZWFibGVTYW1wbGVcIjoxMzMsXCIuL1RyZWVTYW1wbGVcIjoxMzR9XX0se30sWzEzNV0pO1xuIl0sImZpbGUiOiJpbnNlcnQuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==</script></head>
<body>

</body></html>